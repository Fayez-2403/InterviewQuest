problem_statement,titleslug,title,tags,num_occur
"Design a data structure that follows the constraints of a Least Recently Used (LRU) cache. Implement the LRUCache class:  LRUCache(int capacity) Initialize the LRU cache with positive size capacity. int get(int key) Return the value of the key if the key exists, otherwise return -1. void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.  The functions get and put must each run in O(1) average time complexity.  ",lru-cache,LRU Cache,"Hash Table, Linked List, Design, Doubly-Linked List",117
"Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.  ",two-sum,Two Sum,"Array, Hash Table",117
"Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.  ",number-of-islands,Number of Islands,"Array, Depth-First Search, Breadth-First Search, Union Find, Matrix",103
"Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.  ",merge-intervals,Merge Intervals,"Array, Sorting",87
You are given an array of strings products and a string searchWord. Design a system that suggests at most three product names from products after each character of searchWord is typed. Suggested products should have common prefix with searchWord. If there are more than three products with a common prefix return the three lexicographically minimums products. Return a list of lists of the suggested products after each character of searchWord is typed.  ,search-suggestions-system,Search Suggestions System,"Array, String, Trie",68
"You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.  ",best-time-to-buy-and-sell-stock,Best Time to Buy and Sell Stock,"Array, Dynamic Programming",56
"Given an array of strings strs, group the anagrams together. You can return the answer in any order. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.  ",group-anagrams,Group Anagrams,"Array, Hash Table, String, Sorting",51
"Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0). The distance between two points on the X-Y plane is the Euclidean distance (i.e., √(x1 - x2)2 + (y1 - y2)2). You may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in).  ",k-closest-points-to-origin,K Closest Points to Origin,"Array, Math, Divide and Conquer, Geometry, Sorting, Heap (Priority Queue), Quickselect",49
"Given a string s, find the length of the longest substring without repeating characters.  ",longest-substring-without-repeating-characters,Longest Substring Without Repeating Characters,"Hash Table, String, Sliding Window",49
"You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it.  ",merge-k-sorted-lists,Merge k Sorted Lists,"Linked List, Divide and Conquer, Heap (Priority Queue), Merge Sort",47
"Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.  ",trapping-rain-water,Trapping Rain Water,"Array, Two Pointers, Dynamic Programming, Stack, Monotonic Stack",45
"Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0. Notice that the solution set must not contain duplicate triplets.  ",3sum,3Sum,"Array, Two Pointers, Sorting",44
"Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if:  Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Every close bracket has a corresponding open bracket of the same type.   ",valid-parentheses,Valid Parentheses,"String, Stack",43
"A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:  Every adjacent pair of words differs by a single letter. Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList. sk == endWord  Given two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.  ",word-ladder,Word Ladder,"Hash Table, String, Breadth-First Search",41
"Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).  ",median-of-two-sorted-arrays,Median of Two Sorted Arrays,"Array, Binary Search, Divide and Conquer",40
"Given an m x n grid of characters board and a string word, return true if word exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.  ",word-search,Word Search,"Array, Backtracking, Matrix",36
"You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself.  ",add-two-numbers,Add Two Numbers,"Linked List, Math, Recursion",36
"You are given an m x n grid where each cell can have one of three values:  0 representing an empty cell, 1 representing a fresh orange, or 2 representing a rotten orange.  Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten. Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.  ",rotting-oranges,Rotting Oranges,"Array, Breadth-First Search, Matrix",35
"Given an integer array nums, find the subarray with the largest sum, and return its sum.  ",maximum-subarray,Maximum Subarray,"Array, Divide and Conquer, Dynamic Programming",35
"Given a string s, return the longest palindromic substring in s.  ",longest-palindromic-substring,Longest Palindromic Substring,"String, Dynamic Programming",35
"There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.  For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.  Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.  ",course-schedule-ii,Course Schedule II,"Depth-First Search, Breadth-First Search, Graph, Topological Sort",34
"Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words. Note that the same word in the dictionary may be reused multiple times in the segmentation.  ",word-break,Word Break,"Array, Hash Table, String, Dynamic Programming, Trie, Memoization",34
"You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window.  ",sliding-window-maximum,Sliding Window Maximum,"Array, Queue, Sliding Window, Heap (Priority Queue), Monotonic Queue",32
"Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i]. The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer. You must write an algorithm that runs in O(n) time and without using the division operation.  ",product-of-array-except-self,Product of Array Except Self,"Array, Prefix Sum",32
"Given an m x n board of characters and a list of strings words, return all words on the board. Each word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.  ",word-search-ii,Word Search II,"Array, String, Backtracking, Trie, Matrix",31
"There is an integer array nums sorted in ascending order (with distinct values). Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2]. Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums. You must write an algorithm with O(log n) runtime complexity.  ",search-in-rotated-sorted-array,Search in Rotated Sorted Array,"Array, Binary Search",31
"Given an array of strings words (without duplicates), return all the concatenated words in the given list of words. A concatenated word is defined as a string that is comprised entirely of at least two shorter words (not necesssarily distinct) in the given array.  ",concatenated-words,Concatenated Words,"Array, String, Dynamic Programming, Depth-First Search, Trie",30
"Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1.  ",first-unique-character-in-a-string,First Unique Character in a String,"Hash Table, String, Queue, Counting",30
"You are assigned to put some amount of boxes onto one truck. You are given a 2D array boxTypes, where boxTypes[i] = [numberOfBoxesi, numberOfUnitsPerBoxi]:  numberOfBoxesi is the number of boxes of type i. numberOfUnitsPerBoxi is the number of units in each box of the type i.  You are also given an integer truckSize, which is the maximum number of boxes that can be put on the truck. You can choose any boxes to put on the truck as long as the number of boxes does not exceed truckSize. Return the maximum total number of units that can be put on the truck.  ",maximum-units-on-a-truck,Maximum Units on a Truck,"Array, Greedy, Sorting",29
"Given an array of integers nums, find the maximum length of a subarray where the product of all its elements is positive. A subarray of an array is a consecutive sequence of zero or more values taken out of that array. Return the maximum length of a subarray with positive product.  ",maximum-length-of-subarray-with-positive-product,Maximum Length of Subarray With Positive Product,"Array, Dynamic Programming, Greedy",29
"Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.  ",top-k-frequent-elements,Top K Frequent Elements,"Array, Hash Table, Divide and Conquer, Sorting, Heap (Priority Queue), Bucket Sort, Counting, Quickselect",29
"There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.  For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.  Return true if you can finish all courses. Otherwise, return false.  ",course-schedule,Course Schedule,"Depth-First Search, Breadth-First Search, Graph, Topological Sort",28
"Given the root of a binary tree, return the zigzag level order traversal of its nodes' values. (i.e., from left to right, then right to left for the next level and alternate between).  ",binary-tree-zigzag-level-order-traversal,Binary Tree Zigzag Level Order Traversal,"Tree, Breadth-First Search, Binary Tree",28
"Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order. A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.   ",letter-combinations-of-a-phone-number,Letter Combinations of a Phone Number,"Hash Table, String, Backtracking",28
"Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.  Symbol       Value I             1 V             5 X             10 L             50 C             100 D             500 M             1000 For example, 2 is written as II in Roman numeral, just two one's added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:  I can be placed before V (5) and X (10) to make 4 and 9.  X can be placed before L (50) and C (100) to make 40 and 90.  C can be placed before D (500) and M (1000) to make 400 and 900.  Given an integer, convert it to a roman numeral.  ",integer-to-roman,Integer to Roman,"Hash Table, Math, String",27
"You are given two positive integers n and k. A factor of an integer n is defined as an integer i where n % i == 0. Consider a list of all factors of n sorted in ascending order, return the kth factor in this list or return -1 if n has less than k factors.  ",the-kth-factor-of-n,The kth Factor of n,"Math, Number Theory",25
"Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”  ",lowest-common-ancestor-of-a-binary-tree,Lowest Common Ancestor of a Binary Tree,"Tree, Depth-First Search, Binary Tree",25
"Given the root of a binary tree, determine if it is a valid binary search tree (BST). A valid BST is defined as follows:  The left subtree of a node contains only nodes with keys less than the node's key. The right subtree of a node contains only nodes with keys greater than the node's key. Both the left and right subtrees must also be binary search trees.   ",validate-binary-search-tree,Validate Binary Search Tree,"Tree, Depth-First Search, Binary Search Tree, Binary Tree",25
"In a linked list of size n, where n is even, the ith node (0-indexed) of the linked list is known as the twin of the (n-1-i)th node, if 0 <= i <= (n / 2) - 1.  For example, if n = 4, then node 0 is the twin of node 3, and node 1 is the twin of node 2. These are the only nodes with twins for n = 4.  The twin sum is defined as the sum of a node and its twin. Given the head of a linked list with even length, return the maximum twin sum of the linked list.  ",maximum-twin-sum-of-a-linked-list,Maximum Twin Sum of a Linked List,"Linked List, Two Pointers, Stack",23
"Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure. Clarification: The input/output format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.  ",serialize-and-deserialize-binary-tree,Serialize and Deserialize Binary Tree,"String, Tree, Depth-First Search, Breadth-First Search, Design, Binary Tree",21
"You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.  ",house-robber,House Robber,"Array, Dynamic Programming",21
"You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]). Find two lines that together with the x-axis form a container, such that the container contains the most water. Return the maximum amount of water a container can store. Notice that you may not slant the container.  ",container-with-most-water,Container With Most Water,"Array, Two Pointers, Greedy",21
"You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position. Return true if you can reach the last index, or false otherwise.  ",jump-game,Jump Game,"Array, Dynamic Programming, Greedy",20
"Given an unsorted integer array nums, return the smallest missing positive integer. You must implement an algorithm that runs in O(n) time and uses constant extra space.  ",first-missing-positive,First Missing Positive,"Array, Hash Table",20
You are given the heads of two sorted linked lists list1 and list2. Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists. Return the head of the merged linked list.  ,merge-two-sorted-lists,Merge Two Sorted Lists,"Linked List, Recursion",20
"You are given an m x n binary matrix grid. An island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. The area of an island is the number of cells with a value 1 in the island. Return the maximum area of an island in grid. If there is no island, return 0.  ",max-area-of-island,Max Area of Island,"Array, Depth-First Search, Breadth-First Search, Union Find, Matrix",19
"Given an array of integers nums and an integer k, return the total number of subarrays whose sum equals to k. A subarray is a contiguous non-empty sequence of elements within an array.  ",subarray-sum-equals-k,Subarray Sum Equals K,"Array, Hash Table, Prefix Sum",19
Convert a non-negative integer num to its English words representation.  ,integer-to-english-words,Integer to English Words,"Math, String, Recursion",19
"Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.  ",contains-duplicate,Contains Duplicate,"Array, Hash Table, Sorting",19
"A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null. Construct a deep copy of the list. The deep copy should consist of exactly n brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. None of the pointers in the new list should point to nodes in the original list. For example, if there are two nodes X and Y in the original list, where X.random --> Y, then for the corresponding two nodes x and y in the copied list, x.random --> y. Return the head of the copied linked list. The linked list is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where:  val: an integer representing Node.val random_index: the index of the node (range from 0 to n-1) that the random pointer points to, or null if it does not point to any node.  Your code will only be given the head of the original linked list.  ",copy-list-with-random-pointer,Copy List with Random Pointer,"Hash Table, Linked List",19
"There are n gas stations along a circular route, where the amount of gas at the ith station is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the ith station to its next (i + 1)th station. You begin the journey with an empty tank at one of the gas stations. Given two integer arrays gas and cost, return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1. If there exists a solution, it is guaranteed to be unique  ",gas-station,Gas Station,"Array, Greedy",19
Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:  Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.  Note:  A Sudoku board (partially filled) could be valid but is not necessarily solvable. Only the filled cells need to be validated according to the mentioned rules.   ,valid-sudoku,Valid Sudoku,"Array, Hash Table, Matrix",19
"You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money. Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. You may assume that you have an infinite number of each kind of coin.  ",coin-change,Coin Change,"Array, Dynamic Programming, Breadth-First Search",18
"Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. Implement the MinStack class:  MinStack() initializes the stack object. void push(int val) pushes the element val onto the stack. void pop() removes the element on the top of the stack. int top() gets the top element of the stack. int getMin() retrieves the minimum element in the stack.  You must implement a solution with O(1) time complexity for each function.  ",min-stack,Min Stack,"Stack, Design",18
"Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order. The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different. The test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.  ",combination-sum,Combination Sum,"Array, Backtracking",18
"A newly designed keypad was tested, where a tester pressed a sequence of n keys, one at a time. You are given a string keysPressed of length n, where keysPressed[i] was the ith key pressed in the testing sequence, and a sorted list releaseTimes, where releaseTimes[i] was the time the ith key was released. Both arrays are 0-indexed. The 0th key was pressed at the time 0, and every subsequent key was pressed at the exact time the previous key was released. The tester wants to know the key of the keypress that had the longest duration. The ith keypress had a duration of releaseTimes[i] - releaseTimes[i - 1], and the 0th keypress had a duration of releaseTimes[0]. Note that the same key could have been pressed multiple times during the test, and these multiple presses of the same key may not have had the same duration. Return the key of the keypress that had the longest duration. If there are multiple such keypresses, return the lexicographically largest key of the keypresses.  ",slowest-key,Slowest Key,"Array, String",17
"Given a string s, rearrange the characters of s so that any two adjacent characters are not the same. Return any possible rearrangement of s or return """" if not possible.  ",reorganize-string,Reorganize String,"Hash Table, String, Greedy, Sorting, Heap (Priority Queue), Counting",17
"Implement the RandomizedSet class:  RandomizedSet() Initializes the RandomizedSet object. bool insert(int val) Inserts an item val into the set if not present. Returns true if the item was not present, false otherwise. bool remove(int val) Removes an item val from the set if present. Returns true if the item was present, false otherwise. int getRandom() Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the same probability of being returned.  You must implement the functions of the class such that each function works in average O(1) time complexity.  ",insert-delete-getrandom-o1,Insert Delete GetRandom O(1),"Array, Hash Table, Math, Design, Randomized",17
"Given an integer array nums, find a subarray that has the largest product, and return the product. The test cases are generated so that the answer will fit in a 32-bit integer.  ",maximum-product-subarray,Maximum Product Subarray,"Array, Dynamic Programming",17
"A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root. The path sum of a path is the sum of the node's values in the path. Given the root of a binary tree, return the maximum path sum of any non-empty path.  ",binary-tree-maximum-path-sum,Binary Tree Maximum Path Sum,"Dynamic Programming, Tree, Depth-First Search, Binary Tree",17
"Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive. There is only one repeated number in nums, return this repeated number. You must solve the problem without modifying the array nums and uses only constant extra space.  ",find-the-duplicate-number,Find the Duplicate Number,"Array, Two Pointers, Binary Search, Bit Manipulation",16
"Given the head of a singly linked list, return true if it is a palindrome or false otherwise.  ",palindrome-linked-list,Palindrome Linked List,"Linked List, Two Pointers, Stack, Recursion",16
"Given an integer array nums and an integer k, return the kth largest element in the array. Note that it is the kth largest element in the sorted order, not the kth distinct element. You must solve it in O(n) time complexity.  ",kth-largest-element-in-an-array,Kth Largest Element in an Array,"Array, Divide and Conquer, Sorting, Heap (Priority Queue), Quickselect",16
"Given two strings s and p, return an array of all the start indices of p's anagrams in s. You may return the answer in any order. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.  ",find-all-anagrams-in-a-string,Find All Anagrams in a String,"Hash Table, String, Sliding Window",15
"A trie (pronounced as ""try"") or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker. Implement the Trie class:  Trie() Initializes the trie object. void insert(String word) Inserts the string word into the trie. boolean search(String word) Returns true if the string word is in the trie (i.e., was inserted before), and false otherwise. boolean startsWith(String prefix) Returns true if there is a previously inserted string word that has the prefix prefix, and false otherwise.   ",implement-trie-prefix-tree,Implement Trie (Prefix Tree),"Hash Table, String, Design, Trie",15
"You are given the root of a binary search tree (BST), where the values of exactly two nodes of the tree were swapped by mistake. Recover the tree without changing its structure.  ",recover-binary-search-tree,Recover Binary Search Tree,"Tree, Depth-First Search, Binary Search Tree, Binary Tree",15
"Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.  ",generate-parentheses,Generate Parentheses,"String, Dynamic Programming, Backtracking",15
"Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.  ",3sum-closest,3Sum Closest,"Array, Two Pointers, Sorting",15
"Tic-tac-toe is played by two players A and B on a 3 x 3 grid. The rules of Tic-Tac-Toe are:  Players take turns placing characters into empty squares ' '. The first player A always places 'X' characters, while the second player B always places 'O' characters. 'X' and 'O' characters are always placed into empty squares, never on filled ones. The game ends when there are three of the same (non-empty) character filling any row, column, or diagonal. The game also ends if all squares are non-empty. No more moves can be played if the game is over.  Given a 2D integer array moves where moves[i] = [rowi, coli] indicates that the ith move will be played on grid[rowi][coli]. return the winner of the game if it exists (A or B). In case the game ends in a draw return ""Draw"". If there are still movements to play return ""Pending"". You can assume that moves is valid (i.e., it follows the rules of Tic-Tac-Toe), the grid is initially empty, and A will play first.  ",find-winner-on-a-tic-tac-toe-game,Find Winner on a Tic Tac Toe Game,"Array, Hash Table, Matrix, Simulation",14
"You are given a list of songs where the ith song has a duration of time[i] seconds. Return the number of pairs of songs for which their total duration in seconds is divisible by 60. Formally, we want the number of indices i, j such that i < j with (time[i] + time[j]) % 60 == 0.  ",pairs-of-songs-with-total-durations-divisible-by-60,Pairs of Songs With Total Durations Divisible by 60,"Array, Hash Table, Counting",14
"We are given an array asteroids of integers representing asteroids in a row. For each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed. Find out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode. Two asteroids moving in the same direction will never meet.  ",asteroid-collision,Asteroid Collision,"Array, Stack",14
You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?  ,climbing-stairs,Climbing Stairs,"Math, Dynamic Programming, Memoization",14
"Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is. You may not alter the values in the list's nodes, only nodes themselves may be changed.  ",reverse-nodes-in-k-group,Reverse Nodes in k-Group,"Linked List, Recursion",14
"Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order.  ",squares-of-a-sorted-array,Squares of a Sorted Array,"Array, Two Pointers, Sorting",13
"Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1. You must write an algorithm with O(log n) runtime complexity.  ",binary-search,Binary Search,"Array, Binary Search",13
"Given a string s which represents an expression, evaluate this expression and return its value.  The integer division should truncate toward zero. You may assume that the given expression is always valid. All intermediate results will be in the range of [-231, 231 - 1]. Note: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval().  ",basic-calculator-ii,Basic Calculator II,"Math, String, Stack",13
"You are given an integer array prices where prices[i] is the price of a given stock on the ith day. On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day. Find and return the maximum profit you can achieve.  ",best-time-to-buy-and-sell-stock-ii,Best Time to Buy and Sell Stock II,"Array, Dynamic Programming, Greedy",13
"Given an integer array nums of unique elements, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order.  ",subsets,Subsets,"Array, Backtracking, Bit Manipulation",13
"Given an m x n matrix, return all elements of the matrix in spiral order.  ",spiral-matrix,Spiral Matrix,"Array, Matrix, Simulation",13
"You are given a 0-indexed array of integers nums of length n. You are initially positioned at nums[0]. Each element nums[i] represents the maximum length of a forward jump from index i. In other words, if you are at nums[i], you can jump to any nums[i + j] where:  0 <= j <= nums[i] and i + j < n  Return the minimum number of jumps to reach nums[n - 1]. The test cases are generated such that you can reach nums[n - 1].  ",jump-game-ii,Jump Game II,"Array, Dynamic Programming, Greedy",13
"Design a parking system for a parking lot. The parking lot has three kinds of parking spaces: big, medium, and small, with a fixed number of slots for each size. Implement the ParkingSystem class:  ParkingSystem(int big, int medium, int small) Initializes object of the ParkingSystem class. The number of slots for each parking space are given as part of the constructor. bool addCar(int carType) Checks whether there is a parking space of carType for the car that wants to get into the parking lot. carType can be of three kinds: big, medium, or small, which are represented by 1, 2, and 3 respectively. A car can only park in a parking space of its carType. If there is no space available, return false, else park the car in that size space and return true.   ",design-parking-system,Design Parking System,"Design, Simulation, Counting",12
"Given an array of integers nums and an integer limit, return the size of the longest non-empty subarray such that the absolute difference between any two elements of this subarray is less than or equal to limit.  ",longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit,Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit,"Array, Queue, Sliding Window, Heap (Priority Queue), Ordered Set, Monotonic Queue",12
"Given an array of strings words and an integer k, return the k most frequent strings. Return the answer sorted by the frequency from highest to lowest. Sort the words with the same frequency by their lexicographical order.  ",top-k-frequent-words,Top K Frequent Words,"Hash Table, String, Trie, Sorting, Heap (Priority Queue), Bucket Sort, Counting",12
"Given the root of a binary tree, return the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root. The length of a path between two nodes is represented by the number of edges between them.  ",diameter-of-binary-tree,Diameter of Binary Tree,"Tree, Depth-First Search, Binary Tree",12
"Given an encoded string, return its decoded string. The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer. You may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there will not be input like 3a or 2[4]. The test cases are generated so that the length of the output will never exceed 105.  ",decode-string,Decode String,"String, Stack, Recursion",12
"You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad. You are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.  ",first-bad-version,First Bad Version,"Binary Search, Interactive",12
"Given the head of a singly linked list, reverse the list, and return the reversed list.  ",reverse-linked-list,Reverse Linked List,"Linked List, Recursion",12
"Given an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.  ",largest-rectangle-in-histogram,Largest Rectangle in Histogram,"Array, Stack, Monotonic Stack",12
"You are given an m x n integer matrix matrix with the following two properties:  Each row is sorted in non-decreasing order. The first integer of each row is greater than the last integer of the previous row.  Given an integer target, return true if target is in matrix or false otherwise. You must write a solution in O(log(m * n)) time complexity.  ",search-a-2d-matrix,Search a 2D Matrix,"Array, Binary Search, Matrix",12
"You are given a 0-indexed array of positive integers w where w[i] describes the weight of the ith index. You need to implement the function pickIndex(), which randomly picks an index in the range [0, w.length - 1] (inclusive) and returns it. The probability of picking an index i is w[i] / sum(w).  For example, if w = [1, 3], the probability of picking index 0 is 1 / (1 + 3) = 0.25 (i.e., 25%), and the probability of picking index 1 is 3 / (1 + 3) = 0.75 (i.e., 75%).   ",random-pick-with-weight,Random Pick with Weight,"Array, Math, Binary Search, Prefix Sum, Randomized",11
"Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 <= numbers.length. Return the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2. The tests are generated such that there is exactly one solution. You may not use the same element twice. Your solution must use only constant extra space.  ",two-sum-ii-input-array-is-sorted,Two Sum II - Input Array Is Sorted,"Array, Two Pointers, Binary Search",11
"Given a string s and a dictionary of strings wordDict, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in any order. Note that the same word in the dictionary may be reused multiple times in the segmentation.  ",word-break-ii,Word Break II,"Array, Hash Table, String, Dynamic Programming, Backtracking, Trie, Memoization",11
"Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string """". The testcases will be generated such that the answer is unique.  ",minimum-window-substring,Minimum Window Substring,"Hash Table, String, Sliding Window",11
"Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0. Assume the environment does not allow you to store 64-bit integers (signed or unsigned).  ",reverse-integer,Reverse Integer,Math,11
"Given the root of a binary tree, calculate the vertical order traversal of the binary tree. For each node at position (row, col), its left and right children will be at positions (row + 1, col - 1) and (row + 1, col + 1) respectively. The root of the tree is at (0, 0). The vertical order traversal of a binary tree is a list of top-to-bottom orderings for each column index starting from the leftmost column and ending on the rightmost column. There may be multiple nodes in the same row and same column. In such a case, sort these nodes by their values. Return the vertical order traversal of the binary tree.  ",vertical-order-traversal-of-a-binary-tree,Vertical Order Traversal of a Binary Tree,"Hash Table, Tree, Depth-First Search, Breadth-First Search, Binary Tree",10
"An array arr a mountain if the following properties hold:  arr.length >= 3 There exists some i with 0 < i < arr.length - 1 such that: 	 arr[0] < arr[1] < ... < arr[i - 1] < arr[i]  arr[i] > arr[i + 1] > ... > arr[arr.length - 1]    Given a mountain array arr, return the index i such that arr[0] < arr[1] < ... < arr[i - 1] < arr[i] > arr[i + 1] > ... > arr[arr.length - 1]. You must solve it in O(log(arr.length)) time complexity.  ",peak-index-in-a-mountain-array,Peak Index in a Mountain Array,"Array, Binary Search",10
"Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.  ",daily-temperatures,Daily Temperatures,"Array, Stack, Monotonic Stack",10
"Design a HashMap without using any built-in hash table libraries. Implement the MyHashMap class:  MyHashMap() initializes the object with an empty map. void put(int key, int value) inserts a (key, value) pair into the HashMap. If the key already exists in the map, update the corresponding value. int get(int key) returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key. void remove(key) removes the key and its corresponding value if the map contains the mapping for the key.   ",design-hashmap,Design HashMap,"Array, Hash Table, Linked List, Design, Hash Function",10
"The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,  F(0) = 0, F(1) = 1 F(n) = F(n - 1) + F(n - 2), for n > 1.  Given n, calculate F(n).  ",fibonacci-number,Fibonacci Number,"Math, Dynamic Programming, Recursion, Memoization",10
"Given string num representing a non-negative integer num, and an integer k, return the smallest possible integer after removing k digits from num.  ",remove-k-digits,Remove K Digits,"String, Stack, Greedy, Monotonic Stack",10
"You are given an array of variable pairs equations and an array of real numbers values, where equations[i] = [Ai, Bi] and values[i] represent the equation Ai / Bi = values[i]. Each Ai or Bi is a string that represents a single variable. You are also given some queries, where queries[j] = [Cj, Dj] represents the jth query where you must find the answer for Cj / Dj = ?. Return the answers to all queries. If a single answer cannot be determined, return -1.0. Note: The input is always valid. You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.  ",evaluate-division,Evaluate Division,"Array, Depth-First Search, Breadth-First Search, Union Find, Graph, Shortest Path",10
Write an efficient algorithm that searches for a value target in an m x n integer matrix matrix. This matrix has the following properties:  Integers in each row are sorted in ascending from left to right. Integers in each column are sorted in ascending from top to bottom.   ,search-a-2d-matrix-ii,Search a 2D Matrix II,"Array, Binary Search, Divide and Conquer, Matrix",10
"Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.  ",binary-tree-right-side-view,Binary Tree Right Side View,"Tree, Depth-First Search, Breadth-First Search, Binary Tree",10
You are given the head of a singly linked-list. The list can be represented as:  L0 → L1 → … → Ln - 1 → Ln  Reorder the list to be on the following form:  L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …  You may not modify the values in the list's nodes. Only nodes themselves may be changed.  ,reorder-list,Reorder List,"Linked List, Two Pointers, Stack, Recursion",10
"Given the head of a linked list, remove the nth node from the end of the list and return its head.  ",remove-nth-node-from-end-of-list,Remove Nth Node From End of List,"Linked List, Two Pointers",10
"There is a car with capacity empty seats. The vehicle only drives east (i.e., it cannot turn around and drive west). You are given the integer capacity and an array trips where trips[i] = [numPassengersi, fromi, toi] indicates that the ith trip has numPassengersi passengers and the locations to pick them up and drop them off are fromi and toi respectively. The locations are given as the number of kilometers due east from the car's initial location. Return true if it is possible to pick up and drop off all passengers for all the given trips, or false otherwise.  ",car-pooling,Car Pooling,"Array, Sorting, Heap (Priority Queue), Simulation, Prefix Sum",9
"Given an n x n binary matrix grid, return the length of the shortest clear path in the matrix. If there is no clear path, return -1. A clear path in a binary matrix is a path from the top-left cell (i.e., (0, 0)) to the bottom-right cell (i.e., (n - 1, n - 1)) such that:  All the visited cells of the path are 0. All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).  The length of a clear path is the number of visited cells of this path.  ",shortest-path-in-binary-matrix,Shortest Path in Binary Matrix,"Array, Breadth-First Search, Matrix",9
"Design a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key's value at a certain timestamp. Implement the TimeMap class:  TimeMap() Initializes the object of the data structure. void set(String key, String value, int timestamp) Stores the key key with the value value at the given time timestamp. String get(String key, int timestamp) Returns a value such that set was called previously, with timestamp_prev <= timestamp. If there are multiple such values, it returns the value associated with the largest timestamp_prev. If there are no values, it returns """".   ",time-based-key-value-store,Time Based Key-Value Store,"Hash Table, String, Binary Search, Design",9
"You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once. Return the single element that appears only once. Your solution must run in O(log n) time and O(1) space.  ",single-element-in-a-sorted-array,Single Element in a Sorted Array,"Array, Binary Search",9
"Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order.  ",intersection-of-two-arrays,Intersection of Two Arrays,"Array, Hash Table, Two Pointers, Binary Search, Sorting",9
"Given the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree.  ",kth-smallest-element-in-a-bst,Kth Smallest Element in a BST,"Tree, Depth-First Search, Binary Search Tree, Binary Tree",9
"Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.  ",rotate-array,Rotate Array,"Array, Math, Two Pointers",9
"Given an array nums of size n, return the majority element. The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.  ",majority-element,Majority Element,"Array, Hash Table, Divide and Conquer, Sorting, Counting",9
"Given head, the head of a linked list, determine if the linked list has a cycle in it. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter. Return true if there is a cycle in the linked list. Otherwise, return false.  ",linked-list-cycle,Linked List Cycle,"Hash Table, Linked List, Two Pointers",9
"Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence. You must write an algorithm that runs in O(n) time.  ",longest-consecutive-sequence,Longest Consecutive Sequence,"Array, Hash Table, Union Find",9
"A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:  Every adjacent pair of words differs by a single letter. Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList. sk == endWord  Given two words, beginWord and endWord, and a dictionary wordList, return all the shortest transformation sequences from beginWord to endWord, or an empty list if no such sequence exists. Each sequence should be returned as a list of the words [beginWord, s1, s2, ..., sk].  ",word-ladder-ii,Word Ladder II,"Hash Table, String, Backtracking, Breadth-First Search",9
"A message containing letters from A-Z can be encoded into numbers using the following mapping:  'A' -> ""1"" 'B' -> ""2"" ... 'Z' -> ""26""  To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, ""11106"" can be mapped into:  ""AAJF"" with the grouping (1 1 10 6) ""KJF"" with the grouping (11 10 6)  Note that the grouping (1 11 06) is invalid because ""06"" cannot be mapped into 'F' since ""6"" is different from ""06"". Given a string s containing only digits, return the number of ways to decode it. The test cases are generated so that the answer fits in a 32-bit integer.  ",decode-ways,Decode Ways,"String, Dynamic Programming",9
"Given a non-negative integer x, return the square root of x rounded down to the nearest integer. The returned integer should be non-negative as well. You must not use any built-in exponent function or operator.  For example, do not use pow(x, 0.5) in c++ or x ** 0.5 in python.   ",sqrtx,Sqrt(x),"Math, Binary Search",9
"Implement pow(x, n), which calculates x raised to the power n (i.e., xn).  ",powx-n,"Pow(x, n)","Math, Recursion",9
"Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.  ",permutations,Permutations,"Array, Backtracking",9
"Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You must write an algorithm with O(log n) runtime complexity.  ",search-insert-position,Search Insert Position,"Array, Binary Search",9
"Given a string containing just the characters '(' and ')', return the length of the longest valid (well-formed) parentheses substring.  ",longest-valid-parentheses,Longest Valid Parentheses,"String, Dynamic Programming, Stack",9
"Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator. The integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2. Return the quotient after dividing dividend by divisor. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.  ",divide-two-integers,Divide Two Integers,"Math, Bit Manipulation",9
"Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums. Consider the number of unique elements of nums be k, to get accepted, you need to do the following things:  Change the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. The remaining elements of nums are not important as well as the size of nums. Return k.  Custom Judge: The judge will test your solution with the following code:  int[] nums = [...]; // Input array int[] expectedNums = [...]; // The expected answer with correct length  int k = removeDuplicates(nums); // Calls your implementation  assert k == expectedNums.length; for (int i = 0; i < k; i++) {     assert nums[i] == expectedNums[i]; }  If all assertions pass, then your solution will be accepted.  ",remove-duplicates-from-sorted-array,Remove Duplicates from Sorted Array,"Array, Two Pointers",9
"Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string """".  ",longest-common-prefix,Longest Common Prefix,"String, Trie",9
"Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer (similar to C/C++'s atoi function). The algorithm for myAtoi(string s) is as follows:  Read in and ignore any leading whitespace. Check if the next character (if not already at the end of the string) is '-' or '+'. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present. Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored. Convert these digits into an integer (i.e. ""123"" -> 123, ""0032"" -> 32). If no digits were read, then the integer is 0. Change the sign as necessary (from step 2). If the integer is out of the 32-bit signed integer range [-231, 231 - 1], then clamp the integer so that it remains in the range. Specifically, integers less than -231 should be clamped to -231, and integers greater than 231 - 1 should be clamped to 231 - 1. Return the integer as the final result.  Note:  Only the space character ' ' is considered a whitespace character. Do not ignore any characters other than the leading whitespace or the rest of the string after the digits.   ",string-to-integer-atoi,String to Integer (atoi),String,9
"You are given a string s and an integer k, a k duplicate removal consists of choosing k adjacent and equal letters from s and removing them, causing the left and the right side of the deleted substring to concatenate together. We repeatedly make k duplicate removals on s until we no longer can. Return the final string after all such duplicate removals have been made. It is guaranteed that the answer is unique.  ",remove-all-adjacent-duplicates-in-string-ii,Remove All Adjacent Duplicates in String II,"String, Stack",8
"Design and implement a data structure for a Least Frequently Used (LFU) cache. Implement the LFUCache class:  LFUCache(int capacity) Initializes the object with the capacity of the data structure. int get(int key) Gets the value of the key if the key exists in the cache. Otherwise, returns -1. void put(int key, int value) Update the value of the key if present, or inserts the key if not already present. When the cache reaches its capacity, it should invalidate and remove the least frequently used key before inserting a new item. For this problem, when there is a tie (i.e., two or more keys with the same frequency), the least recently used key would be invalidated.  To determine the least frequently used key, a use counter is maintained for each key in the cache. The key with the smallest use counter is the least frequently used key. When a key is first inserted into the cache, its use counter is set to 1 (due to the put operation). The use counter for a key in the cache is incremented either a get or put operation is called on it. The functions get and put must each run in O(1) average time complexity.  ",lfu-cache,LFU Cache,"Hash Table, Linked List, Design, Doubly-Linked List",8
"Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST. Basically, the deletion can be divided into two stages:  Search for a node to remove. If the node is found, delete the node.   ",delete-node-in-a-bst,Delete Node in a BST,"Tree, Binary Search Tree, Binary Tree",8
"Given an array of characters chars, compress it using the following algorithm: Begin with an empty string s. For each group of consecutive repeating characters in chars:  If the group's length is 1, append the character to s. Otherwise, append the character followed by the group's length.  The compressed string s should not be returned separately, but instead, be stored in the input character array chars. Note that group lengths that are 10 or longer will be split into multiple characters in chars. After you are done modifying the input array, return the new length of the array. You must write an algorithm that uses only constant extra space.  ",string-compression,String Compression,"Two Pointers, String",8
"Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements. Note that you must do this in-place without making a copy of the array.  ",move-zeroes,Move Zeroes,"Array, Two Pointers",8
"Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.  ",missing-number,Missing Number,"Array, Hash Table, Math, Binary Search, Bit Manipulation, Sorting",8
"Given two strings s and t, return true if t is an anagram of s, and false otherwise. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.  ",valid-anagram,Valid Anagram,"Hash Table, String, Sorting",8
"Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty). Implement the MyQueue class:  void push(int x) Pushes element x to the back of the queue. int pop() Removes the element from the front of the queue and returns it. int peek() Returns the element at the front of the queue. boolean empty() Returns true if the queue is empty, false otherwise.  Notes:  You must use only standard operations of a stack, which means only push to top, peek/pop from top, size, and is empty operations are valid. Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack's standard operations.   ",implement-queue-using-stacks,Implement Queue using Stacks,"Stack, Design, Queue",8
"A peak element is an element that is strictly greater than its neighbors. Given a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks. You may imagine that nums[-1] = nums[n] = -∞. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array. You must write an algorithm that runs in O(log n) time.  ",find-peak-element,Find Peak Element,"Array, Binary Search",8
"Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null. For example, the following two linked lists begin to intersect at node c1:  The test cases are generated such that there are no cycles anywhere in the entire linked structure. Note that the linked lists must retain their original structure after the function returns. Custom Judge: The inputs to the judge are given as follows (your program is not given these inputs):  intersectVal - The value of the node where the intersection occurs. This is 0 if there is no intersected node. listA - The first linked list. listB - The second linked list. skipA - The number of nodes to skip ahead in listA (starting from the head) to get to the intersected node. skipB - The number of nodes to skip ahead in listB (starting from the head) to get to the intersected node.  The judge will then create the linked structure based on these inputs and pass the two heads, headA and headB to your program. If you correctly return the intersected node, then your solution will be accepted.  ",intersection-of-two-linked-lists,Intersection of Two Linked Lists,"Hash Table, Linked List, Two Pointers",8
"Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:  [4,5,6,7,0,1,2] if it was rotated 4 times. [0,1,2,4,5,6,7] if it was rotated 7 times.  Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]]. Given the sorted rotated array nums of unique elements, return the minimum element of this array. You must write an algorithm that runs in O(log n) time.  ",find-minimum-in-rotated-sorted-array,Find Minimum in Rotated Sorted Array,"Array, Binary Search",8
"Given a non-empty array of integers nums, every element appears twice except for one. Find that single one. You must implement a solution with a linear runtime complexity and use only constant extra space.  ",single-number,Single Number,"Array, Bit Manipulation",8
There are n children standing in a line. Each child is assigned a rating value given in the integer array ratings. You are giving candies to these children subjected to the following requirements:  Each child must have at least one candy. Children with a higher rating get more candies than their neighbors.  Return the minimum number of candies you need to have to distribute the candies to the children.  ,candy,Candy,"Array, Greedy",8
"Given a reference of a node in a connected undirected graph. Return a deep copy (clone) of the graph. Each node in the graph contains a value (int) and a list (List[Node]) of its neighbors.  class Node {     public int val;     public List<Node> neighbors; }    Test case format: For simplicity, each node's value is the same as the node's index (1-indexed). For example, the first node with val == 1, the second node with val == 2, and so on. The graph is represented in the test case using an adjacency list. An adjacency list is a collection of unordered lists used to represent a finite graph. Each list describes the set of neighbors of a node in the graph. The given node will always be the first node with val = 1. You must return the copy of the given node as a reference to the cloned graph.  ",clone-graph,Clone Graph,"Hash Table, Depth-First Search, Breadth-First Search, Graph",8
"A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers. Given a string s, return true if it is a palindrome, or false otherwise.  ",valid-palindrome,Valid Palindrome,"Two Pointers, String",8
"Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).  ",binary-tree-level-order-traversal,Binary Tree Level Order Traversal,"Tree, Breadth-First Search, Binary Tree",8
"Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).  ",symmetric-tree,Symmetric Tree,"Tree, Depth-First Search, Breadth-First Search, Binary Tree",8
"Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue. We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively. You must solve this problem without using the library's sort function.  ",sort-colors,Sort Colors,"Array, Two Pointers, Sorting",8
"Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2. You have the following three operations permitted on a word:  Insert a character Delete a character Replace a character   ",edit-distance,Edit Distance,"String, Dynamic Programming",8
"Given a string path, which is an absolute path (starting with a slash '/') to a file or directory in a Unix-style file system, convert it to the simplified canonical path. In a Unix-style file system, a period '.' refers to the current directory, a double period '..' refers to the directory up a level, and any multiple consecutive slashes (i.e. '//') are treated as a single slash '/'. For this problem, any other format of periods such as '...' are treated as file/directory names. The canonical path should have the following format:  The path starts with a single slash '/'. Any two directories are separated by a single slash '/'. The path does not end with a trailing '/'. The path only contains the directories on the path from the root directory to the target file or directory (i.e., no period '.' or double period '..')  Return the simplified canonical path.  ",simplify-path,Simplify Path,"String, Stack",8
"There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time. Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner. The test cases are generated so that the answer will be less than or equal to 2 * 109.  ",unique-paths,Unique Paths,"Math, Dynamic Programming, Combinatorics",8
"You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise). You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.  ",rotate-image,Rotate Image,"Array, Math, Matrix",8
"Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)  ",swap-nodes-in-pairs,Swap Nodes in Pairs,"Linked List, Recursion",8
"Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:  '.' Matches any single character.​​​​ '*' Matches zero or more of the preceding element.  The matching should cover the entire input string (not partial).  ",regular-expression-matching,Regular Expression Matching,"String, Dynamic Programming, Recursion",8
"Given the root of a binary tree, return all duplicate subtrees. For each kind of duplicate subtrees, you only need to return the root node of any one of them. Two trees are duplicate if they have the same structure with the same node values.  ",find-duplicate-subtrees,Find Duplicate Subtrees,"Hash Table, Tree, Depth-First Search, Binary Tree",7
"Given a binary array nums, return the maximum length of a contiguous subarray with an equal number of 0 and 1.  ",contiguous-array,Contiguous Array,"Array, Hash Table, Prefix Sum",7
"You are given an integer array nums and an integer target. You want to build an expression out of nums by adding one of the symbols '+' and '-' before each integer in nums and then concatenate all the integers.  For example, if nums = [2, 1], you can add a '+' before 2 and a '-' before 1 and concatenate them to build the expression ""+2-1"".  Return the number of different expressions that you can build, which evaluates to target.  ",target-sum,Target Sum,"Array, Dynamic Programming, Backtracking",7
"Given a string s representing a valid expression, implement a basic calculator to evaluate it, and return the result of the evaluation. Note: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval().  ",basic-calculator,Basic Calculator,"Math, String, Stack, Recursion",7
"Given two strings s and t, determine if they are isomorphic. Two strings s and t are isomorphic if the characters in s can be replaced to get t. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.  ",isomorphic-strings,Isomorphic Strings,"Hash Table, String",7
"Given two version numbers, version1 and version2, compare them.   Version numbers consist of one or more revisions joined by a dot '.'. Each revision consists of digits and may contain leading zeros. Every revision contains at least one character. Revisions are 0-indexed from left to right, with the leftmost revision being revision 0, the next revision being revision 1, and so on. For example 2.5.33 and 0.1 are valid version numbers. To compare version numbers, compare their revisions in left-to-right order. Revisions are compared using their integer value ignoring any leading zeros. This means that revisions 1 and 001 are considered equal. If a version number does not specify a revision at an index, then treat the revision as 0. For example, version 1.0 is less than version 1.1 because their revision 0s are the same, but their revision 1s are 0 and 1 respectively, and 0 < 1. Return the following:  If version1 < version2, return -1. If version1 > version2, return 1. Otherwise, return 0.   ",compare-version-numbers,Compare Version Numbers,"Two Pointers, String",7
"Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as a parameter. Do not modify the linked list.  ",linked-list-cycle-ii,Linked List Cycle II,"Hash Table, Linked List, Two Pointers",7
"You are given an array prices where prices[i] is the price of a given stock on the ith day. Find the maximum profit you can achieve. You may complete at most two transactions. Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).  ",best-time-to-buy-and-sell-stock-iii,Best Time to Buy and Sell Stock III,"Array, Dynamic Programming",7
"Given the head of a singly linked list where elements are sorted in ascending order, convert it to a height-balanced binary search tree.  ",convert-sorted-list-to-binary-search-tree,Convert Sorted List to Binary Search Tree,"Linked List, Divide and Conquer, Tree, Binary Search Tree, Binary Tree",7
"Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time.  ",minimum-path-sum,Minimum Path Sum,"Array, Dynamic Programming, Matrix",7
"You are given an m x n integer array grid. There is a robot initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time. An obstacle and space are marked as 1 or 0 respectively in grid. A path that the robot takes cannot include any square that is an obstacle. Return the number of possible unique paths that the robot can take to reach the bottom-right corner. The testcases are generated so that the answer will be less than or equal to 2 * 109.  ",unique-paths-ii,Unique Paths II,"Array, Dynamic Programming, Matrix",7
"The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other. Given an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order. Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space, respectively.  ",n-queens,N-Queens,"Array, Backtracking",7
Write a program to solve a Sudoku puzzle by filling the empty cells. A sudoku solution must satisfy all of the following rules:  Each of the digits 1-9 must occur exactly once in each row. Each of the digits 1-9 must occur exactly once in each column. Each of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.  The '.' character indicates empty cells.  ,sudoku-solver,Sudoku Solver,"Array, Hash Table, Backtracking, Matrix",7
"Given an integer x, return true if x is a palindrome, and false otherwise.  ",palindrome-number,Palindrome Number,Math,7
"Anti-theft security devices are activated inside a bank. You are given a 0-indexed binary string array bank representing the floor plan of the bank, which is an m x n 2D matrix. bank[i] represents the ith row, consisting of '0's and '1's. '0' means the cell is empty, while'1' means the cell has a security device. There is one laser beam between any two security devices if both conditions are met:  The two devices are located on two different rows: r1 and r2, where r1 < r2. For each row i where r1 < i < r2, there are no security devices in the ith row.  Laser beams are independent, i.e., one beam does not interfere nor join with another. Return the total number of laser beams in the bank.  ",number-of-laser-beams-in-a-bank,Number of Laser Beams in a Bank,"Array, Math, String, Matrix",6
"A company has n employees with a unique ID for each employee from 0 to n - 1. The head of the company is the one with headID. Each employee has one direct manager given in the manager array where manager[i] is the direct manager of the i-th employee, manager[headID] = -1. Also, it is guaranteed that the subordination relationships have a tree structure. The head of the company wants to inform all the company employees of an urgent piece of news. He will inform his direct subordinates, and they will inform their subordinates, and so on until all employees know about the urgent news. The i-th employee needs informTime[i] minutes to inform all of his direct subordinates (i.e., After informTime[i] minutes, all his direct subordinates can start spreading the news). Return the number of minutes needed to inform all the employees about the urgent news.  ",time-needed-to-inform-all-employees,Time Needed to Inform All Employees,"Tree, Depth-First Search, Breadth-First Search",6
"You are given the root of a binary tree. A ZigZag path for a binary tree is defined as follow:  Choose any node in the binary tree and a direction (right or left). If the current direction is right, move to the right child of the current node; otherwise, move to the left child. Change the direction from right to left or from left to right. Repeat the second and third steps until you can't move in the tree.  Zigzag length is defined as the number of nodes visited - 1. (A single node has a length of 0). Return the longest ZigZag path contained in that tree.  ",longest-zigzag-path-in-a-binary-tree,Longest ZigZag Path in a Binary Tree,"Dynamic Programming, Tree, Depth-First Search, Binary Tree",6
"Given a string s of '(' , ')' and lowercase English characters. Your task is to remove the minimum number of parentheses ( '(' or ')', in any positions ) so that the resulting parentheses string is valid and return any valid string. Formally, a parentheses string is valid if and only if:  It is the empty string, contains only lowercase characters, or It can be written as AB (A concatenated with B), where A and B are valid strings, or It can be written as (A), where A is a valid string.   ",minimum-remove-to-make-valid-parentheses,Minimum Remove to Make Valid Parentheses,"String, Stack",6
"Given two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0. A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.  For example, ""ace"" is a subsequence of ""abcde"".  A common subsequence of two strings is a subsequence that is common to both strings.  ",longest-common-subsequence,Longest Common Subsequence,"String, Dynamic Programming",6
"Given a circular integer array nums of length n, return the maximum possible sum of a non-empty subarray of nums. A circular array means the end of the array connects to the beginning of the array. Formally, the next element of nums[i] is nums[(i + 1) % n] and the previous element of nums[i] is nums[(i - 1 + n) % n]. A subarray may only include each element of the fixed buffer nums at most once. Formally, for a subarray nums[i], nums[i + 1], ..., nums[j], there does not exist i <= k1, k2 <= j with k1 % n == k2 % n.  ",maximum-sum-circular-subarray,Maximum Sum Circular Subarray,"Array, Divide and Conquer, Dynamic Programming, Queue, Monotonic Queue",6
"Design an algorithm that collects daily price quotes for some stock and returns the span of that stock's price for the current day. The span of the stock's price in one day is the maximum number of consecutive days (starting from that day and going backward) for which the stock price was less than or equal to the price of that day.  For example, if the prices of the stock in the last four days is [7,2,1,2] and the price of the stock today is 2, then the span of today is 4 because starting from today, the price of the stock was less than or equal 2 for 4 consecutive days. Also, if the prices of the stock in the last four days is [7,34,1,2] and the price of the stock today is 8, then the span of today is 3 because starting from today, the price of the stock was less than or equal 8 for 3 consecutive days.  Implement the StockSpanner class:  StockSpanner() Initializes the object of the class. int next(int price) Returns the span of the stock's price given that today's price is price.   ",online-stock-span,Online Stock Span,"Stack, Design, Monotonic Stack, Data Stream",6
"There are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key. When you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms. Given an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.  ",keys-and-rooms,Keys and Rooms,"Depth-First Search, Breadth-First Search, Graph",6
"Given the root of a binary tree, return the maximum width of the given tree. The maximum width of a tree is the maximum width among all levels. The width of one level is defined as the length between the end-nodes (the leftmost and rightmost non-null nodes), where the null nodes between the end-nodes that would be present in a complete binary tree extending down to that level are also counted into the length calculation. It is guaranteed that the answer will in the range of a 32-bit signed integer.  ",maximum-width-of-binary-tree,Maximum Width of Binary Tree,"Tree, Depth-First Search, Breadth-First Search, Binary Tree",6
"Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise. A subtree of a binary tree tree is a tree that consists of a node in tree and all of this node's descendants. The tree tree could also be considered as a subtree of itself.  ",subtree-of-another-tree,Subtree of Another Tree,"Tree, Depth-First Search, String Matching, Binary Tree, Hash Function",6
"Given an m x n binary matrix mat, return the distance of the nearest 0 for each cell. The distance between two adjacent cells is 1.  ",01-matrix,01 Matrix,"Array, Dynamic Programming, Breadth-First Search, Matrix",6
"Given a string s, find the longest palindromic subsequence's length in s. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.  ",longest-palindromic-subsequence,Longest Palindromic Subsequence,"String, Dynamic Programming",6
"Given four integer arrays nums1, nums2, nums3, and nums4 all of length n, return the number of tuples (i, j, k, l) such that:  0 <= i, j, k, l < n nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0   ",4sum-ii,4Sum II,"Array, Hash Table",6
You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times. Return the length of the longest substring containing the same letter you can get after performing the above operations.  ,longest-repeating-character-replacement,Longest Repeating Character Replacement,"Hash Table, String, Sliding Window",6
"A password is considered strong if the below conditions are all met:  It has at least 6 characters and at most 20 characters. It contains at least one lowercase letter, at least one uppercase letter, and at least one digit. It does not contain three repeating characters in a row (i.e., ""Baaabb0"" is weak, but ""Baaba0"" is strong).  Given a string password, return the minimum number of steps required to make password strong. if password is already strong, return 0. In one step, you can:  Insert one character to password, Delete one character from password, or Replace one character of password with another character.   ",strong-password-checker,Strong Password Checker,"String, Greedy, Heap (Priority Queue)",6
"Given an integer array nums and an integer k, split nums into k non-empty subarrays such that the largest sum of any subarray is minimized. Return the minimized largest sum of the split. A subarray is a contiguous part of the array.  ",split-array-largest-sum,Split Array Largest Sum,"Array, Binary Search, Dynamic Programming, Greedy, Prefix Sum",6
"A frog is crossing a river. The river is divided into some number of units, and at each unit, there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water. Given a list of stones' positions (in units) in sorted ascending order, determine if the frog can cross the river by landing on the last stone. Initially, the frog is on the first stone and assumes the first jump must be 1 unit. If the frog's last jump was k units, its next jump must be either k - 1, k, or k + 1 units. The frog can only jump in the forward direction.  ",frog-jump,Frog Jump,"Array, Dynamic Programming",6
"Given an n x n matrix where each of the rows and columns is sorted in ascending order, return the kth smallest element in the matrix. Note that it is the kth smallest element in the sorted order, not the kth distinct element. You must find a solution with a memory complexity better than O(n2).  ",kth-smallest-element-in-a-sorted-matrix,Kth Smallest Element in a Sorted Matrix,"Array, Binary Search, Sorting, Heap (Priority Queue), Matrix",6
Write a function that reverses a string. The input string is given as an array of characters s. You must do this by modifying the input array in-place with O(1) extra memory.  ,reverse-string,Reverse String,"Two Pointers, String",6
"The thief has found himself a new place for his thievery again. There is only one entrance to this area, called root. Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. It will automatically contact the police if two directly-linked houses were broken into on the same night. Given the root of the binary tree, return the maximum amount of money the thief can rob without alerting the police.  ",house-robber-iii,House Robber III,"Dynamic Programming, Tree, Depth-First Search, Binary Tree",6
"According to Wikipedia's article: ""The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970."" The board is made up of an m x n grid of cells, where each cell has an initial state: live (represented by a 1) or dead (represented by a 0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):  Any live cell with fewer than two live neighbors dies as if caused by under-population. Any live cell with two or three live neighbors lives on to the next generation. Any live cell with more than three live neighbors dies, as if by over-population. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.  The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Given the current state of the m x n grid board, return the next state.  ",game-of-life,Game of Life,"Array, Matrix, Simulation",6
"Given an array of positive integers nums and a positive integer target, return the minimal length of a subarray whose sum is greater than or equal to target. If there is no such subarray, return 0 instead.  ",minimum-size-subarray-sum,Minimum Size Subarray Sum,"Array, Binary Search, Sliding Window, Prefix Sum",6
"Write an algorithm to determine if a number n is happy. A happy number is a number defined by the following process:  Starting with any positive integer, replace the number by the sum of the squares of its digits. Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy.  Return true if n is a happy number, and false if not.  ",happy-number,Happy Number,"Hash Table, Math, Two Pointers",6
"You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation. Evaluate the expression. Return an integer that represents the value of the expression. Note that:  The valid operators are '+', '-', '*', and '/'. Each operand may be an integer or another expression. The division between two integers always truncates toward zero. There will not be any division by zero. The input represents a valid arithmetic expression in a reverse polish notation. The answer and all the intermediate calculations can be represented in a 32-bit integer.   ",evaluate-reverse-polish-notation,Evaluate Reverse Polish Notation,"Array, Math, Stack",6
"Given the root of a binary tree, flatten the tree into a ""linked list"":  The ""linked list"" should use the same TreeNode class where the right child pointer points to the next node in the list and the left child pointer is always null. The ""linked list"" should be in the same order as a pre-order traversal of the binary tree.   ",flatten-binary-tree-to-linked-list,Flatten Binary Tree to Linked List,"Linked List, Stack, Tree, Depth-First Search, Binary Tree",6
"Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.  ",remove-duplicates-from-sorted-list,Remove Duplicates from Sorted List,Linked List,6
"Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.  ",remove-duplicates-from-sorted-list-ii,Remove Duplicates from Sorted List II,"Linked List, Two Pointers",6
"Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's. You must do it in place.  ",set-matrix-zeroes,Set Matrix Zeroes,"Array, Hash Table, Matrix",6
"Given two binary strings a and b, return their sum as a binary string.  ",add-binary,Add Binary,"Math, String, Bit Manipulation, Simulation",6
"Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:  0 <= a, b, c, d < n a, b, c, and d are distinct. nums[a] + nums[b] + nums[c] + nums[d] == target  You may return the answer in any order.  ",4sum,4Sum,"Array, Two Pointers, Sorting",6
"You are given an integer array heights representing the heights of buildings, some bricks, and some ladders. You start your journey from building 0 and move to the next building by possibly using bricks or ladders. While moving from building i to building i+1 (0-indexed),  If the current building's height is greater than or equal to the next building's height, you do not need a ladder or bricks. If the current building's height is less than the next building's height, you can either use one ladder or (h[i+1] - h[i]) bricks.  Return the furthest building index (0-indexed) you can reach if you use the given ladders and bricks optimally.  ",furthest-building-you-can-reach,Furthest Building You Can Reach,"Array, Greedy, Heap (Priority Queue)",5
"Given an array of integers nums, sort the array in increasing order based on the frequency of the values. If multiple values have the same frequency, sort them in decreasing order. Return the sorted array.  ",sort-array-by-increasing-frequency,Sort Array by Increasing Frequency,"Array, Hash Table, Sorting",5
Given an array of integers arr and an integer k. Find the least number of unique integers after removing exactly k elements.    ,least-number-of-unique-integers-after-k-removals,Least Number of Unique Integers after K Removals,"Array, Hash Table, Greedy, Sorting, Counting",5
"Write a program to count the number of days between two dates. The two dates are given as strings, their format is YYYY-MM-DD as shown in the examples.  ",number-of-days-between-two-dates,Number of Days Between Two Dates,"Math, String",5
"Given an array of integers arr, return true if the number of occurrences of each value in the array is unique or false otherwise.  ",unique-number-of-occurrences,Unique Number of Occurrences,"Array, Hash Table",5
"You are given the head of a linked list with n nodes. For each node in the list, find the value of the next greater node. That is, for each node, find the value of the first node that is next to it and has a strictly larger value than it. Return an integer array answer where answer[i] is the value of the next greater node of the ith node (1-indexed). If the ith node does not have a next greater node, set answer[i] = 0.  ",next-greater-node-in-linked-list,Next Greater Node In Linked List,"Array, Linked List, Stack, Monotonic Stack",5
"Design a stack-like data structure to push elements to the stack and pop the most frequent element from the stack. Implement the FreqStack class:  FreqStack() constructs an empty frequency stack. void push(int val) pushes an integer val onto the top of the stack. int pop() removes and returns the most frequent element in the stack. 	 If there is a tie for the most frequent element, the element closest to the stack's top is removed and returned.     ",maximum-frequency-stack,Maximum Frequency Stack,"Hash Table, Stack, Design, Ordered Set",5
"Given the head of a singly linked list, return the middle node of the linked list. If there are two middle nodes, return the second middle node.  ",middle-of-the-linked-list,Middle of the Linked List,"Linked List, Two Pointers",5
"You are standing at position 0 on an infinite number line. There is a destination at position target. You can make some number of moves numMoves so that:  On each move, you can either go left or right. During the ith move (starting from i == 1 to i == numMoves), you take i steps in the chosen direction.  Given the integer target, return the minimum number of moves required (i.e., the minimum numMoves) to reach the destination.  ",reach-a-number,Reach a Number,"Math, Binary Search",5
"You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you pay the cost, you can either climb one or two steps. You can either start from the step with index 0, or the step with index 1. Return the minimum cost to reach the top of the floor.  ",min-cost-climbing-stairs,Min Cost Climbing Stairs,"Array, Dynamic Programming",5
"You are given an integer array nums. You want to maximize the number of points you get by performing the following operation any number of times:  Pick any nums[i] and delete it to earn nums[i] points. Afterwards, you must delete every element equal to nums[i] - 1 and every element equal to nums[i] + 1.  Return the maximum number of points you can earn by applying the above operation some number of times.  ",delete-and-earn,Delete and Earn,"Array, Hash Table, Dynamic Programming",5
"Given a string s, return true if the s can be palindrome after deleting at most one character from it.  ",valid-palindrome-ii,Valid Palindrome II,"Two Pointers, String, Greedy",5
"Given a string s containing only three types of characters: '(', ')' and '*', return true if s is valid. The following rules define a valid string:  Any left parenthesis '(' must have a corresponding right parenthesis ')'. Any right parenthesis ')' must have a corresponding left parenthesis '('. Left parenthesis '(' must go before the corresponding right parenthesis ')'. '*' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string """".   ",valid-parenthesis-string,Valid Parenthesis String,"String, Dynamic Programming, Stack, Greedy",5
"Given an integer array nums, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order. Return the shortest such subarray and output its length.  ",shortest-unsorted-continuous-subarray,Shortest Unsorted Continuous Subarray,"Array, Two Pointers, Stack, Greedy, Sorting, Monotonic Stack",5
"Given an integer array nums and an integer k, return true if nums has a good subarray or false otherwise. A good subarray is a subarray where:  its length is at least two, and the sum of the elements of the subarray is a multiple of k.  Note that:  A subarray is a contiguous part of the array. An integer x is a multiple of k if there exists an integer n such that x = n * k. 0 is always a multiple of k.   ",continuous-subarray-sum,Continuous Subarray Sum,"Array, Hash Table, Math, Prefix Sum",5
"Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all the integers in the range [1, n] that do not appear in nums.  ",find-all-numbers-disappeared-in-an-array,Find All Numbers Disappeared in an Array,"Array, Hash Table",5
"Given an integer array nums of length n where all the integers of nums are in the range [1, n] and each integer appears once or twice, return an array of all the integers that appears twice. You must write an algorithm that runs in O(n) time and uses only constant extra space.  ",find-all-duplicates-in-an-array,Find All Duplicates in an Array,"Array, Hash Table",5
"Given an integer n, return true if it is a power of two. Otherwise, return false. An integer n is a power of two, if there exists an integer x such that n == 2x.  ",power-of-two,Power of Two,"Math, Bit Manipulation, Recursion",5
"Given the root of a binary tree, invert the tree, and return its root.  ",invert-binary-tree,Invert Binary Tree,"Tree, Depth-First Search, Breadth-First Search, Binary Tree",5
"Given the root of a complete binary tree, return the number of the nodes in the tree. According to Wikipedia, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h. Design an algorithm that runs in less than O(n) time complexity.  ",count-complete-tree-nodes,Count Complete Tree Nodes,"Binary Search, Tree, Depth-First Search, Binary Tree",5
"Given an integer array nums where every element appears three times except for one, which appears exactly once. Find the single element and return it. You must implement a solution with a linear runtime complexity and use only constant extra space.  ",single-number-ii,Single Number II,"Array, Bit Manipulation",5
"Given an integer numRows, return the first numRows of Pascal's triangle. In Pascal's triangle, each number is the sum of the two numbers directly above it as shown:   ",pascals-triangle,Pascal's Triangle,"Array, Dynamic Programming",5
"Given the root of a binary tree and an integer targetSum, return all root-to-leaf paths where the sum of the node values in the path equals targetSum. Each path should be returned as a list of the node values, not node references. A root-to-leaf path is a path starting from the root and ending at any leaf node. A leaf is a node with no children.  ",path-sum-ii,Path Sum II,"Backtracking, Tree, Depth-First Search, Binary Tree",5
"Given a binary tree, determine if it is height-balanced.  ",balanced-binary-tree,Balanced Binary Tree,"Tree, Depth-First Search, Binary Tree",5
"Given the roots of two binary trees p and q, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.  ",same-tree,Same Tree,"Tree, Depth-First Search, Breadth-First Search, Binary Tree",5
"Given the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from position left to position right, and return the reversed list.  ",reverse-linked-list-ii,Reverse Linked List II,Linked List,5
"You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively. Merge nums1 and nums2 into a single array sorted in non-decreasing order. The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.  ",merge-sorted-array,Merge Sorted Array,"Array, Two Pointers, Sorting",5
"There is an integer array nums sorted in non-decreasing order (not necessarily with distinct values). Before being passed to your function, nums is rotated at an unknown pivot index k (0 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,4,4,5,6,6,7] might be rotated at pivot index 5 and become [4,5,6,6,7,0,1,2,4,4]. Given the array nums after the rotation and an integer target, return true if target is in nums, or false if it is not in nums. You must decrease the overall operation steps as much as possible.  ",search-in-rotated-sorted-array-ii,Search in Rotated Sorted Array II,"Array, Binary Search",5
"You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's. Increment the large integer by one and return the resulting array of digits.  ",plus-one,Plus One,"Array, Math",5
"You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval. Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary). Return intervals after the insertion.  ",insert-interval,Insert Interval,Array,5
"Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*' where:  '?' Matches any single character. '*' Matches any sequence of characters (including the empty sequence).  The matching should cover the entire input string (not partial).  ",wildcard-matching,Wildcard Matching,"String, Dynamic Programming, Greedy, Recursion",5
"Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string. Note: You must not use any built-in BigInteger library or convert the inputs to integer directly.  ",multiply-strings,Multiply Strings,"Math, String, Simulation",5
"Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val. Consider the number of elements in nums which are not equal to val be k, to get accepted, you need to do the following things:  Change the array nums such that the first k elements of nums contain the elements which are not equal to val. The remaining elements of nums are not important as well as the size of nums. Return k.  Custom Judge: The judge will test your solution with the following code:  int[] nums = [...]; // Input array int val = ...; // Value to remove int[] expectedNums = [...]; // The expected answer with correct length.                             // It is sorted with no values equaling val.  int k = removeElement(nums, val); // Calls your implementation  assert k == expectedNums.length; sort(nums, 0, k); // Sort the first k elements of nums for (int i = 0; i < actualLength; i++) {     assert nums[i] == expectedNums[i]; }  If all assertions pass, then your solution will be accepted.  ",remove-element,Remove Element,"Array, Two Pointers",5
"The string ""PAYPALISHIRING"" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)  P   A   H   N A P L S I I G Y   I   R  And then read line by line: ""PAHNAPLSIIGYIR"" Write the code that will take a string and make this conversion given a number of rows:  string convert(string s, int numRows);   ",zigzag-conversion,Zigzag Conversion,String,5
"You are given an integer array prices representing the daily price history of a stock, where prices[i] is the stock price on the ith day. A smooth descent period of a stock consists of one or more contiguous days such that the price on each day is lower than the price on the preceding day by exactly 1. The first day of the period is exempted from this rule. Return the number of smooth descent periods.  ",number-of-smooth-descent-periods-of-a-stock,Number of Smooth Descent Periods of a Stock,"Array, Math, Dynamic Programming",4
"There is a bi-directional graph with n vertices, where each vertex is labeled from 0 to n - 1 (inclusive). The edges in the graph are represented as a 2D integer array edges, where each edges[i] = [ui, vi] denotes a bi-directional edge between vertex ui and vertex vi. Every vertex pair is connected by at most one edge, and no vertex has an edge to itself. You want to determine if there is a valid path that exists from vertex source to vertex destination. Given edges and the integers n, source, and destination, return true if there is a valid path from source to destination, or false otherwise.  ",find-if-path-exists-in-graph,Find if Path Exists in Graph,"Depth-First Search, Breadth-First Search, Union Find, Graph",4
"Given an integer array arr, remove a subarray (can be empty) from arr such that the remaining elements in arr are non-decreasing. Return the length of the shortest subarray to remove. A subarray is a contiguous subsequence of the array.  ",shortest-subarray-to-be-removed-to-make-array-sorted,Shortest Subarray to be Removed to Make Array Sorted,"Array, Two Pointers, Binary Search, Stack, Monotonic Stack",4
"Given an array of integers arr, you are initially positioned at the first index of the array. In one step you can jump from index i to index:  i + 1 where: i + 1 < arr.length. i - 1 where: i - 1 >= 0. j where: arr[i] == arr[j] and i != j.  Return the minimum number of steps to reach the last index of the array. Notice that you can not jump outside of the array at any time.  ",jump-game-iv,Jump Game IV,"Array, Hash Table, Breadth-First Search",4
"Given the root of a binary tree, split the binary tree into two subtrees by removing one edge such that the product of the sums of the subtrees is maximized. Return the maximum product of the sums of the two subtrees. Since the answer may be too large, return it modulo 109 + 7. Note that you need to maximize the answer before taking the mod and not after taking it.  ",maximum-product-of-splitted-binary-tree,Maximum Product of Splitted Binary Tree,"Tree, Depth-First Search, Binary Tree",4
You are given a string s consisting of lowercase English letters. A duplicate removal consists of choosing two adjacent and equal letters and removing them. We repeatedly make duplicate removals on s until we no longer can. Return the final string after all such duplicate removals have been made. It can be proven that the answer is unique.  ,remove-all-adjacent-duplicates-in-string,Remove All Adjacent Duplicates In String,"String, Stack",4
"You are given an array of integers stones where stones[i] is the weight of the ith stone. We are playing a game with the stones. On each turn, we choose the heaviest two stones and smash them together. Suppose the heaviest two stones have weights x and y with x <= y. The result of this smash is:  If x == y, both stones are destroyed, and If x != y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x.  At the end of the game, there is at most one stone left. Return the weight of the last remaining stone. If there are no stones left, return 0.  ",last-stone-weight,Last Stone Weight,"Array, Heap (Priority Queue)",4
"Given an integer array arr, partition the array into (contiguous) subarrays of length at most k. After partitioning, each subarray has their values changed to become the maximum value of that subarray. Return the largest sum of the given array after partitioning. Test cases are generated so that the answer fits in a 32-bit integer.  ",partition-array-for-maximum-sum,Partition Array for Maximum Sum,"Array, Dynamic Programming",4
"Given the root of a binary tree, find the maximum value v for which there exist different nodes a and b where v = |a.val - b.val| and a is an ancestor of b. A node a is an ancestor of b if either: any child of a is equal to b or any child of a is an ancestor of b.  ",maximum-difference-between-node-and-ancestor,Maximum Difference Between Node and Ancestor,"Tree, Depth-First Search, Binary Tree",4
"Given an array of integers preorder, which represents the preorder traversal of a BST (i.e., binary search tree), construct the tree and return its root. It is guaranteed that there is always possible to find a binary search tree with the given requirements for the given test cases. A binary search tree is a binary tree where for every node, any descendant of Node.left has a value strictly less than Node.val, and any descendant of Node.right has a value strictly greater than Node.val. A preorder traversal of a binary tree displays the value of the node first, then traverses Node.left, then traverses Node.right.  ",construct-binary-search-tree-from-preorder-traversal,Construct Binary Search Tree from Preorder Traversal,"Array, Stack, Tree, Binary Search Tree, Monotonic Stack, Binary Tree",4
"Given a string array words, return an array of all characters that show up in all strings within the words (including duplicates). You may return the answer in any order.  ",find-common-characters,Find Common Characters,"Array, Hash Table, String",4
"Given two integer arrays pushed and popped each with distinct values, return true if this could have been the result of a sequence of push and pop operations on an initially empty stack, or false otherwise.  ",validate-stack-sequences,Validate Stack Sequences,"Array, Stack, Simulation",4
"Given the root node of a binary search tree and two integers low and high, return the sum of values of all nodes with a value in the inclusive range [low, high].  ",range-sum-of-bst,Range Sum of BST,"Tree, Depth-First Search, Binary Search Tree, Binary Tree",4
"You are visiting a farm that has a single row of fruit trees arranged from left to right. The trees are represented by an integer array fruits where fruits[i] is the type of fruit the ith tree produces. You want to collect as much fruit as possible. However, the owner has some strict rules that you must follow:  You only have two baskets, and each basket can only hold a single type of fruit. There is no limit on the amount of fruit each basket can hold. Starting from any tree of your choice, you must pick exactly one fruit from every tree (including the start tree) while moving to the right. The picked fruits must fit in one of your baskets. Once you reach a tree with fruit that cannot fit in your baskets, you must stop.  Given the integer array fruits, return the maximum number of fruits you can pick.  ",fruit-into-baskets,Fruit Into Baskets,"Array, Hash Table, Sliding Window",4
"You are given an array people where people[i] is the weight of the ith person, and an infinite number of boats where each boat can carry a maximum weight of limit. Each boat carries at most two people at the same time, provided the sum of the weight of those people is at most limit. Return the minimum number of boats to carry every given person.  ",boats-to-save-people,Boats to Save People,"Array, Two Pointers, Greedy, Sorting",4
"Given a balanced parentheses string s, return the score of the string. The score of a balanced parentheses string is based on the following rule:  ""()"" has score 1. AB has score A + B, where A and B are balanced parentheses strings. (A) has score 2 * A, where A is a balanced parentheses string.   ",score-of-parentheses,Score of Parentheses,"String, Stack",4
"You are given a string s. We want to partition the string into as many parts as possible so that each letter appears in at most one part. Note that the partition is done so that after concatenating all the parts in order, the resultant string should be s. Return a list of integers representing the size of these parts.  ",partition-labels,Partition Labels,"Hash Table, Two Pointers, String, Greedy",4
"You are implementing a program to use as your calendar. We can add a new event if adding the event will not cause a double booking. A double booking happens when two events have some non-empty intersection (i.e., some moment is common to both events.). The event can be represented as a pair of integers start and end that represents a booking on the half-open interval [start, end), the range of real numbers x such that start <= x < end. Implement the MyCalendar class:  MyCalendar() Initializes the calendar object. boolean book(int start, int end) Returns true if the event can be added to the calendar successfully without causing a double booking. Otherwise, return false and do not add the event to the calendar.   ",my-calendar-i,My Calendar I,"Binary Search, Design, Segment Tree, Ordered Set",4
"Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element. Implement KthLargest class:  KthLargest(int k, int[] nums) Initializes the object with the integer k and the stream of integers nums. int add(int val) Appends the integer val to the stream and returns the element representing the kth largest element in the stream.   ",kth-largest-element-in-a-stream,Kth Largest Element in a Stream,"Tree, Design, Binary Search Tree, Heap (Priority Queue), Binary Tree, Data Stream",4
You are given an integer num. You can swap two digits at most once to get the maximum valued number. Return the maximum valued number you can get.  ,maximum-swap,Maximum Swap,"Math, Greedy",4
"There is only one character 'A' on the screen of a notepad. You can perform one of two operations on this notepad for each step:  Copy All: You can copy all the characters present on the screen (a partial copy is not allowed). Paste: You can paste the characters which are copied last time.  Given an integer n, return the minimum number of operations to get the character 'A' exactly n times on the screen.  ",2-keys-keyboard,2 Keys Keyboard,"Math, Dynamic Programming",4
"Solve a given equation and return the value of 'x' in the form of a string ""x=#value"". The equation contains only '+', '-' operation, the variable 'x' and its coefficient. You should return ""No solution"" if there is no solution for the equation, or ""Infinite solutions"" if there are infinite solutions for the equation. If there is exactly one solution for the equation, we ensure that the value of 'x' is an integer.  ",solve-the-equation,Solve the Equation,"Math, String, Simulation",4
"Given the root of a binary tree, return the average value of the nodes on each level in the form of an array. Answers within 10-5 of the actual answer will be accepted.  ",average-of-levels-in-binary-tree,Average of Levels in Binary Tree,"Tree, Depth-First Search, Breadth-First Search, Binary Tree",4
"Design your implementation of the circular queue. The circular queue is a linear data structure in which the operations are performed based on FIFO (First In First Out) principle, and the last position is connected back to the first position to make a circle. It is also called ""Ring Buffer"". One of the benefits of the circular queue is that we can make use of the spaces in front of the queue. In a normal queue, once the queue becomes full, we cannot insert the next element even if there is a space in front of the queue. But using the circular queue, we can use the space to store new values. Implement the MyCircularQueue class:  MyCircularQueue(k) Initializes the object with the size of the queue to be k. int Front() Gets the front item from the queue. If the queue is empty, return -1. int Rear() Gets the last item from the queue. If the queue is empty, return -1. boolean enQueue(int value) Inserts an element into the circular queue. Return true if the operation is successful. boolean deQueue() Deletes an element from the circular queue. Return true if the operation is successful. boolean isEmpty() Checks whether the circular queue is empty or not. boolean isFull() Checks whether the circular queue is full or not.  You must solve the problem without using the built-in queue data structure in your programming language.   ",design-circular-queue,Design Circular Queue,"Array, Linked List, Design, Queue",4
Note: This is a companion problem to the System Design problem: Design TinyURL. TinyURL is a URL shortening service where you enter a URL such as https://leetcode.com/problems/design-tinyurl and it returns a short URL such as http://tinyurl.com/4e9iAk. Design a class to encode a URL and decode a tiny URL. There is no restriction on how your encode/decode algorithm should work. You just need to ensure that a URL can be encoded to a tiny URL and the tiny URL can be decoded to the original URL. Implement the Solution class:  Solution() Initializes the object of the system. String encode(String longUrl) Returns a tiny URL for the given longUrl. String decode(String shortUrl) Returns the original long URL for the given shortUrl. It is guaranteed that the given shortUrl was encoded by the same object.   ,encode-and-decode-tinyurl,Encode and Decode TinyURL,"Hash Table, String, Design, Hash Function",4
"Given an array of n integers nums, a 132 pattern is a subsequence of three integers nums[i], nums[j] and nums[k] such that i < j < k and nums[i] < nums[k] < nums[j]. Return true if there is a 132 pattern in nums, otherwise, return false.  ",132-pattern,132 Pattern,"Array, Binary Search, Stack, Monotonic Stack, Ordered Set",4
"Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.  ",non-overlapping-intervals,Non-overlapping Intervals,"Array, Dynamic Programming, Greedy, Sorting",4
"Given an integer array nums, return true if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or false otherwise.  ",partition-equal-subset-sum,Partition Equal Subset Sum,"Array, Dynamic Programming",4
"Given two strings s and t, return true if s is a subsequence of t, or false otherwise. A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., ""ace"" is a subsequence of ""abcde"" while ""aec"" is not).  ",is-subsequence,Is Subsequence,"Two Pointers, String, Dynamic Programming",4
"Given an array of distinct integers nums and a target integer target, return the number of possible combinations that add up to target. The test cases are generated so that the answer can fit in a 32-bit integer.  ",combination-sum-iv,Combination Sum IV,"Array, Dynamic Programming",4
"Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order.  ",intersection-of-two-arrays-ii,Intersection of Two Arrays II,"Array, Hash Table, Two Pointers, Binary Search, Sorting",4
"You are given a list of airline tickets where tickets[i] = [fromi, toi] represent the departure and the arrival airports of one flight. Reconstruct the itinerary in order and return it. All of the tickets belong to a man who departs from ""JFK"", thus, the itinerary must begin with ""JFK"". If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.  For example, the itinerary [""JFK"", ""LGA""] has a smaller lexical order than [""JFK"", ""LGB""].  You may assume all tickets form at least one valid itinerary. You must use all the tickets once and only once.  ",reconstruct-itinerary,Reconstruct Itinerary,"Depth-First Search, Graph, Eulerian Circuit",4
"Given the head of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list. The first node is considered odd, and the second node is even, and so on. Note that the relative order inside both the even and odd groups should remain as it was in the input. You must solve the problem in O(1) extra space complexity and O(n) time complexity.  ",odd-even-linked-list,Odd Even Linked List,Linked List,4
"Given a pattern and a string s, find if s follows the same pattern. Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.  ",word-pattern,Word Pattern,"Hash Table, String",4
"Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.  ",majority-element-ii,Majority Element II,"Array, Hash Table, Sorting, Counting",4
"You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night. Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.  ",house-robber-ii,House Robber II,"Array, Dynamic Programming",4
"Given an integer n, return the number of prime numbers that are strictly less than n.  ",count-primes,Count Primes,"Array, Math, Enumeration, Number Theory",4
"Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head.  ",remove-linked-list-elements,Remove Linked List Elements,"Linked List, Recursion",4
"You are given an integer array prices where prices[i] is the price of a given stock on the ith day, and an integer k. Find the maximum profit you can achieve. You may complete at most k transactions: i.e. you may buy at most k times and sell at most k times. Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).  ",best-time-to-buy-and-sell-stock-iv,Best Time to Buy and Sell Stock IV,"Array, Dynamic Programming",4
"Implement the BSTIterator class that represents an iterator over the in-order traversal of a binary search tree (BST):  BSTIterator(TreeNode root) Initializes an object of the BSTIterator class. The root of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST. boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false. int next() Moves the pointer to the right, then returns the number at the pointer.  Notice that by initializing the pointer to a non-existent smallest number, the first call to next() will return the smallest element in the BST. You may assume that next() calls will always be valid. That is, there will be at least a next number in the in-order traversal when next() is called.  ",binary-search-tree-iterator,Binary Search Tree Iterator,"Stack, Tree, Design, Binary Search Tree, Binary Tree, Iterator",4
"Given an integer n, return the number of trailing zeroes in n!. Note that n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1.  ",factorial-trailing-zeroes,Factorial Trailing Zeroes,Math,4
"Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane, return the maximum number of points that lie on the same straight line.  ",max-points-on-a-line,Max Points on a Line,"Array, Hash Table, Math, Geometry",4
"Given a triangle array, return the minimum path sum from top to bottom. For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row.  ",triangle,Triangle,"Array, Dynamic Programming",4
"Given two strings s and t, return the number of distinct subsequences of s which equals t. The test cases are generated so that the answer fits on a 32-bit signed integer.  ",distinct-subsequences,Distinct Subsequences,"String, Dynamic Programming",4
"Given the root of a binary tree, return its maximum depth. A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.  ",maximum-depth-of-binary-tree,Maximum Depth of Binary Tree,"Tree, Depth-First Search, Breadth-First Search, Binary Tree",4
"Given strings s1, s2, and s3, find whether s3 is formed by an interleaving of s1 and s2. An interleaving of two strings s and t is a configuration where s and t are divided into n and m substrings respectively, such that:  s = s1 + s2 + ... + sn t = t1 + t2 + ... + tm |n - m| <= 1 The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...  Note: a + b is the concatenation of strings a and b.  ",interleaving-string,Interleaving String,"String, Dynamic Programming",4
"Given an integer n, return the number of structurally unique BST's (binary search trees) which has exactly n nodes of unique values from 1 to n.  ",unique-binary-search-trees,Unique Binary Search Trees,"Math, Dynamic Programming, Tree, Binary Search Tree, Binary Tree",4
"Given the root of a binary tree, return the inorder traversal of its nodes' values.  ",binary-tree-inorder-traversal,Binary Tree Inorder Traversal,"Stack, Tree, Depth-First Search, Binary Tree",4
"Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.  ",permutations-ii,Permutations II,"Array, Backtracking",4
"Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target. Each number in candidates may only be used once in the combination. Note: The solution set must not contain duplicate combinations.  ",combination-sum-ii,Combination Sum II,"Array, Backtracking",4
"There is a long table with a line of plates and candles arranged on top of it. You are given a 0-indexed string s consisting of characters '*' and '|' only, where a '*' represents a plate and a '|' represents a candle. You are also given a 0-indexed 2D integer array queries where queries[i] = [lefti, righti] denotes the substring s[lefti...righti] (inclusive). For each query, you need to find the number of plates between candles that are in the substring. A plate is considered between candles if there is at least one candle to its left and at least one candle to its right in the substring.  For example, s = ""||**||**|*"", and a query [3, 8] denotes the substring ""*||**|"". The number of plates between candles in this substring is 2, as each of the two plates has at least one candle in the substring to its left and right.  Return an integer array answer where answer[i] is the answer to the ith query.  ",plates-between-candles,Plates Between Candles,"Array, String, Binary Search, Prefix Sum",3
"You are given the head of a linked list, and an integer k. Return the head of the linked list after swapping the values of the kth node from the beginning and the kth node from the end (the list is 1-indexed).  ",swapping-nodes-in-a-linked-list,Swapping Nodes in a Linked List,"Linked List, Two Pointers",3
"Design a queue that supports push and pop operations in the front, middle, and back. Implement the FrontMiddleBack class:  FrontMiddleBack() Initializes the queue. void pushFront(int val) Adds val to the front of the queue. void pushMiddle(int val) Adds val to the middle of the queue. void pushBack(int val) Adds val to the back of the queue. int popFront() Removes the front element of the queue and returns it. If the queue is empty, return -1. int popMiddle() Removes the middle element of the queue and returns it. If the queue is empty, return -1. int popBack() Removes the back element of the queue and returns it. If the queue is empty, return -1.  Notice that when there are two middle position choices, the operation is performed on the frontmost middle position choice. For example:  Pushing 6 into the middle of [1, 2, 3, 4, 5] results in [1, 2, 6, 3, 4, 5]. Popping the middle from [1, 2, 3, 4, 5, 6] returns 3 and results in [1, 2, 4, 5, 6].   ",design-front-middle-back-queue,Design Front Middle Back Queue,"Array, Linked List, Design, Queue, Data Stream",3
"Given an array of integers nums, return the number of good pairs. A pair (i, j) is called good if nums[i] == nums[j] and i < j.  ",number-of-good-pairs,Number of Good Pairs,"Array, Hash Table, Math, Counting",3
"You have a browser of one tab where you start on the homepage and you can visit another url, get back in the history number of steps or move forward in the history number of steps. Implement the BrowserHistory class:  BrowserHistory(string homepage) Initializes the object with the homepage of the browser. void visit(string url) Visits url from the current page. It clears up all the forward history. string back(int steps) Move steps back in history. If you can only return x steps in the history and steps > x, you will return only x steps. Return the current url after moving back in history at most steps. string forward(int steps) Move steps forward in history. If you can only forward x steps in the history and steps > x, you will forward only x steps. Return the current url after forwarding in history at most steps.   ",design-browser-history,Design Browser History,"Array, Linked List, Stack, Design, Doubly-Linked List, Data Stream",3
"There are n cities numbered from 0 to n - 1 and n - 1 roads such that there is only one way to travel between two different cities (this network form a tree). Last year, The ministry of transport decided to orient the roads in one direction because they are too narrow. Roads are represented by connections where connections[i] = [ai, bi] represents a road from city ai to city bi. This year, there will be a big event in the capital (city 0), and many people want to travel to this city. Your task consists of reorienting some roads such that each city can visit the city 0. Return the minimum number of edges changed. It's guaranteed that each city can reach city 0 after reorder.  ",reorder-routes-to-make-all-paths-lead-to-the-city-zero,Reorder Routes to Make All Paths Lead to the City Zero,"Depth-First Search, Breadth-First Search, Graph",3
"There are n kids with candies. You are given an integer array candies, where each candies[i] represents the number of candies the ith kid has, and an integer extraCandies, denoting the number of extra candies that you have. Return a boolean array result of length n, where result[i] is true if, after giving the ith kid all the extraCandies, they will have the greatest number of candies among all the kids, or false otherwise. Note that multiple kids can have the greatest number of candies.  ",kids-with-the-greatest-number-of-candies,Kids With the Greatest Number of Candies,Array,3
"There are several cards arranged in a row, and each card has an associated number of points. The points are given in the integer array cardPoints. In one step, you can take one card from the beginning or from the end of the row. You have to take exactly k cards. Your score is the sum of the points of the cards you have taken. Given the integer array cardPoints and the integer k, return the maximum score you can obtain.  ",maximum-points-you-can-obtain-from-cards,Maximum Points You Can Obtain from Cards,"Array, Sliding Window, Prefix Sum",3
"Given an array of string words, return all strings in words that is a substring of another word. You can return the answer in any order. A substring is a contiguous sequence of characters within a string  ",string-matching-in-an-array,String Matching in an Array,"Array, String, String Matching",3
"There are n soldiers standing in a line. Each soldier is assigned a unique rating value. You have to form a team of 3 soldiers amongst them under the following rules:  Choose 3 soldiers with index (i, j, k) with rating (rating[i], rating[j], rating[k]). A team is valid if: (rating[i] < rating[j] < rating[k]) or (rating[i] > rating[j] > rating[k]) where (0 <= i < j < k < n).  Return the number of teams you can form given the conditions. (soldiers can be part of multiple teams).  ",count-number-of-teams,Count Number of Teams,"Array, Dynamic Programming, Binary Indexed Tree",3
"Given a binary tree root, return the maximum sum of all keys of any sub-tree which is also a Binary Search Tree (BST). Assume a BST is defined as follows:  The left subtree of a node contains only nodes with keys less than the node's key. The right subtree of a node contains only nodes with keys greater than the node's key. Both the left and right subtrees must also be binary search trees.   ",maximum-sum-bst-in-binary-tree,Maximum Sum BST in Binary Tree,"Dynamic Programming, Tree, Depth-First Search, Binary Search Tree, Binary Tree",3
"You are given an array of events where events[i] = [startDayi, endDayi]. Every event i starts at startDayi and ends at endDayi. You can attend an event i at any day d where startTimei <= d <= endTimei. You can only attend one event at any time d. Return the maximum number of events you can attend.  ",maximum-number-of-events-that-can-be-attended,Maximum Number of Events That Can Be Attended,"Array, Greedy, Sorting, Heap (Priority Queue)",3
"Design an algorithm that accepts a stream of integers and retrieves the product of the last k integers of the stream. Implement the ProductOfNumbers class:  ProductOfNumbers() Initializes the object with an empty stream. void add(int num) Appends the integer num to the stream. int getProduct(int k) Returns the product of the last k numbers in the current list. You can assume that always the current list has at least k numbers.  The test cases are generated so that, at any time, the product of any contiguous sequence of numbers will fit into a single 32-bit integer without overflowing.  ",product-of-the-last-k-numbers,Product of the Last K Numbers,"Array, Math, Design, Queue, Data Stream",3
"Given two numbers, hour and minutes, return the smaller angle (in degrees) formed between the hour and the minute hand. Answers within 10-5 of the actual value will be accepted as correct.  ",angle-between-hands-of-a-clock,Angle Between Hands of a Clock,Math,3
"An integer has sequential digits if and only if each digit in the number is one more than the previous digit. Return a sorted list of all the integers in the range [low, high] inclusive that have sequential digits.  ",sequential-digits,Sequential Digits,Enumeration,3
"The Tribonacci sequence Tn is defined as follows:  T0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0. Given n, return the value of Tn.  ",n-th-tribonacci-number,N-th Tribonacci Number,"Math, Dynamic Programming, Memoization",3
"Given the root of a binary tree with unique values and the values of two different nodes of the tree x and y, return true if the nodes corresponding to the values x and y in the tree are cousins, or false otherwise. Two nodes of a binary tree are cousins if they have the same depth with different parents. Note that in a binary tree, the root node is at the depth 0, and children of each depth k node are at the depth k + 1.  ",cousins-in-binary-tree,Cousins in Binary Tree,"Tree, Depth-First Search, Breadth-First Search, Binary Tree",3
"You are given an m x n integer array grid where grid[i][j] could be:  1 representing the starting square. There is exactly one starting square. 2 representing the ending square. There is exactly one ending square. 0 representing empty squares we can walk over. -1 representing obstacles that we cannot walk over.  Return the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once.  ",unique-paths-iii,Unique Paths III,"Array, Backtracking, Bit Manipulation, Matrix",3
"Given an integer array nums and an integer k, return the number of non-empty subarrays that have a sum divisible by k. A subarray is a contiguous part of an array.  ",subarray-sums-divisible-by-k,Subarray Sums Divisible by K,"Array, Hash Table, Prefix Sum",3
"The chess knight has a unique movement, it may move two squares vertically and one square horizontally, or two squares horizontally and one square vertically (with both forming the shape of an L). The possible movements of chess knight are shown in this diagaram: A chess knight can move as indicated in the chess diagram below:  We have a chess knight and a phone pad as shown below, the knight can only stand on a numeric cell (i.e. blue cell).  Given an integer n, return how many distinct phone numbers of length n we can dial. You are allowed to place the knight on any numeric cell initially and then you should perform n - 1 jumps to dial a number of length n. All jumps should be valid knight jumps. As the answer may be very large, return the answer modulo 109 + 7.  ",knight-dialer,Knight Dialer,Dynamic Programming,3
"A parentheses string is valid if and only if:  It is the empty string, It can be written as AB (A concatenated with B), where A and B are valid strings, or It can be written as (A), where A is a valid string.  You are given a parentheses string s. In one move, you can insert a parenthesis at any position of the string.  For example, if s = ""()))"", you can insert an opening parenthesis to be ""(()))"" or a closing parenthesis to be ""())))"".  Return the minimum number of moves required to make s valid.  ",minimum-add-to-make-parentheses-valid,Minimum Add to Make Parentheses Valid,"String, Stack, Greedy",3
"Given an array of integers nums, sort the array in ascending order and return it. You must solve the problem without using any built-in functions in O(nlog(n)) time complexity and with the smallest space complexity possible.  ",sort-an-array,Sort an Array,"Array, Divide and Conquer, Sorting, Heap (Priority Queue), Merge Sort, Bucket Sort, Radix Sort, Counting Sort",3
"At a lemonade stand, each lemonade costs $5. Customers are standing in a queue to buy from you and order one at a time (in the order specified by bills). Each customer will only buy one lemonade and pay with either a $5, $10, or $20 bill. You must provide the correct change to each customer so that the net transaction is that the customer pays $5. Note that you do not have any change in hand at first. Given an integer array bills where bills[i] is the bill the ith customer pays, return true if you can provide every customer with the correct change, or false otherwise.  ",lemonade-change,Lemonade Change,"Array, Greedy",3
"You are given an array representing a row of seats where seats[i] = 1 represents a person sitting in the ith seat, and seats[i] = 0 represents that the ith seat is empty (0-indexed). There is at least one empty seat, and at least one person sitting. Alex wants to sit in the seat such that the distance between him and the closest person to him is maximized.  Return that maximum distance to the closest person.  ",maximize-distance-to-closest-person,Maximize Distance to Closest Person,Array,3
"You're given strings jewels representing the types of stones that are jewels, and stones representing the stones you have. Each character in stones is a type of stone you have. You want to know how many of the stones you have are also jewels. Letters are case sensitive, so ""a"" is considered a different type of stone from ""A"".  ",jewels-and-stones,Jewels and Stones,"Hash Table, String",3
"You are given a network of n nodes, labeled from 1 to n. You are also given times, a list of travel times as directed edges times[i] = (ui, vi, wi), where ui is the source node, vi is the target node, and wi is the time it takes for a signal to travel from source to target. We will send a signal from a given node k. Return the minimum time it takes for all the n nodes to receive the signal. If it is impossible for all the n nodes to receive the signal, return -1.  ",network-delay-time,Network Delay Time,"Depth-First Search, Breadth-First Search, Graph, Heap (Priority Queue), Shortest Path",3
"Given an array of integers nums, calculate the pivot index of this array. The pivot index is the index where the sum of all the numbers strictly to the left of the index is equal to the sum of all the numbers strictly to the index's right. If the index is on the left edge of the array, then the left sum is 0 because there are no elements to the left. This also applies to the right edge of the array. Return the leftmost pivot index. If no such index exists, return -1.  ",find-pivot-index,Find Pivot Index,"Array, Prefix Sum",3
"You are given an array prices where prices[i] is the price of a given stock on the ith day, and an integer fee representing a transaction fee. Find the maximum profit you can achieve. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).  ",best-time-to-buy-and-sell-stock-with-transaction-fee,Best Time to Buy and Sell Stock with Transaction Fee,"Array, Dynamic Programming, Greedy",3
"Given an array of integers nums and an integer k, return the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than k.  ",subarray-product-less-than-k,Subarray Product Less Than K,"Array, Sliding Window",3
"Design a HashSet without using any built-in hash table libraries. Implement MyHashSet class:  void add(key) Inserts the value key into the HashSet. bool contains(key) Returns whether the value key exists in the HashSet or not. void remove(key) Removes the value key in the HashSet. If key does not exist in the HashSet, do nothing.   ",design-hashset,Design HashSet,"Array, Hash Table, Linked List, Design, Hash Function",3
"On an n x n chessboard, a knight starts at the cell (row, column) and attempts to make exactly k moves. The rows and columns are 0-indexed, so the top-left cell is (0, 0), and the bottom-right cell is (n - 1, n - 1). A chess knight has eight possible moves it can make, as illustrated below. Each move is two cells in a cardinal direction, then one cell in an orthogonal direction.  Each time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there. The knight continues moving until it has made exactly k moves or has moved off the chessboard. Return the probability that the knight remains on the board after it has stopped moving.  ",knight-probability-in-chessboard,Knight Probability in Chessboard,Dynamic Programming,3
"You are asked to cut off all the trees in a forest for a golf event. The forest is represented as an m x n matrix. In this matrix:  0 means the cell cannot be walked through. 1 represents an empty cell that can be walked through. A number greater than 1 represents a tree in a cell that can be walked through, and this number is the tree's height.  In one step, you can walk in any of the four directions: north, east, south, and west. If you are standing in a cell with a tree, you can choose whether to cut it off. You must cut off the trees in order from shortest to tallest. When you cut off a tree, the value at its cell becomes 1 (an empty cell). Starting from the point (0, 0), return the minimum steps you need to walk to cut off all the trees. If you cannot cut off all the trees, return -1. Note: The input is generated such that no two trees have the same height, and there is at least one tree needs to be cut off.  ",cut-off-trees-for-golf-event,Cut Off Trees for Golf Event,"Array, Breadth-First Search, Heap (Priority Queue), Matrix",3
"Given the root of a binary search tree and the lowest and highest boundaries as low and high, trim the tree so that all its elements lies in [low, high]. Trimming the tree should not change the relative structure of the elements that will remain in the tree (i.e., any node's descendant should remain a descendant). It can be proven that there is a unique answer. Return the root of the trimmed binary search tree. Note that the root may change depending on the given bounds.  ",trim-a-binary-search-tree,Trim a Binary Search Tree,"Tree, Depth-First Search, Binary Search Tree, Binary Tree",3
"Given a sorted integer array arr, two integers k and x, return the k closest integers to x in the array. The result should also be sorted in ascending order. An integer a is closer to x than an integer b if:  |a - x| < |b - x|, or |a - x| == |b - x| and a < b   ",find-k-closest-elements,Find K Closest Elements,"Array, Two Pointers, Binary Search, Sliding Window, Sorting, Heap (Priority Queue)",3
"Given a characters array tasks, representing the tasks a CPU needs to do, where each letter represents a different task. Tasks could be done in any order. Each task is done in one unit of time. For each unit of time, the CPU could complete either one task or just be idle. However, there is a non-negative integer n that represents the cooldown period between two same tasks (the same letter in the array), that is that there must be at least n units of time between any two same tasks. Return the least number of units of times that the CPU will take to finish all the given tasks.  ",task-scheduler,Task Scheduler,"Array, Hash Table, Greedy, Sorting, Heap (Priority Queue), Counting",3
"You are given two binary trees root1 and root2. Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree. Return the merged tree. Note: The merging process must start from the root nodes of both trees.  ",merge-two-binary-trees,Merge Two Binary Trees,"Tree, Depth-First Search, Breadth-First Search, Binary Tree",3
"You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots. Given an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return true if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule and false otherwise.  ",can-place-flowers,Can Place Flowers,"Array, Greedy",3
"There is an m x n grid with a ball. The ball is initially at the position [startRow, startColumn]. You are allowed to move the ball to one of the four adjacent cells in the grid (possibly out of the grid crossing the grid boundary). You can apply at most maxMove moves to the ball. Given the five integers m, n, maxMove, startRow, startColumn, return the number of paths to move the ball out of the grid boundary. Since the answer can be very large, return it modulo 109 + 7.  ",out-of-boundary-paths,Out of Boundary Paths,Dynamic Programming,3
"Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise. In other words, return true if one of s1's permutations is the substring of s2.  ",permutation-in-string,Permutation in String,"Hash Table, Two Pointers, String, Sliding Window",3
"Given a string s, reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.  ",reverse-words-in-a-string-iii,Reverse Words in a String III,"Two Pointers, String",3
"Given the root of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST. As a reminder, a binary search tree is a tree that satisfies these constraints:  The left subtree of a node contains only nodes with keys less than the node's key. The right subtree of a node contains only nodes with keys greater than the node's key. Both the left and right subtrees must also be binary search trees.   ",convert-bst-to-greater-tree,Convert BST to Greater Tree,"Tree, Depth-First Search, Binary Search Tree, Binary Tree",3
"Given an integer array nums, return the number of reverse pairs in the array. A reverse pair is a pair (i, j) where:  0 <= i < j < nums.length and nums[i] > 2 * nums[j].   ",reverse-pairs,Reverse Pairs,"Array, Binary Search, Divide and Conquer, Binary Indexed Tree, Segment Tree, Merge Sort, Ordered Set",3
"We define str = [s, n] as the string str which consists of the string s concatenated n times.  For example, str == [""abc"", 3] ==""abcabcabc"".  We define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.  For example, s1 = ""abc"" can be obtained from s2 = ""abdbec"" based on our definition by removing the bolded underlined characters.  You are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2]. Return the maximum integer m such that str = [str2, m] can be obtained from str1.  ",count-the-repetitions,Count The Repetitions,"String, Dynamic Programming",3
"Serialization is converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary search tree. There is no restriction on how your serialization/deserialization algorithm should work. You need to ensure that a binary search tree can be serialized to a string, and this string can be deserialized to the original tree structure. The encoded string should be as compact as possible.  ",serialize-and-deserialize-bst,Serialize and Deserialize BST,"String, Tree, Depth-First Search, Breadth-First Search, Design, Binary Search Tree, Binary Tree",3
"You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself.  ",add-two-numbers-ii,Add Two Numbers II,"Linked List, Math, Stack",3
"Design a data structure to store the strings' count with the ability to return the strings with minimum and maximum counts. Implement the AllOne class:  AllOne() Initializes the object of the data structure. inc(String key) Increments the count of the string key by 1. If key does not exist in the data structure, insert it with count 1. dec(String key) Decrements the count of the string key by 1. If the count of key is 0 after the decrement, remove it from the data structure. It is guaranteed that key exists in the data structure before the decrement. getMaxKey() Returns one of the keys with the maximal count. If no element exists, return an empty string """". getMinKey() Returns one of the keys with the minimum count. If no element exists, return an empty string """".  Note that each function must run in O(1) average time complexity.  ",all-oone-data-structure,All O`one Data Structure,"Hash Table, Linked List, Design, Doubly-Linked List",3
"Given two non-negative integers, num1 and num2 represented as string, return the sum of num1 and num2 as a string. You must solve the problem without using any built-in library for handling large integers (such as BigInteger). You must also not convert the inputs to integers directly.  ",add-strings,Add Strings,"Math, String, Simulation",3
"Given a string s and an integer k, return the length of the longest substring of s such that the frequency of each character in this substring is greater than or equal to k.  ",longest-substring-with-at-least-k-repeating-characters,Longest Substring with At Least K Repeating Characters,"Hash Table, String, Divide and Conquer, Sliding Window",3
You are given two strings s and t. String t is generated by random shuffling string s and then add one more letter at a random position. Return the letter that was added to t.  ,find-the-difference,Find the Difference,"Hash Table, String, Bit Manipulation, Sorting",3
"Given an integer n, return an array ans of length n + 1 such that for each i (0 <= i <= n), ans[i] is the number of 1's in the binary representation of i.  ",counting-bits,Counting Bits,"Dynamic Programming, Bit Manipulation",3
"You are given an array of integers distance. You start at the point (0, 0) on an X-Y plane, and you move distance[0] meters to the north, then distance[1] meters to the west, distance[2] meters to the south, distance[3] meters to the east, and so on. In other words, after each move, your direction changes counter-clockwise. Return true if your path crosses itself or false if it does not.  ",self-crossing,Self Crossing,"Array, Math, Geometry",3
"Given an integer array nums, return an integer array counts where counts[i] is the number of smaller elements to the right of nums[i].  ",count-of-smaller-numbers-after-self,Count of Smaller Numbers After Self,"Array, Binary Search, Divide and Conquer, Binary Indexed Tree, Segment Tree, Merge Sort, Ordered Set",3
"Given an integer array nums, handle multiple queries of the following types:  Update the value of an element in nums. Calculate the sum of the elements of nums between indices left and right inclusive where left <= right.  Implement the NumArray class:  NumArray(int[] nums) Initializes the object with the integer array nums. void update(int index, int val) Updates the value of nums[index] to be val. int sumRange(int left, int right) Returns the sum of the elements of nums between indices left and right inclusive (i.e. nums[left] + nums[left + 1] + ... + nums[right]).   ",range-sum-query-mutable,Range Sum Query - Mutable,"Array, Design, Binary Indexed Tree, Segment Tree",3
"Given a 2D matrix matrix, handle multiple queries of the following type:  Calculate the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).  Implement the NumMatrix class:  NumMatrix(int[][] matrix) Initializes the object with the integer matrix matrix. int sumRegion(int row1, int col1, int row2, int col2) Returns the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).  You must design an algorithm where sumRegion works on O(1) time complexity.  ",range-sum-query-2d-immutable,Range Sum Query 2D - Immutable,"Array, Design, Matrix, Prefix Sum",3
"Design an iterator that supports the peek operation on an existing iterator in addition to the hasNext and the next operations. Implement the PeekingIterator class:  PeekingIterator(Iterator<int> nums) Initializes the object with the given integer iterator iterator. int next() Returns the next element in the array and moves the pointer to the next element. boolean hasNext() Returns true if there are still elements in the array. int peek() Returns the next element in the array without moving the pointer.  Note: Each language may have a different implementation of the constructor and Iterator, but they all support the int next() and boolean hasNext() functions.  ",peeking-iterator,Peeking Iterator,"Array, Design, Iterator",3
"Given the root of a binary tree, return all root-to-leaf paths in any order. A leaf is a node with no children.  ",binary-tree-paths,Binary Tree Paths,"String, Backtracking, Tree, Depth-First Search, Binary Tree",3
"Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”  ",lowest-common-ancestor-of-a-binary-search-tree,Lowest Common Ancestor of a Binary Search Tree,"Tree, Depth-First Search, Binary Search Tree, Binary Tree",3
"Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty). Implement the MyStack class:  void push(int x) Pushes element x to the top of the stack. int pop() Removes the element on the top of the stack and returns it. int top() Returns the element on the top of the stack. boolean empty() Returns true if the stack is empty, false otherwise.  Notes:  You must use only standard operations of a queue, which means that only push to back, peek/pop from front, size and is empty operations are valid. Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue's standard operations.   ",implement-stack-using-queues,Implement Stack using Queues,"Stack, Design, Queue",3
"Given an m x n binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.  ",maximal-square,Maximal Square,"Array, Dynamic Programming, Matrix",3
"Write a function that takes the binary representation of an unsigned integer and returns the number of '1' bits it has (also known as the Hamming weight). Note:  Note that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned. In Java, the compiler represents the signed integers using 2's complement notation. Therefore, in Example 3, the input represents the signed integer. -3.   ",number-of-1-bits,Number of 1 Bits,"Divide and Conquer, Bit Manipulation",3
"Given the head of a linked list, return the list after sorting it in ascending order.  ",sort-list,Sort List,"Linked List, Two Pointers, Divide and Conquer, Sorting, Merge Sort",3
"You are given the root of a binary tree containing digits from 0 to 9 only. Each root-to-leaf path in the tree represents a number.  For example, the root-to-leaf path 1 -> 2 -> 3 represents the number 123.  Return the total sum of all root-to-leaf numbers. Test cases are generated so that the answer will fit in a 32-bit integer. A leaf node is a node with no children.  ",sum-root-to-leaf-numbers,Sum Root to Leaf Numbers,"Tree, Depth-First Search, Binary Tree",3
"Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree.  ",convert-sorted-array-to-binary-search-tree,Convert Sorted Array to Binary Search Tree,"Array, Divide and Conquer, Tree, Binary Search Tree, Binary Tree",3
"Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.  ",construct-binary-tree-from-preorder-and-inorder-traversal,Construct Binary Tree from Preorder and Inorder Traversal,"Array, Hash Table, Divide and Conquer, Tree, Binary Tree",3
"A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.  For example, ""0.1.2.201"" and ""192.168.1.1"" are valid IP addresses, but ""0.011.255.245"", ""192.168.1.312"" and ""192.168@1.1"" are invalid IP addresses.  Given a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.  ",restore-ip-addresses,Restore IP Addresses,"String, Backtracking",3
"Given a rows x cols binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.  ",maximal-rectangle,Maximal Rectangle,"Array, Dynamic Programming, Stack, Matrix, Monotonic Stack",3
"Given a string s consisting of words and spaces, return the length of the last word in the string. A word is a maximal substring consisting of non-space characters only.  ",length-of-last-word,Length of Last Word,String,3
"You are given a string s and an array of strings words. All the strings of words are of the same length. A concatenated substring in s is a substring that contains all the strings of any permutation of words concatenated.  For example, if words = [""ab"",""cd"",""ef""], then ""abcdef"", ""abefcd"", ""cdabef"", ""cdefab"", ""efabcd"", and ""efcdab"" are all concatenated strings. ""acdbef"" is not a concatenated substring because it is not the concatenation of any permutation of words.  Return the starting indices of all the concatenated substrings in s. You can return the answer in any order.  ",substring-with-concatenation-of-all-words,Substring with Concatenation of All Words,"Hash Table, String, Sliding Window",3
"A swap is defined as taking two distinct positions in an array and swapping the values in them. A circular array is defined as an array where we consider the first element and the last element to be adjacent. Given a binary circular array nums, return the minimum number of swaps required to group all 1's present in the array together at any location.  ",minimum-swaps-to-group-all-1s-together-ii,Minimum Swaps to Group All 1's Together II,"Array, Sliding Window",2
"A parentheses string is a non-empty string consisting only of '(' and ')'. It is valid if any of the following conditions is true:  It is (). It can be written as AB (A concatenated with B), where A and B are valid parentheses strings. It can be written as (A), where A is a valid parentheses string.  You are given a parentheses string s and a string locked, both of length n. locked is a binary string consisting only of '0's and '1's. For each index i of locked,  If locked[i] is '1', you cannot change s[i]. But if locked[i] is '0', you can change s[i] to either '(' or ')'.  Return true if you can make s a valid parentheses string. Otherwise, return false.  ",check-if-a-parentheses-string-can-be-valid,Check if a Parentheses String Can Be Valid,"String, Stack, Greedy",2
"There are n houses evenly lined up on the street, and each house is beautifully painted. You are given a 0-indexed integer array colors of length n, where colors[i] represents the color of the ith house. Return the maximum distance between two houses with different colors. The distance between the ith and jth houses is abs(i - j), where abs(x) is the absolute value of x.  ",two-furthest-houses-with-different-colors,Two Furthest Houses With Different Colors,"Array, Greedy",2
"A sentence consists of lowercase letters ('a' to 'z'), digits ('0' to '9'), hyphens ('-'), punctuation marks ('!', '.', and ','), and spaces (' ') only. Each sentence can be broken down into one or more tokens separated by one or more spaces ' '. A token is a valid word if all three of the following are true:  It only contains lowercase letters, hyphens, and/or punctuation (no digits). There is at most one hyphen '-'. If present, it must be surrounded by lowercase characters (""a-b"" is valid, but ""-ab"" and ""ab-"" are not valid). There is at most one punctuation mark. If present, it must be at the end of the token (""ab,"", ""cd!"", and ""."" are valid, but ""a!b"" and ""c.,"" are not valid). ",number-of-valid-words-in-a-sentence,Number of Valid Words in a Sentence,String,2
"A teacher is writing a test with n true/false questions, with 'T' denoting true and 'F' denoting false. He wants to confuse the students by maximizing the number of consecutive questions with the same answer (multiple trues or multiple falses in a row). You are given a string answerKey, where answerKey[i] is the original answer to the ith question. In addition, you are given an integer k, the maximum number of times you may perform the following operation:  Change the answer key for any question to 'T' or 'F' (i.e., set answerKey[i] to 'T' or 'F').  Return the maximum number of consecutive 'T's or 'F's in the answer key after performing the operation at most k times.  ",maximize-the-confusion-of-an-exam,Maximize the Confusion of an Exam,"String, Binary Search, Sliding Window, Prefix Sum",2
"Given an array of strings nums containing n unique binary strings each of length n, return a binary string of length n that does not appear in nums. If there are multiple answers, you may return any of them.  ",find-unique-binary-string,Find Unique Binary String,"Array, String, Backtracking",2
"You are given a 0-indexed array nums of distinct integers. You want to rearrange the elements in the array such that every element in the rearranged array is not equal to the average of its neighbors. More formally, the rearranged array should have the property such that for every i in the range 1 <= i < nums.length - 1, (nums[i-1] + nums[i+1]) / 2 is not equal to nums[i]. Return any rearrangement of nums that meets the requirements.  ",array-with-elements-not-equal-to-average-of-neighbors,Array With Elements Not Equal to Average of Neighbors,"Array, Greedy, Sorting",2
"You are given an m x n matrix maze (0-indexed) with empty cells (represented as '.') and walls (represented as '+'). You are also given the entrance of the maze, where entrance = [entrancerow, entrancecol] denotes the row and column of the cell you are initially standing at. In one step, you can move one cell up, down, left, or right. You cannot step into a cell with a wall, and you cannot step outside the maze. Your goal is to find the nearest exit from the entrance. An exit is defined as an empty cell that is at the border of the maze. The entrance does not count as an exit. Return the number of steps in the shortest path from the entrance to the nearest exit, or -1 if no such path exists.  ",nearest-exit-from-entrance-in-maze,Nearest Exit from Entrance in Maze,"Array, Breadth-First Search, Matrix",2
"A square triple (a,b,c) is a triple where a, b, and c are integers and a2 + b2 = c2. Given an integer n, return the number of square triples such that 1 <= a, b, c <= n.  ",count-square-sum-triples,Count Square Sum Triples,"Math, Enumeration",2
"Given two strings s and part, perform the following operation on s until all occurrences of the substring part are removed:  Find the leftmost occurrence of the substring part and remove it from s.  Return s after removing all occurrences of part. A substring is a contiguous sequence of characters in a string.  ",remove-all-occurrences-of-a-substring,Remove All Occurrences of a Substring,String,2
"Given a binary string s, return true if the longest contiguous segment of 1's is strictly longer than the longest contiguous segment of 0's in s, or return false otherwise.  For example, in s = ""110100010"" the longest continuous segment of 1s has length 2, and the longest continuous segment of 0s has length 3.  Note that if there are no 0's, then the longest continuous segment of 0's is considered to have a length 0. The same applies if there is no 1's.  ",longer-contiguous-segments-of-ones-than-zeros,Longer Contiguous Segments of Ones than Zeros,String,2
"There is a school that has classes of students and each class will be having a final exam. You are given a 2D integer array classes, where classes[i] = [passi, totali]. You know beforehand that in the ith class, there are totali total students, but only passi number of students will pass the exam. You are also given an integer extraStudents. There are another extraStudents brilliant students that are guaranteed to pass the exam of any class they are assigned to. You want to assign each of the extraStudents students to a class in a way that maximizes the average pass ratio across all the classes. The pass ratio of a class is equal to the number of students of the class that will pass the exam divided by the total number of students of the class. The average pass ratio is the sum of pass ratios of all the classes divided by the number of the classes. Return the maximum possible average pass ratio after assigning the extraStudents students. Answers within 10-5 of the actual answer will be accepted.  ",maximum-average-pass-ratio,Maximum Average Pass Ratio,"Array, Greedy, Heap (Priority Queue)",2
"You have n boxes. You are given a binary string boxes of length n, where boxes[i] is '0' if the ith box is empty, and '1' if it contains one ball. In one operation, you can move one ball from a box to an adjacent box. Box i is adjacent to box j if abs(i - j) == 1. Note that after doing so, there may be more than one ball in some boxes. Return an array answer of size n, where answer[i] is the minimum number of operations needed to move all the balls to the ith box. Each answer[i] is calculated considering the initial state of the boxes.  ",minimum-number-of-operations-to-move-all-balls-to-each-box,Minimum Number of Operations to Move All Balls to Each Box,"Array, String",2
"Given an array nums, return true if the array was originally sorted in non-decreasing order, then rotated some number of positions (including zero). Otherwise, return false. There may be duplicates in the original array. Note: An array A rotated by x positions results in an array B of the same length such that A[i] == B[(i+x) % A.length], where % is the modulo operation.  ",check-if-array-is-sorted-and-rotated,Check if Array Is Sorted and Rotated,Array,2
"You are given an integer array nums. The absolute sum of a subarray [numsl, numsl+1, ..., numsr-1, numsr] is abs(numsl + numsl+1 + ... + numsr-1 + numsr). Return the maximum absolute sum of any (possibly empty) subarray of nums. Note that abs(x) is defined as follows:  If x is a negative integer, then abs(x) = -x. If x is a non-negative integer, then abs(x) = x.   ",maximum-absolute-sum-of-any-subarray,Maximum Absolute Sum of Any Subarray,"Array, Dynamic Programming",2
"A good meal is a meal that contains exactly two different food items with a sum of deliciousness equal to a power of two. You can pick any two different foods to make a good meal. Given an array of integers deliciousness where deliciousness[i] is the deliciousness of the i​​​​​​th​​​​​​​​ item of food, return the number of different good meals you can make from this list modulo 109 + 7. Note that items with different indices are considered different even if they have the same deliciousness value.  ",count-good-meals,Count Good Meals,"Array, Hash Table",2
"You are given an integer array nums and an integer k. In one operation, you can pick two numbers from the array whose sum equals k and remove them from the array. Return the maximum number of operations you can perform on the array.  ",max-number-of-k-sum-pairs,Max Number of K-Sum Pairs,"Array, Hash Table, Two Pointers, Sorting",2
"You are given an array nums of n positive integers. You can perform two types of operations on any element of the array any number of times:  If the element is even, divide it by 2.  	 For example, if the array is [1,2,3,4], then you can do this operation on the last element, and the array will be [1,2,3,2].   If the element is odd, multiply it by 2. 	 For example, if the array is [1,2,3,4], then you can do this operation on the first element, and the array will be [2,2,3,4].    The deviation of the array is the maximum difference between any two elements in the array. Return the minimum deviation the array can have after performing some number of operations.  ",minimize-deviation-in-array,Minimize Deviation in Array,"Array, Greedy, Heap (Priority Queue), Ordered Set",2
"You are given an integer array nums and an integer x. In one operation, you can either remove the leftmost or the rightmost element from the array nums and subtract its value from x. Note that this modifies the array for future operations. Return the minimum number of operations to reduce x to exactly 0 if it is possible, otherwise, return -1.  ",minimum-operations-to-reduce-x-to-zero,Minimum Operations to Reduce X to Zero,"Array, Hash Table, Binary Search, Sliding Window, Prefix Sum",2
"Given an array of positive integers arr, return the sum of all possible odd-length subarrays of arr. A subarray is a contiguous subsequence of the array.  ",sum-of-all-odd-length-subarrays,Sum of All Odd Length Subarrays,"Array, Math, Prefix Sum",2
"Given a square matrix mat, return the sum of the matrix diagonals. Only include the sum of all the elements on the primary diagonal and all the elements on the secondary diagonal that are not part of the primary diagonal.  ",matrix-diagonal-sum,Matrix Diagonal Sum,"Array, Matrix",2
"Given a directed acyclic graph, with n vertices numbered from 0 to n-1, and an array edges where edges[i] = [fromi, toi] represents a directed edge from node fromi to node toi. Find the smallest set of vertices from which all nodes in the graph are reachable. It's guaranteed that a unique solution exists. Notice that you can return the vertices in any order.  ",minimum-number-of-vertices-to-reach-all-nodes,Minimum Number of Vertices to Reach All Nodes,Graph,2
"Given an array arr of positive integers sorted in a strictly increasing order, and an integer k. Return the kth positive integer that is missing from this array.  ",kth-missing-positive-number,Kth Missing Positive Number,"Array, Binary Search",2
"You are given a string s. A split is called good if you can split s into two non-empty strings sleft and sright where their concatenation is equal to s (i.e., sleft + sright = s) and the number of distinct letters in sleft and sright is the same. Return the number of good splits you can make in s.  ",number-of-good-ways-to-split-a-string,Number of Good Ways to Split a String,"String, Dynamic Programming, Bit Manipulation",2
Given two non-negative integers low and high. Return the count of odd numbers between low and high (inclusive).  ,count-odd-numbers-in-an-interval-range,Count Odd Numbers in an Interval Range,Math,2
"There are numBottles water bottles that are initially full of water. You can exchange numExchange empty water bottles from the market with one full water bottle. The operation of drinking a full water bottle turns it into an empty bottle. Given the two integers numBottles and numExchange, return the maximum number of water bottles you can drink.  ",water-bottles,Water Bottles,"Math, Simulation",2
You are given an array of unique integers salary where salary[i] is the salary of the ith employee. Return the average salary of employees excluding the minimum and maximum salary. Answers within 10-5 of the actual answer will be accepted.  ,average-salary-excluding-the-minimum-and-maximum-salary,Average Salary Excluding the Minimum and Maximum Salary,"Array, Sorting",2
"You are given an integer array prices where prices[i] is the price of the ith item in a shop. There is a special discount for items in the shop. If you buy the ith item, then you will receive a discount equivalent to prices[j] where j is the minimum index such that j > i and prices[j] <= prices[i]. Otherwise, you will not receive any discount at all. Return an integer array answer where answer[i] is the final price you will pay for the ith item of the shop, considering the special discount.  ",final-prices-with-a-special-discount-in-a-shop,Final Prices With a Special Discount in a Shop,"Array, Stack, Monotonic Stack",2
"Given the array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn]. Return the array in the form [x1,y1,x2,y2,...,xn,yn].  ",shuffle-the-array,Shuffle the Array,Array,2
"Given a sentence that consists of some words separated by a single space, and a searchWord, check if searchWord is a prefix of any word in sentence. Return the index of the word in sentence (1-indexed) where searchWord is a prefix of this word. If searchWord is a prefix of more than one word, return the index of the first word (minimum index). If there is no such word return -1. A prefix of a string s is any leading contiguous substring of s.  ",check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence,Check If a Word Occurs As a Prefix of Any Word in a Sentence,"String, String Matching",2
"Given a sentence text (A sentence is a string of space-separated words) in the following format:  First letter is in upper case. Each word in text are separated by a single space.  Your task is to rearrange the words in text such that all words are rearranged in an increasing order of their lengths. If two words have the same length, arrange them in their original order. Return the new text following the format shown above.  ",rearrange-words-in-a-sentence,Rearrange Words in a Sentence,"String, Sorting",2
"Given an array of integers nums, you start with an initial positive value startValue. In each iteration, you calculate the step by step sum of startValue plus elements in nums (from left to right). Return the minimum positive value of startValue such that the step by step sum is never less than 1.  ",minimum-value-to-get-positive-step-by-step-sum,Minimum Value to Get Positive Step by Step Sum,"Array, Prefix Sum",2
"Given the array nums, obtain a subsequence of the array whose sum of elements is strictly greater than the sum of the non included elements in such subsequence.  If there are multiple solutions, return the subsequence with minimum size and if there still exist multiple solutions, return the subsequence with the maximum total sum of all its elements. A subsequence of an array can be obtained by erasing some (possibly zero) elements from the array.  Note that the solution with the given constraints is guaranteed to be unique. Also return the answer sorted in non-increasing order.  ",minimum-subsequence-in-non-increasing-order,Minimum Subsequence in Non-Increasing Order,"Array, Greedy, Sorting",2
"A string is called a happy prefix if is a non-empty prefix which is also a suffix (excluding itself). Given a string s, return the longest happy prefix of s. Return an empty string """" if no such prefix exists.  ",longest-happy-prefix,Longest Happy Prefix,"String, Rolling Hash, String Matching, Hash Function",2
"Given two arrays of integers nums and index. Your task is to create target array under the following rules:  Initially target array is empty. From left to right read nums[i] and index[i], insert at index index[i] the value nums[i] in target array. Repeat the previous step until there are no elements to read in nums and index.  Return the target array. It is guaranteed that the insertion operations will be valid.  ",create-target-array-in-the-given-order,Create Target Array in the Given Order,"Array, Simulation",2
" A cinema has n rows of seats, numbered from 1 to n and there are ten seats in each row, labelled from 1 to 10 as shown in the figure above. Given the array reservedSeats containing the numbers of seats already reserved, for example, reservedSeats[i] = [3,8] means the seat located in row 3 and labelled with 8 is already reserved. Return the maximum number of four-person groups you can assign on the cinema seats. A four-person group occupies four adjacent seats in one single row. Seats across an aisle (such as [3,3] and [3,4]) are not considered to be adjacent, but there is an exceptional case on which an aisle split a four-person group, in that case, the aisle split a four-person group in the middle, which means to have two people on each side.  ",cinema-seat-allocation,Cinema Seat Allocation,"Array, Hash Table, Greedy, Bit Manipulation",2
Given two binary trees original and cloned and given a reference to a node target in the original tree. The cloned tree is a copy of the original tree. Return a reference to the same node in the cloned tree. Note that you are not allowed to change any of the two trees or the target node and the answer must be a reference to a node in the cloned tree.  ,find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree,Find a Corresponding Node of a Binary Tree in a Clone of That Tree,"Tree, Depth-First Search, Breadth-First Search, Binary Tree",2
"Given an undirected tree consisting of n vertices numbered from 1 to n. A frog starts jumping from vertex 1. In one second, the frog jumps from its current vertex to another unvisited vertex if they are directly connected. The frog can not jump back to a visited vertex. In case the frog can jump to several vertices, it jumps randomly to one of them with the same probability. Otherwise, when the frog can not jump to any unvisited vertex, it jumps forever on the same vertex. The edges of the undirected tree are given in the array edges, where edges[i] = [ai, bi] means that exists an edge connecting the vertices ai and bi. Return the probability that after t seconds the frog is on the vertex target. Answers within 10-5 of the actual answer will be accepted.  ",frog-position-after-t-seconds,Frog Position After T Seconds,"Tree, Depth-First Search, Breadth-First Search, Graph",2
"You are given a string s. Reorder the string using the following algorithm:  Pick the smallest character from s and append it to the result. Pick the smallest character from s which is greater than the last appended character to the result and append it. Repeat step 2 until you cannot pick more characters. Pick the largest character from s and append it to the result. Pick the largest character from s which is smaller than the last appended character to the result and append it. Repeat step 5 until you cannot pick more characters. Repeat the steps from 1 to 6 until you pick all characters from s.  In each step, If the smallest or the largest character appears more than once you can choose any occurrence and append it to the result. Return the result string after sorting s with this algorithm.  ",increasing-decreasing-string,Increasing Decreasing String,"Hash Table, String, Counting",2
Given a binary tree root and a linked list with head as the first node.  Return True if all the elements in the linked list starting from the head correspond to some downward path connected in the binary tree otherwise return False. In this context downward path means a path that starts at some node and goes downwards.  ,linked-list-in-binary-tree,Linked List in Binary Tree,"Linked List, Tree, Depth-First Search, Breadth-First Search, Binary Tree",2
"Given the array nums, for each nums[i] find out how many numbers in the array are smaller than it. That is, for each nums[i] you have to count the number of valid j's such that j != i and nums[j] < nums[i]. Return the answer in an array.  ",how-many-numbers-are-smaller-than-the-current-number,How Many Numbers Are Smaller Than the Current Number,"Array, Hash Table, Sorting, Counting",2
You are given an integer array arr. You can choose a set of integers and remove all the occurrences of these integers in the array. Return the minimum size of the set so that at least half of the integers of the array are removed.  ,reduce-array-size-to-the-half,Reduce Array Size to The Half,"Array, Hash Table, Greedy, Sorting, Heap (Priority Queue)",2
"Given a binary tree root and an integer target, delete all the leaf nodes with value target. Note that once you delete a leaf node with value target, if its parent node becomes a leaf node and has the value target, it should also be deleted (you need to continue doing that until you cannot).  ",delete-leaves-with-a-given-value,Delete Leaves With a Given Value,"Tree, Depth-First Search, Binary Tree",2
"Given the root of a binary tree, return the sum of values of nodes with an even-valued grandparent. If there are no nodes with an even-valued grandparent, return 0. A grandparent of a node is the parent of its parent if it exists.  ",sum-of-nodes-with-even-valued-grandparent,Sum of Nodes with Even-Valued Grandparent,"Tree, Depth-First Search, Breadth-First Search, Binary Tree",2
"Given a m x n matrix mat and an integer k, return a matrix answer where each answer[i][j] is the sum of all elements mat[r][c] for:  i - k <= r <= i + k, j - k <= c <= j + k, and (r, c) is a valid position in the matrix.   ",matrix-block-sum,Matrix Block Sum,"Array, Matrix, Prefix Sum",2
"We are given a list nums of integers representing a list compressed with run-length encoding. Consider each adjacent pair of elements [freq, val] = [nums[2*i], nums[2*i+1]] (with i >= 0).  For each such pair, there are freq elements with value val concatenated in a sublist. Concatenate all the sublists from left to right to generate the decompressed list. Return the decompressed list.  ",decompress-run-length-encoded-list,Decompress Run-Length Encoded List,Array,2
"Given two binary search trees root1 and root2, return a list containing all the integers from both trees sorted in ascending order.  ",all-elements-in-two-binary-search-trees,All Elements in Two Binary Search Trees,"Tree, Depth-First Search, Binary Search Tree, Sorting, Binary Tree",2
"Given a string s, return the maximum number of ocurrences of any substring under the following rules:  The number of unique characters in the substring must be less than or equal to maxLetters. The substring size must be between minSize and maxSize inclusive.   ",maximum-number-of-occurrences-of-a-substring,Maximum Number of Occurrences of a Substring,"Hash Table, String, Sliding Window",2
"Given an array nums of integers, return how many of them contain an even number of digits.  ",find-numbers-with-even-number-of-digits,Find Numbers with Even Number of Digits,Array,2
Given head which is a reference node to a singly-linked list. The value of each node in the linked list is either 0 or 1. The linked list holds the binary representation of a number. Return the decimal value of the number in the linked list. The most significant bit is at the head of the linked list.  ,convert-binary-number-in-a-linked-list-to-integer,Convert Binary Number in a Linked List to Integer,"Linked List, Math",2
"Balanced strings are those that have an equal quantity of 'L' and 'R' characters. Given a balanced string s, split it into some number of substrings such that:  Each substring is balanced.  Return the maximum number of balanced strings you can obtain.  ",split-a-string-in-balanced-strings,Split a String in Balanced Strings,"String, Greedy, Counting",2
"Return the number of permutations of 1 to n so that prime numbers are at prime indices (1-indexed.) (Recall that an integer is prime if and only if it is greater than 1, and cannot be written as a product of two positive integers both smaller than it.) Since the answer may be large, return the answer modulo 10^9 + 7.  ",prime-arrangements,Prime Arrangements,Math,2
"Given the head of a linked list, we repeatedly delete consecutive sequences of nodes that sum to 0 until there are no such sequences. After doing so, return the head of the final linked list.  You may return any such answer.   (Note that in the examples below, all sequences are serializations of ListNode objects.)",remove-zero-sum-consecutive-nodes-from-linked-list,Remove Zero Sum Consecutive Nodes from Linked List,"Hash Table, Linked List",2
You are given an array of strings words and a string chars. A string is good if it can be formed by characters from chars (each character can only be used once). Return the sum of lengths of all good strings in words.  ,find-words-that-can-be-formed-by-characters,Find Words That Can Be Formed by Characters,"Array, Hash Table, String",2
"On an alphabet board, we start at position (0, 0), corresponding to character board[0][0]. Here, board = [""abcde"", ""fghij"", ""klmno"", ""pqrst"", ""uvwxy"", ""z""], as shown in the diagram below.  We may make the following moves:  'U' moves our position up one row, if the position exists on the board; 'D' moves our position down one row, if the position exists on the board; 'L' moves our position left one column, if the position exists on the board; 'R' moves our position right one column, if the position exists on the board; '!' adds the character board[r][c] at our current position (r, c) to the answer.  (Here, the only positions that exist on the board are positions with letters on them.) Return a sequence of moves that makes our answer equal to target in the minimum number of moves.  You may return any path that does so.  ",alphabet-board-path,Alphabet Board Path,"Hash Table, String",2
"Given a valid (IPv4) IP address, return a defanged version of that IP address. A defanged IP address replaces every period ""."" with ""[.]"".  ",defanging-an-ip-address,Defanging an IP Address,String,2
"Given the root of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST. As a reminder, a binary search tree is a tree that satisfies these constraints:  The left subtree of a node contains only nodes with keys less than the node's key. The right subtree of a node contains only nodes with keys greater than the node's key. Both the left and right subtrees must also be binary search trees.   ",binary-search-tree-to-greater-sum-tree,Binary Search Tree to Greater Sum Tree,"Tree, Depth-First Search, Binary Search Tree, Binary Tree",2
"You are given a series of video clips from a sporting event that lasted time seconds. These video clips can be overlapping with each other and have varying lengths. Each video clip is described by an array clips where clips[i] = [starti, endi] indicates that the ith clip started at starti and ended at endi. We can cut these clips into segments freely.  For example, a clip [0, 7] can be cut into segments [0, 1] + [1, 3] + [3, 7].  Return the minimum number of clips needed so that we can cut the clips into segments that cover the entire sporting event [0, time]. If the task is impossible, return -1.  ",video-stitching,Video Stitching,"Array, Dynamic Programming, Greedy",2
"You are given the root of a binary tree where each node has a value 0 or 1. Each root-to-leaf path represents a binary number starting with the most significant bit.  For example, if the path is 0 -> 1 -> 1 -> 0 -> 1, then this could represent 01101 in binary, which is 13.  For all leaves in the tree, consider the numbers represented by the path from the root to that leaf. Return the sum of these numbers. The test cases are generated so that the answer fits in a 32-bits integer.  ",sum-of-root-to-leaf-binary-numbers,Sum of Root To Leaf Binary Numbers,"Tree, Depth-First Search, Binary Tree",2
"Given a binary array nums and an integer k, return the maximum number of consecutive 1's in the array if you can flip at most k 0's.  ",max-consecutive-ones-iii,Max Consecutive Ones III,"Array, Binary Search, Sliding Window, Prefix Sum",2
"In a town, there are n people labeled from 1 to n. There is a rumor that one of these people is secretly the town judge. If the town judge exists, then:  The town judge trusts nobody. Everybody (except for the town judge) trusts the town judge. There is exactly one person that satisfies properties 1 and 2.  You are given an array trust where trust[i] = [ai, bi] representing that the person labeled ai trusts the person labeled bi. If a trust relationship does not exist in trust array, then such a trust relationship does not exist. Return the label of the town judge if the town judge exists and can be identified, or return -1 otherwise.  ",find-the-town-judge,Find the Town Judge,"Array, Hash Table, Graph",2
"You are given the root of a binary tree with n nodes where each node in the tree has node.val coins. There are n coins in total throughout the whole tree. In one move, we may choose two adjacent nodes and move one coin from one node to another. A move may be from parent to child, or from child to parent. Return the minimum number of moves required to make every node have exactly one coin.  ",distribute-coins-in-binary-tree,Distribute Coins in Binary Tree,"Tree, Depth-First Search, Binary Tree",2
"Given three integers x, y, and bound, return a list of all the powerful integers that have a value less than or equal to bound. An integer is powerful if it can be represented as xi + yj for some integers i >= 0 and j >= 0. You may return the answer in any order. In your answer, each value should occur at most once.  ",powerful-integers,Powerful Integers,"Hash Table, Math",2
"In an alien language, surprisingly, they also use English lowercase letters, but possibly in a different order. The order of the alphabet is some permutation of lowercase letters. Given a sequence of words written in the alien language, and the order of the alphabet, return true if and only if the given words are sorted lexicographically in this alien language.  ",verifying-an-alien-dictionary,Verifying an Alien Dictionary,"Array, Hash Table, String",2
"Given an array of integers arr, return true if and only if it is a valid mountain array. Recall that arr is a mountain array if and only if:  arr.length >= 3 There exists some i with 0 < i < arr.length - 1 such that: 	 arr[0] < arr[1] < ... < arr[i - 1] < arr[i]  arr[i] > arr[i + 1] > ... > arr[arr.length - 1]      ",valid-mountain-array,Valid Mountain Array,Array,2
"Given an integer array arr, and an integer target, return the number of tuples i, j, k such that i < j < k and arr[i] + arr[j] + arr[k] == target. As the answer can be very large, return it modulo 109 + 7.  ",3sum-with-multiplicity,3Sum With Multiplicity,"Array, Hash Table, Two Pointers, Sorting, Counting",2
"Given a string s, reverse the string according to the following rules:  All the characters that are not English letters remain in the same position. All the English letters (lowercase or uppercase) should be reversed.  Return s after reversing it.  ",reverse-only-letters,Reverse Only Letters,"Two Pointers, String",2
"An array is monotonic if it is either monotone increasing or monotone decreasing. An array nums is monotone increasing if for all i <= j, nums[i] <= nums[j]. An array nums is monotone decreasing if for all i <= j, nums[i] >= nums[j]. Given an integer array nums, return true if the given array is monotonic, or false otherwise.  ",monotonic-array,Monotonic Array,Array,2
"You are given an n x n grid where you have placed some 1 x 1 x 1 cubes. Each value v = grid[i][j] represents a tower of v cubes placed on top of cell (i, j). After placing these cubes, you have decided to glue any directly adjacent cubes to each other, forming several irregular 3D shapes. Return the total surface area of the resulting shapes. Note: The bottom face of each shape counts toward its surface area.  ",surface-area-of-3d-shapes,Surface Area of 3D Shapes,"Array, Math, Geometry, Matrix",2
"Alice and Bob have a different total number of candies. You are given two integer arrays aliceSizes and bobSizes where aliceSizes[i] is the number of candies of the ith box of candy that Alice has and bobSizes[j] is the number of candies of the jth box of candy that Bob has. Since they are friends, they would like to exchange one candy box each so that after the exchange, they both have the same total amount of candy. The total amount of candy a person has is the sum of the number of candies in each box they have. Return an integer array answer where answer[0] is the number of candies in the box that Alice must exchange, and answer[1] is the number of candies in the box that Bob must exchange. If there are multiple answers, you may return any one of them. It is guaranteed that at least one answer exists.  ",fair-candy-swap,Fair Candy Swap,"Array, Hash Table, Binary Search, Sorting",2
"You are given an encoded string s. To decode the string to a tape, the encoded string is read one character at a time and the following steps are taken:  If the character read is a letter, that letter is written onto the tape. If the character read is a digit d, the entire current tape is repeatedly written d - 1 more times in total.  Given an integer k, return the kth letter (1-indexed) in the decoded string.  ",decoded-string-at-index,Decoded String at Index,"String, Stack",2
"Alice and Bob play a game with piles of stones. There are an even number of piles arranged in a row, and each pile has a positive integer number of stones piles[i]. The objective of the game is to end with the most stones. The total number of stones across all the piles is odd, so there are no ties. Alice and Bob take turns, with Alice starting first. Each turn, a player takes the entire pile of stones either from the beginning or from the end of the row. This continues until there are no more piles left, at which point the person with the most stones wins. Assuming Alice and Bob play optimally, return true if Alice wins the game, or false if Bob wins.  ",stone-game,Stone Game,"Array, Math, Dynamic Programming, Game Theory",2
"Given a 2D integer array matrix, return the transpose of matrix. The transpose of a matrix is the matrix flipped over its main diagonal, switching the matrix's row and column indices.   ",transpose-matrix,Transpose Matrix,"Array, Matrix, Simulation",2
"You are given an m x n binary matrix grid. A move consists of choosing any row or column and toggling each value in that row or column (i.e., changing all 0's to 1's, and all 1's to 0's). Every row of the matrix is interpreted as a binary number, and the score of the matrix is the sum of these numbers. Return the highest possible score after making any number of moves (including zero moves).  ",score-after-flipping-matrix,Score After Flipping Matrix,"Array, Greedy, Bit Manipulation, Matrix",2
"Given an array of unique integers, arr, where each integer arr[i] is strictly greater than 1. We make a binary tree using these integers, and each number may be used for any number of times. Each non-leaf node's value should be equal to the product of the values of its children. Return the number of binary trees we can make. The answer may be too large so return the answer modulo 109 + 7.  ",binary-trees-with-factors,Binary Trees With Factors,"Array, Hash Table, Dynamic Programming",2
"A valid encoding of an array of words is any reference string s and array of indices indices such that:  words.length == indices.length The reference string s ends with the '#' character. For each index indices[i], the substring of s starting from indices[i] and up to (but not including) the next '#' character is equal to words[i].  Given an array of words, return the length of the shortest reference string s possible of any valid encoding of words.  ",short-encoding-of-words,Short Encoding of Words,"Array, Hash Table, String, Trie",2
"Given a string paragraph and a string array of the banned words banned, return the most frequent word that is not banned. It is guaranteed there is at least one word that is not banned, and that the answer is unique. The words in paragraph are case-insensitive and the answer should be returned in lowercase.  ",most-common-word,Most Common Word,"Hash Table, String, Counting",2
"There is a city composed of n x n blocks, where each block contains a single building shaped like a vertical square prism. You are given a 0-indexed n x n integer matrix grid where grid[r][c] represents the height of the building located in the block at row r and column c. A city's skyline is the outer contour formed by all the building when viewing the side of the city from a distance. The skyline from each cardinal direction north, east, south, and west may be different. We are allowed to increase the height of any number of buildings by any amount (the amount can be different per building). The height of a 0-height building can also be increased. However, increasing the height of a building should not affect the city's skyline from any cardinal direction. Return the maximum total sum that the height of the buildings can be increased by without changing the city's skyline from any cardinal direction.  ",max-increase-to-keep-city-skyline,Max Increase to Keep City Skyline,"Array, Greedy, Matrix",2
"We stack glasses in a pyramid, where the first row has 1 glass, the second row has 2 glasses, and so on until the 100th row.  Each glass holds one cup of champagne. Then, some champagne is poured into the first glass at the top.  When the topmost glass is full, any excess liquid poured will fall equally to the glass immediately to the left and right of it.  When those glasses become full, any excess champagne will fall equally to the left and right of those glasses, and so on.  (A glass at the bottom row has its excess champagne fall on the floor.) For example, after one cup of champagne is poured, the top most glass is full.  After two cups of champagne are poured, the two glasses on the second row are half full.  After three cups of champagne are poured, those two cups become full - there are 3 full glasses total now.  After four cups of champagne are poured, the third row has the middle glass half full, and the two outside glasses are a quarter full, as pictured below.  Now after pouring some non-negative integer cups of champagne, return how full the jth glass in the ith row is (both i and j are 0-indexed.)  ",champagne-tower,Champagne Tower,Dynamic Programming,2
"There is a forest with an unknown number of rabbits. We asked n rabbits ""How many rabbits have the same color as you?"" and collected the answers in an integer array answers where answers[i] is the answer of the ith rabbit. Given the array answers, return the minimum number of rabbits that could be in the forest.  ",rabbits-in-forest,Rabbits in Forest,"Array, Hash Table, Math, Greedy",2
"You are given an integer array arr of length n that represents a permutation of the integers in the range [0, n - 1]. We split arr into some number of chunks (i.e., partitions), and individually sort each chunk. After concatenating them, the result should equal the sorted array. Return the largest number of chunks we can make to sort the array.  ",max-chunks-to-make-sorted,Max Chunks To Make Sorted,"Array, Stack, Greedy, Sorting, Monotonic Stack",2
"You are stacking blocks to form a pyramid. Each block has a color, which is represented by a single letter. Each row of blocks contains one less block than the row beneath it and is centered on top. To make the pyramid aesthetically pleasing, there are only specific triangular patterns that are allowed. A triangular pattern consists of a single block stacked on top of two blocks. The patterns are given as a list of three-letter strings allowed, where the first two characters of a pattern represent the left and right bottom blocks respectively, and the third character is the top block.  For example, ""ABC"" represents a triangular pattern with a 'C' block stacked on top of an 'A' (left) and 'B' (right) block. Note that this is different from ""BAC"" where 'B' is on the left bottom and 'A' is on the right bottom.  You start with a bottom row of blocks bottom, given as a single string, that you must use as the base of the pyramid. Given bottom and allowed, return true if you can build the pyramid all the way to the top such that every triangular pattern in the pyramid is in allowed, or false otherwise.  ",pyramid-transition-matrix,Pyramid Transition Matrix,"Bit Manipulation, Depth-First Search, Breadth-First Search",2
"You are given an array of characters letters that is sorted in non-decreasing order, and a character target. There are at least two different characters in letters. Return the smallest character in letters that is lexicographically greater than target. If such a character does not exist, return the first character in letters.  ",find-smallest-letter-greater-than-target,Find Smallest Letter Greater Than Target,"Array, Binary Search",2
"A self-dividing number is a number that is divisible by every digit it contains.  For example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0.  A self-dividing number is not allowed to contain the digit zero. Given two integers left and right, return a list of all the self-dividing numbers in the range [left, right].  ",self-dividing-numbers,Self Dividing Numbers,Math,2
"Given the head of a singly linked list and an integer k, split the linked list into k consecutive linked list parts. The length of each part should be as equal as possible: no two parts should have a size differing by more than one. This may lead to some parts being null. The parts should be in the order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal to parts occurring later. Return an array of the k parts.  ",split-linked-list-in-parts,Split Linked List in Parts,Linked List,2
"Given a list of accounts where each element accounts[i] is a list of strings, where the first element accounts[i][0] is a name, and the rest of the elements are emails representing emails of the account. Now, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some common email to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name. After merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails in sorted order. The accounts themselves can be returned in any order.  ",accounts-merge,Accounts Merge,"Array, String, Depth-First Search, Breadth-First Search, Union Find",2
"Given a string s, return the string after replacing every uppercase letter with the same lowercase letter.  ",to-lower-case,To Lower Case,String,2
"You are given the root node of a binary search tree (BST) and a value to insert into the tree. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST. Notice that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them.  ",insert-into-a-binary-search-tree,Insert into a Binary Search Tree,"Tree, Binary Search Tree, Binary Tree",2
"You are given the root of a binary search tree (BST) and an integer val. Find the node in the BST that the node's value equals val and return the subtree rooted with that node. If such a node does not exist, return null.  ",search-in-a-binary-search-tree,Search in a Binary Search Tree,"Tree, Binary Search Tree, Binary Tree",2
"Given an integer array nums and an integer k, return true if it is possible to divide this array into k non-empty subsets whose sums are all equal.  ",partition-to-k-equal-sum-subsets,Partition to K Equal Sum Subsets,"Array, Dynamic Programming, Backtracking, Bit Manipulation, Memoization, Bitmask",2
"Given the root of a binary tree, return the length of the longest path, where each node in the path has the same value. This path may or may not pass through the root. The length of the path between two nodes is represented by the number of edges between them.  ",longest-univalue-path,Longest Univalue Path,"Tree, Depth-First Search, Binary Tree",2
"In this problem, a rooted tree is a directed graph such that, there is exactly one node (the root) for which all other nodes are descendants of this node, plus every node has exactly one parent, except for the root node which has no parents. The given input is a directed graph that started as a rooted tree with n nodes (with distinct values from 1 to n), with one additional directed edge added. The added edge has two different vertices chosen from 1 to n, and was not an edge that already existed. The resulting graph is given as a 2D-array of edges. Each element of edges is a pair [ui, vi] that represents a directed edge connecting nodes ui and vi, where ui is a parent of child vi. Return an edge that can be removed so that the resulting graph is a rooted tree of n nodes. If there are multiple answers, return the answer that occurs last in the given 2D-array.  ",redundant-connection-ii,Redundant Connection II,"Depth-First Search, Breadth-First Search, Union Find, Graph",2
"Given an integer array nums, return the number of longest increasing subsequences. Notice that the sequence has to be strictly increasing.  ",number-of-longest-increasing-subsequence,Number of Longest Increasing Subsequence,"Array, Dynamic Programming, Binary Indexed Tree, Segment Tree",2
"Given the root of a binary tree, construct a 0-indexed m x n string matrix res that represents a formatted layout of the tree. The formatted layout matrix should be constructed using the following rules:  The height of the tree is height and the number of rows m should be equal to height + 1. The number of columns n should be equal to 2height+1 - 1. Place the root node in the middle of the top row (more formally, at location res[0][(n-1)/2]). For each node that has been placed in the matrix at position res[r][c], place its left child at res[r+1][c-2height-r-1] and its right child at res[r+1][c+2height-r-1]. Continue this process until all the nodes in the tree have been placed. Any empty cells should contain the empty string """".  Return the constructed matrix res.  ",print-binary-tree,Print Binary Tree,"Tree, Depth-First Search, Breadth-First Search, Binary Tree",2
You are given an integer array nums with no duplicates. A maximum binary tree can be built recursively from nums using the following algorithm:  Create a root node whose value is the maximum value in nums. Recursively build the left subtree on the subarray prefix to the left of the maximum value. Recursively build the right subtree on the subarray suffix to the right of the maximum value.  Return the maximum binary tree built from nums.  ,maximum-binary-tree,Maximum Binary Tree,"Array, Divide and Conquer, Stack, Tree, Monotonic Stack, Binary Tree",2
"Given the root of a binary search tree and an integer k, return true if there exist two elements in the BST such that their sum is equal to k, or false otherwise.  ",two-sum-iv-input-is-a-bst,Two Sum IV - Input is a BST,"Hash Table, Two Pointers, Tree, Depth-First Search, Breadth-First Search, Binary Search Tree, Binary Tree",2
"You are given an array of n pairs pairs where pairs[i] = [lefti, righti] and lefti < righti. A pair p2 = [c, d] follows a pair p1 = [a, b] if b < c. A chain of pairs can be formed in this fashion. Return the length longest chain which can be formed. You do not need to use up all the given intervals. You can select pairs in any order.  ",maximum-length-of-pair-chain,Maximum Length of Pair Chain,"Array, Dynamic Programming, Greedy, Sorting",2
"In LeetCode Store, there are n items to sell. Each item has a price. However, there are some special offers, and a special offer consists of one or more different kinds of items with a sale price. You are given an integer array price where price[i] is the price of the ith item, and an integer array needs where needs[i] is the number of pieces of the ith item you want to buy. You are also given an array special where special[i] is of size n + 1 where special[i][j] is the number of pieces of the jth item in the ith offer and special[i][n] (i.e., the last integer in the array) is the price of the ith offer. Return the lowest price you have to pay for exactly certain items as given, where you could make optimal use of the special offers. You are not allowed to buy more items than you want, even if that would lower the overall price. You could use any of the special offers as many times as you want.  ",shopping-offers,Shopping Offers,"Array, Dynamic Programming, Backtracking, Bit Manipulation, Memoization, Bitmask",2
"Given a non-negative integer c, decide whether there're two integers a and b such that a2 + b2 = c.  ",sum-of-square-numbers,Sum of Square Numbers,"Math, Two Pointers, Binary Search",2
"Given an integer array nums, return the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle.  ",valid-triangle-number,Valid Triangle Number,"Array, Two Pointers, Binary Search, Greedy, Sorting",2
"You are given an m x n matrix M initialized with all 0's and an array of operations ops, where ops[i] = [ai, bi] means M[x][y] should be incremented by one for all 0 <= x < ai and 0 <= y < bi. Count and return the number of maximum integers in the matrix after performing all the operations.  ",range-addition-ii,Range Addition II,"Array, Math",2
"Given a string representing a code snippet, implement a tag validator to parse the code and return whether it is valid. A code snippet is valid if all the following rules hold:  The code must be wrapped in a valid closed tag. Otherwise, the code is invalid. A closed tag (not necessarily valid) has exactly the following format : <TAG_NAME>TAG_CONTENT</TAG_NAME>. Among them, <TAG_NAME> is the start tag, and </TAG_NAME> is the end tag. The TAG_NAME in start and end tags should be the same. A closed tag is valid if and only if the TAG_NAME and TAG_CONTENT are valid. A valid TAG_NAME only contain upper-case letters, and has length in range [1,9]. Otherwise, the TAG_NAME is invalid. A valid TAG_CONTENT may contain other valid closed tags, cdata and any characters (see note1) EXCEPT unmatched <, unmatched start and end tag, and unmatched or closed tags with invalid TAG_NAME. Otherwise, the TAG_CONTENT is invalid. A start tag is unmatched if no end tag exists with the same TAG_NAME, and vice versa. However, you also need to consider the issue of unbalanced when tags are nested. A < is unmatched if you cannot find a subsequent >. And when you find a < or </, all the subsequent characters until the next > should be parsed as TAG_NAME (not necessarily valid). The cdata has the following format : <![CDATA[CDATA_CONTENT]]>. The range of CDATA_CONTENT is defined as the characters between <![CDATA[ and the first subsequent ]]>. CDATA_CONTENT may contain any characters. The function of cdata is to forbid the validator to parse CDATA_CONTENT, so even it has some characters that can be parsed as tag (no matter valid or invalid), you should treat it as regular characters.   ",tag-validator,Tag Validator,"String, Stack",2
"Given the root of an n-ary tree, return the postorder traversal of its nodes' values. Nary-Tree input serialization is represented in their level order traversal. Each group of children is separated by the null value (See examples)  ",n-ary-tree-postorder-traversal,N-ary Tree Postorder Traversal,"Stack, Tree, Depth-First Search",2
"Given two strings word1 and word2, return the minimum number of steps required to make word1 and word2 the same. In one step, you can delete exactly one character in either string.  ",delete-operation-for-two-strings,Delete Operation for Two Strings,"String, Dynamic Programming",2
"Given a list of 24-hour clock time points in ""HH:MM"" format, return the minimum minutes difference between any two time-points in the list.  ",minimum-time-difference,Minimum Time Difference,"Array, Math, String, Sorting",2
"Given an array of integers nums and an integer k, return the number of unique k-diff pairs in the array. A k-diff pair is an integer pair (nums[i], nums[j]), where the following are true:  0 <= i, j < nums.length i != j nums[i] - nums[j] == k  Notice that |val| denotes the absolute value of val.  ",k-diff-pairs-in-an-array,K-diff Pairs in an Array,"Array, Hash Table, Two Pointers, Binary Search, Sorting",2
"Let's play the minesweeper game (Wikipedia, online game)! You are given an m x n char matrix board representing the game board where:  'M' represents an unrevealed mine, 'E' represents an unrevealed empty square, 'B' represents a revealed blank square that has no adjacent mines (i.e., above, below, left, right, and all 4 diagonals), digit ('1' to '8') represents how many mines are adjacent to this revealed square, and 'X' represents a revealed mine.  You are also given an integer array click where click = [clickr, clickc] represents the next click position among all the unrevealed squares ('M' or 'E'). Return the board after revealing this position according to the following rules:  If a mine 'M' is revealed, then the game is over. You should change it to 'X'. If an empty square 'E' with no adjacent mines is revealed, then change it to a revealed blank 'B' and all of its adjacent unrevealed squares should be revealed recursively. If an empty square 'E' with at least one adjacent mine is revealed, then change it to a digit ('1' to '8') representing the number of adjacent mines. Return the board when no more squares will be revealed.   ",minesweeper,Minesweeper,"Array, Depth-First Search, Breadth-First Search, Matrix",2
"We define the usage of capitals in a word to be right when one of the following cases holds:  All letters in this word are capitals, like ""USA"". All letters in this word are not capitals, like ""leetcode"". Only the first letter in this word is capital, like ""Google"".  Given a string word, return true if the usage of capitals in it is right.  ",detect-capital,Detect Capital,String,2
"The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Given an integer array nums, return the sum of Hamming distances between all the pairs of the integers in nums.  ",total-hamming-distance,Total Hamming Distance,"Array, Math, Bit Manipulation",2
"The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's to 0's in its binary representation.  For example, The integer 5 is ""101"" in binary and its complement is ""010"" which is the integer 2.  Given an integer num, return its complement.  ",number-complement,Number Complement,Bit Manipulation,2
"Winter is coming! During the contest, your first job is to design a standard heater with a fixed warm radius to warm all the houses. Every house can be warmed, as long as the house is within the heater's warm radius range.  Given the positions of houses and heaters on a horizontal line, return the minimum radius standard of heaters so that those heaters could cover all houses. Notice that all the heaters follow your radius standard, and the warm radius will the same.  ",heaters,Heaters,"Array, Two Pointers, Binary Search, Sorting",2
"Given a string queryIP, return ""IPv4"" if IP is a valid IPv4 address, ""IPv6"" if IP is a valid IPv6 address or ""Neither"" if IP is not a correct IP of any type. A valid IPv4 address is an IP in the form ""x1.x2.x3.x4"" where 0 <= xi <= 255 and xi cannot contain leading zeros. For example, ""192.168.1.1"" and ""192.168.1.0"" are valid IPv4 addresses while ""192.168.01.1"", ""192.168.1.00"", and ""192.168@1.1"" are invalid IPv4 addresses. A valid IPv6 address is an IP in the form ""x1:x2:x3:x4:x5:x6:x7:x8"" where:  1 <= xi.length <= 4 xi is a hexadecimal string which may contain digits, lowercase English letter ('a' to 'f') and upper-case English letters ('A' to 'F'). Leading zeros are allowed in xi.  For example, ""2001:0db8:85a3:0000:0000:8a2e:0370:7334"" and ""2001:db8:85a3:0:0:8A2E:0370:7334"" are valid IPv6 addresses, while ""2001:0db8:85a3::8A2E:037j:7334"" and ""02001:0db8:85a3:0000:0000:8a2e:0370:7334"" are invalid IPv6 addresses.  ",validate-ip-address,Validate IP Address,String,2
"You are given row x col grid representing a map where grid[i][j] = 1 represents land and grid[i][j] = 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn't have ""lakes"", meaning the water inside isn't connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island.  ",island-perimeter,Island Perimeter,"Array, Depth-First Search, Breadth-First Search, Matrix",2
"Given a string s, sort it in decreasing order based on the frequency of the characters. The frequency of a character is the number of times it appears in the string. Return the sorted string. If there are multiple answers, return any of them.  ",sort-characters-by-frequency,Sort Characters By Frequency,"Hash Table, String, Sorting, Heap (Priority Queue), Bucket Sort, Counting",2
"You are given an array of intervals, where intervals[i] = [starti, endi] and each starti is unique. The right interval for an interval i is an interval j such that startj >= endi and startj is minimized. Note that i may equal j. Return an array of right interval indices for each interval i. If no right interval exists for interval i, then put -1 at index i.  ",find-right-interval,Find Right Interval,"Array, Binary Search, Sorting",2
"You are given a doubly linked list, which contains nodes that have a next pointer, a previous pointer, and an additional child pointer. This child pointer may or may not point to a separate doubly linked list, also containing these special nodes. These child lists may have one or more children of their own, and so on, to produce a multilevel data structure as shown in the example below. Given the head of the first level of the list, flatten the list so that all the nodes appear in a single-level, doubly linked list. Let curr be a node with a child list. The nodes in the child list should appear after curr and before curr.next in the flattened list. Return the head of the flattened list. The nodes in the list must have all of their child pointers set to null.  ",flatten-a-multilevel-doubly-linked-list,Flatten a Multilevel Doubly Linked List,"Linked List, Depth-First Search, Doubly-Linked List",2
"Given an m x n matrix board where each cell is a battleship 'X' or empty '.', return the number of the battleships on board. Battleships can only be placed horizontally or vertically on board. In other words, they can only be made of the shape 1 x k (1 row, k columns) or k x 1 (k rows, 1 column), where k can be of any size. At least one horizontal or vertical cell separates between two battleships (i.e., there are no adjacent battleships).  ",battleships-in-a-board,Battleships in a Board,"Array, Depth-First Search, Matrix",2
"There is an m x n rectangular island that borders both the Pacific Ocean and Atlantic Ocean. The Pacific Ocean touches the island's left and top edges, and the Atlantic Ocean touches the island's right and bottom edges. The island is partitioned into a grid of square cells. You are given an m x n integer matrix heights where heights[r][c] represents the height above sea level of the cell at coordinate (r, c). The island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is less than or equal to the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean. Return a 2D list of grid coordinates result where result[i] = [ri, ci] denotes that rain water can flow from cell (ri, ci) to both the Pacific and Atlantic oceans.  ",pacific-atlantic-water-flow,Pacific Atlantic Water Flow,"Array, Depth-First Search, Breadth-First Search, Matrix",2
"Given an integer array nums, return the third distinct maximum number in this array. If the third maximum does not exist, return the maximum number.  ",third-maximum-number,Third Maximum Number,"Array, Sorting",2
"An integer array is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.  For example, [1,3,5,7,9], [7,7,7,7], and [3,-1,-5,-9] are arithmetic sequences.  Given an integer array nums, return the number of arithmetic subarrays of nums. A subarray is a contiguous subsequence of the array.  ",arithmetic-slices,Arithmetic Slices,"Array, Dynamic Programming",2
"Given a string s which consists of lowercase or uppercase letters, return the length of the longest palindrome that can be built with those letters. Letters are case sensitive, for example, ""Aa"" is not considered a palindrome here.  ",longest-palindrome,Longest Palindrome,"Hash Table, String, Greedy",2
"Given an integer num, return a string representing its hexadecimal representation. For negative integers, two’s complement method is used. All the letters in the answer string should be lowercase characters, and there should not be any leading zeros in the answer except for the zero itself. Note: You are not allowed to use any built-in library method to directly solve this problem.  ",convert-a-number-to-hexadecimal,Convert a Number to Hexadecimal,"Math, Bit Manipulation",2
"Given an integer array nums with possible duplicates, randomly output the index of a given target number. You can assume that the given target number must exist in the array. Implement the Solution class:  Solution(int[] nums) Initializes the object with the array nums. int pick(int target) Picks a random index i from nums where nums[i] == target. If there are multiple valid i's, then each index should have an equal probability of returning.   ",random-pick-index,Random Pick Index,"Hash Table, Math, Reservoir Sampling, Randomized",2
"Suppose we have a file system that stores both files and directories. An example of one system is represented in the following picture:  Here, we have dir as the only directory in the root. dir contains two subdirectories, subdir1 and subdir2. subdir1 contains a file file1.ext and subdirectory subsubdir1. subdir2 contains a subdirectory subsubdir2, which contains a file file2.ext. In text form, it looks like this (with ⟶ representing the tab character):  dir ⟶ subdir1 ⟶ ⟶ file1.ext ⟶ ⟶ subsubdir1 ⟶ subdir2 ⟶ ⟶ subsubdir2 ⟶ ⟶ ⟶ file2.ext  If we were to write this representation in code, it will look like this: ""dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext"". Note that the '\n' and '\t' are the new-line and tab characters. Every file and directory has a unique absolute path in the file system, which is the order of directories that must be opened to reach the file/directory itself, all concatenated by '/'s. Using the above example, the absolute path to file2.ext is ""dir/subdir2/subsubdir2/file2.ext"". Each directory name consists of letters, digits, and/or spaces. Each file name is of the form name.extension, where name and extension consist of letters, digits, and/or spaces. Given a string input representing the file system in the explained format, return the length of the longest absolute path to a file in the abstracted file system. If there is no file in the system, return 0. Note that the testcases are generated such that the file system is valid and no file or directory name has length 0.  ",longest-absolute-file-path,Longest Absolute File Path,"String, Stack, Depth-First Search",2
"Given a singly linked list, return a random node's value from the linked list. Each node must have the same probability of being chosen. Implement the Solution class:  Solution(ListNode head) Initializes the object with the head of the singly-linked list head. int getRandom() Chooses a node randomly from the list and returns its value. All the nodes of the list should be equally likely to be chosen.   ",linked-list-random-node,Linked List Random Node,"Linked List, Math, Reservoir Sampling, Randomized",2
"You are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k. Define a pair (u, v) which consists of one element from the first array and one element from the second array. Return the k pairs (u1, v1), (u2, v2), ..., (uk, vk) with the smallest sums.  ",find-k-pairs-with-smallest-sums,Find K Pairs with Smallest Sums,"Array, Heap (Priority Queue)",2
"Design a simplified version of Twitter where users can post tweets, follow/unfollow another user, and is able to see the 10 most recent tweets in the user's news feed. Implement the Twitter class:  Twitter() Initializes your twitter object. void postTweet(int userId, int tweetId) Composes a new tweet with ID tweetId by the user userId. Each call to this function will be made with a unique tweetId. List<Integer> getNewsFeed(int userId) Retrieves the 10 most recent tweet IDs in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user themself. Tweets must be ordered from most recent to least recent. void follow(int followerId, int followeeId) The user with ID followerId started following the user with ID followeeId. void unfollow(int followerId, int followeeId) The user with ID followerId started unfollowing the user with ID followeeId.   ",design-twitter,Design Twitter,"Hash Table, Linked List, Design, Heap (Priority Queue)",2
"You are given a nested list of integers nestedList. Each element is either an integer or a list whose elements may also be integers or other lists. Implement an iterator to flatten it. Implement the NestedIterator class:  NestedIterator(List<NestedInteger> nestedList) Initializes the iterator with the nested list nestedList. int next() Returns the next integer in the nested list. boolean hasNext() Returns true if there are still some integers in the nested list and false otherwise.  Your code will be tested with the following pseudocode:  initialize iterator with nestedList res = [] while iterator.hasNext()     append iterator.next() to the end of res return res  If res matches the expected flattened list, then your code will be judged as correct.  ",flatten-nested-list-iterator,Flatten Nested List Iterator,"Stack, Tree, Depth-First Search, Design, Queue, Iterator",2
"Given a sorted integer array nums and an integer n, add/patch elements to the array such that any number in the range [1, n] inclusive can be formed by the sum of some elements in the array. Return the minimum number of patches required.  ",patching-array,Patching Array,"Array, Greedy",2
"Given an integer n, return true if it is a power of three. Otherwise, return false. An integer n is a power of three, if there exists an integer x such that n == 3x.  ",power-of-three,Power of Three,"Math, Recursion",2
"Given a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.  ",remove-duplicate-letters,Remove Duplicate Letters,"String, Stack, Greedy, Monotonic Stack",2
"You are given n balloons, indexed from 0 to n - 1. Each balloon is painted with a number on it represented by an array nums. You are asked to burst all the balloons. If you burst the ith balloon, you will get nums[i - 1] * nums[i] * nums[i + 1] coins. If i - 1 or i + 1 goes out of bounds of the array, then treat it as if there is a balloon with a 1 painted on it. Return the maximum coins you can collect by bursting the balloons wisely.  ",burst-balloons,Burst Balloons,"Array, Dynamic Programming",2
"A tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree. Given a tree of n nodes labelled from 0 to n - 1, and an array of n - 1 edges where edges[i] = [ai, bi] indicates that there is an undirected edge between the two nodes ai and bi in the tree, you can choose any node of the tree as the root. When you select a node x as the root, the result tree has height h. Among all possible rooted trees, those with minimum height (i.e. min(h))  are called minimum height trees (MHTs). Return a list of all MHTs' root labels. You can return the answer in any order. The height of a rooted tree is the number of edges on the longest downward path between the root and a leaf.  ",minimum-height-trees,Minimum Height Trees,"Depth-First Search, Breadth-First Search, Graph, Topological Sort",2
"Given a string s that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid. Return a list of unique strings that are valid with the minimum number of removals. You may return the answer in any order.  ",remove-invalid-parentheses,Remove Invalid Parentheses,"String, Backtracking, Breadth-First Search",2
"Given an integer n, return the least number of perfect square numbers that sum to n. A perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not.  ",perfect-squares,Perfect Squares,"Math, Dynamic Programming, Breadth-First Search",2
"Given an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper, return the researcher's h-index. According to the definition of h-index on Wikipedia: The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times.  ",h-index,H-Index,"Array, Sorting, Counting Sort",2
"There is a singly-linked list head and we want to delete a node node in it. You are given the node to be deleted node. You will not be given access to the first node of head. All the values of the linked list are unique, and it is guaranteed that the given node node is not the last node in the linked list. Delete the given node. Note that by deleting the node, we do not mean removing it from memory. We mean:  The value of the given node should not exist in the linked list. The number of nodes in the linked list should decrease by one. All the values before node should be in the same order. All the values after node should be in the same order.  Custom testing:  For the input, you should provide the entire linked list head and the node to be given node. node should not be the last node of the list and should be an actual node in the list. We will build the linked list and pass the node to your function. The output will be the entire list after calling your function.   ",delete-node-in-a-linked-list,Delete Node in a Linked List,Linked List,2
"Given the coordinates of two rectilinear rectangles in a 2D plane, return the total area covered by the two rectangles. The first rectangle is defined by its bottom-left corner (ax1, ay1) and its top-right corner (ax2, ay2). The second rectangle is defined by its bottom-left corner (bx1, by1) and its top-right corner (bx2, by2).  ",rectangle-area,Rectangle Area,"Math, Geometry",2
"You are given an integer array nums and two integers indexDiff and valueDiff. Find a pair of indices (i, j) such that:  i != j, abs(i - j) <= indexDiff. abs(nums[i] - nums[j]) <= valueDiff, and  Return true if such pair exists or false otherwise.  ",contains-duplicate-iii,Contains Duplicate III,"Array, Sliding Window, Sorting, Bucket Sort, Ordered Set",2
"Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) <= k.  ",contains-duplicate-ii,Contains Duplicate II,"Array, Hash Table, Sliding Window",2
"The DNA sequence is composed of a series of nucleotides abbreviated as 'A', 'C', 'G', and 'T'.  For example, ""ACGAATTCCG"" is a DNA sequence.  When studying DNA, it is useful to identify repeated sequences within the DNA. Given a string s that represents a DNA sequence, return all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. You may return the answer in any order.  ",repeated-dna-sequences,Repeated DNA Sequences,"Hash Table, String, Bit Manipulation, Sliding Window, Rolling Hash, Hash Function",2
"Given a list of non-negative integers nums, arrange them such that they form the largest number and return it. Since the result may be very large, so you need to return a string instead of an integer.  ",largest-number,Largest Number,"Array, String, Greedy, Sorting",2
"The demons had captured the princess and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of m x n rooms laid out in a 2D grid. Our valiant knight was initially positioned in the top-left room and must fight his way through dungeon to rescue the princess. The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately. Some of the rooms are guarded by demons (represented by negative integers), so the knight loses health upon entering these rooms; other rooms are either empty (represented as 0) or contain magic orbs that increase the knight's health (represented by positive integers). To reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step. Return the knight's minimum initial health so that he can rescue the princess. Note that any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.  ",dungeon-game,Dungeon Game,"Array, Dynamic Programming, Matrix",2
"Given an integer columnNumber, return its corresponding column title as it appears in an Excel sheet. For example:  A -> 1 B -> 2 C -> 3 ... Z -> 26 AA -> 27 AB -> 28  ...   ",excel-sheet-column-title,Excel Sheet Column Title,"Math, String",2
"Given an integer array nums, return the maximum difference between two successive elements in its sorted form. If the array contains less than two elements, return 0. You must write an algorithm that runs in linear time and uses linear extra space.  ",maximum-gap,Maximum Gap,"Array, Sorting, Bucket Sort, Radix Sort",2
"Given an input string s, reverse the order of the words. A word is defined as a sequence of non-space characters. The words in s will be separated by at least one space. Return a string of the words in reverse order concatenated by a single space. Note that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.  ",reverse-words-in-a-string,Reverse Words in a String,"Two Pointers, String",2
"Given a string s, partition s such that every substring of the partition is a palindrome. Return the minimum cuts needed for a palindrome partitioning of s.  ",palindrome-partitioning-ii,Palindrome Partitioning II,"String, Dynamic Programming",2
"Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s.  ",palindrome-partitioning,Palindrome Partitioning,"String, Dynamic Programming, Backtracking",2
"Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum. A leaf is a node with no children.  ",path-sum,Path Sum,"Tree, Depth-First Search, Breadth-First Search, Binary Tree",2
"Given the root of a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from left to right, level by level from leaf to root).  ",binary-tree-level-order-traversal-ii,Binary Tree Level Order Traversal II,"Tree, Breadth-First Search, Binary Tree",2
"Given an integer array nums that may contain duplicates, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order.  ",subsets-ii,Subsets II,"Array, Backtracking, Bit Manipulation",2
"An n-bit gray code sequence is a sequence of 2n integers where:  Every integer is in the inclusive range [0, 2n - 1], The first integer is 0, An integer appears no more than once in the sequence, The binary representation of every pair of adjacent integers differs by exactly one bit, and The binary representation of the first and last integers differs by exactly one bit.  Given an integer n, return any valid n-bit gray code sequence.  ",gray-code,Gray Code,"Math, Backtracking, Bit Manipulation",2
"Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, n]. You may return the answer in any order.  ",combinations,Combinations,Backtracking,2
"Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order.  ",spiral-matrix-ii,Spiral Matrix II,"Array, Matrix, Simulation",2
"The count-and-say sequence is a sequence of digit strings defined by the recursive formula:  countAndSay(1) = ""1"" countAndSay(n) is the way you would ""say"" the digit string from countAndSay(n-1), which is then converted into a different digit string.  To determine how you ""say"" a digit string, split it into the minimal number of substrings such that each substring contains exactly one unique digit. Then for each substring, say the number of digits, then say the digit. Finally, concatenate every said digit. For example, the saying and conversion for digit string ""3322251"":  Given a positive integer n, return the nth term of the count-and-say sequence.  ",count-and-say,Count and Say,String,2
"You are given a 0-indexed integer array nums of length n. The average difference of the index i is the absolute difference between the average of the first i + 1 elements of nums and the average of the last n - i - 1 elements. Both averages should be rounded down to the nearest integer. Return the index with the minimum average difference. If there are multiple such indices, return the smallest one. Note:  The absolute difference of two numbers is the absolute value of their difference. The average of n elements is the sum of the n elements divided (integer division) by n. The average of 0 elements is considered to be 0.   ",minimum-average-difference,Minimum Average Difference,"Array, Prefix Sum",1
"You are given a 0-indexed integer array tasks, where tasks[i] represents the difficulty level of a task. In each round, you can complete either 2 or 3 tasks of the same difficulty level. Return the minimum rounds required to complete all the tasks, or -1 if it is not possible to complete all the tasks.  ",minimum-rounds-to-complete-all-tasks,Minimum Rounds to Complete All Tasks,"Array, Hash Table, Greedy, Counting",1
"You are given a 0-indexed integer array nums and an integer pivot. Rearrange nums such that the following conditions are satisfied:  Every element less than pivot appears before every element greater than pivot. Every element equal to pivot appears in between the elements less than and greater than pivot. The relative order of the elements less than pivot and the elements greater than pivot is maintained. 	 More formally, consider every pi, pj where pi is the new position of the ith element and pj is the new position of the jth element. For elements less than pivot, if i < j and nums[i] < pivot and nums[j] < pivot, then pi < pj. Similarly for elements greater than pivot, if i < j and nums[i] > pivot and nums[j] > pivot, then pi < pj.    Return nums after the rearrangement.  ",partition-array-according-to-given-pivot,Partition Array According to Given Pivot,"Array, Two Pointers, Simulation",1
"You are given a positive integer num consisting of exactly four digits. Split num into two new integers new1 and new2 by using the digits found in num. Leading zeros are allowed in new1 and new2, and all the digits found in num must be used.  For example, given num = 2932, you have the following digits: two 2's, one 9 and one 3. Some of the possible pairs [new1, new2] are [22, 93], [23, 92], [223, 9] and [2, 329].  Return the minimum possible sum of new1 and new2.  ",minimum-sum-of-four-digit-number-after-splitting-digits,Minimum Sum of Four Digit Number After Splitting Digits,"Math, Greedy, Sorting",1
"You are given a 0-indexed integer array nums of even length consisting of an equal number of positive and negative integers. You should rearrange the elements of nums such that the modified array follows the given conditions:  Every consecutive pair of integers have opposite signs. For all integers with the same sign, the order in which they were present in nums is preserved. The rearranged array begins with a positive integer.  Return the modified array after rearranging the elements to satisfy the aforementioned conditions.  ",rearrange-array-elements-by-sign,Rearrange Array Elements by Sign,"Array, Two Pointers, Simulation",1
"You are given a 0-indexed string s and a 0-indexed integer array spaces that describes the indices in the original string where spaces will be added. Each space should be inserted before the character at the given index.  For example, given s = ""EnjoyYourCoffee"" and spaces = [5, 9], we place spaces before 'Y' and 'C', which are at indices 5 and 9 respectively. Thus, we obtain ""Enjoy Your Coffee"".  Return the modified string after the spaces have been added.  ",adding-spaces-to-a-string,Adding Spaces to a String,"Array, String, Simulation",1
"A string originalText is encoded using a slanted transposition cipher to a string encodedText with the help of a matrix having a fixed number of rows rows. originalText is placed first in a top-left to bottom-right manner.  The blue cells are filled first, followed by the red cells, then the yellow cells, and so on, until we reach the end of originalText. The arrow indicates the order in which the cells are filled. All empty cells are filled with ' '. The number of columns is chosen such that the rightmost column will not be empty after filling in originalText. encodedText is then formed by appending all characters of the matrix in a row-wise fashion.  The characters in the blue cells are appended first to encodedText, then the red cells, and so on, and finally the yellow cells. The arrow indicates the order in which the cells are accessed. For example, if originalText = ""cipher"" and rows = 3, then we encode it in the following manner:  The blue arrows depict how originalText is placed in the matrix, and the red arrows denote the order in which encodedText is formed. In the above example, encodedText = ""ch ie pr"". Given the encoded string encodedText and number of rows rows, return the original string originalText. Note: originalText does not have any trailing spaces ' '. The test cases are generated such that there is only one possible originalText.  ",decode-the-slanted-ciphertext,Decode the Slanted Ciphertext,"String, Simulation",1
"A distinct string is a string that is present only once in an array. Given an array of strings arr, and an integer k, return the kth distinct string present in arr. If there are fewer than k distinct strings, return an empty string """". Note that the strings are considered in the order in which they appear in the array.  ",kth-distinct-string-in-an-array,Kth Distinct String in an Array,"Array, Hash Table, String, Counting",1
"You are given a 0-indexed integer array nums. For each index i (1 <= i <= nums.length - 2) the beauty of nums[i] equals:  2, if nums[j] < nums[i] < nums[k], for all 0 <= j < i and for all i < k <= nums.length - 1. 1, if nums[i - 1] < nums[i] < nums[i + 1], and the previous condition is not satisfied. 0, if none of the previous conditions holds.  Return the sum of beauty of all nums[i] where 1 <= i <= nums.length - 2.  ",sum-of-beauty-in-the-array,Sum of Beauty in the Array,Array,1
"Given an integer array nums and an integer k, return the number of pairs (i, j) where i < j such that |nums[i] - nums[j]| == k. The value of |x| is defined as:  x if x >= 0. -x if x < 0.   ",count-number-of-pairs-with-absolute-difference-k,Count Number of Pairs With Absolute Difference K,"Array, Hash Table, Counting",1
You are given an m x n integer matrix mat and an integer target. Choose one integer from each row in the matrix such that the absolute difference between target and the sum of the chosen elements is minimized. Return the minimum absolute difference. The absolute difference between two numbers a and b is the absolute value of a - b.  ,minimize-the-difference-between-target-and-chosen-elements,Minimize the Difference Between Target and Chosen Elements,"Array, Dynamic Programming, Matrix",1
"You are given a 2D integer array groups of length n. You are also given an integer array nums. You are asked if you can choose n disjoint subarrays from the array nums such that the ith subarray is equal to groups[i] (0-indexed), and if i > 0, the (i-1)th subarray appears before the ith subarray in nums (i.e. the subarrays must be in the same order as groups). Return true if you can do this task, and false otherwise. Note that the subarrays are disjoint if and only if there is no index k such that nums[k] belongs to more than one subarray. A subarray is a contiguous sequence of elements within an array.  ",form-array-by-concatenating-subarrays-of-another-array,Form Array by Concatenating Subarrays of Another Array,"Array, Greedy, String Matching",1
"We have n buildings numbered from 0 to n - 1. Each building has a number of employees. It's transfer season, and some employees want to change the building they reside in. You are given an array requests where requests[i] = [fromi, toi] represents an employee's request to transfer from building fromi to building toi. All buildings are full, so a list of requests is achievable only if for each building, the net change in employee transfers is zero. This means the number of employees leaving is equal to the number of employees moving in. For example if n = 3 and two employees are leaving building 0, one is leaving building 1, and one is leaving building 2, there should be two employees moving to building 0, one employee moving to building 1, and one employee moving to building 2. Return the maximum number of achievable requests.  ",maximum-number-of-achievable-transfer-requests,Maximum Number of Achievable Transfer Requests,"Array, Backtracking, Bit Manipulation, Enumeration",1
You are given an integer array nums. You have an integer array arr of the same length with all values set to 0 initially. You also have the following modify function:  You want to use the modify function to covert arr to nums using the minimum number of calls. Return the minimum number of function calls to make nums from arr. The test cases are generated so that the answer fits in a 32-bit signed integer.  ,minimum-numbers-of-function-calls-to-make-target-array,Minimum Numbers of Function Calls to Make Target Array,"Array, Greedy, Bit Manipulation",1
"A sequence of numbers is called an arithmetic progression if the difference between any two consecutive elements is the same. Given an array of numbers arr, return true if the array can be rearranged to form an arithmetic progression. Otherwise, return false.  ",can-make-arithmetic-progression-from-sequence,Can Make Arithmetic Progression From Sequence,"Array, Sorting",1
"Given a string s and an integer k, return the maximum number of vowel letters in any substring of s with length k. Vowel letters in English are 'a', 'e', 'i', 'o', and 'u'.  ",maximum-number-of-vowels-in-a-substring-of-given-length,Maximum Number of Vowels in a Substring of Given Length,"String, Sliding Window",1
"Given the array queries of positive integers between 1 and m, you have to process all queries[i] (from i=0 to i=queries.length-1) according to the following rules:  In the beginning, you have the permutation P=[1,2,3,...,m]. For the current i, find the position of queries[i] in the permutation P (indexing from 0) and then move this at the beginning of the permutation P. Notice that the position of queries[i] in P is the result for queries[i].  Return an array containing the result for the given queries.  ",queries-on-a-permutation-with-key,Queries on a Permutation With Key,"Array, Binary Indexed Tree, Simulation",1
"Given an integer num, find the closest two integers in absolute difference whose product equals num + 1 or num + 2. Return the two integers in any order.  ",closest-divisors,Closest Divisors,Math,1
"You are given an m x n binary matrix mat of 1's (representing soldiers) and 0's (representing civilians). The soldiers are positioned in front of the civilians. That is, all the 1's will appear to the left of all the 0's in each row. A row i is weaker than a row j if one of the following is true:  The number of soldiers in row i is less than the number of soldiers in row j. Both rows have the same number of soldiers and i < j.  Return the indices of the k weakest rows in the matrix ordered from weakest to strongest.  ",the-k-weakest-rows-in-a-matrix,The K Weakest Rows in a Matrix,"Array, Binary Search, Sorting, Heap (Priority Queue), Matrix",1
"Given a list of dominoes, dominoes[i] = [a, b] is equivalent to dominoes[j] = [c, d] if and only if either (a == c and b == d), or (a == d and b == c) - that is, one domino can be rotated to be equal to another domino. Return the number of pairs (i, j) for which 0 <= i < j < dominoes.length, and dominoes[i] is equivalent to dominoes[j].  ",number-of-equivalent-domino-pairs,Number of Equivalent Domino Pairs,"Array, Hash Table, Counting",1
"Given two integers left and right, return the count of numbers in the inclusive range [left, right] having a prime number of set bits in their binary representation. Recall that the number of set bits an integer has is the number of 1's present when written in binary.  For example, 21 written in binary is 10101, which has 3 set bits.   ",prime-number-of-set-bits-in-binary-representation,Prime Number of Set Bits in Binary Representation,"Math, Bit Manipulation",1
"An integer has monotone increasing digits if and only if each pair of adjacent digits x and y satisfy x <= y. Given an integer n, return the largest number that is less than or equal to n with monotone increasing digits.  ",monotone-increasing-digits,Monotone Increasing Digits,"Math, Greedy",1
"You are given an integer array nums. The adjacent integers in nums will perform the float division.  For example, for nums = [2,3,4], we will evaluate the expression ""2/3/4"".  However, you can add any number of parenthesis at any position to change the priority of operations. You want to add these parentheses such the value of the expression after the evaluation is maximum. Return the corresponding expression that has the maximum value in string format. Note: your expression should not contain redundant parenthesis.  ",optimal-division,Optimal Division,"Array, Math, Dynamic Programming",1
"A complex number can be represented as a string on the form ""real+imaginaryi"" where:  real is the real part and is an integer in the range [-100, 100]. imaginary is the imaginary part and is an integer in the range [-100, 100]. i2 == -1.  Given two complex numbers num1 and num2 as strings, return a string of the complex number that represents their multiplications.  ",complex-number-multiplication,Complex Number Multiplication,"Math, String, Simulation",1
"You are given an integer array nums of length n. Assume arrk to be an array obtained by rotating nums by k positions clock-wise. We define the rotation function F on nums as follow:  F(k) = 0 * arrk[0] + 1 * arrk[1] + ... + (n - 1) * arrk[n - 1].  Return the maximum value of F(0), F(1), ..., F(n-1). The test cases are generated so that the answer fits in a 32-bit integer.  ",rotate-function,Rotate Function,"Array, Math, Dynamic Programming",1

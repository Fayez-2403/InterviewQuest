 This page intentionally left blank COMPUTER NETWORKS FIFTH EDITION This page intentionally left blank COMPUTER NETWORKS FIFTH EDITION ANDREW S\n TANENBAUM Vrije Universiteit Amsterdam  The Netherlands DAVID J\n WETHERALL University of Washington Seattle  WA PRENTICE HALL Boston Columbus Indianapolis New York San Francisco Upper Saddle River Amsterdam Cape Town Dubai London Madrid Milan Paris Montreal Toronto Delhi Mexico City Sao Paulo Sydney Hong Kong Seoul Singapore Tapei Tokyo Editorial Director: Marcia Horton Editor-in-Chief: Michael Hirsch Executive Editor: Tracy Dunkelberger Assistant Editor: Melinda Haggerty Editorial Assistant: Allison Michael Vice President  Marketing: Patrice Jones Marketing Manager: Yezan Alayan Marketing Coordinator: Kathryn Ferranti Vice President  Production: Vince O’Brien Managing Editor: Jeff Holcomb Senior Operations Supervisor: Alan Fischer Manufacturing Buyer: Lisa McDowell Cover Direction: Andrew S\n Tanenbaum  David J\n Wetherall  Tracy Dunkelberger Art Director: Linda Knowles Cover Designer: Susan Paradise Cover Illustration: Jason Consalvo Interior Design: Andrew S\n Tanenbaum AV Production Project Manager: Gregory L\n Dulles Interior Illustrations: Laserwords  Inc\n Media Editor: Daniel Sandin Composition: Andrew S\n Tanenbaum Copyeditor: Rachel Head Proofreader: Joe Ruddick Printer/Binder: Courier/Westford Cover Printer: Lehigh-Phoenix Color/ Hagerstown Credits and acknowledgments borrowed from other sources and reproduced  with permission  in this textbook appear on appropriate page within text\n Many of the designations by manufacturers and sellers to distinguish their products are claimed as trademarks\n Where those designations appear in this book  and the publisher was aware of a trademark claim  the designations have been printed in initial caps or all caps\n Copyright ©    Pearson Education  Inc\n  publishing as Prentice Hall\n All rights reserved\n Manufactured in the United States of America\n This publication is protected by Copyright  and permission should be obtained from the publisher prior to any prohibited reproduction  storage in a retrieval system  or transmission in any form or by any means  electronic  mechanical  photocopying  recording  or likewise\n To obtain permission(s) to use material from this work  please submit a written request to Pearson Education  Inc\n  Permissions Department  Boylston Street  Suite  Boston  Massachusetts  \n Library of Congress Cataloging-in-Publication Data Tanenbaum  Andrew S\n  - Computer networks / Andrew S\n Tanenbaum  David J\n Wetherall\n --  th ed\n p\n cm\n Includes bibliographical references and index\n ISBN-  :   - -  -  -  (alk\n paper) ISBN-  :  -  -  -  (alk\n paper)  \n Computer networks\n I\n Wetherall  D\n (David) II\n Title\n TK   T  \n --dc       —CRW—  To Suzanne  Barbara  Daniel  Aron  Marvin  Matilde  and the memory of Bram  and Sweetie π (AST) To Katrin  Lucy  and Pepper (DJW) This page intentionally left blank CONTENTS PREFACE xix  INTRODUCTION   \n  USES OF COMPUTER NETWORKS   Business Applications   Home Applications   Mobile Users    Social Issues  \n  NETWORK HARDWARE    Personal Area Networks    Local Area Networks    Metropolitan Area Networks    Wide Area Networks    Internetworks  \n  NETWORK SOFTWARE    Protocol Hierarchies    Design Issues for the Layers    Connection-Oriented Versus Connectionless Service    Service Primitives    The Relationship of Services to Protocols  \n  REFERENCE MODELS    The OSI Reference Model    The TCP/IP Reference Model    The Model Used in This Book vii viii CONTENTS    A Comparison of the OSI and TCP/IP Reference Models*    A Critique of the OSI Model and Protocols*    A Critique of the TCP/IP Reference Model*  \n  EXAMPLE NETWORKS    The Internet    Third-Generation Mobile Phone Networks*    Wireless LANs:   \n  *    RFID and Sensor Networks*  \n  NETWORK STANDARDIZATION*    Who’s Who in the Telecommunications World    Who’s Who in the International Standards World    Who’s Who in the Internet Standards World  \n  METRIC UNITS  \n  OUTLINE OF THE REST OF THE BOOK  \n  SUMMARY  THE PHYSICAL LAYER \n  THE THEORETICAL BASIS FOR DATA COMMUNICATION    Fourier Analysis    Bandwidth-Limited Signals    The Maximum Data Rate of a Channel  \n  GUIDED TRANSMISSION MEDIA    Magnetic Media    Twisted Pairs    Coaxial Cable    Power Lines    Fiber Optics  \n  WIRELESS TRANSMISSION    The Electromagnetic Spectrum    Radio Transmission    Microwave Transmission    Infrared Transmission    Light Transmission  CONTENTS ix  \n  COMMUNICATION SATELLITES*    Geostationary Satellites    Medium-Earth Orbit Satellites    Low-Earth Orbit Satellites    Satellites Versus Fiber  \n  DIGITAL MODULATION AND MULTIPLEXING    Baseband Transmission    Passband Transmission    Frequency Division Multiplexing    Time Division Multiplexing    Code Division Multiplexing  \n  THE PUBLIC SWITCHED TELEPHONE NETWORK    Structure of the Telephone System    The Politics of Telephones    The Local Loop: Modems  ADSL  and Fiber    Trunks and Multiplexing    Switching  \n  THE MOBILE TELEPHONE SYSTEM*    First-Generation (coco G) Mobile Phones: Analog Voice    ond-Generation ( G) Mobile Phones: Digital Voice    Third-Generation ( G) Mobile Phones: Digital Voice and Data  \n  CABLE TELEVISION*    Community Antenna Television    Internet over Cable    Spectrum Allocation    Cable Modems    ADSL Versus Cable  \n  SUMMARY   THE DATA LINK LAYER  \n  DATA LINK LAYER DESIGN ISSUES    Services Provided to the Network Layer    Framing    Error Control    Flow Control  x CONTENTS  \n  ERROR DETECTION AND CORRECTION    Error-Correcting Codes    Error-Detecting Codes  \n  ELEMENTARY DATA LINK PROTOCOLS    A Utopian Simplex Protocol    A Simplex Stop-and-Wait Protocol for an Error-Free Channel    A Simplex Stop-and-Wait Protocol for a Noisy Channel  \n  SLIDING WINDOW PROTOCOLS    A One-Bit Sliding Window Protocol    A Protocol Using Go-Back-N    A Protocol Using Selective Repeat  \n  EXAMPLE DATA LINK PROTOCOLS    Packet over SONET    ADSL (Asymmetric Digital Subscriber Loop)  \n  SUMMARY   THE MEDIUM ACCESS CONTROL SUBLAYER  \n  THE CHANNEL ALLOCATION PROBLEM    Static Channel Allocation    Assumptions for Dynamic Channel Allocation  \n  MULTIPLE ACCESS PROTOCOLS    ALOHA    Carrier Sense Multiple Access Protocols    Collision-Free Protocols    Limited-Contention Protocols    Wireless LAN Protocols  \n  ETHERNET    Classic Ethernet Physical Layer    Classic Ethernet MAC Sublayer Protocol    Ethernet Performance    Switched Ethernet  CONTENTS xi    Fast Ethernet    Gigabit Ethernet     -Gigabit Ethernet    Retrospective on Ethernet  \n  WIRELESS LANS    The   \n  Architecture and Protocol Stack    The   \n  Physical Layer    The   \n  MAC Sublayer Protocol    The   \n  Frame Structure    Services  \n  BROADBAND WIRELESS*    Comparison of   \n  with   \n  and  G    The   \n  Architecture and Protocol Stack    The   \n  Physical Layer    The   \n  MAC Sublayer Protocol    The   \n  Frame Structure  \n  BLUETOOTH*    Bluetooth Architecture    Bluetooth Applications    The Bluetooth Protocol Stack    The Bluetooth Radio Layer    The Bluetooth Link Layers    The Bluetooth Frame Structure  \n  RFID*    EPC Gen  Architecture    EPC Gen  Physical Layer    EPC Gen  Tag Identification Layer    Tag Identification Message Formats  \n  DATA LINK LAYER SWITCHING    Uses of Bridges    Learning Bridges    Spanning Tree Bridges    Repeaters  Hubs  Bridges  Switches  Routers  and Gateways    Virtual LANs  \n  SUMMARY  xii CONTENTS  THE NETWORK LAYER  \n  NETWORK LAYER DESIGN ISSUES    Store-and-Forward Packet Switching    Services Provided to the Transport Layer    Implementation of Connectionless Service    Implementation of Connection-Oriented Service    Comparison of Virtual-Circuit and Datagram Networks  \n  ROUTING ALGORITHMS    The Optimality Principle    Shortest Path Algorithm    Flooding    Distance Vector Routing    Link State Routing    Hierarchical Routing    Broadcast Routing    Multicast Routing    Anycast Routing    Routing for Mobile Hosts    Routing in Ad Hoc Networks  \n  CONGESTION CONTROL ALGORITHMS    Approaches to Congestion Control    Traffic-Aware Routing    Admission Control    Traffic Throttling    Load Shedding  \n  QUALITY OF SERVICE    Application Requirements    Traffic Shaping    Packet Scheduling    Admission Control    Integrated Services    Differentiated Services  \n  INTERNETWORKING    How Networks Differ    How Networks Can Be Connected    Tunneling  CONTENTS xiii    Internetwork Routing    Packet Fragmentation  \n  THE NETWORK LAYER IN THE INTERNET    The IP Version  Protocol    IP Addresses    IP Version      Internet Control Protocols    Label Switching and MPLS    OSPF—An Interior Gateway Routing Protocol    BGP—The Exterior Gateway Routing Protocol    Internet Multicasting    Mobile IP  \n  SUMMARY   THE TRANSPORT LAYER  \n  THE TRANSPORT SERVICE    Services Provided to the Upper Layers    Transport Service Primitives    Berkeley Sockets    An Example of Socket Programming: An Internet File Server  \n  ELEMENTS OF TRANSPORT PROTOCOLS    Addressing    Connection Establishment    Connection Release    Error Control and Flow Control    Multiplexing    Crash Recovery  \n  CONGESTION CONTROL    Desirable Bandwidth Allocation    Regulating the Sending Rate    Wireless Issues  \n  THE INTERNET TRANSPORT PROTOCOLS: UDP    Introduction to UDP    Remote Procedure Call    Real-Time Transport Protocols  xiv CONTENTS  \n  THE INTERNET TRANSPORT PROTOCOLS: TCP    Introduction to TCP    The TCP Service Model    The TCP Protocol    The TCP Segment Header    TCP Connection Establishment    TCP Connection Release    TCP Connection Management Modeling    TCP Sliding Window    TCP Timer Management    TCP Congestion Control    The Future of TCP  \n  PERFORMANCE ISSUES*    Performance Problems in Computer Networks    Network Performance Measurement    Host Design for Fast Networks    Fast Segment Processing    Header Compression    Protocols for Long Fat Networks  \n  DELAY-TOLERANT NETWORKING*    DTN Architecture    The Bundle Protocol  \n  SUMMARY   THE APPLICATION LAYER  \n  DNS—THE DOMAIN NAME SYSTEM    The DNS Name Space    Domain Resource Records    Name Servers  \n  ELECTRONIC MAIL*    Architecture and Services    The User Agent    Message Formats    Message Transfer    Final Delivery  CONTENTS xv  \n  THE WORLD WIDE WEB    Architectural Overview    Static Web Pages    Dynamic Web Pages and Web Applications    HTTP—The HyperText Transfer Protocol    The Mobile Web    Web Search  \n  STREAMING AUDIO AND VIDEO    Digital Audio    Digital Video    Streaming Stored Media    Streaming Live Media    Real-Time Conferencing  \n  CONTENT DELIVERY    Content and Internet Traffic    Server Farms and Web Proxies    Content Delivery Networks    Peer-to-Peer Networks  \n  SUMMARY   NETWORK URITY  \n  CRYPTOGRAPHY    Introduction to Cryptography    Substitution Ciphers    Transposition Ciphers    One-Time Pads    Two Fundamental Cryptographic Principles  \n  SYMMETRIC-KEY ALGORITHMS    DES—The Data Encryption Standard    AES—The Advanced Encryption Standard    Cipher Modes    Other Ciphers    Cryptanalysis  xvi CONTENTS  \n  PUBLIC-KEY ALGORITHMS    RSA    Other Public-Key Algorithms  \n  DIGITAL SIGNATURES    Symmetric-Key Signatures    Public-Key Signatures    Message Digests    The Birthday Attack  \n  MANAGEMENT OF PUBLIC KEYS    Certificates    X\n    Public Key Infrastructures  \n  COMMUNICATION URITY    IP    Firewalls    Virtual Private Networks    Wireless urity  \n  AUTHENTICATION PROTOCOLS    Authentication Based on a Shared ret Key    Establishing a Shared Key: The Diffie-Hellman Key Exchange    Authentication Using a Key Distribution Center    Authentication Using Kerberos    Authentication Using Public-Key Cryptography  \n  EMAIL URITY*    PGP—Pretty Good Privacy    S/MIME  \n  WEB URITY    Threats    ure Naming    SSL—The ure Sockets Layer    Mobile Code urity  \n  SOCIAL ISSUES    Privacy    Freedom of Speech    Copyright  \n  SUMMARY  CONTENTS xvii  READING LIST AND BIBLIOGRAPHY  \n  SUGGESTIONS FOR FURTHER READING*    Introduction and General Works    The Physical Layer    The Data Link Layer    The Medium Access Control Sublayer    The Network Layer    The Transport Layer    The Application Layer    Network urity  \n  ALPHABETICAL BIBLIOGRAPHY*  INDEX This page intentionally left blank PREFACE This book is now in its fifth edition\n Each edition has corresponded to a different phase in the way computer networks were used\n When the first edition appeared in  networks were an academic curiosity\n When the ond edition appeared in  networks were used by universities and large businesses\n When the third edition appeared in  computer networks  especially the Internet  had become a daily reality for millions of people\n By the fourth edition  in  wireless networks and mobile computers had become commonplace for accessing the Web and the Internet\n Now  in the fifth edition  networks are about content distribution (especially videos using CDNs and peer-to-peer networks) and mobile phones are small computers on the Internet\n New in the Fifth Edition Among the many changes in this book  the most important one is the addition of Prof\n David J\n Wetherall as a co-author\n David brings a rich background in networking  having cut his teeth designing metropolitan-area networks more than   years ago\n He has worked with the Internet and wireless networks ever since and is a professor at the University of Washington  where he has been teaching and doing research on computer networks and related topics for the past decade\n Of course  the book also has many changes to keep up with the: ever-changing world of computer networks\n Among these are revised and new material on Wireless networks (  \n  and   \n  ) The  G networks used by smart phones RFID and sensor networks Content distribution using CDNs Peer-to-peer networks Real-time media (from stored  streaming  and live sources) Internet telephony (voice over IP) Delay-tolerant networks A more detailed  ter-by-  ter list follows\n xix xx PREFACE  ter  has the same introductory function as in the fourth edition  but the contents have been revised and brought up to date\n The Internet  mobile phone networks \n   and RFID and sensor networks are discussed as examples of computer networks\n Material on the original Ethernet—with its vampire taps— has been removed  along with the material on ATM\n  ter   which covers the physical layer  has expanded coverage of digital modulation (including OFDM as widely used in wireless networks) and  G networks (based on CDMA)\n New technologies are discussed  including Fiber to the Home and power-line networking\n  ter   on point-to-point links  has been improved in two ways\n The material on codes for error detection and correction has been updated  and also includes a brief description of the modern codes that are important in practice ( \n  convolutional and LDPC codes)\n The examples of protocols now use Packet over SONET and ADSL\n Sadly  the material on protocol verification has been removed as it is little used\n In  ter   on the MAC sublayer  the principles are timeless but the technologies have changed\n tions on the example networks have been redone accordingly  including gigabit Ethernet    Bluetooth  and RFID\n Also updated is the coverage of LAN switching  including VLANs\n  ter   on the network layer  covers the same ground as in the fourth edition\n The revisions have been to update material and add depth  particularly for quality of service (relevant for real-time media) and internetworking\n The tions on BGP  OSPF and CIDR have been expanded  as has the treatment of multicast routing\n Anycast routing is now included\n  ter   on the transport layer  has had material added  revised  and removed\n New material describes delay-tolerant networking and congestion control in general\n The revised material updates and expands the coverage of TCP congestion control\n The material removed described connection-oriented network layers  something rarely seen any more\n  ter   on applications  has also been updated and enlarged\n While material on DNS and email is similar to that in the fourth edition  in the past few years there have been many developments in the use of the Web  streaming media and content delivery\n Accordingly  tions on the Web and streaming media have been brought up to date\n A new tion covers content distribution  including CDNs and peer-to-peer networks\n  ter   on urity  still covers both symmetric and public-key cryptography for confidentiality and authenticity\n Material on the techniques used in practice  including firewalls and VPNs  has been updated  with new material on   \n  urity and Kerberos V  added\n  ter  contains a renewed list of suggested readings and a comprehensive bibliography of over citations to the current literature\n More than half of these are to papers and books written in  or later  and the rest are citations to classic papers\n PREFACE xxi List of Acronyms Computer books are full of acronyms\n This one is no exception\n By the time you are finished reading this one  the following should ring a bell: ADSL  AES  AJAX  AODV  AP  ARP  ARQ  AS  BGP  BOC  CDMA  CDN  CGI  CIDR  CRL  CSMA  CSS  DCT  DES  DHCP  DHT  DIFS  DMCA  DMT  DMZ  DNS  DOCSIS  DOM  DSLAM  DTN  FCFS  FDD  FDDI  FDM  FEC  FIFO  FSK  FTP  GPRS  GSM  HDTV  HFC  HMAC  HTTP  IAB  ICANN  ICMP  IDEA  IETF  IMAP  IMP  IP  IPTV  IRTF  ISO  ISP  ITU  JPEG  JSP  JVM  LAN  LATA  LEC  LEO  LLC  LSR  LTE  MAN  MFJ  MIME  MPEG  MPLS  MSC  MTSO  MTU  NAP  NAT  NRZ  NSAP  OFDM  OSI  OSPF  PAWS  PCM  PGP  PIM  PKI  POP  POTS  PPP  PSTN  QAM  QPSK  RED  RFC  RFID  RPC  RSA  RTSP  SHA  SIP  SMTP  SNR  SOAP  SONET  SPE  SSL  TCP  TDD  TDM  TSAP  UDP  UMTS  URL  VLAN  VSAT  WAN  WDM  and XML\n But don’t worry\n Each will appear in boldface type and be carefully defined before it is used\n As a fun test  see how many you can identify before reading the book  write the number in the margin  then try again after reading the book\n How to Use the Book To help instructors use this book as a text for courses ranging in length from quarters to semesters  we have structured the  ters into core and optional material\n The tions marked with a ‘‘*’’ in the table of contents are the optional ones\n If a major tion (  ) is so marked  all of its subtions are optional\n They provide material on network technologies that is useful but can be omitted from a short course without loss of continuity\n Of course  students should be encouraged to read those tions as well  to the extent they have time  as all the material is up to date and of value\n Instructors’ Resource Materials The following protected instructors’ resource materials are available on the publisher’s Web site at  /tanenbaum\n For a username and password  please contact your local Pearson representative\n Solutions manual PowerPoint lecture slides Students’ Resource Materials Resources for students are available through the open-access Companion Web site link on  /tanenbaum  including Web resources  links to tutorials  organizations  FAQs  and more Figures  tables  and programs from the book Steganography demo Protocol simulators xxii PREFACE Acknowledgements Many people helped us during the course of the fifth edition\n We would especially like to thank Emmanuel Agu (Worcester Polytechnic Institute)  Yoris Au (University of Texas at Antonio)  Nikhil Bhargava (Aircom International  Inc\n)  Michael Buettner (University of Washington)  John Day (Boston University)  Kevin Fall (Intel Labs)  Ronald Fulle (Rochester Institute of Technology)  Ben Greenstein (Intel Labs)  Daniel Halperin (University of Washington)  Bob Kinicki (Worcester Polytechnic Institute)  Tadayoshi Kohno (University of Washington)  Sarvish Kulkarni (Villanova University)  Hank Levy (University of Washington)  Ratul Mahajan (Microsoft Research)  Craig Partridge (BBN)  Michael Piatek (University of Washington)  Joshua Smith (Intel Labs)  Neil Spring (University of Maryland)  David Teneyuca (University of Texas at Antonio)  Tammy VanDegrift (University of Portland)  and Bo Yuan (Rochester Institute of Technology)  for providing ideas and feedback\n Melody Kadenko and Julie Svendsen provided administrative support to David\n Shivakant Mishra (University of Colorado at Boulder) and Paul Nagin (Chimborazo Publishing  Inc\n) thought of many new and challenging end-of-  ter problems\n Our editor at Pearson  Tracy Dunkelberger  was her usual helpful self in many ways large and small\n Melinda Haggerty and Jeff Holcomb did a good job of keeping things running smoothly\n Steve Armstrong (LeTourneau University) prepared the PowerPoint slides\n Stephen Turner (University of Michigan at Flint) artfully revised the Web resources and the simulators that accompany the text\n Our copyeditor  Rachel Head  is an odd hybrid: she has the eye of an eagle and the memory of an elephant\n After reading all her corrections  both of us wondered how we ever made it past third grade\n Finally  we come to the most important people\n Suzanne has been through this   times now and still has endless patience and love\n Barbara and Marvin now know the difference between good textbooks and bad ones and are always an inspiration to produce good ones\n Daniel and Matilde are welcome additions to our family\n Aron is unlikely to read this book soon  but he likes the nice pictures on page (AST)\n Katrin and Lucy provided endless support and always managed to keep a smile on my face\n Thank you (DJW)\n ANDREW S\n TANENBAUM DAVID    INTRODUCTION Each of the past three centuries was dominated by a single new technology\n The  th century was the era of the great mechanical systems accompanying the Industrial Revolution\n The  th century was the age of the steam engine\n During the  th century  the key technology was information gathering  processing  and distribution\n Among other developments  we saw the installation of worldwide telephone networks  the invention of radio and television  the birth and unprecedented growth of the computer industry  the launching of communication satellites  and  of course  the Internet\n As a result of rapid technological progress  these areas are rapidly converging in the  st century and the differences between collecting  transporting  storing  and processing information are quickly disappearing\n Organizations with hundreds of offices spread over a wide geographical area routinely expect to be able to examine the current status of even their most remote outpost at the push of a button\n As our ability to gather  process  and distribute information grows  the demand for ever more sophisticated information processing grows even faster\n Although the computer industry is still young compared to other industries ( \n  automobiles and air transportation)  computers have made spectacular progress in a short time\n During the first two decades of their existence  computer systems were highly centralized  usually within a single large room\n Not infrequently  this room had glass walls  through which visitors could gawk at the great electronic wonder inside\n A medium-sized company or university might have had INTRODUCTION  \n  one or two computers  while very large institutions had at most a few dozen\n The idea that within forty years vastly more powerful computers smaller than postage stamps would be mass produced by the billions was pure science fiction\n The merging of computers and communications has had a profound influence on the way computer systems are organized\n The once-dominant concept of the ‘‘computer center’’ as a room with a large computer to which users bring their work for processing is now totally obsolete (although data centers holding thousands of Internet servers are becoming common)\n The old model of a single computer serving all of the organization’s computational needs has been replaced by one in which a large number of separate but interconnected computers do the job\n These systems are called computer networks\n The design and organization of these networks are the subjects of this book\n Throughout the book we will use the term ‘‘computer network’’ to mean a collection of autonomous computers interconnected by a single technology\n Two computers are said to be interconnected if they are able to exchange information\n The connection need not be via a copper wire; fiber optics  microwaves  infrared  and communication satellites can also be used\n Networks come in many sizes  shapes and forms  as we will see later\n They are usually connected together to make larger networks  with the Internet being the most well-known example of a network of networks\n There is considerable confusion in the literature between a computer network and a distributed system\n The key distinction is that in a distributed system  a collection of independent computers appears to its users as a single coherent system\n Usually  it has a single model or paradigm that it presents to the users\n Often a layer of software on top of the operating system  called middleware  is responsible for implementing this model\n A well-known example of a distributed system is the World Wide Web\n It runs on top of the Internet and presents a model in which everything looks like a document (Web page)\n In a computer network  this coherence  model  and software are absent\n Users are exposed to the actual machines  without any attempt by the system to make the machines look and act in a coherent way\n If the machines have different hardware and different operating systems  that is fully visible to the users\n If a user wants to run a program on a remote machine  he† has to log onto that machine and run it there\n In effect  a distributed system is a software system built on top of a network\n The software gives it a high degree of cohesiveness and transparency\n Thus  the distinction between a network and a distributed system lies with the software (especially the operating system)  rather than with the hardware\n Nevertheless  there is considerable overlap between the two subjects\n For example  both distributed systems and computer networks need to move files around\n The difference lies in who invokes the movement  the system or the user\n † ‘‘He’’ should be read as ‘‘he or she’’ throughout this book\n   USES OF COMPUTER NETWORKS  Although this book primarily focuses on networks  many of the topics are also important in distributed systems\n For more information about distributed systems  see Tanenbaum and Van Steen (   )  USES OF COMPUTER NETWORKS Before we start to examine the technical issues in detail  it is worth devoting some time to pointing out why people are interested in computer networks and what they can be used for\n After all  if nobody were interested in computer networks  few of them would be built\n We will start with traditional uses at companies  then move on to home networking and recent developments regarding mobile users  and finish with social issues\n    Business Applications Most companies have a substantial number of computers\n For example  a company may have a computer for each worker and use them to design products  write brochures  and do the payroll\n Initially  some of these computers may have worked in isolation from the others  but at some point  management may have decided to connect them to be able to distribute information throughout the company\n Put in slightly more general form  the issue here is resource sharing\n The goal is to make all programs  equipment  and especially data available to anyone on the network without regard to the physical location of the resource or the user\n An obvious and widespread example is having a group of office workers share a common printer\n None of the individuals really needs a private printer  and a high-volume networked printer is often cheaper  faster  and easier to maintain than a large collection of individual printers\n However  probably even more important than sharing physical resources such as printers  and tape backup systems  is sharing information\n Companies small and large are vitally dependent on computerized information\n Most companies have customer records  product information  inventories  financial statements  tax information  and much more online\n If all of its computers suddenly went down  a bank could not last more than five minutes\n A modern manufacturing plant  with a computer-controlled assembly line  would not last even  onds\n Even a small travel agency or three-person law firm is now highly dependent on computer networks for allowing employees to access relevant information and documents instantly\n For smaller companies  all the computers are likely to be in a single office or perhaps a single building  but for larger ones  the computers and employees may be scattered over dozens of offices and plants in many countries\n Nevertheless  a sales person in New York might sometimes need access to a product inventory  INTRODUCTION  \n  database in Singapore\n Networks called VPNs (Virtual Private Networks) may be used to join the individual networks at different sites into one extended network\n In other words  the mere fact that a user happens to be   km away from his data should not prevent him from using the data as though they were local\n This goal may be summarized by saying that it is an attempt to end the ‘‘tyranny of geography\n’’ In the simplest of terms  one can imagine a company’s information system as consisting of one or more databases with company information and some number of employees who need to access them remotely\n In this model  the data are stored on powerful computers called servers\n Often these are centrally housed and maintained by a system administrator\n In contrast  the employees have simpler machines  called clients  on their desks  with which they access remote data  for example  to include in spreadsheets they are constructing\n (Sometimes we will refer to the human user of the client machine as the ‘‘client ’’ but it should be clear from the context whether we mean the computer or its user\n) The client and server machines are connected by a network  as illustrated in Fig\n  - \n Note that we have shown the network as a simple oval  without any detail\n We will use this form when we mean a network in the most abstract sense\n When more detail is required  it will be provided\n Client Server Network Figure  - \n A network with two clients and one server\n This whole arrangement is called the client-server model\n It is widely used and forms the basis of much network usage\n The most popular realization is that of a Web application  in which the server generates Web pages based on its database in response to client requests that may update the database\n The client-server model is applicable when the client and server are both in the same building (and belong to the same company)  but also when they are far apart\n For example  when a person at home accesses a page on the World Wide Web  the same model is employed  with the remote Web server being the server and the user’s personal   USES OF COMPUTER NETWORKS  computer being the client\n Under most conditions  one server can handle a large number (hundreds or thousands) of clients simultaneously\n If we look at the client-server model in detail  we see that two processes ( \n  running programs) are involved  one on the client machine and one on the server machine\n Communication takes the form of the client process sending a message over the network to the server process\n The client process then waits for a reply message\n When the server process gets the request  it performs the requested work or looks up the requested data and sends back a reply\n These messages are shown in Fig\n  - \n Client process Server process Client machine Network Reply Request Server machine Figure  - \n The client-server model involves requests and replies\n A ond goal of setting up a computer network has to do with people rather than information or even computers\n A computer network can provide a powerful communication medium among employees\n Virtually every company that has two or more computers now has email (electronic mail)  which employees generally use for a great deal of daily communication\n In fact  a common gripe around the water cooler is how much email everyone has to deal with  much of it quite meaningless because bosses have discovered that they can send the same (often content-free) message to all their subordinates at the push of a button\n Telephone calls between employees may be carried by the computer network instead of by the phone company\n This technology is called IP telephony or Voice over IP (VoIP) when Internet technology is used\n The microphone and speaker at each end may belong to a VoIP-enabled phone or the employee’s computer\n Companies find this a wonderful way to save on their telephone bills\n Other  richer forms of communication are made possible by computer networks\n Video can be added to audio so that employees at distant locations can see and hear each other as they hold a meeting\n This technique is a powerful tool for eliminating the cost and time previously devoted to travel\n Desktop sharing lets remote workers see and interact with a graphical computer screen\n This makes it easy for two or more people who work far apart to read and write a shared blackboard or write a report together\n When one worker makes a change to an online document  the others can see the change immediately  instead of waiting several days for a letter\n Such a speedup makes cooperation among far-flung groups of people easy where it previously had been impossible\n More ambitious forms of remote coordination such as telemedicine are only now starting to be used ( \n   INTRODUCTION  \n  remote patient monitoring) but may become much more important\n It is sometimes said that communication and transportation are having a race  and whichever wins will make the other obsolete\n A third goal for many companies is doing business electronically  especially with customers and suppliers\n This new model is called e-commerce (electronic commerce) and it has grown rapidly in recent years\n Airlines  bookstores  and other retailers have discovered that many customers like the convenience of shopping from home\n Consequently  many companies provide catalogs of their goods and services online and take orders online\n Manufacturers of automobiles  aircraft  and computers  among others  buy subsystems from a variety of suppliers and then assemble the parts\n Using computer networks  manufacturers can place orders electronically as needed\n This reduces the need for large inventories and enhances efficiency\n    Home Applications In  Ken Olsen was president of the Digital Equipment Corporation  then the number two computer vendor in the world (after IBM)\n When asked why Digital was not going after the personal computer market in a big way  he said: ‘‘There is no reason for any individual to have a computer in his home\n’’ History showed otherwise and Digital no longer exists\n People initially bought computers for word processing and games\n Recently  the biggest reason to buy a home computer was probably for Internet access\n Now  many consumer electronic devices  such as set-top boxes  game consoles  and clock radios  come with embedded computers and computer networks  especially wireless networks  and home networks are broadly used for entertainment  including listening to  looking at  and creating music  photos  and videos\n Internet access provides home users with connectivity to remote computers\n As with companies  home users can access information  communicate with other people  and buy products and services with e-commerce\n The main benefit now comes from connecting outside of the home\n Bob Metcalfe  the inventor of Ethernet  hypothesized that the value of a network is proportional to the square of the number of users because this is roughly the number of different connections that may be made (Gilder  )\n This hypothesis is known as ‘‘Metcalfe’s law\n’’ It helps to explain how the tremendous popularity of the Internet comes from its size\n Access to remote information comes in many forms\n It can be surfing the World Wide Web for information or just for fun\n Information available includes the arts  business  cooking  government  health  history  hobbies  recreation  science  sports  travel  and many others\n Fun comes in too many ways to mention  plus some ways that are better left unmentioned\n Many newspapers have gone online and can be personalized\n For example  it is sometimes possible to tell a newspaper that you want everything about corrupt   USES OF COMPUTER NETWORKS  politicians  big fires  scandals involving celebrities  and epidemics  but no football  thank you\n Sometimes it is possible to have the selected articles downloaded to your computer while you sleep\n As this trend continues  it will cause massive unemployment among  -year-old paperboys  but newspapers like it because distribution has always been the weakest link in the whole production chain\n Of course  to make this model work  they will first have to figure out how to make money in this new world  something not entirely obvious since Internet users expect everything to be free\n The next step beyond newspapers (plus magazines and scientific journals) is the online digital library\n Many professional organizations  such as the ACM ( ) and the IEEE Computer Society ( )  already have all their journals and conference proceedings online\n Electronic book readers and online libraries may make printed books obsolete\n Skeptics should take note of the effect the printing press had on the medieval illuminated manuscript\n Much of this information is accessed using the client-server model  but there is different  popular model for accessing information that goes by the name of peer-to-peer communication (Parameswaran et al\n  )\n In this form  individuals who form a loose group can communicate with others in the group  as shown in Fig\n  - \n Every person can  in principle  communicate with one or more other people; there is no fixed division into clients and servers\n Figure  - \n In a peer-to-peer system there are no fixed clients and servers\n Many peer-to-peer systems  such BitTorrent (Cohen  )  do not have any central database of content\n Instead  each user maintains his own database locally and provides a list of other nearby people who are members of the system\n A new user can then go to any existing member to see what he has and get the names of other members to inspect for more content and more names\n This lookup process can be repeated indefinitely to build up a large local database of what is out there\n It is an activity that would get tedious for people but computers excel at it\n  INTRODUCTION  \n  Peer-to-peer communication is often used to share music and videos\n It really hit the big time around  with a music sharing service called Napster that was shut down after what was probably the biggest copyright infringement case in all of recorded history (Lam and Tan  ; and Macedonia  )\n Legal applications for peer-to-peer communication also exist\n These include fans sharing public domain music  families sharing photos and movies  and users downloading public software packages\n In fact  one of the most popular Internet applications of all  email  is inherently peer-to-peer\n This form of communication is likely to grow considerably in the future\n All of the above applications involve interactions between a person and a remote database full of information\n The ond broad category of network use is person-to-person communication  basically the  st century’s answer to the  th century’s telephone\n E-mail is already used on a daily basis by millions of people all over the world and its use is growing rapidly\n It already routinely contains audio and video as well as text and pictures\n Smell may take a while\n Any teenager worth his or her salt is addicted to instant messaging\n This facility  derived from the UNIX talk program in use since around  allows two people to type messages at each other in real time\n There are multi-person messaging services too  such as the Twitter service that lets people send short text messages called ‘‘tweets’’ to their circle of friends or other willing audiences\n The Internet can be used by applications to carry audio ( \n  Internet radio stations) and video ( \n  YouTube)\n Besides being a cheap way to call to distant friends  these applications can provide rich experiences such as telelearning  meaning attending   \n classes without the inconvenience of having to get out of bed first\n In the long run  the use of networks to enhance human-to-human communication may prove more important than any of the others\n It may become hugely important to people who are geographically challenged  giving them the same access to services as people living in the middle of a big city\n Between person-to-person communications and accessing information are social network applications\n Here  the flow of information is driven by the relationships that people declare between each other\n One of the most popular social networking sites is Facebook\n It lets people update their personal profiles and shares the updates with other people who they have declared to be their friends\n Other social networking applications can make introductions via friends of friends  send news messages to friends such as Twitter above  and much more\n Even more loosely  groups of people can work together to create content\n A wiki  for example  is a collaborative Web site that the members of a community edit\n The most famous wiki is the Wikipedia  an encyclopedia anyone can edit  but there are thousands of other wikis\n Our third category is electronic commerce in the broadest sense of the term\n Home shopping is already popular and enables users to inspect the online catalogs of thousands of companies\n Some of these catalogs are interactive  showing products from different viewpoints and in configurations that can be personalized\n   USES OF COMPUTER NETWORKS  After the customer buys a product electronically but cannot figure out how to use it  online technical support may be consulted\n Another area in which e-commerce is widely used is access to financial institutions\n Many people already pay their bills  manage their bank accounts  and handle their investments electronically\n This trend will surely continue as networks become more ure\n One area that virtually nobody foresaw is electronic flea markets (e-flea?)\n Online auctions of ond-hand goods have become a massive industry\n Unlike traditional e-commerce  which follows the client-server model  online auctions are peer-to-peer in the sense that consumers can act as both buyers and sellers\n Some of these forms of e-commerce have acquired cute little tags based on the fact that ‘‘to’’ and ‘‘ ’’ are pronounced the same\n The most popular ones are listed in Fig\n  - \n Tag Full name Example B C Business-to-consumer Ordering books online B B Business-to-business Car manufacturer ordering tires from supplier G C Government-to-consumer Government distributing tax forms electronically C C Consumer-to-consumer Auctioning ond-hand products online P P Peer-to-peer Music sharing Figure  - \n Some forms of e-commerce\n Our fourth category is entertainment\n This has made huge strides in the home in recent years  with the distribution of music  radio and television programs  and movies over the Internet beginning to rival that of traditional mechanisms\n Users can find  buy  and download MP  songs and DVD-quality movies and add them to their personal collection\n TV shows now reach many homes via IPTV (IP TeleVision) systems that are based on IP technology instead of cable TV or radio transmissions\n Media streaming applications let users tune into Internet radio stations or watch recent episodes of their favorite TV shows\n Naturally  all of this content can be moved around your house between different devices  displays and speakers  usually with a wireless network\n Soon  it may be possible to search for any movie or television program ever made  in any country  and have it displayed on your screen instantly\n New films may become interactive  where the user is occasionally prompted for the story direction (should Macbeth murder Duncan or just bide his time?) with alternative scenarios provided for all cases\n Live television may also become interactive  with the audience participating in quiz shows  choosing among contestants  and so on\n Another form of entertainment is game playing\n Already we have multiperson real-time simulation games  like hide-and-seek in a virtual dungeon  and flight   INTRODUCTION  \n  simulators with the players on one team trying to shoot down the players on the opposing team\n Virtual worlds provide a persistent setting in which thousands of users can experience a shared reality with three-dimensional graphics\n Our last category is ubiquitous computing  in which computing is embedded into everyday life  as in the vision of Mark Weiser (   )\n Many homes are already wired with urity systems that include door and window sensors  and there are many more sensors that can be folded in to a smart home monitor  such as energy consumption\n Your electricity  gas and water meters could also report usage over the network\n This would save money as there would be no need to send out meter readers\n And your smoke detectors could call the fire department instead of making a big noise (which has little value if no one is home)\n As the cost of sensing and communication drops  more and more measurement and reporting will be done with networks\n Increasingly  consumer electronic devices are networked\n For example  some high-end cameras already have a wireless network capability and use it to send photos to a nearby display for viewing\n Professional sports photographers can also send their photos to their editors in real-time  first wirelessly to an access point then over the Internet\n Devices such as televisions that plug into the wall can use power-line networks to send information throughout the house over the wires that carry electricity\n It may not be very surprising to have these objects on the network  but objects that we do not think of as computers may sense and communicate information too\n For example  your shower may record water usage  give you visual feedback while you lather up  and report to a home environmental monitoring application when you are done to help save on your water bill\n A technology called RFID (Radio Frequency IDentification) will push this idea even further in the future\n RFID tags are passive ( \n  have no battery) chips the size of stamps and they can already be affixed to books  passports  pets  credit cards  and other items in the home and out\n This lets RFID readers locate and communicate with the items over a distance of up to several meters  depending on the kind of RFID\n Originally  RFID was commercialized to replace barcodes\n It has not succeeded yet because barcodes are free and RFID tags cost a few cents\n Of course  RFID tags offer much more and their price is rapidly declining\n They may turn the real world into the Internet of things (ITU  )\n    Mobile Users Mobile computers  such as laptop and handheld computers  are one of the fastest-growing segments of the computer industry\n Their sales have already overtaken those of desktop computers\n Why would anyone want one? People on the go often want to use their mobile devices to read and send email  tweet  watch movies  download music  play games  or simply to surf the Web for information\n They want to do all of the things they do at home and in the office\n Naturally  they want to do them from anywhere on land  sea or in the air\n   USES OF COMPUTER NETWORKS   Connectivity to the Internet enables many of these mobile uses\n Since having a wired connection is impossible in cars  boats  and airplanes  there is a lot of interest in wireless networks\n Cellular networks operated by the telephone companies are one familiar kind of wireless network that blankets us with coverage for mobile phones\n Wireless hotspots based on the   \n  standard are another kind of wireless network for mobile computers\n They have sprung up everywhere that people go  resulting in a patchwork of coverage at cafes  hotels  airports  schools  trains and planes\n Anyone with a laptop computer and a wireless modem can just turn on their computer on and be connected to the Internet through the hotspot  as though the computer were plugged into a wired network\n Wireless networks are of great value to fleets of trucks  taxis  delivery vehicles  and repairpersons for keeping in contact with their home base\n For example  in many cities  taxi drivers are independent businessmen  rather than being employees of a taxi company\n In some of these cities  the taxis have a display the driver can see\n When a customer calls up  a central dispatcher types in the pickup and destination points\n This information is displayed on the drivers’ displays and a beep sounds\n The first driver to hit a button on the display gets the call\n Wireless networks are also important to the military\n If you have to be able to fight a war anywhere on Earth at short notice  counting on using the local networking infrastructure is probably not a good idea\n It is better to bring your own\n Although wireless networking and mobile computing are often related  they are not identical  as Fig\n  -  shows\n Here we see a distinction between fixed wireless and mobile wireless networks\n Even notebook computers are sometimes wired\n For example  if a traveler plugs a notebook computer into the wired network jack in a hotel room  he has mobility without a wireless network\n Wireless Mobile Typical applications No No Desktop computers in offices No Yes A notebook computer used in a hotel room Yes No Networks in unwired buildings Yes Yes Store inventory with a handheld computer Figure  - \n Combinations of wireless networks and mobile computing\n Conversely  some wireless computers are not mobile\n In the home  and in offices or hotels that lack suitable cabling  it can be more convenient to connect desktop computers or media players wirelessly than to install wires\n Installing a wireless network may require little more than buying a small box with some electronics in it  unpacking it  and plugging it in\n This solution may be far cheaper than having workmen put in cable ducts to wire the building\n Finally  there are also true mobile  wireless applications  such as people walking around stores with a handheld computers recording inventory\n At many busy   INTRODUCTION  \n  airports  car rental return clerks work in the parking lot with wireless mobile computers\n They scan the barcodes or RFID chips of returning cars  and their mobile device  which has a built-in printer  calls the main computer  gets the rental information  and prints out the bill on the spot\n Perhaps the key driver of mobile  wireless applications is the mobile phone\n Text messaging or texting is tremendously popular\n It lets a mobile phone user type a short message that is then delivered by the cellular network to another mobile subscriber\n Few people would have predicted ten years ago that having teenagers tediously typing short text messages on mobile phones would be an immense money maker for telephone companies\n But texting (or Short Message Service as it is known outside the  \n) is very profitable since it costs the carrier but a tiny fraction of one cent to relay a text message  a service for which they charge far more\n The long-awaited convergence of telephones and the Internet has finally arrived  and it will accelerate the growth of mobile applications\n Smart phones  such as the popular iPhone  combine aspects of mobile phones and mobile computers\n The ( G and  G) cellular networks to which they connect can provide fast data services for using the Internet as well as handling phone calls\n Many advanced phones connect to wireless hotspots too  and automatically switch between networks to choose the best option for the user\n Other consumer electronics devices can also use cellular and hotspot networks to stay connected to remote computers\n Electronic book readers can download a newly purchased book or the next edition of a magazine or today’s newspaper wherever they roam\n Electronic picture frames can update their displays on cue with fresh images\n Since mobile phones know their locations  often because they are equipped with GPS (Global Positioning System) receivers  some services are intentionally location dependent\n Mobile maps and directions are an obvious candidate as your GPS-enabled phone and car probably have a better idea of where you are than you do\n So  too  are searches for a nearby bookstore or Chinese restaurant  or a local weather forecast\n Other services may record location  such as annotating photos and videos with the place at which they were made\n This annotation is known as ‘‘geo-tagging\n’’ An area in which mobile phones are now starting to be used is m-commerce (mobile-commerce) (Senn  )\n Short text messages from the mobile are used to authorize payments for food in vending machines  movie tickets  and other small items instead of cash and credit cards\n The charge then appears on the mobile phone bill\n When equipped with NFC (Near Field Communication) technology the mobile can act as an RFID smartcard and interact with a nearby reader for payment\n The driving forces behind this phenomenon are the mobile device makers and network operators  who are trying hard to figure out how to get a piece of the e-commerce pie\n From the store’s point of view  this scheme may save them most of the credit card company’s fee  which can be several percent\n   USES OF COMPUTER NETWORKS   Of course  this plan may backfire  since customers in a store might use the RFID or barcode readers on their mobile devices to check out competitors’ prices before buying and use them to get a detailed report on where else an item can be purchased nearby and at what price\n One huge thing that m-commerce has going for it is that mobile phone users are accustomed to paying for everything (in contrast to Internet users  who expect everything to be free)\n If an Internet Web site charged a fee to allow its customers to pay by credit card  there would be an immense howling noise from the users\n If  however  a mobile phone operator its customers to pay for items in a store by waving the phone at the cash register and then tacked on a fee for this convenience  it would probably be accepted as normal\n Time will tell\n No doubt the uses of mobile and wireless computers will grow rapidly in the future as the size of computers shrinks  probably in ways no one can now foresee\n Let us take a quick look at some possibilities\n Sensor networks are made up of nodes that gather and wirelessly relay information they sense about the state of the physical world\n The nodes may be part of familiar items such as cars or phones  or they may be small separate devices\n For example  your car might gather data on its location  speed  vibration  and fuel efficiency from its on-board diagnostic system and upload this information to a database (Hull et al\n  )\n Those data can help find potholes  plan trips around congested roads  and tell you if you are a ‘‘gas guzzler’’ compared to other drivers on the same stretch of road\n Sensor networks are revolutionizing science by providing a wealth of data on behavior that could not previously be observed\n One example is tracking the migration of individual zebras by placing a small sensor on each animal (Juang et al\n  )\n Researchers have packed a wireless computer into a cube  mm on edge (Warneke et al\n  )\n With mobile computers this small  even small birds  rodents  and ints can be tracked\n Even mundane uses  such as in parking meters  can be significant because they make use of data that were not previously available\n Wireless parking meters can accept credit or debit card payments with instant verification over the wireless link\n They can also report when they are in use over the wireless network\n This would let drivers download a recent parking map to their car so they can find an available spot more easily\n Of course  when a meter expires  it might also check for the presence of a car (by bouncing a signal off it) and report the expiration to parking enforcement\n It has been estimated that city governments in the  \n alone could collect an additional $  billion this way (Harte et al\n  )\n Wearable computers are another promising application\n Smart watches with radios have been part of our mental space since their appearance in the Dick Tracy comic strip in ; now you can buy them\n Other such devices may be implanted  such as pacemakers and insulin pumps\n Some of these can be controlled over a wireless network\n This lets doctors test and reconfigure them more easily\n It could also lead to some nasty problems if the devices are as inure as the average PC and can be hacked easily (Halperin et al\n  )\n   INTRODUCTION  \n     Social Issues Computer networks  like the printing press years ago  allow ordinary citizens to distribute and view content in ways that were not previously possible\n But along with the good comes the bad  as this new-found freedom brings with it many unsolved social  political  and ethical issues\n Let us just briefly mention a few of them; a thorough study would require a full book  at least\n Social networks  message boards  content sharing sites  and a host of other applications allow people to share their views with like-minded individuals\n As long as the subjects are restricted to technical topics or hobbies like gardening  not too many problems will arise\n The trouble comes with topics that people actually care about  like politics  religion  or sex\n Views that are publicly posted may be deeply offensive to some people\n Worse yet  they may not be politically correct\n Furthermore  opinions need not be limited to text; high-resolution color photographs and video clips are easily shared over computer networks\n Some people take a live-and-let-live view  but others feel that posting certain material ( \n  verbal attacks on particular countries or religions  pornography  etc\n) is simply unacceptable and that such content must be censored\n Different countries have different and conflicting laws in this area\n Thus  the debate rages\n In the past  people have sued network operators  claiming that they are responsible for the contents of what they carry  just as newspapers and magazines are\n The inevitable response is that a network is like a telephone company or the post office and cannot be expected to police what its users say\n It should now come only as a slight surprise to learn that some network operators block content for their own reasons\n Some users of peer-to-peer applications had their network service cut off because the network operators did not find it profitable to carry the large amounts of traffic sent by those applications\n Those same operators would probably like to treat different companies differently\n If you are a big company and pay well then you get good service  but if you are a small-time player  you get poor service\n Opponents of this practice argue that peer-to-peer and other content should be treated in the same way because they are all just bits to the network\n This argument for communications that are not differentiated by their content or source or who is providing the content is known as network neutrality (Wu  )\n It is probably safe to say that this debate will go on for a while\n Many other parties are involved in the tussle over content\n For instance  pirated music and movies fueled the massive growth of peer-to-peer networks  which did not please the copyright holders  who have threatened (and sometimes taken) legal action\n There are now automated systems that search peer-to-peer networks and fire off warnings to network operators and users who are suspected of infringing copyright\n In the United States  these warnings are known as DMCA takedown notices after the Digital Millennium Copyright Act\n This   USES OF COMPUTER NETWORKS   search is an arms’ race because it is hard to reliably catch copyright infringement\n Even your printer might be mistaken for a culprit (Piatek et al\n  )\n Computer networks make it very easy to communicate\n They also make it easy for the people who run the network to snoop on the traffic\n This sets up conflicts over issues such as employee rights versus employer rights\n Many people read and write email at work\n Many employers have claimed the right to read and possibly censor employee messages  including messages sent from a home computer outside working hours\n Not all employees agree with this  especially the latter part\n Another conflict is centered around government versus citizen’s rights\n The FBI has installed systems at many Internet service providers to snoop on all incoming and outgoing email for nuggets of interest\n One early system was originally called Carnivore  but bad publicity caused it to be renamed to the more innocent-sounding DCS (Blaze and Bellovin  ; Sobel  ; and Zacks  )\n The goal of such systems is to spy on millions of people in the hope of perhaps finding information about illegal activities\n Unfortunately for the spies  the Fourth Amendment to the  \n Constitution prohibits government searches without a search warrant  but the government often ignores it\n Of course  the government does not have a monopoly on threatening people’s privacy\n The private tor does its bit too by profiling users\n For example  small files called cookies that Web browsers store on users’ computers allow companies to track users’ activities in cyberspace and may also allow credit card numbers  social urity numbers  and other confidential information to leak all over the Internet (Berghel  )\n Companies that provide Web-based services may maintain large amounts of personal information about their users that allows them to study user activities directly\n For example  Google can read your email and show you advertisements based on your interests if you use its email service  Gmail\n A new twist with mobile devices is location privacy (Beresford and Stajano  )\n As part of the process of providing service to your mobile device the network operators learn where you are at different times of day\n This allows them to track your movements\n They may know which nightclub you frequent and which medical center you visit\n Computer networks also offer the potential to increase privacy by sending anonymous messages\n In some situations  this capability may be desirable\n Beyond preventing companies from learning your habits  it provides  for example  a way for students  soldiers  employees  and citizens to blow the whistle on illegal behavior on the part of professors  officers  superiors  and politicians without fear of reprisals\n On the other hand  in the United States and most other democracies  the law specifically permits an accused person the right to confront and challenge his accuser in court so anonymous accusations cannot be used as evidence\n The Internet makes it possible to find information quickly  but a great deal of it is ill considered  misleading  or downright wrong\n That medical advice you   INTRODUCTION  \n  plucked from the Internet about the pain in your chest may have come from a Nobel Prize winner or from a high-school dropout\n Other information is frequently unwanted\n Electronic junk mail (spam) has become a part of life because spammers have collected millions of email addresses and would-be marketers can cheaply send computer-generated messages to them\n The resulting flood of spam rivals the flow messages from real people\n Fortunately  filtering software is able to read and discard the spam generated by other computers  with lesser or greater degrees of success\n Still other content is intended for criminal behavior\n Web pages and email messages containing active content (basically  programs or macros that execute on the receiver’s machine) can contain viruses that take over your computer\n They might be used to steal your bank account passwords  or to have your computer send spam as part of a botnet or pool of compromised machines\n Phishing messages masquerade as originating from a trustworthy party  for example  your bank  to try to trick you into revealing sensitive information  for example  credit card numbers\n Identity theft is becoming a serious problem as thieves collect enough information about a victim to obtain credit cards and other documents in the victim’s name\n It can be difficult to prevent computers from impersonating people on the Internet\n This problem has led to the development of CAPTCHAs  in which a computer asks a person to solve a short recognition task  for example  typing in the letters shown in a distorted image  to show that they are human (von Ahn  )\n This process is a variation on the famous Turing test in which a person asks questions over a network to judge whether the entity responding is human\n A lot of these problems could be solved if the computer industry took computer urity seriously\n If all messages were encrypted and authenticated  it would be harder to commit mischief\n Such technology is well established and we will study it in detail in   The problem is that hardware and software vendors know that putting in urity features costs money and their customers are not demanding such features\n In addition  a substantial number of the problems are caused by buggy software  which occurs because vendors keep adding more and more features to their programs  which inevitably means more code and thus more bugs\n A tax on new features might help  but that might be a tough sell in some quarters\n A refund for defective software might be nice  except it would bankrupt the entire software industry in the first year\n Computer networks raise new legal problems when they interact with old laws\n Electronic gambling provides an example\n Computers have been simulating things for decades  so why not simulate slot machines  roulette wheels  blackjack dealers  and more gambling equipment? Well  because it is illegal in a lot of places\n The trouble is  gambling is legal in a lot of other places (England  for example) and casino owners there have grasped the potential for Internet gambling\n What happens if the gambler  the casino  and the server are all in different countries  with conflicting laws? Good question\n   NETWORK HARDWARE \n  NETWORK HARDWARE It is now time to turn our attention from the applications and social aspects of networking (the dessert) to the technical issues involved in network design (the spinach)\n There is no generally accepted taxonomy into which all computer networks fit  but two dimensions stand out as important: transmission technology and scale\n We will now examine each of these in turn\n Broadly speaking  there are two types of transmission technology that are in widespread use: broadcast links and point-to-point links\n Point-to-point links connect individual pairs of machines\n To go from the source to the destination on a network made up of point-to-point links  short messages  called packets in certain contexts  may have to first visit one or more intermediate machines\n Often multiple routes  of different lengths  are possible  so finding good ones is important in point-to-point networks\n Point-to-point transmission with exactly one sender and exactly one receiver is sometimes called unicasting\n In contrast  on a broadcast network  the communication channel is shared by all the machines on the network; packets sent by any machine are received by all the others\n An address field within each packet specifies the intended recipient\n Upon receiving a packet  a machine checks the address field\n If the packet is intended for the receiving machine  that machine processes the packet; if the packet is intended for some other machine  it is just ignored\n A wireless network is a common example of a broadcast link  with communication shared over a coverage region that depends on the wireless channel and the transmitting machine\n As an analogy  consider someone standing in a meeting room and shouting ‘‘Watson  come here\n I want you\n’’ Although the packet may actually be received (heard) by many people  only Watson will respond; the others just ignore it\n Broadcast systems usually also allow the possibility of addressing a packet to all destinations by using a special code in the address field\n When a packet with this code is transmitted  it is received and processed by every machine on the network\n This mode of operation is called broadcasting\n Some broadcast systems also support transmission to a subset of the machines  which known as multicasting\n An alternative criterion for classifying networks is by scale\n Distance is important as a classification metric because different technologies are used at different scales\n In Fig\n  -  we classify multiple processor systems by their rough physical size\n At the top are the personal area networks  networks that are meant for one person\n Beyond these come longer-range networks\n These can be divided into local  metropolitan  and wide area networks  each with increasing scale\n Finally  the connection of two or more networks is called an internetwork\n The worldwide Internet is certainly the best-known (but not the only) example of an internetwork\n   INTRODUCTION  \n  Soon we will have even larger internetworks with the Interplanetary Internet that connects networks across space (Burleigh et al\n  )\n  m Square meter   m Room m Building  km Campus   km City Interprocessor distance Processors located in same Example km Country  km Continent Planet Personal area network The Internet Local area network Metropolitan area network Wide area network   km Figure  - \n Classification of interconnected processors by scale\n In this book we will be concerned with networks at all these scales\n In the following tions  we give a brief introduction to network hardware by scale\n    Personal Area Networks PANs (Personal Area Networks) let devices communicate over the range of a person\n A common example is a wireless network that connects a computer with its peripherals\n Almost every computer has an attached monitor  keyboard  mouse  and printer\n Without using wireless  this connection must be done with cables\n So many new users have a hard time finding the right cables and plugging them into the right little holes (even though they are usually color coded) that most computer vendors offer the option of sending a technician to the user’s home to do it\n To help these users  some companies got together to design a short-range wireless network called Bluetooth to connect these components without wires\n The idea is that if your devices have Bluetooth  then you need no cables\n You just put them down  turn them on  and they work together\n For many people  this ease of operation is a big plus\n In the simplest form  Bluetooth networks use the master-slave paradigm of Fig\n  - \n The system unit (the PC) is normally the master  talking to the mouse  keyboard  etc\n  as slaves\n The master tells the slaves what addresses to use  when they can broadcast  how long they can transmit  what frequencies they can use  and so on\n Bluetooth can be used in other settings  too\n It is often used to connect a headset to a mobile phone without cords and it can allow your digital music player   NETWORK HARDWARE   Figure  - \n Bluetooth PAN configuration\n to connect to your car merely being brought within range\n A completely different kind of PAN is formed when an embedded medical device such as a pacemaker  insulin pump  or hearing aid talks to a user-operated remote control\n We will discuss Bluetooth in more detail in   PANs can also be built with other technologies that communicate over short ranges  such as RFID on smartcards and library books\n We will study RFID in      Local Area Networks The next step up is the LAN (Local Area Network)\n A LAN is a privately owned network that operates within and nearby a single building like a home  office or factory\n LANs are widely used to connect personal computers and consumer electronics to let them share resources ( \n  printers) and exchange information\n When LANs are used by companies  they are called enterprise networks\n Wireless LANs are very popular these days  especially in homes  older office buildings  cafeterias  and other places where it is too much trouble to install cables\n In these systems  every computer has a radio modem and an antenna that it uses to communicate with other computers\n In most cases  each computer talks to a device in the ceiling as shown in Fig\n  - (a)\n This device  called an AP (Access Point)  wireless router  or base station  relays packets between the wireless computers and also between them and the Internet\n Being the AP is like being the popular kid as school because everyone wants to talk to you\n However  if other computers are close enough  they can communicate directly with one another in a peer-to-peer configuration\n There is a standard for wireless LANs called IEEE   \n   popularly known as WiFi  which has become very widespread\n It runs at speeds anywhere from  INTRODUCTION  \n  Ethernet Ports switch To rest of network Access To wired network point Figure  - \n Wireless and wired LANs\n (a)    (b) Switched Ethernet\n to hundreds of Mbps\n (In this book we will adhere to tradition and measure line speeds in megabits/  where  Mbps is  bits/  and gigabits/  where  Gbps is  bits/\n) We will discuss   \n  in   Wired LANs use a range of different transmission technologies\n Most of them use copper wires  but some use optical fiber\n LANs are restricted in size  which means that the worst-case transmission time is bounded and known in advance\n Knowing these bounds helps with the task of designing network protocols\n Typically  wired LANs run at speeds of Mbps to  Gbps  have low delay (microonds or nanoonds)  and make very few errors\n Newer LANs can operate at up to   Gbps\n Compared to wireless networks  wired LANs exceed them in all dimensions of performance\n It is just easier to send signals over a wire or through a fiber than through the air\n The topology of many wired LANs is built from point-to-point links\n IEEE   \n  popularly called Ethernet  is  by far  the most common type of wired LAN\n Fig\n  - (b) shows a sample topology of switched Ethernet\n Each computer speaks the Ethernet protocol and connects to a box called a switch with a point-to-point link\n Hence the name\n A switch has multiple ports  each of which can connect to one computer\n The job of the switch is to relay packets between computers that are attached to it  using the address in each packet to determine which computer to send it to\n To build larger LANs  switches can be plugged into each other using their ports\n What happens if you plug them together in a loop? Will the network still work? Luckily  the designers thought of this case\n It is the job of the protocol to sort out what paths packets should travel to safely reach the intended computer\n We will see how this works in   It is also possible to divide one large physical LAN into two smaller logical LANs\n You might wonder why this would be useful\n Sometimes  the layout of the network equipment does not match the organization’s structure\n For example  the   NETWORK HARDWARE   engineering and finance departments of a company might have computers on the same physical LAN because they are in the same wing of the building but it might be easier to manage the system if engineering and finance logically each had its own network Virtual LAN or VLAN\n In this design each port is tagged with a ‘‘color ’’ say green for engineering and red for finance\n The switch then forwards packets so that computers attached to the green ports are separated from the computers attached to the red ports\n Broadcast packets sent on a red port  for example  will not be received on a green port  just as though there were two different LANs\n We will cover VLANs at the end of   There are other wired LAN topologies too\n In fact  switched Ethernet is a modern version of the original Ethernet design that broadcast all the packets over a single linear cable\n At most one machine could successfully transmit at a time  and a distributed arbitration mechanism was used to resolve conflicts\n It used a simple algorithm: computers could transmit whenever the cable was idle\n If two or more packets collided  each computer just waited a random time and tried later\n We will call that version classic Ethernet for clarity  and as you suspected  you will learn about it in   Both wireless and wired broadcast networks can be divided into static and dynamic designs  depending on how the channel is allocated\n A typical static allocation would be to divide time into discrete intervals and use a round-robin algorithm  allowing each machine to broadcast only when its time slot comes up\n Static allocation wastes channel capacity when a machine has nothing to say during its allocated slot  so most systems attempt to allocate the channel dynamically ( \n  on demand)\n Dynamic allocation methods for a common channel are either centralized or decentralized\n In the centralized channel allocation method  there is a single entity  for example  the base station in cellular networks  which determines who goes next\n It might do this by accepting multiple packets and prioritizing them according to some internal algorithm\n In the decentralized channel allocation method  there is no central entity; each machine must decide for itself whether to transmit\n You might think that this approach would lead to chaos  but it does not\n Later we will study many algorithms designed to bring order out of the potential chaos\n It is worth spending a little more time discussing LANs in the home\n In the future  it is likely that every appliance in the home will be capable of communicating with every other appliance  and all of them will be accessible over the Internet\n This development is likely to be one of those visionary concepts that nobody asked for (like TV remote controls or mobile phones)  but once they arrived nobody can imagine how they lived without them\n Many devices are already capable of being networked\n These include computers  entertainment devices such as TVs and DVDs  phones and other consumer electronics such as cameras  appliances like clock radios  and infrastructure like utility meters and thermostats\n This trend will only continue\n For instance  the average home probably has a dozen clocks ( \n  in appliances)  all of which could   INTRODUCTION  \n  adjust to daylight savings time automatically if the clocks were on the Internet\n Remote monitoring of the home is a likely winner  as many grown children would be willing to spend some money to help their aging parents live safely in their own homes\n While we could think of the home network as just another LAN  it is more likely to have different properties than other networks\n First  the networked devices have to be very easy to install\n Wireless routers are the most returned consumer electronic item\n People buy one because they want a wireless network at home  find that it does not work ‘‘out of the box ’’ and then return it rather than listen to elevator music while on hold on the technical helpline\n ond  the network and devices have to be foolproof in operation\n Air conditioners used to have one knob with four settings: OFF  LOW  MEDIUM  and HIGH\n Now they have  -page manuals\n Once they are networked  expect the  ter on urity alone to be   pages\n This is a problem because only computer users are accustomed to putting up with products that do not work; the car-  television-  and refrigerator-buying public is far less tolerant\n They expect products to work   % without the need to hire a geek\n Third  low price is essential for success\n People will not pay a $  premium for an Internet thermostat because few people regard monitoring their home temperature from work that important\n For $  extra  though  it might sell\n Fourth  it must be possible to start out with one or two devices and expand the reach of the network gradually\n This means no format wars\n Telling consumers to buy peripherals with IEEE  (FireWire) interfaces and a few years later retracting that and saying USB  \n  is the interface-of-the-month and then switching that to   \n  g—oops  no  make that   \n  n—I mean   \n  (different wireless networks)—is going to make consumers very skittish\n The network interface will have to remain stable for decades  like the television broadcasting standards\n Fifth  urity and reliability will be very important\n Losing a few files to an email virus is one thing; having a burglar disarm your urity system from his mobile computer and then plunder your house is something quite different\n An interesting question is whether home networks will be wired or wireless\n Convenience and cost favors wireless networking because there are no wires to fit  or worse  retrofit\n urity favors wired networking because the radio waves that wireless networks use are quite good at going through walls\n Not everyone is overjoyed at the thought of having the neighbors piggybacking on their Internet connection and reading their email\n In  \n  we will study how encryption can be used to provide urity  but it is easier said than done with inexperienced users\n A third option that may be appealing is to reuse the networks that are already in the home\n The obvious candidate is the electric wires that are installed throughout the house\n Power-line networks let devices that plug into outlets broadcast information throughout the house\n You have to plug in the TV anyway  and this way it can get Internet connectivity at the same time\n The difficulty is   NETWORK HARDWARE   how to carry both power and data signals at the same time\n Part of the answer is that they use different frequency bands\n In short  home LANs offer many opportunities and challenges\n Most of the latter relate to the need for the networks to be easy to manage  dependable  and ure  especially in the hands of nontechnical users  as well as low cost\n    Metropolitan Area Networks A MAN (Metropolitan Area Network) covers a city\n The best-known examples of MANs are the cable television networks available in many cities\n These systems grew from earlier community antenna systems used in areas with poor over-the-air television reception\n In those early systems  a large antenna was placed on top of a nearby hill and a signal was then piped to the subscribers’ houses\n At first  these were locally designed  ad hoc systems\n Then companies began jumping into the business  getting contracts from local governments to wire up entire cities\n The next step was television programming and even entire channels designed for cable only\n Often these channels were highly specialized  such as all news  all sports  all cooking  all gardening  and so on\n But from their inception until the late s  they were intended for television reception only\n When the Internet began attracting a mass audience  the cable TV network operators began to realize that with some changes to the system  they could provide two-way Internet service in unused parts of the spectrum\n At that point  the cable TV system began to morph from simply a way to distribute television to a metropolitan area network\n To a first approximation  a MAN might look something like the system shown in Fig\n  - \n In this figure we see both television signals and Internet being fed into the centralized cable headend for subsequent distribution to people’s homes\n We will come back to this subject in detail in   Cable television is not the only MAN  though\n Recent developments in highspeed wireless Internet access have resulted in another MAN  which has been standardized as IEEE   \n  and is popularly known as WiMAX\n We will look at it in      Wide Area Networks A WAN (Wide Area Network) spans a large geographical area  often a country or continent\n We will begin our discussion with wired WANs  using the example of a company with branch offices in different cities\n The WAN in Fig\n  -  is a network that connects offices in Perth  Melbourne  and Brisbane\n Each of these offices contains computers intended for running user ( \n  application) programs\n We will follow traditional usage and call these machines hosts\n The rest of the network that connects these hosts is then called the   INTRODUCTION  \n  Internet Antenna Junction box Head end Figure  - \n A metropolitan area network based on cable TV\n communication subnet  or just subnet for short\n The job of the subnet is to carry messages from host to host  just as the telephone system carries words (really just sounds) from speaker to listener\n In most WANs  the subnet consists of two distinct components: transmission lines and switching elements\n Transmission lines move bits between machines\n They can be made of copper wire  optical fiber  or even radio links\n Most companies do not have transmission lines lying about  so instead they lease the lines from a telecommunications company\n Switching elements  or just switches  are specialized computers that connect two or more transmission lines\n When data arrive on an incoming line  the switching element must choose an outgoing line on which to forward them\n These switching computers have been called by various names in the past; the name router is now most commonly used\n Unfortunately  some people pronounce it ‘‘rooter’’ while others have it rhyme with ‘‘doubter\n’’ Determining the correct pronunciation will be left as an exercise for the reader\n (Note: the perceived correct answer may depend on where you live\n) A short comment about the term ‘‘subnet’’ is in order here\n Originally  its only meaning was the collection of routers and communication lines that moved packets from the source host to the destination host\n Readers should be aware that it has acquired a ond  more recent meaning in conjunction with network addressing\n We will discuss that meaning in  \n  and stick with the original meaning (a collection of lines and routers) until then\n The WAN as we have described it looks similar to a large wired LAN  but there are some important differences that go beyond long wires\n Usually in a WAN  the hosts and subnet are owned and operated by different people\n In our   NETWORK HARDWARE   Subnet Router Perth Brisbane Melbourne Transmission line Figure  -  \n WAN that connects three branch offices in Australia\n example  the employees might be responsible for their own computers  while the company’s IT department is in charge of the rest of the network\n We will see clearer boundaries in the coming examples  in which the network provider or telephone company operates the subnet\n Separation of the pure communication aspects of the network (the subnet) from the application aspects (the hosts) greatly simplifies the overall network design\n A ond difference is that the routers will usually connect different kinds of networking technology\n The networks inside the offices may be switched Ethernet  for example  while the long-distance transmission lines may be SONET links (which we will cover in  \n  )\n Some device needs to join them\n The astute reader will notice that this goes beyond our definition of a network\n This means that many WANs will in fact be internetworks  or composite networks that are made up of more than one network\n We will have more to say about internetworks in the next tion\n A final difference is in what is connected to the subnet\n This could be individual computers  as was the case for connecting to LANs  or it could be entire LANs\n This is how larger networks are built from smaller ones\n As far as the subnet is concerned  it does the same job\n We are now in a position to look at two other varieties of WANs\n First  rather than lease dedicated transmission lines  a company might connect its offices to the Internet This allows connections to be made between the offices as virtual links   INTRODUCTION  \n  that use the underlying capacity of the Internet\n This arrangement  shown in Fig\n  -   is called a VPN (Virtual Private Network)\n Compared to the dedicated arrangement  a VPN has the usual advantage of virtualization  which is that it provides flexible reuse of a resource (Internet connectivity)\n Consider how easy it is to add a fourth office to see this\n A VPN also has the usual disadvantage of virtualization  which is a lack of control over the underlying resources\n With a dedicated line  the capacity is clear\n With a VPN your mileage may vary with your Internet service\n Internet Perth Brisbane Melbourne Link via the internet Figure  -  \n WAN using a virtual private network\n The ond variation is that the subnet may be run by a different company\n The subnet operator is known as a network service provider and the offices are its customers\n This structure is shown in Fig\n  -  \n The subnet operator will connect to other customers too  as long as they can pay and it can provide service\n Since it would be a disappointing network service if the customers could only send packets to each other  the subnet operator will also connect to other networks that are part of the Internet\n Such a subnet operator is called an ISP (Internet Service Provider) and the subnet is an ISP network\n Its customers who connect to the ISP receive Internet service\n We can use the ISP network to preview some key issues that we will study in later  ters\n In most WANs  the network contains many transmission lines  each connecting a pair of routers\n If two routers that do not share a transmission line wish to communicate  they must do this indirectly  via other routers\n There   NETWORK HARDWARE   ISP network Perth Brisbane Melbourne Transmission line Customer network Figure  -  \n WAN using an ISP network\n may be many paths in the network that connect these two routers\n How the network makes the decision as to which path to use is called the routing algorithm\n Many such algorithms exist\n How each router makes the decision as to where to send a packet next is called the forwarding algorithm\n Many of them exist too\n We will study some of both types in detail in   Other kinds of WANs make heavy use of wireless technologies\n In satellite systems  each computer on the ground has an antenna through which it can send data to and receive data from to a satellite in orbit\n All computers can hear the output from the satellite  and in some cases they can also hear the upward transmissions of their fellow computers to the satellite as well\n Satellite networks are inherently broadcast and are most useful when the broadcast property is important\n The cellular telephone network is another example of a WAN that uses wireless technology\n This system has already gone through three generations and a fourth one is on the horizon\n The first generation was analog and for voice only\n The ond generation was digital and for voice only\n The third generation is digital and is for both voice and data\n Each cellular base station covers a distance much larger than a wireless LAN  with a range measured in kilometers rather than tens of meters\n The base stations are connected to each other by a backbone network that is usually wired\n The data rates of cellular networks are often on the order of  Mbps  much smaller than a wireless LAN that can range up to on the order of Mbps\n We will have a lot to say about these networks in     INTRODUCTION  \n     Internetworks Many networks exist in the world  often with different hardware and software\n People connected to one network often want to communicate with people attached to a different one\n The fulfillment of this desire requires that different  and frequently incompatible  networks be connected\n A collection of interconnected networks is called an internetwork or internet\n These terms will be used in a generic sense  in contrast to the worldwide Internet (which is one specific internet)  which we will always capitalize\n The Internet uses ISP networks to connect enterprise networks  home networks  and many other networks\n We will look at the Internet in great detail later in this book\n Subnets  networks  and internetworks are often confused\n The term ‘‘subnet’’ makes the most sense in the context of a wide area network  where it refers to the collection of routers and communication lines owned by the network operator\n As an analogy  the telephone system consists of telephone switching offices connected to one another by high-speed lines  and to houses and businesses by low-speed lines\n These lines and equipment  owned and managed by the telephone company  form the subnet of the telephone system\n The telephones themselves (the hosts in this analogy) are not part of the subnet\n A network is formed by the combination of a subnet and its hosts\n However  the word ‘‘network’’ is often used in a loose sense as well\n A subnet might be described as a network  as in the case of the ‘‘ISP network’’ of Fig\n  -  \n An internetwork might also be described as a network  as in the case of the WAN in Fig\n  -  \n We will follow similar practice  and if we are distinguishing a network from other arrangements  we will stick with our original definition of a collection of computers interconnected by a single technology\n Let us say more about what constitutes an internetwork\n We know that an internet is formed when distinct networks are interconnected\n In our view  connecting a LAN and a WAN or connecting two LANs is the usual way to form an internetwork  but there is little agreement in the industry over terminology in this area\n There are two rules of thumb that are useful\n First  if different organizations have paid to construct different parts of the network and each maintains its part  we have an internetwork rather than a single network\n ond  if the underlying technology is different in different parts ( \n  broadcast versus point-to-point and wired versus wireless)  we probably have an internetwork\n To go deeper  we need to talk about how two different networks can be connected\n The general name for a machine that makes a connection between two or more networks and provides the necessary translation  both in terms of hardware and software  is a gateway\n Gateways are distinguished by the layer at which they operate in the protocol hierarchy\n We will have much more to say about layers and protocol hierarchies starting in the next tion  but for now imagine that higher layers are more tied to applications  such as the Web  and lower layers are more tied to transmission links  such as Ethernet\n   NETWORK HARDWARE   Since the benefit of forming an internet is to connect computers across networks  we do not want to use too low-level a gateway or we will be unable to make connections between different kinds of networks\n We do not want to use too high-level a gateway either  or the connection will only work for particular applications\n The level in the middle that is ‘‘just right’’ is often called the network layer  and a router is a gateway that switches packets at the network layer\n We can now spot an internet by finding a network that has routers  NETWORK SOFTWARE The first computer networks were designed with the hardware as the main concern and the software as an afterthought\n This strategy no longer works\n Network software is now highly structured\n In the following tions we examine the software structuring technique in some detail\n The approach described here forms the keystone of the entire book and will occur repeatedly later on\n    Protocol Hierarchies To reduce their design complexity  most networks are organized as a stack of layers or levels  each one built upon the one below it\n The number of layers  the name of each layer  the contents of each layer  and the function of each layer differ from network to network\n The purpose of each layer is to offer certain services to the higher layers while shielding those layers from the details of how the offered services are actually implemented\n In a sense  each layer is a kind of virtual machine  offering certain services to the layer above it\n This concept is actually a familiar one and is used throughout computer science  where it is variously known as information hiding  abstract data types  data encapsulation  and object-oriented programming\n The fundamental idea is that a particular piece of software (or hardware) provides a service to its users but keeps the details of its internal state and algorithms hidden from them\n When layer n on one machine carries on a conversation with layer n on another machine  the rules and conventions used in this conversation are collectively known as the layer n protocol\n Basically  a protocol is an agreement between the communicating parties on how communication is to proceed\n As an analogy  when a woman is introduced to a man  she may choose to stick out her hand\n He  in turn  may decide to either shake it or kiss it  depending  for example  on whether she is an American lawyer at a business meeting or a European princess at a formal ball\n Violating the protocol will make communication more difficult  if not completely impossible\n A five-layer network is illustrated in Fig\n  -  \n The entities comprising the corresponding layers on different machines are called peers\n The peers may be   INTRODUCTION  \n  software processes  hardware devices  or even human beings\n In other words  it is the peers that communicate by using the protocol to talk to each other\n Layer  Layer  Layer  Layer  Layer  Host  Layer  /  interface Layer  /  interface Layer  /  interface Layer  /  interface Layer  protocol Layer  Layer  Layer  Layer  Layer  Host  Layer  protocol Layer  protocol Layer  protocol Layer  protocol Physical medium Figure  -  \n Layers  protocols  and interfaces\n In reality  no data are directly transferred from layer n on one machine to layer n on another machine\n Instead  each layer passes data and control information to the layer immediately below it  until the lowest layer is reached\n Below layer  is the physical medium through which actual communication occurs\n In Fig\n  -   virtual communication is shown by dotted lines and physical communication by solid lines\n Between each pair of adjacent layers is an interface\n The interface defines which primitive operations and services the lower layer makes available to the upper one\n When network designers decide how many layers to include in a network and what each one should do  one of the most important considerations is defining clean interfaces between the layers\n Doing so  in turn  requires that each layer perform a specific collection of well-understood functions\n In addition to minimizing the amount of information that must be passed between layers  clearcut interfaces also make it simpler to replace one layer with a completely different protocol or implementation ( \n  replacing all the telephone lines by satellite channels) because all that is required of the new protocol or implementation is that it offer exactly the same set of services to its upstairs neighbor as the old one did\n It is common that different hosts use different implementations of the same protocol (often written by different companies)\n In fact  the protocol itself can change in some layer without the layers above and below it even noticing\n   NETWORK SOFTWARE   A set of layers and protocols is called a network architecture\n The specification of an architecture must contain enough information to allow an implementer to write the program or build the hardware for each layer so that it will correctly obey the appropriate protocol\n Neither the details of the implementation nor the specification of the interfaces is part of the architecture because these are hidden away inside the machines and not visible from the outside\n It is not even necessary that the interfaces on all machines in a network be the same  provided that each machine can correctly use all the protocols\n A list of the protocols used by a certain system  one protocol per layer  is called a protocol stack\n Network architectures  protocol stacks  and the protocols themselves are the principal subjects of this book\n An analogy may help explain the idea of multilayer communication\n Imagine two philosophers (peer processes in layer  )  one of whom speaks Urdu and English and one of whom speaks Chinese and French\n Since they have no common language  they each engage a translator (peer processes at layer  )  each of whom in turn contacts a retary (peer processes in layer  )\n Philosopher  wishes to convey his affection for oryctolagus cuniculus to his peer\n To do so  he passes a message (in English) across the  /  interface to his translator  saying ‘‘I like rabbits ’’ as illustrated in Fig\n  -  \n The translators have agreed on a neutral language known to both of them  Dutch  so the message is converted to ‘‘Ik vind konijnen leuk\n’’ The choice of the language is the layer  protocol and is up to the layer  peer processes\n The translator then gives the message to a retary for transmission  for example  by email (the layer  protocol)\n When the message arrives at the other retary  it is passed to the local translator  who translates it into French and passes it across the  /  interface to the ond philosopher\n Note that each protocol is completely independent of the other ones as long as the interfaces are not changed\n The translators can switch from Dutch to  say  Finnish  at will  provided that they both agree and neither changes his interface with either layer  or layer  \n Similarly  the retaries can switch from email to telephone without disturbing (or even informing) the other layers\n Each process may add some information intended only for its peer\n This information is not passed up to the layer above\n Now consider a more technical example: how to provide communication to the top layer of the five-layer network in Fig\n  -  \n A message  M  is produced by an application process running in layer  and given to layer  for transmission\n Layer  puts a header in front of the message to identify the message and passes the result to layer  \n The header includes control information  such as addresses  to allow layer  on the destination machine to deliver the message\n Other examples of control information used in some layers are sequence numbers (in case the lower layer does not preserve message order)  sizes  and times\n In many networks  no limit is placed on the size of messages transmitted in the layer  protocol but there is nearly always a limit imposed by the layer  protocol\n Consequently  layer  must break up the incoming messages into smaller   INTRODUCTION  \n  I like rabbits Location A    Location B Message Philosopher Translator retary Information for the remote translator Information for the remote retary L: Dutch Ik vind konijnen leuk Fax #--- L: Dutch Ik vind konijnen leuk J'aime bien les lapins L: Dutch Ik vind konijnen leuk Fax #--- L: Dutch Ik vind konijnen leuk Figure  -  \n The philosopher-translator-retary architecture\n units  packets  prepending a layer  header to each packet\n In this example  M is split into two parts  M  and M  that will be transmitted separately\n Layer  decides which of the outgoing lines to use and passes the packets to layer  \n Layer  adds to each piece not only a header but also a trailer  and gives the resulting unit to layer  for physical transmission\n At the receiving machine the message moves upward  from layer to layer  with headers being stripped off as it progresses\n None of the headers for layers below n are passed up to layer n\n The important thing to understand about Fig\n  -  is the relation between the virtual and actual communication and the difference between protocols and interfaces\n The peer processes in layer   for example  conceptually think of their communication as being ‘‘horizontal ’’ using the layer  protocol\n Each one is likely to have procedures called something like SendToOtherSide and GetFrom- OtherSide  even though these procedures actually communicate with lower layers across the  /  interface  and not with the other side\n   NETWORK SOFTWARE   H  H  H  M  T  H  H  M  T  H  H  H  M  T  H  H  M  T  H  H  M  H  M  H  H  M  H  M  H  M H  M M M Layer  protocol  Layer  protocol Layer  protocol Layer  protocol    Layer Source machine Destination machine Figure  -  \n Example information flow supporting virtual communication in layer  \n The peer process abstraction is crucial to all network design\n Using it  the unmanageable task of designing the complete network can be broken into several smaller  manageable design problems  namely  the design of the individual layers\n Although   is called ‘‘Network Software ’’ it is worth pointing out that the lower layers of a protocol hierarchy are frequently implemented in hardware or firmware\n Nevertheless  complex protocol algorithms are involved  even if they are embedded (in whole or in part) in hardware\n    Design Issues for the Layers Some of the key design issues that occur in computer networks will come up in layer after layer\n Below  we will briefly mention the more important ones\n Reliability is the design issue of making a network that operates correctly even though it is made up of a collection of components that are themselves unreliable\n Think about the bits of a packet traveling through the network\n There is a chance that some of these bits will be received damaged (inverted) due to fluke electrical noise  random wireless signals  hardware flaws  software bugs and so on\n How is it possible that we find and fix these errors? One mechanism for finding errors in received information uses codes for error detection\n Information that is incorrectly received can then be retransmitted   INTRODUCTION  \n  until it is received correctly\n More powerful codes allow for error correction  where the correct message is recovered from the possibly incorrect bits that were originally received\n Both of these mechanisms work by adding redundant information\n They are used at low layers  to protect packets sent over individual links  and high layers  to check that the right contents were received\n Another reliability issue is finding a working path through a network\n Often there are multiple paths between a source and destination  and in a large network  there may be some links or routers that are broken\n Suppose that the network is down in Germany\n Packets sent from London to Rome via Germany will not get through  but we could instead send packets from London to Rome via Paris\n The network should automatically make this decision\n This topic is called routing\n A ond design issue concerns the evolution of the network\n Over time  networks grow larger and new designs emerge that need to be connected to the existing network\n We have recently seen the key structuring mechanism used to support change by dividing the overall problem and hiding implementation details: protocol layering\n There are many other strategies as well\n Since there are many computers on the network  every layer needs a mechanism for identifying the senders and receivers that are involved in a particular message\n This mechanism is called addressing or naming  in the low and high layers  respectively\n An aspect of growth is that different network technologies often have different limitations\n For example  not all communication channels preserve the order of messages sent on them  leading to solutions that number messages\n Another example is differences in the maximum size of a message that the networks can transmit\n This leads to mechanisms for disassembling  transmitting  and then reassembling messages\n This overall topic is called internetworking\n When networks get large  new problems arise\n Cities can have traffic jams  a shortage of telephone numbers  and it is easy to get lost\n Not many people have these problems in their own neighborhood  but citywide they may be a big issue\n Designs that continue to work well when the network gets large are said to be scalable\n A third design issue is resource allocation\n Networks provide a service to hosts from their underlying resources  such as the capacity of transmission lines\n To do this well  they need mechanisms that divide their resources so that one host does not interfere with another too much\n Many designs share network bandwidth dynamically  according to the shortterm needs of hosts  rather than by giving each host a fixed fraction of the bandwidth that it may or may not use\n This design is called statistical multiplexing  meaning sharing based on the statistics of demand\n It can be applied at low layers for a single link  or at high layers for a network or even applications that use the network\n An allocation problem that occurs at every level is how to keep a fast sender from swamping a slow receiver with data\n Feedback from the receiver to the   NETWORK SOFTWARE   sender is often used\n This subject is called flow control\n Sometimes the problem is that the network is oversubscribed because too many computers want to send too much traffic  and the network cannot deliver it all\n This overloading of the network is called congestion\n One strategy is for each computer to reduce its demand when it experiences congestion\n It  too  can be used in all layers\n It is interesting to observe that the network has more resources to offer than simply bandwidth\n For uses such as carrying live video  the timeliness of delivery matters a great deal\n Most networks must provide service to applications that want this real-time delivery at the same time that they provide service to applications that want high throughput\n Quality of service is the name given to mechanisms that reconcile these competing demands\n The last major design issue is to ure the network by defending it against different kinds of threats\n One of the threats we have mentioned previously is that of eavesdropping on communications\n Mechanisms that provide confidentiality defend against this threat  and they are used in multiple layers\n Mechanisms for authentication prevent someone from impersonating someone else\n They might be used to tell fake banking Web sites from the real one  or to let the cellular network check that a call is really coming from your phone so that you will pay the bill\n Other mechanisms for integrity prevent surreptitious changes to messages  such as altering ‘‘debit my account $  ’’ to ‘‘debit my account $   \n’’ All of these designs are based on cryptography  which we shall study in      Connection-Oriented Versus Connectionless Service Layers can offer two different types of service to the layers above them: connection- oriented and connectionless\n In this tion we will look at these two types and examine the differences between them\n Connection-oriented service is modeled after the telephone system\n To talk to someone  you pick up the phone  dial the number  talk  and then hang up\n Similarly  to use a connection-oriented network service  the service user first establishes a connection  uses the connection  and then releases the connection\n The essential aspect of a connection is that it acts like a tube: the sender pushes objects (bits) in at one end  and the receiver takes them out at the other end\n In most cases the order is preserved so that the bits arrive in the order they were sent\n In some cases when a connection is established  the sender  receiver  and subnet conduct a negotiation about the parameters to be used  such as maximum message size  quality of service required  and other issues\n Typically  one side makes a proposal and the other side can accept it  reject it  or make a counterproposal\n A circuit is another name for a connection with associated resources  such as a fixed bandwidth\n This dates from the telephone network in which a circuit was a path over copper wire that carried a phone conversation\n In contrast to connection-oriented service  connectionless service is modeled after the postal system\n Each message (letter) carries the full destination address INTRODUCTION  \n  and each one is routed through the intermediate nodes inside the system independent of all the subsequent messages\n There are different names for messages in different contexts; a packet is a message at the network layer\n When the intermediate nodes receive a message in full before sending it on to the next node  this is called store-and-forward switching\n The alternative  in which the onward transmission of a message at a node starts before it is completely received by the node  is called cut-through switching\n Normally  when two messages are sent to the same destination  the first one sent will be the first one to arrive\n However  it is possible that the first one sent can be delayed so that the ond one arrives first\n Each kind of service can further be characterized by its reliability\n Some services are reliable in the sense that they never lose data\n Usually  a reliable service is implemented by having the receiver acknowledge the receipt of each message so the sender is sure that it arrived\n The acknowledgement process introduces overhead and delays  which are often worth it but are sometimes undesirable\n A typical situation in which a reliable connection-oriented service is appropriate is file transfer\n The owner of the file wants to be sure that all the bits arrive correctly and in the same order they were sent\n Very few file transfer customers would prefer a service that occasionally scrambles or loses a few bits  even if it is much faster\n Reliable connection-oriented service has two minor variations: message sequences and byte streams\n In the former variant  the message boundaries are preserved\n When two -byte messages are sent  they arrive as two distinct - byte messages  never as one -byte message\n In the latter  the connection is simply a stream of bytes  with no message boundaries\n When  bytes arrive at the receiver  there is no way to tell if they were sent as one -byte message  two -byte messages  or  -byte messages\n If the pages of a book are sent over a network to a phototypesetter as separate messages  it might be important to preserve the message boundaries\n On the other hand  to download a DVD movie  a byte stream from the server to the user’s computer is all that is needed\n Message boundaries within the movie are not relevant\n For some applications  the transit delays introduced by acknowledgements are unacceptable\n One such application is digitized voice traffic for voice over IP\n It is less disruptive for telephone users to hear a bit of noise on the line from time to time than to experience a delay waiting for acknowledgements\n Similarly  when transmitting a video conference  having a few pixels wrong is no problem  but having the image jerk along as the flow stops and starts to correct errors is irritating\n Not all applications require connections\n For example  spammers send electronic junk-mail to many recipients\n The spammer probably does not want to go to the trouble of setting up and later tearing down a connection to a recipient just to send them one item\n Nor is percent reliable delivery essential  especially if it costs more\n All that is needed is a way to send a single message that has a high   NETWORK SOFTWARE   probability of arrival  but no guarantee\n Unreliable (meaning not acknowledged) connectionless service is often called datagram service  in analogy with telegram service  which also does not return an acknowledgement to the sender\n Despite it being unreliable  it is the dominant form in most networks for reasons that will become clear later In other situations  the convenience of not having to establish a connection to send one message is desired  but reliability is essential\n The acknowledged datagram service can be provided for these applications\n It is like sending a registered letter and requesting a return receipt\n When the receipt comes back  the sender is absolutely sure that the letter was delivered to the intended party and not lost along the way\n Text messaging on mobile phones is an example\n Still another service is the request-reply service\n In this service the sender transmits a single datagram containing a request; the reply contains the answer\n Request-reply is commonly used to implement communication in the client-server model: the client issues a request and the server responds to it\n For example  a mobile phone client might send a query to a map server to retrieve the map data for the current location\n Figure  -  summarizes the types of services discussed above\n Reliable message stream Reliable byte stream Unreliable connection Unreliable datagram Acknowledged datagram Request-reply Service Connectionoriented Connectionless Sequence of pages Movie download Voice over IP Electronic junk mail Text messaging Database query Example Figure  -  \n Six different types of service\n The concept of using unreliable communication may be confusing at first\n After all  why would anyone actually prefer unreliable communication to reliable communication? First of all  reliable communication (in our sense  that is  acknowledged) may not be available in a given layer\n For example  Ethernet does not provide reliable communication\n Packets can occasionally be damaged in transit\n It is up to higher protocol levels to recover from this problem\n In particular  many reliable services are built on top of an unreliable datagram service\n ond  the delays inherent in providing a reliable service may be unacceptable  especially in real-time applications such as multimedia\n For these reasons  both reliable and unreliable communication coexist\n   INTRODUCTION  \n     Service Primitives A service is formally specified by a set of primitives (operations) available to user processes to access the service\n These primitives tell the service to perform some action or report on an action taken by a peer entity\n If the protocol stack is located in the operating system  as it often is  the primitives are normally system calls\n These calls cause a trap to kernel mode  which then turns control of the machine over to the operating system to send the necessary packets\n The set of primitives available depends on the nature of the service being provided\n The primitives for connection-oriented service are different from those of connectionless service\n As a minimal example of the service primitives that might provide a reliable byte stream  consider the primitives listed in Fig\n  -  \n They will be familiar to fans of the Berkeley socket interface  as the primitives are a simplified version of that interface\n Primitive Meaning LISTEN Block waiting for an incoming connection CONNECT Establish a connection with a waiting peer ACCEPT Accept an incoming connection from a peer RECEIVE Block waiting for an incoming message SEND Send a message to the peer DISCONNECT Terminate a connection Figure  -  \n Six service primitives that provide a simple connection-oriented service\n These primitives might be used for a request-reply interaction in a client-server environment\n To illustrate how  We sketch a simple protocol that implements the service using acknowledged datagrams\n First  the server executes LISTEN to indicate that it is prepared to accept incoming connections\n A common way to implement LISTEN is to make it a blocking system call\n After executing the primitive  the server process is blocked until a request for connection appears\n Next  the client process executes CONNECT to establish a connection with the server\n The CONNECT call needs to specify who to connect to  so it might have a parameter giving the server’s address\n The operating system then typically sends a packet to the peer asking it to connect  as shown by ( ) in Fig\n  -  \n The client process is suspended until there is a response\n When the packet arrives at the server  the operating system sees that the packet is requesting a connection\n It checks to see if there is a listener  and if so it unblocks the listener\n The server process can then establish the connection with the ACCEPT call\n This sends a response ( ) back to the client process to accept the   NETWORK SOFTWARE   Client machine ( ) Connect request ( ) Accept response System calls Operating Kernel system Client process Protocol Drivers stack Server machine System process Kernel Protocol Drivers stack ( ) Request for data ( ) Reply ( ) Disconnect ( ) Disconnect Figure  -  \n A simple client-server interaction using acknowledged datagrams\n connection\n The arrival of this response then releases the client\n At this point the client and server are both running and they have a connection established\n The obvious analogy between this protocol and real life is a customer (client) calling a company’s customer service manager\n At the start of the day  the service manager sits next to his telephone in case it rings\n Later  a client places a call\n When the manager picks up the phone  the connection is established\n The next step is for the server to execute RECEIVE to prepare to accept the first request\n Normally  the server does this immediately upon being released from the LISTEN  before the acknowledgement can get back to the client\n The RECEIVE call blocks the server\n Then the client executes SEND to transmit its request ( ) followed by the execution of RECEIVE to get the reply\n The arrival of the request packet at the server machine unblocks the server so it can handle the request\n After it has done the work  the server uses SEND to return the answer to the client ( )\n The arrival of this packet unblocks the client  which can now inspect the answer\n If the client has additional requests  it can make them now\n When the client is done  it executes DISCONNECT to terminate the connection ( )\n Usually  an initial DISCONNECT is a blocking call  suspending the client and sending a packet to the server saying that the connection is no longer needed\n When the server gets the packet  it also issues a DISCONNECT of its own  acknowledging the client and releasing the connection ( )\n When the server’s packet gets back to the client machine  the client process is released and the connection is broken\n In a nutshell  this is how connection-oriented communication works\n Of course  life is not so simple\n Many things can go wrong here\n The timing can be wrong ( \n  the CONNECT is done before the LISTEN)  packets can get lost  and much more\n We will look at these issues in great detail later  but for the moment  Fig\n  -  briefly summarizes how client-server communication might work with acknowledged datagrams so that we can ignore lost packets\n Given that six packets are required to complete this protocol  one might wonder why a connectionless protocol is not used instead\n The answer is that in a perfect world it could be  in which case only two packets would be needed: one   INTRODUCTION  \n  for the request and one for the reply\n However  in the face of large messages in either direction ( \n  a megabyte file)  transmission errors  and lost packets  the situation changes\n If the reply consisted of hundreds of packets  some of which could be lost during transmission  how would the client know if some pieces were missing? How would the client know whether the last packet actually received was really the last packet sent? Suppose the client wanted a ond file\n How could it tell packet  from the ond file from a lost packet  from the first file that suddenly found its way to the client? In short  in the real world  a simple request- reply protocol over an unreliable network is often inadequate\n In  \n  we will study a variety of protocols in detail that overcome these and other problems\n For the moment  suffice it to say that having a reliable  ordered byte stream between processes is sometimes very convenient\n    The Relationship of Services to Protocols Services and protocols are distinct concepts\n This distinction is so important that we emphasize it again here\n A service is a set of primitives (operations) that a layer provides to the layer above it\n The service defines what operations the layer is prepared to perform on behalf of its users  but it says nothing at all about how these operations are implemented\n A service relates to an interface between two layers  with the lower layer being the service provider and the upper layer being the service user\n A protocol  in contrast  is a set of rules governing the format and meaning of the packets  or messages that are exchanged by the peer entities within a layer\n Entities use protocols to implement their service definitions\n They are free to change their protocols at will  provided they do not change the service visible to their users\n In this way  the service and the protocol are completely decoupled\n This is a key concept that any network designer should understand well\n To repeat this crucial point  services relate to the interfaces between layers  as illustrated in Fig\n  -  \n In contrast  protocols relate to the packets sent between peer entities on different machines\n It is very important not to confuse the two concepts\n An analogy with programming languages is worth making\n A service is like an abstract data type or an object in an object-oriented language\n It defines operations that can be performed on an object but does not specify how these operations are implemented\n In contrast  a protocol relates to the implementation of the service and as such is not visible to the user of the service\n Many older protocols did not distinguish the service from the protocol\n In effect  a typical layer might have had a service primitive SEND PACKET with the user providing a pointer to a fully assembled packet\n This arrangement meant that all changes to the protocol were immediately visible to the users\n Most network designers now regard such a design as a serious blunder\n   REFERENCE MODELS   Layer k Layer k +  Layer k -  Protocol Service provided by layer k Layer k Layer k +  Layer k -  Figure  -  \n The relationship between a service and a protocol  REFERENCE MODELS Now that we have discussed layered networks in the abstract  it is time to look at some examples\n We will discuss two important network architectures: the OSI reference model and the TCP/IP reference model\n Although the protocols associated with the OSI model are not used any more  the model itself is actually quite general and still valid  and the features discussed at each layer are still very important\n The TCP/IP model has the opposite properties: the model itself is not of much use but the protocols are widely used\n For this reason we will look at both of them in detail\n Also  sometimes you can learn more from failures than from successes\n    The OSI Reference Model The OSI model (minus the physical medium) is shown in Fig\n  -  \n This model is based on a proposal developed by the International Standards Organization (ISO) as a first step toward international standardization of the protocols used in the various layers (Day and Zimmermann  )\n It was revised in  (Day  )\n The model is called the ISO OSI (Open Systems Interconnection) Reference Model because it deals with connecting open systems—that is  systems that are open for communication with other systems\n We will just call it the OSI model for short\n The OSI model has seven layers\n The principles that were applied to arrive at the seven layers can be briefly summarized as follows:  \n A layer should be created where a different abstraction is needed Each layer should perform a well-defined function The function of each layer should be chosen with an eye toward defining internationally standardized protocols\n   INTRODUCTION  \n  Layer Presentation Application Session Transport Network Data link Physical  Interface Host A Name of unit exchanged APDU PPDU SPDU TPDU Packet Frame Bit Presentation Application Session Transport Network Data link Physical Host B Network Network Data link Data link Physical Physical Router Router Internal subnet protocol Application protocol Presentation protocol Transport protocol Session protocol Communication subnet boundary Network layer host-router protocol Data link layer host-router protocol Physical layer host-router protocol Figure  -  \n The OSI reference model The layer boundaries should be chosen to minimize the information flow across the interfaces The number of layers should be large enough that distinct functions need not be thrown together in the same layer out of necessity and small enough that the architecture does not become unwieldy\n Below we will discuss each layer of the model in turn  starting at the bottom layer\n Note that the OSI model itself is not a network architecture because it does not specify the exact services and protocols to be used in each layer\n It just tells what each layer should do\n However  ISO has also produced standards for all the layers  although these are not part of the reference model itself\n Each one has been published as a separate international standard\n The model (in part) is widely used although the associated protocols have been long forgotten\n   REFERENCE MODELS   The Physical Layer The physical layer is concerned with transmitting raw bits over a communication channel\n The design issues have to do with making sure that when one side sends a  bit it is received by the other side as a  bit  not as a  bit\n Typical questions here are what electrical signals should be used to represent a  and a   how many nanoonds a bit lasts  whether transmission may proceed simultaneously in both directions  how the initial connection is established  how it is torn down when both sides are finished  how many pins the network connector has  and what each pin is used for\n These design issues largely deal with mechanical  electrical  and timing interfaces  as well as the physical transmission medium  which lies below the physical layer\n The Data Link Layer The main task of the data link layer is to transform a raw transmission facility into a line that appears free of undetected transmission errors\n It does so by masking the real errors so the network layer does not see them\n It accomplishes this task by having the sender break up the input data into data frames (typically a few hundred or a few thousand bytes) and transmit the frames sequentially\n If the service is reliable  the receiver confirms correct receipt of each frame by sending back an acknowledgement frame\n Another issue that arises in the data link layer (and most of the higher layers as well) is how to keep a fast transmitter from drowning a slow receiver in data\n Some traffic regulation mechanism may be needed to let the transmitter know when the receiver can accept more data\n Broadcast networks have an additional issue in the data link layer: how to control access to the shared channel\n A special sublayer of the data link layer  the medium access control sublayer  deals with this problem\n The Network Layer The network layer controls the operation of the subnet\n A key design issue is determining how packets are routed from source to destination\n Routes can be based on static tables that are ‘‘wired into’’ the network and rarely changed  or more often they can be updated automatically to avoid failed components\n They can also be determined at the start of each conversation  for example  a terminal session  such as a login to a remote machine\n Finally  they can be highly dynamic  being determined anew for each packet to reflect the current network load\n If too many packets are present in the subnet at the same time  they will get in one another’s way  forming bottlenecks\n Handling congestion is also a responsibility of the network layer  in conjunction with higher layers that adapt the load   INTRODUCTION  \n  they place on the network\n More generally  the quality of service provided (delay  transit time  jitter  etc\n) is also a network layer issue\n When a packet has to travel from one network to another to get to its destination  many problems can arise\n The addressing used by the ond network may be different from that used by the first one\n The ond one may not accept the packet at all because it is too large\n The protocols may differ  and so on\n It is up to the network layer to overcome all these problems to allow heterogeneous networks to be interconnected\n In broadcast networks  the routing problem is simple  so the network layer is often thin or even nonexistent\n The Transport Layer The basic function of the transport layer is to accept data from above it  split it up into smaller units if need be  pass these to the network layer  and ensure that the pieces all arrive correctly at the other end\n Furthermore  all this must be done efficiently and in a way that isolates the upper layers from the inevitable changes in the hardware technology over the course of time\n The transport layer also determines what type of service to provide to the session layer  and  ultimately  to the users of the network\n The most popular type of transport connection is an error-free point-to-point channel that delivers messages or bytes in the order in which they were sent\n However  other possible kinds of transport service exist  such as the transporting of isolated messages with no guarantee about the order of delivery  and the broadcasting of messages to multiple destinations\n The type of service is determined when the connection is established\n (As an aside  an error-free channel is completely impossible to achieve; what people really mean by this term is that the error rate is low enough to ignore in practice\n) The transport layer is a true end-to-end layer; it carries data all the way from the source to the destination\n In other words  a program on the source machine carries on a conversation with a similar program on the destination machine  using the message headers and control messages\n In the lower layers  each protocols is between a machine and its immediate neighbors  and not between the ultimate source and destination machines  which may be separated by many routers\n The difference between layers  through   which are chained  and layers  through   which are end-to-end  is illustrated in Fig\n  -  \n The Session Layer The session layer allows users on different machines to establish sessions between them\n Sessions offer various services  including dialog control (keeping track of whose turn it is to transmit)  token management (preventing two parties from attempting the same critical operation simultaneously)  and synchronization   REFERENCE MODELS   (checkpointing long transmissions to allow them to pick up from where they left off in the event of a crash and subsequent recovery)\n The Presentation Layer Unlike the lower layers  which are mostly concerned with moving bits around  the presentation layer is concerned with the syntax and semantics of the information transmitted\n In order to make it possible for computers with different internal data representations to communicate  the data structures to be exchanged can be defined in an abstract way  along with a standard encoding to be used ‘‘on the wire\n’’ The presentation layer manages these abstract data structures and allows higher-level data structures ( \n  banking records) to be defined and exchanged\n The Application Layer The application layer contains a variety of protocols that are commonly needed by users\n One widely used application protocol is HTTP (HyperText Transfer Protocol)  which is the basis for the World Wide Web\n When a browser wants a Web page  it sends the name of the page it wants to the server hosting the page using HTTP\n The server then sends the page back\n Other application protocols are used for file transfer  electronic mail  and network news\n    The TCP/IP Reference Model Let us now turn from the OSI reference model to the reference model used in the grandparent of all wide area computer networks  the ARPANET  and its successor  the worldwide Internet\n Although we will give a brief history of the ARPANET later  it is useful to mention a few key aspects of it now\n The ARPANET was a research network sponsored by the DoD ( \n Department of Defense)\n It eventually connected hundreds of universities and government installations  using leased telephone lines\n When satellite and radio networks were added later  the existing protocols had trouble interworking with them  so a new reference architecture was needed\n Thus  from nearly the beginning  the ability to connect multiple networks in a seamless way was one of the major design goals\n This architecture later became known as the TCP/IP Reference Model  after its two primary protocols\n It was first described by Cerf and Kahn (   )  and later refined and defined as a standard in the Internet community (Braden  )\n The design philosophy behind the model is discussed by Clark (   )\n Given the DoD’s worry that some of its precious hosts  routers  and internetwork gateways might get blown to pieces at a moment’s notice by an attack from the Soviet Union  another major goal was that the network be able to survive loss of subnet hardware  without existing conversations being broken off\n In other   INTRODUCTION  \n  words  the DoD wanted connections to remain intact as long as the source and destination machines were functioning  even if some of the machines or transmission lines in between were suddenly put out of operation\n Furthermore  since applications with divergent requirements were envisioned  ranging from transferring files to real-time speech transmission  a flexible architecture was needed\n The Link Layer All these requirements led to the choice of a packet-switching network based on a connectionless layer that runs across different networks\n The lowest layer in the model  the link layer describes what links such as serial lines and classic Ethernet must do to meet the needs of this connectionless internet layer\n It is not really a layer at all  in the normal sense of the term  but rather an interface between hosts and transmission links\n Early material on the TCP/IP model has little to say about it\n The Internet Layer The internet layer is the linchpin that holds the whole architecture together\n It is shown in Fig\n  -  as corresponding roughly to the OSI network layer\n Its job is to permit hosts to inject packets into any network and have them travel independently to the destination (potentially on a different network)\n They may even arrive in a completely different order than they were sent  in which case it is the job of higher layers to rearrange them  if in-order delivery is desired\n Note that ‘‘internet’’ is used here in a generic sense  even though this layer is present in the Internet\n OSI TCP/IP Application Presentation Session Transport Network Data link Physical  Application Transport Internet Link Not present in the model Figure  -  \n The TCP/IP reference model\n The analogy here is with the (snail) mail system\n A person can drop a sequence of international letters into a mailbox in one country  and with a little luck    REFERENCE MODELS   most of them will be delivered to the correct address in the destination country\n The letters will probably travel through one or more international mail gateways along the way  but this is transparent to the users\n Furthermore  that each country ( \n  each network) has its own stamps  preferred envelope sizes  and delivery rules is hidden from the users\n The internet layer defines an official packet format and protocol called IP (Internet Protocol)  plus a companion protocol called ICMP (Internet Control Message Protocol) that helps it function\n The job of the internet layer is to deliver IP packets where they are supposed to go\n Packet routing is clearly a major issue here  as is congestion (though IP has not proven effective at avoiding congestion)\n The Transport Layer The layer above the internet layer in the TCP/IP model is now usually called the transport layer\n It is designed to allow peer entities on the source and destination hosts to carry on a conversation  just as in the OSI transport layer\n Two end-to-end transport protocols have been defined here\n The first one  TCP (Transmission Control Protocol)  is a reliable connection-oriented protocol that allows a byte stream originating on one machine to be delivered without error on any other machine in the internet\n It segments the incoming byte stream into discrete messages and passes each one on to the internet layer\n At the destination  the receiving TCP process reassembles the received messages into the output stream\n TCP also handles flow control to make sure a fast sender cannot swamp a slow receiver with more messages than it can handle\n The ond protocol in this layer  UDP (User Datagram Protocol)  is an unreliable  connectionless protocol for applications that do not want TCP’s sequencing or flow control and wish to provide their own\n It is also widely used for one-shot  client-server-type request-reply queries and applications in which prompt delivery is more important than accurate delivery  such as transmitting speech or video\n The relation of IP  TCP  and UDP is shown in Fig\n  -  \n Since the model was developed  IP has been implemented on many other networks\n The Application Layer The TCP/IP model does not have session or presentation layers\n No need for them was perceived\n Instead  applications simply include any session and presentation functions that they require\n Experience with the OSI model has proven this view correct: these layers are of little use to most applications\n On top of the transport layer is the application layer\n It contains all the higher- level protocols\n The early ones included virtual terminal (TELNET)  file transfer (FTP)  and electronic mail (SMTP)\n Many other protocols have been added to these over the years\n Some important ones that we will study  shown in Fig\n  -  INTRODUCTION  \n  Link DSL SONET   \n  Ethernet IP ICMP HTTP SMTP RTP DNS TCP UDP Internet Transport Layers Protocols Application Figure  -  \n The TCP/IP model with some protocols we will study\n include the Domain Name System (DNS)  for mapping host names onto their network addresses  HTTP  the protocol for fetching pages on the World Wide Web  and RTP  the protocol for delivering real-time media such as voice or movies\n    The Model Used in This Book As mentioned earlier  the strength of the OSI reference model is the model itself (minus the presentation and session layers)  which has proven to be exceptionally useful for discussing computer networks\n In contrast  the strength of the TCP/IP reference model is the protocols  which have been widely used for many years\n Since computer scientists like to have their cake and eat it  too  we will use the hybrid model of Fig\n  -  as the framework for this book\n  Application  Transport  Network  Link  Physical Figure  -  \n The reference model used in this book\n This model has five layers  running from the physical layer up through the link  network and transport layers to the application layer\n The physical layer specifies how to transmit bits across different kinds of media as electrical (or other analog) signals\n The link layer is concerned with how to send finite-length messages between directly connected computers with specified levels of reliability\n Ethernet and   \n  are examples of link layer protocols\n   REFERENCE MODELS   The network layer deals with how to combine multiple links into networks  and networks of networks  into internetworks so that we can send packets between distant computers\n This includes the task of finding the path along which to send the packets\n IP is the main example protocol we will study for this layer\n The transport layer strengthens the delivery guarantees of the Network layer  usually with increased reliability  and provide delivery abstractions  such as a reliable byte stream  that match the needs of different applications\n TCP is an important example of a transport layer protocol\n Finally  the application layer contains programs that make use of the network\n Many  but not all  networked applications have user interfaces  such as a Web browser\n Our concern  however  is with the portion of the program that uses the network\n This is the HTTP protocol in the case of the Web browser\n There are also important support programs in the application layer  such as the DNS  that are used by many applications\n Our  ter sequence is based on this model\n In this way  we retain the value of the OSI model for understanding network architectures  but concentrate primarily on protocols that are important in practice  from TCP/IP and related protocols to newer ones such as   \n   SONET  and Bluetooth\n    A Comparison of the OSI and TCP/IP Reference Models The OSI and TCP/IP reference models have much in common\n Both are based on the concept of a stack of independent protocols\n Also  the functionality of the layers is roughly similar\n For example  in both models the layers up through and including the transport layer are there to provide an end-to-end  network- independent transport service to processes wishing to communicate\n These layers form the transport provider\n Again in both models  the layers above transport are application-oriented users of the transport service\n Despite these fundamental similarities  the two models also have many differences\n In this tion we will focus on the key differences between the two reference models\n It is important to note that we are comparing the reference models here  not the corresponding protocol stacks\n The protocols themselves will be discussed later\n For an entire book comparing and contrasting TCP/IP and OSI  see Piscitello and  in (   )\n Three concepts are central to the OSI model:  \n Services Interfaces Protocols\n Probably the biggest contribution of the OSI model is that it makes the distinction between these three concepts explicit\n Each layer performs some services for the   INTRODUCTION  \n  layer above it\n The service definition tells what the layer does  not how entities above it access it or how the layer works\n It defines the layer’s semantics\n A layer’s interface tells the processes above it how to access it\n It specifies what the parameters are and what results to expect\n It  too  says nothing about how the layer works inside\n Finally  the peer protocols used in a layer are the layer’s own business\n It can use any protocols it wants to  as long as it gets the job done ( \n  provides the offered services)\n It can also change them at will without affecting software in higher layers\n These ideas fit very nicely with modern ideas about object-oriented programming\n An object  like a layer  has a set of methods (operations) that processes outside the object can invoke\n The semantics of these methods define the set of services that the object offers\n The methods’ parameters and results form the object’s interface\n The code internal to the object is its protocol and is not visible or of any concern outside the object\n The TCP/IP model did not originally clearly distinguish between services  interfaces  and protocols  although people have tried to retrofit it after the fact to make it more OSI-like\n For example  the only real services offered by the internet layer are SEND IP PACKET and RECEIVE IP PACKET\n As a consequence  the protocols in the OSI model are better hidden than in the TCP/IP model and can be replaced relatively easily as the technology changes\n Being able to make such changes transparently is one of the main purposes of having layered protocols in the first place\n The OSI reference model was devised before the corresponding protocols were invented\n This ordering meant that the model was not biased toward one particular set of protocols  a fact that made it quite general\n The downside of this ordering was that the designers did not have much experience with the subject and did not have a good idea of which functionality to put in which layer\n For example  the data link layer originally dealt only with point-to-point networks\n When broadcast networks came around  a new sublayer had to be hacked into the model\n Furthermore  when people started to build real networks using the OSI model and existing protocols  it was discovered that these networks did not match the required service specifications (wonder of wonders)  so convergence sublayers had to be grafted onto the model to provide a place for papering over the differences\n Finally  the committee originally expected that each country would have one network  run by the government and using the OSI protocols  so no thought was given to internetworking\n To make a long story short  things did not turn out that way\n With TCP/IP the reverse was true: the protocols came first  and the model was really just a description of the existing protocols\n There was no problem with the protocols fitting the model\n They fit perfectly\n The only trouble was that the model did not fit any other protocol stacks\n Consequently  it was not especially useful for describing other  non-TCP/IP networks\n   REFERENCE MODELS   Turning from philosophical matters to more specific ones  an obvious difference between the two models is the number of layers: the OSI model has seven layers and the TCP/IP model has four\n Both have (inter)network  transport  and application layers  but the other layers are different\n Another difference is in the area of connectionless versus connection-oriented communication\n The OSI model supports both connectionless and connectionoriented communication in the network layer  but only connection-oriented communication in the transport layer  where it counts (because the transport service is visible to the users)\n The TCP/IP model supports only one mode in the network layer (connectionless) but both in the transport layer  giving the users a choice\n This choice is especially important for simple request-response protocols\n    A Critique of the OSI Model and Protocols Neither the OSI model and its protocols nor the TCP/IP model and its protocols are perfect\n Quite a bit of criticism can be  and has been  directed at both of them\n In this tion and the next one  we will look at some of these criticisms\n We will begin with OSI and examine TCP/IP afterward\n At the time the ond edition of this book was published (   )  it appeared to many experts in the field that the OSI model and its protocols were going to take over the world and push everything else out of their way\n This did not happen\n Why? A look back at some of the reasons may be useful\n They can be summarized as:  \n Bad timing Bad technology Bad implementations Bad politics\n Bad Timing First let us look at reason one: bad timing\n The time at which a standard is established is absolutely critical to its success\n David Clark of  \n has a theory of standards that he calls the apocalypse of the two elephants  which is illustrated in Fig\n  -  \n This figure shows the amount of activity surrounding a new subject\n When the subject is first discovered  there is a burst of research activity in the form of discussions  papers  and meetings\n After a while this activity subsides  corporations discover the subject  and the billion-dollar wave of investment hits\n It is essential that the standards be written in the trough in between the two ‘‘elephants\n’’ If they are written too early (before the research results are well   INTRODUCTION  \n  Time Activity Research Standards Billion dollar investment Figure  -  \n The apocalypse of the two elephants\n established)  the subject may still be poorly understood; the result is a bad standard\n If they are written too late  so many companies may have already made major investments in different ways of doing things that the standards are effectively ignored\n If the interval between the two elephants is very short (because everyone is in a hurry to get started)  the people developing the standards may get crushed\n It now appears that the standard OSI protocols got crushed\n The competing TCP/IP protocols were already in widespread use by research universities by the time the OSI protocols appeared\n While the billion-dollar wave of investment had not yet hit  the academic market was large enough that many vendors had begun cautiously offering TCP/IP products\n When OSI came around  they did not want to support a ond protocol stack until they were forced to  so there were no initial offerings\n With every company waiting for every other company to go first  no company went first and OSI never happened\n Bad Technology The ond reason that OSI never caught on is that both the model and the protocols are flawed\n The choice of seven layers was more political than technical  and two of the layers (session and presentation) are nearly empty  whereas two other ones (data link and network) are overfull\n The OSI model  along with its associated service definitions and protocols  is extraordinarily complex\n When piled up  the printed standards occupy a significant fraction of a meter of paper\n They are also difficult to implement and inefficient in operation\n In this context  a riddle posed by Paul Mockapetris and cited by Rose (   ) comes to mind: Q: What do you get when you cross a mobster with an international standard? A: Someone who makes you an offer you can’t understand\n   REFERENCE MODELS   In addition to being incomprehensible  another problem with OSI is that some functions  such as addressing  flow control  and error control  reappear again and again in each layer\n Saltzer et al\n (   )  for example  have pointed out that to be effective  error control must be done in the highest layer  so that repeating it over and over in each of the lower layers is often unnecessary and inefficient\n Bad Implementations Given the enormous complexity of the model and the protocols  it will come as no surprise that the initial implementations were huge  unwieldy  and slow\n Everyone who tried them got burned\n It did not take long for people to associate ‘‘OSI’’ with ‘‘poor quality\n’’ Although the products improved in the course of time  the image stuck\n In contrast  one of the first implementations of TCP/IP was part of Berkeley UNIX and was quite good (not to mention  free)\n People began using it quickly  which led to a large user community  which led to improvements  which led to an even larger community\n Here the spiral was upward instead of downward\n Bad Politics On account of the initial implementation  many people  especially in academia  thought of TCP/IP as part of UNIX  and UNIX in the s in academia was not unlike parenthood (then incorrectly called motherhood) and apple pie\n OSI  on the other hand  was widely thought to be the creature of the European telecommunication ministries  the European Community  and later the  \n Government\n This belief was only partly true  but the very idea of a bunch of government bureaucrats trying to shove a technically inferior standard down the throats of the poor researchers and programmers down in the trenches actually developing computer networks did not aid OSI’s cause\n Some people viewed this development in the same light as IBM announcing in the s that PL/I was the language of the future  or the DoD correcting this later by announcing that it was actually Ada\n    A Critique of the TCP/IP Reference Model The TCP/IP model and protocols have their problems too\n First  the model does not clearly distinguish the concepts of services  interfaces  and protocols\n Good software engineering practice requires differentiating between the specification and the implementation  something that OSI does very carefully  but TCP/IP does not\n Consequently  the TCP/IP model is not much of a guide for designing new networks using new technologies\n ond  the TCP/IP model is not at all general and is poorly suited to describing any protocol stack other than TCP/IP\n Trying to use the TCP/IP model to describe Bluetooth  for example  is completely impossible\n   INTRODUCTION  \n  Third  the link layer is not really a layer at all in the normal sense of the term as used in the context of layered protocols\n It is an interface (between the network and data link layers)\n The distinction between an interface and a layer is crucial  and one should not be sloppy about it\n Fourth  the TCP/IP model does not distinguish between the physical and data link layers\n These are completely different\n The physical layer has to do with the transmission characteristics of copper wire  fiber optics  and wireless communication\n The data link layer’s job is to delimit the start and end of frames and get them from one side to the other with the desired degree of reliability\n A proper model should include both as separate layers\n The TCP/IP model does not do this\n Finally  although the IP and TCP protocols were carefully thought out and well implemented  many of the other protocols were ad hoc  generally produced by a couple of graduate students hacking away until they got tired\n The protocol implementations were then distributed free  which resulted in their becoming widely used  deeply entrenched  and thus hard to replace\n Some of them are a bit of an embarrassment now\n The virtual terminal protocol  TELNET  for example  was designed for a ten-character-per-ond mechanical Teletype terminal\n It knows nothing of graphical user interfaces and mice\n Nevertheless  it is still in use some   years later  EXAMPLE NETWORKS The subject of computer networking covers many different kinds of networks  large and small  well known and less well known\n They have different goals  scales  and technologies\n In the following tions  we will look at some examples  to get an idea of the variety one finds in the area of computer networking\n We will start with the Internet  probably the best known network  and look at its history  evolution  and technology\n Then we will consider the mobile phone network\n Technically  it is quite different from the Internet  contrasting nicely with it\n Next we will introduce IEEE   \n   the dominant standard for wireless LANs\n Finally  we will look at RFID and sensor networks  technologies that extend the reach of the network to include the physical world and everyday objects\n    The Internet The Internet is not really a network at all  but a vast collection of different networks that use certain common protocols and provide certain common services\n It is an unusual system in that it was not planned by anyone and is not controlled by anyone\n To better understand it  let us start from the beginning and see how it has developed and why\n For a wonderful history of the Internet  John Naughton’s (   ) book is highly recommended\n It is one of those rare books that is not only fun to read  but also has   pages of ibid\n’s and op\n cit\n’s for the serious historian\n Some of the material in this tion is based on this book\n   EXAMPLE NETWORKS   Of course  countless technical books have been written about the Internet and its protocols as well\n For more information  see  for example  Maufer (   )\n The ARPANET The story begins in the late s\n At the height of the Cold War  the  \n DoD wanted a command-and-control network that could survive a nuclear war\n At that time  all military communications used the public telephone network  which was considered vulnerable\n The reason for this belief can be gleaned from Fig\n  -  (a)\n Here the black dots represent telephone switching offices  each of which was connected to thousands of telephones\n These switching offices were  in turn  connected to higher-level switching offices (toll offices)  to form a national hierarchy with only a small amount of redundancy\n The vulnerability of the system was that the destruction of a few key toll offices could fragment it into many isolated islands\n (a) Toll office Switching office (b) Figure  -  \n (a) Structure of the telephone system\n (b) Baran’s proposed distributed switching system\n Around  the DoD awarded a contract to the RAND Corporation to find a solution\n One of its employees  Paul Baran  came up with the highly distributed and fault-tolerant design of Fig\n  -  (b)\n Since the paths between any two switching offices were now much longer than analog signals could travel without distortion  Baran proposed using digital packet-switching technology\n Baran wrote several reports for the DoD describing his ideas in detail (Baran  )\n Officials at the Pentagon liked the concept and asked AT&T  then the  \n’ national telephone monopoly  to build a prototype\n AT&T dismissed Baran’s ideas out of hand\n The biggest and richest corporation in the world was not about to allow   INTRODUCTION  \n  some young whippersnapper tell it how to build a telephone system\n They said Baran’s network could not be built and the idea was killed\n Several years went by and still the DoD did not have a better command-andcontrol system\n To understand what happened next  we have to go back all the way to October  when the Soviet Union beat the  \n into space with the launch of the first artificial satellite  Sputnik\n When President Eisenhower tried to find out who was asleep at the switch  he was appalled to find the Army  Navy  and Air Force squabbling over the Pentagon’s research budget\n His immediate response was to create a single defense research organization  ARPA  the Advanced Research Projects Agency\n ARPA had no scientists or laboratories; in fact  it had nothing more than an office and a small (by Pentagon standards) budget\n It did its work by issuing grants and contracts to universities and companies whose ideas looked promising to it\n For the first few years  ARPA tried to figure out what its mission should be\n In  the attention of Larry Roberts  a program manager at ARPA who was trying to figure out how to provide remote access to computers  turned to networking\n He contacted various experts to decide what to do\n One of them  Wesley Clark  suggested building a packet-switched subnet  connecting each host to its own router\n After some initial skepticism  Roberts bought the idea and presented a somewhat vague paper about it at the ACM SIGOPS Symposium on Operating System Principles held in Gatlinburg  Tennessee in late  (Roberts  )\n Much to Roberts’ surprise  another paper at the conference described a similar system that had not only been designed but actually fully implemented under the direction of Donald Davies at the National Physical Laboratory in England\n The NPL system was not a national system (it just connected several computers on the NPL campus)  but it demonstrated that packet switching could be made to work\n Furthermore  it cited Baran’s now discarded earlier work\n Roberts came away from Gatlinburg determined to build what later became known as the ARPANET\n The subnet would consist of minicomputers called IMPs (Interface Message Processors) connected by  -kbps transmission lines\n For high reliability  each IMP would be connected to at least two other IMPs\n The subnet was to be a datagram subnet  so if some lines and IMPs were destroyed  messages could be automatically rerouted along alternative paths\n Each node of the network was to consist of an IMP and a host  in the same room  connected by a short wire\n A host could send messages of up to  bits to its IMP  which would then break these up into packets of at most  bits and forward them independently toward the destination\n Each packet was received in its entirety before being forwarded  so the subnet was the first electronic storeand- forward packet-switching network\n ARPA then put out a tender for building the subnet\n Twelve companies bid for it\n After evaluating all the proposals  ARPA selected BBN  a consulting firm based in Cambridge  Massachusetts  and in December  awarded it a contract   EXAMPLE NETWORKS   to build the subnet and write the subnet software\n BBN chose to use specially modified Honeywell DDP-   minicomputers with  K  -bit words of core memory as the IMPs\n The IMPs did not have disks  since moving parts were considered unreliable\n The IMPs were interconnected by  -kbps lines leased from telephone companies\n Although   kbps is now the choice of teenagers who cannot afford DSL or cable  it was then the best money could buy\n The software was split into two parts: subnet and host\n The subnet software consisted of the IMP end of the host-IMP connection  the IMP-IMP protocol  and a source IMP to destination IMP protocol designed to improve reliability\n The original ARPANET design is shown in Fig\n  -  \n Host-IMP protocol Host-host protocol Source IMP to destination IMP protocol IMP-IMP protocol IMP-IMP protocol Host IMP Subnet Figure  -  \n The original ARPANET design\n Outside the subnet  software was also needed  namely  the host end of the host-IMP connection  the host-host protocol  and the application software\n It soon became clear that BBN was of the opinion that when it had accepted a message on a host-IMP wire and placed it on the host-IMP wire at the destination  its job was done\n Roberts had a problem  though: the hosts needed software too\n To deal with it  he convened a meeting of network researchers  mostly graduate students  at Snowbird  Utah  in the summer of \n The graduate students expected some network expert to explain the grand design of the network and its software to them and then assign each of them the job of writing part of it\n They were astounded when there was no network expert and no grand design\n They had to figure out what to do on their own\n Nevertheless  somehow an experimental network went online in December  with four nodes: at UCLA  UCSB  SRI  and the University of Utah\n These four were chosen because all had a large number of ARPA contracts  and all had different and completely incompatible host computers (just to make it more fun)\n The first host-to-host message had been sent two months earlier from the UCLA   INTRODUCTION  \n  node by a team led by Len Kleinrock (a pioneer of the theory of packet switching) to the SRI node\n The network grew quickly as more IMPs were delivered and installed; it soon spanned the United States\n Figure  -  shows how rapidly the ARPANET grew in the first  years\n MIT UCLA UCLA RAND BBN SRI UTAH ILLINOIS MIT LINCOLN CASE CARN RAND BBN HARVARD BURROUGHS SDC STAN UCLA SRI UTAH UCSB SDC UCSB SRI UTAH UCSB NCAR GWC LINCOLN CASE MITRE ETAC RAND TINKER BBN HARVARD NBS SDC AMES USC STAN UCLA CARN SRI UTAH MCCLELLAN UCSB ILLINOIS LINC RADC MIT ILLINOIS MIT LINC RADC UTAH TINKER RAND SRI LBL MCCLELLAN AMES TIP AMES IMP X-PARC FNWC UCSB UCSD STANFORD CCA BBN HARVARD ABERDEEN NBS ETAC ARPA MITRE SAAC BELVOIR CMU UCLA SDC USC NOAA GWC CASE (a) (d) (b) (c) (e) Figure  -  \n Growth of the ARPANET\n (a) December \n (b) July \n (c) March \n (d) April \n (e) September \n In addition to helping the fledgling ARPANET grow  ARPA also funded research on the use of satellite networks and mobile packet radio networks\n In one now famous demonstration  a truck driving around in California used the packet radio network to send messages to SRI  which were then forwarded over the ARPANET to the East Coast  where they were shipped to University College in London over the satellite network\n This allowed a researcher in the truck to use a computer in London while driving around in California\n This experiment also demonstrated that the existing ARPANET protocols were not suitable for running over different networks\n This observation led to more research on protocols  culminating with the invention of the TCP/IP model and protocols (Cerf and Kahn  )\n TCP/IP was specifically designed to handle communication over internetworks  something becoming increasingly important as more and more networks were hooked up to the ARPANET\n   EXAMPLE NETWORKS   To encourage adoption of these new protocols  ARPA awarded several contracts to implement TCP/IP on different computer platforms  including IBM  DEC  and HP systems  as well as for Berkeley UNIX\n Researchers at the University of California at Berkeley rewrote TCP/IP with a new programming interface called sockets for the upcoming  \n BSD release of Berkeley UNIX\n They also wrote many application  utility  and management programs to show how convenient it was to use the network with sockets\n The timing was perfect\n Many universities had just acquired a ond or third VAX computer and a LAN to connect them  but they had no networking software\n When  \n BSD came along  with TCP/IP  sockets  and many network utilities  the complete package was adopted immediately\n Furthermore  with TCP/IP  it was easy for the LANs to connect to the ARPANET  and many did\n During the s  additional networks  especially LANs  were connected to the ARPANET\n As the scale increased  finding hosts became increasingly expensive  so DNS (Domain Name System) was created to organize machines into domains and map host names onto IP addresses\n Since then  DNS has become a generalized  distributed database system for storing a variety of information related to naming\n We will study it in detail in   NSFNET By the late s  NSF (the  \n National Science Foundation) saw the enormous impact the ARPANET was having on university research  allowing scientists across the country to share data and collaborate on research projects\n However  to get on the ARPANET a university had to have a research contract with the DoD\n Many did not have a contract\n NSF’s initial response was to fund the Computer Science Network (CSNET) in \n It connected computer science departments and industrial research labs to the ARPANET via dial-up and leased lines\n In the late s  the NSF went further and decided to design a successor to the ARPANET that would be open to all university research groups\n To have something concrete to start with  NSF decided to build a backbone network to connect its six supercomputer centers  in San Diego  Boulder  Champaign  Pittsburgh  Ithaca  and Princeton\n Each supercomputer was given a little brother  consisting of an LSI-  microcomputer called a fuzzball\n The fuzzballs were connected with  -kbps leased lines and formed the subnet  the same hardware technology the ARPANET used\n The software technology was different however: the fuzzballs spoke TCP/IP right from the start  making it the first TCP/IP WAN\n NSF also funded some (eventually about  ) regional networks that connected to the backbone to allow users at thousands of universities  research labs  libraries  and museums to access any of the supercomputers and to communicate with one another\n The complete network  including backbone and the regional networks  was called NSFNET\n It connected to the ARPANET through a link between an   INTRODUCTION  \n  IMP and a fuzzball in the Carnegie-Mellon machine room\n The first NSFNET backbone is illustrated in Fig\n  -  superimposed on a map of the  \n NSF Supercomputer center NSF Midlevel network Both Figure  -  \n The NSFNET backbone in \n NSFNET was an instantaneous success and was overloaded from the word go\n NSF immediately began planning its successor and awarded a contract to the Michigan-based MERIT consortium to run it\n Fiber optic channels at kbps were leased from MCI (since merged with WorldCom) to provide the version  backbone\n IBM PC-RTs were used as routers\n This  too  was soon overwhelmed  and by  the ond backbone was upgraded to  \n  Mbps\n As growth continued  NSF realized that the government could not continue financing networking forever\n Furthermore  commercial organizations wanted to join but were forbidden by NSF’s charter from using networks NSF paid for\n Consequently  NSF encouraged MERIT  MCI  and IBM to form a nonprofit corporation  ANS (Advanced Networks and Services)  as the first step along the road to commercialization\n In  ANS took over NSFNET and upgraded the  \n -Mbps links to   Mbps to form ANSNET\n This network operated for  years and was then sold to America Online\n But by then  various companies were offering commercial IP service and it was clear the government should now get out of the networking business\n To ease the transition and make sure every regional network could communicate with every other regional network  NSF awarded contracts to four different network operators to establish a NAP (Network Access Point)\n These operators were PacBell (San Francisco)  Ameritech (Chicago)  MFS (Washington   \n)  and Sprint (New York City  where for NAP purposes  Pennsauken  New Jersey counts as New York City)\n Every network operator that wanted to provide backbone service to the NSF regional networks had to connect to all the NAPs\n   EXAMPLE NETWORKS   This arrangement meant that a packet originating on any regional network had a choice of backbone carriers to get from its NAP to the destination’s NAP\n Consequently  the backbone carriers were forced to compete for the regional networks’ business on the basis of service and price  which was the idea  of course\n As a result  the concept of a single default backbone was replaced by a commercially driven competitive infrastructure\n Many people like to criticize the Federal Government for not being innovative  but in the area of networking  it was DoD and NSF that created the infrastructure that formed the basis for the Internet and then handed it over to industry to operate\n During the s  many other countries and regions also built national research networks  often patterned on the ARPANET and NSFNET\n These included EuropaNET and EBONE in Europe  which started out with  -Mbps lines and then upgraded to  -Mbps lines\n Eventually  the network infrastructure in Europe was handed over to industry as well\n The Internet has changed a great deal since those early days\n It exploded in size with the emergence of the World Wide Web (WWW) in the early s\n Recent data from the Internet Systems Consortium puts the number of visible Internet hosts at over million\n This guess is only a low-ball estimate  but it far exceeds the few million hosts that were around when the first conference on the WWW was held at CERN in \n The way we use the Internet has also changed radically\n Initially  applications such as email-for-academics  newsgroups  remote login  and file transfer dominated\n Later it switched to email-for-everyman  then the Web and peer-to-peer content distribution  such as the now-shuttered Napster\n Now real-time media distribution  social networks ( \n  Facebook)  and microblogging ( \n  Twitter) are taking off\n These switches brought richer kinds of media to the Internet and hence much more traffic\n In fact  the dominant traffic on the Internet seems to change with some regularity as  for example  new and better ways to work with music or movies can become very popular very quickly\n Architecture of the Internet The architecture of the Internet has also changed a great deal as it has grown explosively\n In this tion  we will attempt to give a brief overview of what it looks like today\n The picture is complicated by continuous upheavals in the businesses of telephone companies (telcos)  cable companies and ISPs that often make it hard to tell who is doing what\n One driver of these upheavals is telecommunications convergence  in which one network is used for previously different uses\n For example  in a ‘‘triple play’’ one company sells you telephony  TV  and Internet service over the same network connection on the assumption that this will save you money\n Consequently  the description given here will be of necessity somewhat simpler than reality\n And what is true today may not be true tomorrow\n   INTRODUCTION  \n  The big picture is shown in Fig\n  -  \n Let us examine this figure piece by piece  starting with a computer at home (at the edges of the figure)\n To join the Internet  the computer is connected to an Internet Service Provider  or simply ISP  from who the user purchases Internet access or connectivity\n This lets the computer exchange packets with all of the other accessible hosts on the Internet\n The user might send packets to surf the Web or for any of a thousand other uses  it does not matter\n There are many kinds of Internet access  and they are usually distinguished by how much bandwidth they provide and how much they cost  but the most important attribute is connectivity\n Data center Fiber (FTTH) DSL Dialup Cable  G mobile phone Tier  ISP Other ISPs Peering at IXP POP Data path Router Cable modem CMTS Backbone DSLAM DSL modem Figure  -  \n Overview of the Internet architecture\n A common way to connect to an ISP is to use the phone line to your house  in which case your phone company is your ISP\n DSL  short for Digital Subscriber Line  reuses the telephone line that connects to your house for digital data transmission\n The computer is connected to a device called a DSL modem that converts between digital packets and analog signals that can pass unhindered over the telephone line\n At the other end  a device called a DSLAM (Digital Subscriber Line Access Multiplexer) converts between signals and packets\n Several other popular ways to connect to an ISP are shown in Fig\n  -  \n DSL is a higher-bandwidth way to use the local telephone line than to send bits over a traditional telephone call instead of a voice conversation\n That is called dial-up and done with a different kind of modem at both ends\n The word modem is short for ‘‘modulator demodulator’’ and refers to any device that converts between digital bits and analog signals\n Another method is to send signals over the cable TV system\n Like DSL  this is a way to reuse existing infrastructure  in this case otherwise unused cable TV   EXAMPLE NETWORKS   channels\n The device at the home end is called a cable modem and the device at the cable headend is called the CMTS (Cable Modem Termination System)\n DSL and cable provide Internet access at rates from a small fraction of a megabit/ to multiple megabit/  depending on the system\n These rates are much greater than dial-up rates  which are limited to   kbps because of the narrow bandwidth used for voice calls\n Internet access at much greater than dial-up speeds is called broadband\n The name refers to the broader bandwidth that is used for faster networks  rather than any particular speed\n The access methods mentioned so far are limited by the bandwidth of the ‘‘last mile’’ or last leg of transmission\n By running optical fiber to residences  faster Internet access can be provided at rates on the order of   to Mbps\n This design is called FTTH (Fiber to the Home)\n For businesses in commercial areas  it may make sense to lease a high-speed transmission line from the offices to the nearest ISP\n For example  in North America  a T  line runs at roughly   Mbps\n Wireless is used for Internet access too\n An example we will explore shortly is that of  G mobile phone networks\n They can provide data delivery at rates of  Mbps or higher to mobile phones and fixed subscribers in the coverage area\n We can now move packets between the home and the ISP\n We call the location at which customer packets enter the ISP network for service the ISP’s POP (Point of Presence)\n We will next explain how packets are moved between the POPs of different ISPs\n From this point on  the system is fully digital and packet switched\n ISP networks may be regional  national  or international in scope\n We have already seen that their architecture is made up of long-distance transmission lines that interconnect routers at POPs in the different cities that the ISPs serve\n This equipment is called the backbone of the ISP\n If a packet is destined for a host served directly by the ISP  that packet is routed over the backbone and delivered to the host\n Otherwise  it must be handed over to another ISP\n ISPs connect their networks to exchange traffic at IXPs (Internet eXchange Points)\n The connected ISPs are said to peer with each other\n There are many IXPs in cities around the world\n They are drawn vertically in Fig\n  -  because ISP networks overlap geographically\n Basically  an IXP is a room full of routers  at least one per ISP\n A LAN in the room connects all the routers  so packets can be forwarded from any ISP backbone to any other ISP backbone\n IXPs can be large and independently owned facilities\n One of the largest is the Amsterdam Internet Exchange  to which hundreds of ISPs connect and through which they exchange hundreds of gigabits/ of traffic\n The peering that happens at IXPs depends on the business relationships between ISPs\n There are many possible relationships\n For example  a small ISP might pay a larger ISP for Internet connectivity to reach distant hosts  much as a customer purchases service from an Internet provider\n In this case  the small ISP is said to pay for transit\n Alternatively  two large ISPs might decide to exchange   INTRODUCTION  \n  traffic so that each ISP can deliver some traffic to the other ISP without having to pay for transit\n One of the many paradoxes of the Internet is that ISPs who publicly compete with one another for customers often privately cooperate to do peering (Metz  )\n The path a packet takes through the Internet depends on the peering choices of the ISPs\n If the ISP delivering a packet peers with the destination ISP  it might deliver the packet directly to its peer\n Otherwise  it might route the packet to the nearest place at which it connects to a paid transit provider so that provider can deliver the packet\n Two example paths across ISPs are drawn in Fig\n  -  \n Often  the path a packet takes will not be the shortest path through the Internet\n At the top of the food chain are a small handful of companies  like AT&T and Sprint  that operate large international backbone networks with thousands of routers connected by high-bandwidth fiber optic links\n These ISPs do not pay for transit\n They are usually called tier  ISPs and are said to form the backbone of the Internet  since everyone else must connect to them to be able to reach the entire Internet\n Companies that provide lots of content  such as Google and Yahoo!  locate their computers in data centers that are well connected to the rest of the Internet\n These data centers are designed for computers  not humans  and may be filled with rack upon rack of machines called a server farm\n Colocation or hosting data centers let customers put equipment such as servers at ISP POPs so that short  fast connections can be made between the servers and the ISP backbones\n The Internet hosting industry has become increasingly virtualized so that it is now common to rent a virtual machine that is run on a server farm instead of installing a physical computer\n These data centers are so large (tens or hundreds of thousands of machines) that electricity is a major cost  so data centers are sometimes built in areas where electricity is cheap\n This ends our quick tour of the Internet\n We will have a great deal to say about the individual components and their design  algorithms  and protocols in subsequent  ters\n One further point worth mentioning here is that what it means to be on the Internet is changing\n It used to be that a machine was on the Internet if it: ( ) ran the TCP/IP protocol stack; ( ) had an IP address; and ( ) could send IP packets to all the other machines on the Internet\n However  ISPs often reuse IP addresses depending on which computers are in use at the moment  and home networks often share one IP address between multiple computers\n This practice undermines the ond condition\n urity measures such as firewalls can also partly block computers from receiving packets  undermining the third condition\n Despite these difficulties  it makes sense to regard such machines as being on the Internet while they are connected to their ISPs\n Also worth mentioning in passing is that some companies have interconnected all their existing internal networks  often using the same technology as the Internet\n These intranets are typically accessible only on company premises or from company notebooks but otherwise work the same way as the Internet\n   EXAMPLE NETWORKS   Third-Generation Mobile Phone Networks People love to talk on the phone even more than they like to surf the Internet  and this has made the mobile phone network the most successful network in the world\n It has more than four billion subscribers worldwide\n To put this number in perspective  it is roughly  % of the world’s population and more than the number of Internet hosts and fixed telephone lines combined (ITU  )\n The architecture of the mobile phone network has changed greatly over the past   years along with its tremendous growth\n First-generation mobile phone systems transmitted voice calls as continuously varying (analog) signals rather than sequences of (digital) bits\n AMPS (Advanced Mobile Phone System)  which was deployed in the United States in  was a widely used firstgeneration system\n ond-generation mobile phone systems switched to transmitting voice calls in digital form to increase capacity  improve urity  and offer text messaging\n GSM (Global System for Mobile communications)  which was deployed starting in  and has become the most widely used mobile phone system in the world  is a  G system\n The third generation  or  G  systems were initially deployed in  and offer both digital voice and broadband digital data services\n They also come with a lot of jargon and many different standards to choose from\n  G is loosely defined by the ITU (an international standards body we will discuss in the next tion) as providing rates of at least  Mbps for stationary or walking users and kbps in a moving vehicle\n UMTS (Universal Mobile Telecommunications System)  also called WCDMA (Wideband Code Division Multiple Access)  is the main  G system that is being rapidly deployed worldwide\n It can provide up to   Mbps on the downlink and almost  Mbps on the uplink\n Future releases will use multiple antennas and radios to provide even greater speeds for users\n The scarce resource in  G systems  as in  G and  G systems before them  is radio spectrum\n Governments license the right to use parts of the spectrum to the mobile phone network operators  often using a spectrum auction in which network operators submit bids\n Having a piece of licensed spectrum makes it easier to design and operate systems  since no one else is allowed transmit on that spectrum  but it often costs a serious amount of money\n In the UK in  for example  five  G licenses were auctioned for a total of about $  billion\n It is the scarcity of spectrum that led to the cellular network design shown in Fig\n  -  that is now used for mobile phone networks\n To manage the radio interference between users  the coverage area is divided into cells\n Within a cell  users are assigned channels that do not interfere with each other and do not cause too much interference for adjacent cells\n This allows for good reuse of the spectrum  or frequency reuse  in the neighboring cells  which increases the capacity of the network\n In  G systems  which carried each voice call on a specific frequency band  the frequencies were carefully chosen so that they did not conflict with neighboring cells\n In this way  a given frequency might only be reused once   INTRODUCTION  \n  in several cells\n Modern  G systems allow each cell to use all frequencies  but in a way that results in a tolerable level of interference to the neighboring cells\n There are variations on the cellular design  including the use of directional or tored antennas on cell towers to further reduce interference  but the basic idea is the same\n Cells Base station Figure  -  \n Cellular design of mobile phone networks\n The architecture of the mobile phone network is very different than that of the Internet\n It has several parts  as shown in the simplified version of the UMTS architecture in Fig\n  -  \n First  there is the air interface\n This term is a fancy name for the radio communication protocol that is used over the air between the mobile device ( \n  the cell phone) and the cellular base station\n Advances in the air interface over the past decades have greatly increased wireless data rates\n The UMTS air interface is based on Code Division Multiple Access (CDMA)  a technique that we will study in   The cellular base station together with its controller forms the radio access network\n This part is the wireless side of the mobile phone network\n The controller node or RNC (Radio Network Controller) controls how the spectrum is used\n The base station implements the air interface\n It is called Node B  a temporary label that stuck\n The rest of the mobile phone network carries the traffic for the radio access network\n It is called the core network\n The UMTS core network evolved from the core network used for the  G GSM system that came before it\n However  something surprising is happening in the UMTS core network\n Since the beginning of networking  a war has been going on between the people who support packet networks ( \n  connectionless subnets) and the people who support circuit networks ( \n  connection-oriented subnets)\n The main proponents of packets come from the Internet community\n In a connectionless design  every packet is routed independently of every other packet\n As a consequence  if some routers go down during a session  no harm will be done as long as the system can   EXAMPLE NETWORKS   RNC RNC MSC / MGW GMSC / MGW SGSN GGSN Radio access network Core network Air interface (“Uu”) Node B PSTN Internet Packets Circuits (“Iu-CS”) Access / Core interface (“Iu”) Packets (“Iu-PS”) HSS Figure  -  \n Architecture of the UMTS  G mobile phone network\n dynamically reconfigure itself so that subsequent packets can find some route to the destination  even if it is different from that which previous packets used\n The circuit camp comes from the world of telephone companies\n In the telephone system  a caller must dial the called party’s number and wait for a connection before talking or sending data\n This connection setup establishes a route through the telephone system that is maintained until the call is terminated\n All words or packets follow the same route\n If a line or switch on the path goes down  the call is aborted  making it less fault tolerant than a connectionless design\n The advantage of circuits is that they can support quality of service more easily\n By setting up a connection in advance  the subnet can reserve resources such as link bandwidth  switch buffer space  and CPU\n If an attempt is made to set up a call and insufficient resources are available  the call is rejected and the caller gets a kind of busy signal\n In this way  once a connection has been set up  the connection will get good service\n With a connectionless network  if too many packets arrive at the same router at the same moment  the router will choke and probably lose packets\n The sender will eventually notice this and resend them  but the quality of service will be jerky and unsuitable for audio or video unless the network is lightly loaded\n Needless to say  providing adequate audio quality is something telephone companies care about very much  hence their preference for connections\n The surprise in Fig\n  -  is that there is both packet and circuit switched equipment in the core network\n This shows the mobile phone network in transition  with mobile phone companies able to implement one or sometimes both of   INTRODUCTION  \n  the alternatives\n Older mobile phone networks used a circuit-switched core in the style of the traditional phone network to carry voice calls\n This legacy is seen in the UMTS network with the MSC (Mobile Switching Center)  GMSC (Gateway Mobile Switching Center)  and MGW (Media Gateway) elements that set up connections over a circuit-switched core network such as the PSTN (Public Switched Telephone Network)\n Data services have become a much more important part of the mobile phone network than they used to be  starting with text messaging and early packet data services such as GPRS (General Packet Radio Service) in the GSM system\n These older data services ran at tens of kbps  but users wanted more\n Newer mobile phone networks carry packet data at rates of multiple Mbps\n For comparison  a voice call is carried at a rate of   kbps  typically  – x less with compression\n To carry all this data  the UMTS core network nodes connect directly to a packet-switched network\n The SGSN (Serving GPRS Support Node) and the GGSN (Gateway GPRS Support Node) deliver data packets to and from mobiles and interface to external packet networks such as the Internet\n This transition is set to continue in the mobile phone networks that are now being planned and deployed\n Internet protocols are even used on mobiles to set up connections for voice calls over a packet data network  in the manner of voiceover- IP\n IP and packets are used all the way from the radio access through to the core network\n Of course  the way that IP networks are designed is also changing to support better quality of service\n If it did not  then problems with chopped-up audio and jerky video would not impress paying customers\n We will return to this subject in   Another difference between mobile phone networks and the traditional Internet is mobility\n When a user moves out of the range of one cellular base station and into the range of another one  the flow of data must be re-routed from the old to the new cell base station\n This technique is known as handover or handoff  and it is illustrated in Fig\n  -  \n (a) (b) Figure  -  \n Mobile phone handover (a) before  (b) after\n Either the mobile device or the base station may request a handover when the quality of the signal drops\n In some cell networks  usually those based on CDMA   EXAMPLE NETWORKS   technology  it is possible to connect to the new base station before disconnecting from the old base station\n This improves the connection quality for the mobile because there is no break in service; the mobile is actually connected to two base stations for a short while\n This way of doing a handover is called a soft handover to distinguish it from a hard handover  in which the mobile disconnects from the old base station before connecting to the new one\n A related issue is how to find a mobile in the first place when there is an incoming call\n Each mobile phone network has a HSS (Home Subscriber Server) in the core network that knows the location of each subscriber  as well as other profile information that is used for authentication and authorization\n In this way  each mobile can be found by contacting the HSS\n A final area to discuss is urity\n Historically  phone companies have taken urity much more seriously than Internet companies for a long time because of the need to bill for service and avoid (payment) fraud\n Unfortunately that is not saying much\n Nevertheless  in the evolution from  G through  G technologies  mobile phone companies have been able to roll out some basic urity mechanisms for mobiles\n Starting with the  G GSM system  the mobile phone was divided into a handset and a removable chip containing the subscriber’s identity and account information\n The chip is informally called a SIM card  short for Subscriber Identity Module\n SIM cards can be switched to different handsets to activate them  and they provide a basis for urity\n When GSM customers travel to other countries on vacation or business  they often bring their handsets but buy a new SIM card for few dollars upon arrival in order to make local calls with no roaming charges\n To reduce fraud  information on SIM cards is also used by the mobile phone network to authenticate subscribers and check that they are allowed to use the network\n With UMTS  the mobile also uses the information on the SIM card to check that it is talking to a legitimate network\n Another aspect of urity is privacy\n Wireless signals are broadcast to all nearby receivers  so to make it difficult to eavesdrop on conversations  cryptographic keys on the SIM card are used to encrypt transmissions\n This approach provides much better privacy than in  G systems  which were easily tapped  but is not a panacea due to weaknesses in the encryption schemes\n Mobile phone networks are destined to play a central role in future networks\n They are now more about mobile broadband applications than voice calls  and this has major implications for the air interfaces  core network architecture  and urity of future networks\n  G technologies that are faster and better are on the drawing board under the name of LTE (Long Term Evolution)  even as  G design and deployment continues\n Other wireless technologies also offer broadband Internet access to fixed and mobile clients  notably   \n  networks under the common name of WiMAX\n It is entirely possible that LTE and WiMAX are on a collision course with each other and it is hard to predict what will happen to them\n   INTRODUCTION  \n     Wireless LANs:   \n  Almost as soon as laptop computers appeared  many people had a dream of walking into an office and magically having their laptop computer be connected to the Internet\n Consequently  various groups began working on ways to accomplish this goal\n The most practical approach is to equip both the office and the laptop computers with short-range radio transmitters and receivers to allow them to talk\n Work in this field rapidly led to wireless LANs being marketed by a variety of companies\n The trouble was that no two of them were compatible\n The proliferation of standards meant that a computer equipped with a brand X radio would not work in a room equipped with a brand Y base station\n In the mid s  the industry decided that a wireless LAN standard might be a good idea  so the IEEE committee that had standardized wired LANs was given the task of drawing up a wireless LAN standard\n The first decision was the easiest: what to call it\n All the other LAN standards had numbers like     and   \n  up to   \n   so the wireless LAN standard was dubbed    A common slang name for it is WiFi but it is an important standard and deserves respect  so we will call it by its proper name  The rest was harder\n The first problem was to find a suitable frequency band that was available  preferably worldwide\n The approach taken was the opposite of that used in mobile phone networks\n Instead of expensive  licensed spectrum \n  systems operate in unlicensed bands such as the ISM (Industrial  Scientific  and Medical) bands defined by ITU-R ( \n -   MHz  \n - \n  GHz  \n  - \n   GHz)\n All devices are allowed to use this spectrum provided that they limit their transmit power to let different devices coexist\n Of course  this means that   \n  radios may find themselves competing with cordless phones  garage door openers  and microwave ovens\n   \n  networks are made up of clients  such as laptops and mobile phones  and infrastructure called APs (access points) that is installed in buildings\n Access points are sometimes called base stations\n The access points connect to the wired network  and all communication between clients goes through an access point\n It is also possible for clients that are in radio range to talk directly  such as two computers in an office without an access point\n This arrangement is called an ad hoc network\n It is used much less often than the access point mode\n Both modes are shown in Fig\n  -  \n   \n  transmission is complicated by wireless conditions that vary with even small changes in the environment\n At the frequencies used for   \n   radio signals can be reflected off solid objects so that multiple echoes of a transmission may reach a receiver along different paths\n The echoes can cancel or reinforce each other  causing the received signal to fluctuate greatly\n This phenomenon is called multipath fading  and it is shown in Fig\n  -  \n The key idea for overcoming variable wireless conditions is path diversity  or the sending of information along multiple  independent paths\n In this way  the   EXAMPLE NETWORKS   (a) (b) Access To wired network point Figure  -  \n (a) Wireless network with an access point\n (b) Ad hoc network\n information is likely to be received even if one of the paths happens to be poor due to a fade\n These independent paths are typically built into the digital modulation scheme at the physical layer\n Options include using different frequencies across the allowed band  following different spatial paths between different pairs of antennas  or repeating bits over different periods of time\n Reflector Faded signal Wireless transmitter Non-faded signal Multiple paths Wireless receiver Figure  -  \n Multipath fading\n Different versions of   \n  have used all of these techniques\n The initial (   ) standard defined a wireless LAN that ran at either  Mbps or  Mbps by hopping between frequencies or spreading the signal across the allowed spectrum\n Almost immediately  people complained that it was too slow  so work began on faster standards\n The spread spectrum design was extended and became the (   )   \n  b standard running at rates up to   Mbps\n The   \n  a (   ) and   \n  g (   ) standards switched to a different modulation scheme called OFDM (Orthogonal Frequency Division Multiplexing)\n It divides a wide band of spectrum into many narrow slices over which different bits are sent in parallel\n This improved scheme  which we will study in  \n   boosted the   \n  a/g bit   INTRODUCTION  \n  rates up to   Mbps\n That is a significant increase  but people still wanted more throughput to support more demanding uses\n The latest version is   \n  n (   )\n It uses wider frequency bands and up to four antennas per computer to achieve rates up to Mbps\n Since wireless is inherently a broadcast medium \n  radios also have to deal with the problem that multiple transmissions that are sent at the same time will collide  which may interfere with reception\n To handle this problem \n  uses a CSMA (Carrier Sense Multiple Access) scheme that draws on ideas from classic wired Ethernet  which  ironically  drew from an early wireless network developed in Hawaii and called ALOHA\n Computers wait for a short random interval before transmitting  and defer their transmissions if they hear that someone else is already transmitting\n This scheme makes it less likely that two computers will send at the same time\n It does not work as well as in the case of wired networks  though\n To see why  examine Fig\n  -  \n Suppose that computer A is transmitting to computer B  but the radio range of A’s transmitter is too short to reach computer C\n If C wants to transmit to B it can listen before starting  but the fact that it does not hear anything does not mean that its transmission will succeed\n The inability of C to hear A before starting causes some collisions to occur\n After any collision  the sender then waits another  longer  random delay and retransmits the packet\n Despite this and some other issues  the scheme works well enough in practice\n A B C Range of A's radio Range of C's radio Figure  -  \n The range of a single radio may not cover the entire system\n Another problem is that of mobility\n If a mobile client is moved away from the access point it is using and into the range of a different access point  some way of handing it off is needed\n The solution is that an   \n  network can consist of multiple cells  each with its own access point  and a distribution system that connects the cells\n The distribution system is often switched Ethernet  but it can use any technology\n As the clients move  they may find another access point with a better signal than the one they are currently using and change their association\n From the outside  the entire system looks like a single wired LAN\n   EXAMPLE NETWORKS   That said  mobility in   \n  has been of limited value so far compared to mobility in the mobile phone network\n Typically \n  is used by nomadic clients that go from one fixed location to another  rather than being used on-the-go\n Mobility is not really needed for nomadic usage\n Even when   \n  mobility is used  it extends over a single   \n  network  which might cover at most a large building\n Future schemes will need to provide mobility across different networks and across different technologies (   )\n Finally  there is the problem of urity\n Since wireless transmissions are broadcast  it is easy for nearby computers to receive packets of information that were not intended for them\n To prevent this  the   \n  standard included an encryption scheme known as WEP (Wired Equivalent Privacy)\n The idea was to make wireless urity like that of wired urity\n It is a good idea  but unfortunately the scheme was flawed and soon broken (Borisov et al\n  )\n It has since been replaced with newer schemes that have different cryptographic details in the   \n  i standard  also called WiFi Protected Access  initially called WPA but now replaced by WPA \n   \n  has caused a revolution in wireless networking that is set to continue\n Beyond buildings  it is starting to be installed in trains  planes  boats  and automobiles so that people can surf the Internet wherever they go\n Mobile phones and all manner of consumer electronics  from game consoles to digital cameras  can communicate with it\n We will come back to it in detail in      RFID and Sensor Networks The networks we have studied so far are made up of computing devices that are easy to recognize  from computers to mobile phones\n With Radio Frequency IDentification (RFID)  everyday objects can also be part of a computer network\n An RFID tag looks like a postage stamp-sized sticker that can be affixed to (or embedded in) an object so that it can be tracked\n The object might be a cow  a passport  a book or a shipping pallet\n The tag consists of a small microchip with a unique identifier and an antenna that receives radio transmissions\n RFID readers installed at tracking points find tags when they come into range and interrogate them for their information as shown in Fig\n  -  \n Applications include checking identities  managing the supply chain  timing races  and replacing barcodes\n There are many kinds of RFID  each with different properties  but perhaps the most fascinating aspect of RFID technology is that most RFID tags have neither an electric plug nor a battery\n Instead  all of the energy needed to operate them is supplied in the form of radio waves by RFID readers\n This technology is called passive RFID to distinguish it from the (less common) active RFID in which there is a power source on the tag\n One common form of RFID is UHF RFID (Ultra-High Frequency RFID)\n It is used on shipping pallets and some drivers licenses\n Readers send signals in   INTRODUCTION  \n  RFID reader RFID tag Figure  -  \n RFID used to network everyday objects\n the   -   MHz band in the United States\n Tags communicate at distances of several meters by changing the way they reflect the reader signals; the reader is able to pick up these reflections\n This way of operating is called backscatter\n Another popular kind of RFID is HF RFID (High Frequency RFID)\n It operates at  \n  MHz and is likely to be in your passport  credit cards  books  and noncontact payment systems\n HF RFID has a short range  typically a meter or less  because the physical mechanism is based on induction rather than backscatter\n There are also other forms of RFID using other frequencies  such as LF RFID (Low Frequency RFID)  which was developed before HF RFID and used for animal tracking\n It is the kind of RFID likely to be in your cat\n RFID readers must somehow solve the problem of dealing with multiple tags within reading range\n This means that a tag cannot simply respond when it hears a reader  or the signals from multiple tags may collide\n The solution is similar to the approach taken in   \n  : tags wait for a short random interval before responding with their identification  which allows the reader to narrow down individual tags and interrogate them further\n urity is another problem\n The ability of RFID readers to easily track an object  and hence the person who uses it  can be an invasion of privacy\n Unfortunately  it is difficult to ure RFID tags because they lack the computation and communication power to run strong cryptographic algorithms\n Instead  weak measures like passwords (which can easily be cracked) are used\n If an identity card can be remotely read by an official at a border  what is to stop the same card from being tracked by other people without your knowledge? Not much\n RFID tags started as identification chips  but are rapidly turning into fullfledged computers\n For example  many tags have memory that can be updated and later queried  so that information about what has happened to the tagged object can be stored with it\n Rieback et al\n (   ) demonstrated that this means that all of the usual problems of computer malware apply  only now your cat or your passport might be used to spread an RFID virus\n A step up in capability from RFID is the sensor network\n Sensor networks are deployed to monitor aspects of the physical world\n So far  they have mostly been used for scientific experimentation  such as monitoring bird habitats  volcanic activity  and zebra migration  but business applications including healthcare    EXAMPLE NETWORKS   monitoring equipment for vibration  and tracking of frozen  refrigerated  or otherwise perishable goods cannot be too far behind\n Sensor nodes are small computers  often the size of a key fob  that have temperature  vibration  and other sensors\n Many nodes are placed in the environment that is to be monitored\n Typically  they have batteries  though they may scavenge energy from vibrations or the sun\n As with RFID  having enough energy is a key challenge  and the nodes must communicate carefully to be able to deliver their sensor information to an external collection point\n A common strategy is for the nodes to self-organize to relay messages for each other  as shown in Fig\n  -  \n This design is called a multihop network\n Data collection point Sensor node Wireless hop Figure  -  \n Multihop topology of a sensor network\n RFID and sensor networks are likely to become much more capable and pervasive in the future\n Researchers have already combined the best of both technologies by prototyping programmable RFID tags with light  movement  and other sensors (Sample et al\n  )  NETWORK STANDARDIZATION Many network vendors and suppliers exist  each with its own ideas of how things should be done\n Without coordination  there would be complete chaos  and users would get nothing done\n The only way out is to agree on some network standards\n Not only do good standards allow different computers to communicate  but they also increase the market for products adhering to the standards\n A larger market leads to mass production  economies of scale in manufacturing  better implementations  and other benefits that decrease price and further increase acceptance\n In this tion we will take a quick look at the important but little-known  world of international standardization\n But let us first discuss what belongs in a   INTRODUCTION  \n  standard\n A reasonable person might assume that a standard tells you how a protocol should work so that you can do a good job of implementing it\n That person would be wrong\n Standards define what is needed for interoperability: no more  no less\n That lets the larger market emerge and also lets companies compete on the basis of how good their products are\n For example  the   \n  standard defines many transmission rates but does not say when a sender should use which rate  which is a key factor in good performance\n That is up to whoever makes the product\n Often getting to interoperability this way is difficult  since there are many implementation choices and standards usually define many options\n For   \n   there were so many problems that  in a strategy that has become common practice  a trade group called the WiFi Alliance was started to work on interoperability within the   \n  standard\n Similarly  a protocol standard defines the protocol over the wire but not the service interface inside the box  except to help explain the protocol\n Real service interfaces are often proprietary\n For example  the way TCP interfaces to IP within a computer does not matter for talking to a remote host\n It only matters that the remote host speaks TCP/IP\n In fact  TCP and IP are commonly implemented together without any distinct interface\n That said  good service interfaces  like good APIs  are valuable for getting protocols used  and the best ones (such as Berkeley sockets) can become very popular\n Standards fall into two categories: de facto and de jure\n De facto (Latin for ‘‘from the fact’’) standards are those that have just happened  without any formal plan\n HTTP  the protocol on which the Web runs  started life as a de facto standard\n It was part of early WWW browsers developed by Tim Berners-Lee at CERN  and its use took off with the growth of the Web\n Bluetooth is another example\n It was originally developed by Ericsson but now everyone is using it\n De jure (Latin for ‘‘by law’’) standards  in contrast  are adopted through the rules of some formal standardization body\n International standardization authorities are generally divided into two classes: those established by treaty among national governments  and those comprising voluntary  nontreaty organizations\n In the area of computer network standards  there are several organizations of each type  notably ITU  ISO  IETF and IEEE  all of which we will discuss below\n In practice  the relationships between standards  companies  and standardization bodies are complicated\n De facto standards often evolve into de jure standards  especially if they are successful\n This happened in the case of HTTP  which was quickly picked up by IETF\n Standards bodies often ratify each others’ standards  in what looks like patting one another on the back  to increase the market for a technology\n These days  many ad hoc business alliances that are formed around particular technologies also play a significant role in developing and refining network standards\n For example  GPP (Third Generation Partnership Project) is a collaboration between telecommunications associations that drives the UMTS  G mobile phone standards\n   NETWORK STANDARDIZATION   Who’s Who in the Telecommunications World The legal status of the world’s telephone companies varies considerably from country to country\n At one extreme is the United States  which has over  separate  (mostly very small) privately owned telephone companies\n A few more were added with the breakup of AT&T in  (which was then the world’s largest corporation  providing telephone service to about   percent of America’s telephones)  and the Telecommunications Act of  that overhauled regulation to foster competition\n At the other extreme are countries in which the national government has a complete monopoly on all communication  including the mail  telegraph  telephone  and often radio and television\n Much of the world falls into this category\n In some cases the telecommunication authority is a nationalized company  and in others it is simply a branch of the government  usually known as the PTT (Post  Telegraph & Telephone administration)\n Worldwide  the trend is toward liberalization and competition and away from government monopoly\n Most European countries have now (partially) privatized their PTTs  but elsewhere the process is still only slowly gaining steam\n With all these different suppliers of services  there is clearly a need to provide compatibility on a worldwide scale to ensure that people (and computers) in one country can call their counterparts in another one\n Actually  this need has existed for a long time\n In  representatives from many European governments met to form the predecessor to today’s ITU (International Telecommunication Union)\n Its job was to standardize international telecommunications  which in those days meant telegraphy\n Even then it was clear that if half the countries used Morse code and the other half used some other code  there was going to be a problem\n When the telephone was put into international service  ITU took over the job of standardizing telephony (pronounced te-LEF-ony) as well\n In  ITU became an agency of the United Nations\n ITU has about governmental members  including almost every member of the United Nations\n Since the United States does not have a PTT  somebody else had to represent it in ITU\n This task fell to the State Department  probably on the grounds that ITU had to do with foreign countries  the State Department’s specialty\n ITU also has more than tor and associate members\n They include telephone companies ( \n  AT&T  Vodafone  Sprint)  telecom equipment manufacturers ( \n  Cisco  Nokia  Nortel)  computer vendors ( \n  Microsoft  Agilent  Toshiba)  chip manufacturers ( \n  Intel  Motorola  TI)  and other interested companies ( \n  Boeing  CBS  VeriSign)\n ITU has three main tors\n We will focus primarily on ITU-T  the Telecommunications Standardization tor  which is concerned with telephone and data communication systems\n Before  this tor was called CCITT  which is an acronym for its French name  Comite´ Consultatif International Te´le´graphique et Te´le´phonique\n ITU-R  the Radiocommunications tor  is concerned with   INTRODUCTION  \n  coordinating the use by competing interest groups of radio frequencies worldwide\n The other tor is ITU-D  the Development tor\n It promotes the development of information and communication technologies to narrow the ‘‘digital divide’’ between countries with effective access to the information technologies and countries with limited access\n ITU-T’s task is to make technical recommendations about telephone  telegraph  and data communication interfaces\n These often become internationally recognized standards  though technically the recommendations are only suggestions that governments can adopt or ignore  as they wish (because governments are like  -year-old boys—they do not take kindly to being given orders)\n In practice  a country that wishes to adopt a telephone standard different from that used by the rest of the world is free to do so  but at the price of cutting itself off from everyone else\n This might work for North Korea  but elsewhere it would be a real problem\n The real work of ITU-T is done in its Study Groups\n There are currently   Study Groups  often as large as people  that cover topics ranging from telephone billing to multimedia services to urity\n SG for example  standardizes the DSL technologies popularly used to connect to the Internet\n In order to make it possible to get anything at all done  the Study Groups are divided into Working Parties  which are in turn divided into Expert Teams  which are in turn divided into ad hoc groups\n Once a bureaucracy  always a bureaucracy\n Despite all this  ITU-T actually does get things done\n Since its inception  it has produced more than  recommendations  many of which are widely used in practice\n For example  Recommendation H\n   (also an ISO standard known as MPEG-  AVC) is widely used for video compression  and X\n   public key certificates are used for ure Web browsing and digitally signed email\n As the field of telecommunications completes the transition started in the s from being entirely national to being entirely global  standards will become increasingly important  and more and more organizations will want to become involved in setting them\n For more information about ITU  see Irmer (   )\n    Who’s Who in the International Standards World International standards are produced and published by ISO (International Standards Organization†)  a voluntary nontreaty organization founded in \n Its members are the national standards organizations of the member countries\n These members include ANSI ( \n)  BSI (Great Britain)  AFNOR (France)  DIN (Germany)  and others\n ISO issues standards on a truly vast number of subjects  ranging from nuts and bolts (literally) to telephone pole coatings [not to mention cocoa beans (ISO )  fishing nets (ISO )  women’s underwear (ISO ) and quite a few † For the purist  ISO’s true name is the International Organization for Standardization\n   NETWORK STANDARDIZATION   other subjects one might not think were subject to standardization]\n On issues of telecommunication standards  ISO and ITU-T often cooperate (ISO is a member of ITU-T) to avoid the irony of two official and mutually incompatible international standards\n Over   standards have been issued  including the OSI standards\n ISO has over Technical Committees (TCs)  numbered in the order of their creation  each dealing with a specific subject\n TC  deals with the nuts and bolts (standardizing screw thread pitches)\n JTC  deals with information technology  including networks  computers  and software\n It is the first (and so far only) Joint Technical Committee  created in  by merging TC  with activities in IEC  yet another standardization body\n Each TC has subcommittees (SCs) divided into working groups (WGs)\n The real work is done largely in the WGs by over    volunteers worldwide\n Many of these ‘‘volunteers’’ are assigned to work on ISO matters by their employers  whose products are being standardized\n Others are government officials keen on having their country’s way of doing things become the international standard\n Academic experts also are active in many of the WGs\n The procedure used by ISO for adopting standards has been designed to achieve as broad a consensus as possible\n The process begins when one of the national standards organizations feels the need for an international standard in some area\n A working group is then formed to come up with a CD (Committee Draft)\n The CD is then circulated to all the member bodies  which get  months to criticize it\n If a substantial majority approves  a revised document  called a DIS (Draft International Standard) is produced and circulated for comments and voting\n Based on the results of this round  the final text of the IS (International Standard) is prepared  approved  and published\n In areas of great controversy  a CD or DIS may have to go through several versions before acquiring enough votes  and the whole process can take years\n NIST (National Institute of Standards and Technology) is part of the  \n Department of Commerce\n It used to be called the National Bureau of Standards\n It issues standards that are mandatory for purchases made by the  \n Government  except for those of the Department of Defense  which defines its own standards\n Another major player in the standards world is IEEE (Institute of Electrical and Electronics Engineers)  the largest professional organization in the world\n In addition to publishing scores of journals and running hundreds of conferences each year  IEEE has a standardization group that develops standards in the area of electrical engineering and computing\n IEEE’s committee has standardized many kinds of LANs\n We will study some of its output later in this book\n The actual work is done by a collection of working groups  which are listed in Fig\n  -  \n The success rate of the various working groups has been low; having an    number is no guarantee of success\n Still  the impact of the success stories (especially   \n  and   \n  ) on the industry and the world has been enormous\n   INTRODUCTION  \n  Number Topic   \n  Overview and architecture of LANs   \n  ↓ Logical link control   \n  * Ethernet   \n  ↓ Token bus (was briefly used in manufacturing plants)   \n  Token ring (IBM’s entry into the LAN world)   \n  ↓ Dual queue dual bus (early metropolitan area network)   \n  ↓ Technical advisory group on broadband technologies   \n  † Technical advisory group on fiber optic technologies   \n  ↓ Isochronous LANs (for real-time applications)   \n  ↓ Virtual LANs and urity   \n  * Wireless LANs (WiFi)   \n  ↓ Demand priority (Hewlett-Packard’s AnyLAN)   \n  Unlucky number; nobody wanted it   \n  ↓ Cable modems (defunct: an industry consortium got there first)   \n  * Personal area networks (Bluetooth  Zigbee)   \n  * Broadband wireless (WiMAX)   \n  Resilient packet ring   \n  Technical advisory group on radio regulatory issues   \n  Technical advisory group on coexistence of all these standards   \n  Mobile broadband wireless (similar to   \n  e)   \n  Media independent handoff (for roaming over technologies)   \n  Wireless regional area network Figure  -  \n The working groups\n The important ones are marked with *\n The ones marked with ↓ are hibernating\n The one marked with † gave up and disbanded itself\n    Who’s Who in the Internet Standards World The worldwide Internet has its own standardization mechanisms  very different from those of ITU-T and ISO\n The difference can be crudely summed up by saying that the people who come to ITU or ISO standardization meetings wear suits  while the people who come to Internet standardization meetings wear jeans (except when they meet in San Diego  when they wear shorts and T-shirts)\n ITU-T and ISO meetings are populated by corporate officials and government civil servants for whom standardization is their job\n They regard standardization as a Good Thing and devote their lives to it\n Internet people  on the other hand  prefer anarchy as a matter of principle\n However  with hundreds of millions of   NETWORK STANDARDIZATION   people all doing their own thing  little communication can occur\n Thus  standards  however regrettable  are sometimes needed\n In this context  David Clark of  \n once made a now-famous remark about Internet standardization consisting of ‘‘rough consensus and running code\n’’ When the ARPANET was set up  DoD created an informal committee to oversee it\n In  the committee was renamed the IAB (Internet Activities Board) and was given a slighter broader mission  namely  to keep the researchers involved with the ARPANET and the Internet pointed more or less in the same direction  an activity not unlike herding cats\n The meaning of the acronym ‘‘IAB’’ was later changed to Internet Architecture Board\n Each of the approximately ten members of the IAB headed a task force on some issue of importance\n The IAB met several times a year to discuss results and to give feedback to the DoD and NSF  which were providing most of the funding at this time\n When a standard was needed ( \n  a new routing algorithm)  the IAB members would thrash it out and then announce the change so the graduate students who were the heart of the software effort could implement it\n Communication was done by a series of technical reports called RFCs (Request For Comments)\n RFCs are stored online and can be fetched by anyone interested in them from  /rfc\n They are numbered in chronological order of creation\n Over  now exist\n We will refer to many RFCs in this book\n By  the Internet had grown so large that this highly informal style no longer worked\n Many vendors by then offered TCP/IP products and did not want to change them just because ten researchers had thought of a better idea\n In the summer of  the IAB was reorganized again\n The researchers were moved to the IRTF (Internet Research Task Force)  which was made subsidiary to IAB  along with the IETF (Internet Engineering Task Force)\n The IAB was repopulated with people representing a broader range of organizations than just the research community\n It was initially a self-perpetuating group  with members serving for a  -year term and new members being appointed by the old ones\n Later  the Internet Society was created  populated by people interested in the Internet\n The Internet Society is thus in a sense comparable to ACM or IEEE\n It is governed by elected trustees who appoint the IAB’s members\n The idea of this split was to have the IRTF concentrate on long-term research while the IETF dealt with short-term engineering issues\n The IETF was divided up into working groups  each with a specific problem to solve\n The chairmen of these working groups initially met as a steering committee to direct the engineering effort\n The working group topics include new applications  user information  OSI integration  routing and addressing  urity  network management  and standards\n Eventually  so many working groups were formed (more than  ) that they were grouped into areas and the area chairmen met as the steering committee\n In addition  a more formal standardization process was adopted  patterned after ISOs\n To become a Proposed Standard  the basic idea must be explained in an RFC and have sufficient interest in the community to warrant consideration\n   INTRODUCTION  \n  To advance to the Draft Standard stage  a working implementation must have been rigorously tested by at least two independent sites for at least  months\n If the IAB is convinced that the idea is sound and the software works  it can declare the RFC to be an Internet Standard\n Some Internet Standards have become DoD standards (MIL-STD)  making them mandatory for DoD suppliers\n For Web standards  the World Wide Web Consortium (W C) develops protocols and guidelines to facilitate the long-term growth of the Web\n It is an industry consortium led by Tim Berners-Lee and set up in  as the Web really begun to take off\n W C now has more than members from around the world and has produced more than W C Recommendations  as its standards are called  covering topics such as HTML and Web privacy  METRIC UNITS To avoid any confusion  it is worth stating explicitly that in this book  as in computer science in general  metric units are used instead of traditional English units (the furlong-stone-fortnight system)\n The principal metric prefixes are listed in Fig\n  -  \n The prefixes are typically abbreviated by their first letters  with the units greater than  capitalized (KB  MB  etc\n)\n One exception (for historical reasons) is kbps for kilobits/\n Thus  a  -Mbps communication line transmits bits/ and a   -p (or   -ps) clock ticks every  −  onds\n Since milli and micro both begin with the letter ‘‘m ’’ a choice had to be made\n Normally  ‘‘m’’ is used for milli and ‘‘μ’’ (the Greek letter mu) is used for micro\n Exp\n Explicit Prefix Exp\n Explicit Prefix  −  \n   milli  Kilo  −  \n  micro  Mega  −  \n  nano     Giga  −   \n    pico      Tera  −   \n   femto      Peta  −   \n   atto      Exa  −   \n     zepto      Zetta  −   \n    yocto      Yotta Figure  -  \n The principal metric prefixes\n It is also worth pointing out that for measuring memory  disk  file  and database sizes  in common industry practice  the units have slightly different meanings\n There  kilo means (   ) rather than (   ) because memories are always a power of two\n Thus  a  -KB memory contains  bytes  not  bytes\n Note also the capital ‘‘B’’ in that usage to mean ‘‘bytes’’ (units of eight   METRIC UNITS   bits)  instead of a lowercase ‘‘b’’ that means ‘‘bits\n’’ Similarly  a  -MB memory contains (    ) bytes  a  -GB memory contains (    ) bytes  and a  -TB database contains (    ) bytes\n However  a  -kbps communication line transmits  bits per ond and a  -Mbps LAN runs at   bits/ because these speeds are not powers of two\n Unfortunately  many people tend to mix up these two systems  especially for disk sizes\n To avoid ambiguity  in this book  we will use the symbols KB  MB  GB  and TB for   and bytes  respectively  and the symbols kbps  Mbps  Gbps  and Tbps for   and  bits/  respectively  OUTLINE OF THE REST OF THE BOOK This book discusses both the principles and practice of computer networking\n Most  ters start with a discussion of the relevant principles  followed by a number of examples that illustrate these principles\n These examples are usually taken from the Internet and wireless networks such as the mobile phone network since these are both important and very different\n Other examples will be given where relevant\n The book is structured according to the hybrid model of Fig\n  -  \n Starting with  \n   we begin working our way up the protocol hierarchy beginning at the bottom\n We provide some background in the field of data communication that covers both wired and wireless transmission systems\n This material is concerned with how to deliver information over physical channels  although we cover only the architectural rather than the hardware aspects\n Several examples of the physical layer  such as the public switched telephone network  the mobile telephone network  and the cable television network are also discussed\n  ters  and  discuss the data link layer in two parts  looks at the problem of how to send packets across a link  including error detection and correction\n We look at DSL (used for broadband Internet access over phone lines) as a real-world example of a data link protocol\n In  \n   we examine the medium access sublayer\n This is the part of the data link layer that deals with how to share a channel between multiple computers\n The examples we look at include wireless  such as   \n  and RFID  and wired LANs such as classic Ethernet\n Link layer switches that connect LANs  such as switched Ethernet  are also discussed here\n  ter  deals with the network layer  especially routing\n Many routing algorithms  both static and dynamic  are covered\n Even with good routing algorithms  though  if more traffic is offered than the network can handle  some packets will be delayed or discarded\n We discuss this issue from how to prevent congestion to how to guarantee a certain quality of service\n Connecting heterogeneous networks to form internetworks also leads to numerous problems that are discussed here\n The network layer in the Internet is given extensive coverage\n   INTRODUCTION  \n ter  deals with the transport layer\n Much of the emphasis is on connection- oriented protocols and reliability  since many applications need these\n Both Internet transport protocols  UDP and TCP  are covered in detail  as are their performance issues\n  ter  deals with the application layer  its protocols  and its applications\n The first topic is DNS  which is the Internet’s telephone book\n Next comes email  including a discussion of its protocols\n Then we move on to the Web  with detailed discussions of static and dynamic content  and what happens on the client and server sides\n We follow this with a look at networked multimedia  including streaming audio and video\n Finally  we discuss content-delivery networks  including peer-to-peer technology\n  ter  is about network urity\n This topic has aspects that relate to all layers  so it is easiest to treat it after all the layers have been thoroughly explained\n The  ter starts with an introduction to cryptography\n Later  it shows how cryptography can be used to ure communication  email  and the Web\n The  ter ends with a discussion of some areas in which urity collides with privacy  freedom of speech  censorship  and other social issues\n  ter  contains an annotated list of suggested readings arranged by  ter\n It is intended to help those readers who would like to pursue their study of networking further\n The  ter also has an alphabetical bibliography of all the references cited in this book\n The authors’ Web site at Pearson: http:// /tanenbaum has a page with links to many tutorials  FAQs  companies  industry consortia  professional organizations  standards organizations  technologies  papers  and more  SUMMARY Computer networks have many uses  both for companies and for individuals  in the home and while on the move\n Companies use networks of computers to share corporate information  typically using the client-server model with employee desktops acting as clients accessing powerful servers in the machine room\n For individuals  networks offer access to a variety of information and entertainment resources  as well as a way to buy and sell products and services\n Individuals often access the Internet via their phone or cable providers at home  though increasingly wireless access is used for laptops and phones\n Technology advances are enabling new kinds of mobile applications and networks with computers embedded in appliances and other consumer devices\n The same advances raise social issues such as privacy concerns\n Roughly speaking  networks can be divided into LANs  MANs  WANs  and internetworks\n LANs typical cover a building and operate at high speeds\n MANs   SUMMARY   usually cover a city\n An example is the cable television system  which is now used by many people to access the Internet\n WANs may cover a country or a continent\n Some of the technologies used to build these networks are point-to-point ( \n  a cable) while others are broadcast ( \n wireless)\n Networks can be interconnected with routers to form internetworks  of which the Internet is the largest and best known example\n Wireless networks  for example   \n  LANs and  G mobile telephony  are also becoming extremely popular\n Network software is built around protocols  which are rules by which processes communicate\n Most networks support protocol hierarchies  with each layer providing services to the layer above it and insulating them from the details of the protocols used in the lower layers\n Protocol stacks are typically based either on the OSI model or on the TCP/IP model\n Both have link  network  transport  and application layers  but they differ on the other layers\n Design issues include reliability  resource allocation  growth  urity  and more\n Much of this book deals with protocols and their design\n Networks provide various services to their users\n These services can range from connectionless best-efforts packet delivery to connection-oriented guaranteed delivery\n In some networks  connectionless service is provided in one layer and connection-oriented service is provided in the layer above it\n Well-known networks include the Internet  the  G mobile telephone network  and   \n  LANs\n The Internet evolved from the ARPANET  to which other networks were added to form an internetwork\n The present-day Internet is actually a collection of many thousands of networks that use the TCP/IP protocol stack\n The  G mobile telephone network provides wireless and mobile access to the Internet at speeds of multiple Mbps  and  of course  carries voice calls as well\n Wireless LANs based on the IEEE   \n  standard are deployed in many homes and cafes and can provide connectivity at rates in excess of Mbps\n New kinds of networks are emerging too  such as embedded sensor networks and networks based on RFID technology\n Enabling multiple computers to talk to each other requires a large amount of standardization  both in the hardware and software\n Organizations such as ITU-T  ISO  IEEE  and IAB manage different parts of the standardization process\n PROBLEMS  \n Imagine that you have trained your St\n Bernard  Bernie  to carry a box of three  -mm tapes instead of a flask of brandy\n (When your disk fills up  you consider that an emergency\n) These tapes each contain  gigabytes\n The dog can travel to your side  wherever you may be  at   km/hour\n For what range of distances does Bernie have a higher data rate than a transmission line whose data rate (excluding overhead) is Mbps? How does your answer change if (i) Bernie’s speed is doubled; (ii) each tape capacity is doubled; (iii) the data rate of the transmission line is doubled\n   INTRODUCTION  \n   \n An alternative to a LAN is simply a big timesharing system with terminals for all users\n Give two advantages of a client-server system using a LAN The performance of a client-server system is strongly influenced by two major network characteristics: the bandwidth of the network (that is  how many bits/ it can transport) and the latency (that is  how many onds it takes for the first bit to get from the client to the server)\n Give an example of a network that exhibits high bandwidth but also high latency\n Then give an example of one that has both low bandwidth and low latency Besides bandwidth and latency  what other parameter is needed to give a good characterization of the quality of service offered by a network used for (i) digitized voice traffic? (ii) video traffic? (iii) financial transaction traffic?  \n A factor in the delay of a store-and-forward packet-switching system is how long it takes to store and forward a packet through a switch\n If switching time is   μ  is this likely to be a major factor in the response of a client-server system where the client is in New York and the server is in California? Assume the propagation speed in copper and fiber to be  /  the speed of light in vacuum A client-server system uses a satellite network  with the satellite at a height of   km\n What is the best-case delay in response to a request?  \n In the future  when everyone has a home terminal connected to a computer network  instant public referendums on important pending legislation will become possible\n Ultimately  existing legislatures could be eliminated  to let the will of the people be expressed directly\n The positive aspects of such a direct democracy are fairly obvious; discuss some of the negative aspects Five routers are to be connected in a point-to-point subnet\n Between each pair of routers  the designers may put a high-speed line  a medium-speed line  a low-speed line  or no line\n If it takes ms of computer time to generate and inspect each topology  how long will it take to inspect all of them?  \n A disadvantage of a broadcast subnet is the capacity wasted when multiple hosts attempt to access the channel at the same time\n As a simplistic example  suppose that time is divided into discrete slots  with each of the n hosts attempting to use the channel with probability p during each slot\n What fraction of the slots will be wasted due to collisions?  \n What are two reasons for using layered protocols? What is one possible disadvantage of using layered protocols?  \n The president of the Specialty Paint Corp\n gets the idea to work with a local beer brewer to produce an invisible beer can (as an anti-litter measure)\n The president tells her legal department to look into it  and they in turn ask engineering for help\n As a result  the chief engineer calls his counterpart at the brewery to discuss the technical aspects of the project\n The engineers then report back to their respective legal departments  which then confer by telephone to arrange the legal aspects\n Finally  the two corporate presidents discuss the financial side of the deal\n What principle of a multilayer protocol in the sense of the OSI model does this communication mechanism violate?  \n  PROBLEMS  \n Two networks each provide reliable connection-oriented service\n One of them offers a reliable byte stream and the other offers a reliable message stream\n Are these identical? If so  why is the distinction made? If not  give an example of how they differ What does ‘‘negotiation’’ mean when discussing network protocols? Give an example In Fig\n  -   a service is shown\n Are any other services implicit in this figure? If so  where? If not  why not?  \n In some networks  the data link layer handles transmission errors by requesting that damaged frames be retransmitted\n If the probability of a frame’s being damaged is p  what is the mean number of transmissions required to send a frame? Assume that acknowledgements are never lost A system has an n-layer protocol hierarchy\n Applications generate messages of length M bytes\n At each of the layers  an h-byte header is added\n What fraction of the network bandwidth is filled with headers?  \n What is the main difference between TCP and UDP?  \n The subnet of Fig\n  -  (b) was designed to withstand a nuclear war\n How many bombs would it take to partition the nodes into two disconnected sets? Assume that any bomb wipes out a node and all of the links connected to it The Internet is roughly doubling in size every   months\n Although no one really knows for sure  one estimate put the number of hosts on it at million in \n Use these data to compute the expected number of Internet hosts in the year \n Do you believe this? Explain why or why not When a file is transferred between two computers  two acknowledgement strategies are possible\n In the first one  the file is chopped up into packets  which are individually acknowledged by the receiver  but the file transfer as a whole is not acknowledged\n In the ond one  the packets are not acknowledged individually  but the entire file is acknowledged when it arrives\n Discuss these two approaches Mobile phone network operators need to know where their subscribers’ mobile phones (hence their users) are located\n Explain why this is bad for users\n Now give reasons why this is good for users How long was a bit in the original   \n  standard in meters? Use a transmission speed of   Mbps and assume the propagation speed in coax is  /  the speed of light in vacuum An image is  ×  pixels with  bytes/pixel\n Assume the image is uncompressed\n How long does it take to transmit it over a  -kbps modem channel? Over a  -Mbps cable modem? Over a  -Mbps Ethernet? Over   -Mbps Ethernet? Over gigabit Ethernet?  \n Ethernet and wireless networks have some similarities and some differences\n One property of Ethernet is that only one frame at a time can be transmitted on an Ethernet\n Does   \n  share this property with Ethernet? Discuss your answer List two advantages and two disadvantages of having international standards for network protocols\n   INTRODUCTION   When a system has a permanent part and a removable part (such as a CD-ROM drive and the CD-ROM)  it is important that the system be standardized  so that different companies can make both the permanent and removable parts and everything still works together\n Give three examples outside the computer industry where such international standards exist\n Now give three areas outside the computer industry where they do not exist Suppose the algorithms used to implement the operations at layer k is changed\n How does this impact operations at layers k −  and k +  ?  \n Suppose there is a change in the service (set of operations) provided by layer k\n How does this impact services at layers k-  and k+ ?  \n Provide a list of reasons for why the response time of a client may be larger than the best-case delay What are the disadvantages of using small  fixed-length cells in ATM?  \n Make a list of activities that you do every day in which computer networks are used\n How would your life be altered if these networks were suddenly switched off?  \n Find out what networks are used at your school or place of work\n Describe the network types  topologies  and switching methods used there The ping program allows you to send a test packet to a given location and see how long it takes to get there and back\n Try using ping to see how long it takes to get from your location to several known locations\n From these data  plot the one-way transit time over the Internet as a function of distance\n It is best to use universities since the location of their servers is known very accurately\n For example    is in Berkeley  California;   is in Cambridge  Massachusetts;   is in Amsterdam; The Netherlands;  \n  is in Sydney  Australia; and  \n  is in Cape Town  South Africa Go to IETF’s Web site     to see what they are doing\n Pick a project you like and write a half-page report on the problem and the proposed solution The Internet is made up of a large number of networks\n Their arrangement determines the topology of the Internet\n A considerable amount of information about the Internet topology is available on line\n Use a search engine to find out more about the Internet topology and write a short report summarizing your findings Search the Internet to find out some of the important peering points used for routing packets in the Internet at present Write a program that implements message flow from the top layer to the bottom layer of the  -layer protocol model\n Your program should include a separate protocol function for each layer\n Protocol headers are sequence up to   characters\n Each protocol function has two parameters: a message passed from the higher layer protocol (a char buffer) and the size of the message\n This function attaches its header in front of the message  prints the new message on the standard output  and then invokes the protocol function of the lower-layer protocol\n Program input is an application message (a sequence of   characters or less)\n  THE PHYSICAL LAYER In this  ter we will look at the lowest layer in our protocol model  the physical layer\n It defines the electrical  timing and other interfaces by which bits are sent as signals over channels\n The physical layer is the foundation on which the network is built\n The properties of different kinds of physical channels determine the performance ( \n  throughput  latency  and error rate) so it is a good place to start our journey into networkland\n We will begin with a theoretical analysis of data transmission  only to discover that Mother (Parent?) Nature puts some limits on what can be sent over a channel\n Then we will cover three kinds of transmission media: guided (copper wire and fiber optics)  wireless (terrestrial radio)  and satellite\n Each of these technologies has different properties that affect the design and performance of the networks that use them\n This material will provide background information on the key transmission technologies used in modern networks\n Next comes digital modulation  which is all about how analog signals are converted into digital bits and back again\n After that we will look at multiplexing schemes  exploring how multiple conversations can be put on the same transmission medium at the same time without interfering with one another\n Finally  we will look at three examples of communication systems used in practice for wide area computer networks: the (fixed) telephone system  the mobile phone system  and the cable television system\n Each of these is important in practice  so we will devote a fair amount of space to each one\n  THE PHYSICAL LAYER  \n   \n  THE THEORETICAL BASIS FOR DATA COMMUNICATION Information can be transmitted on wires by varying some physical property such as voltage or current\n By representing the value of this voltage or current as a single-valued function of time  f(t)  we can model the behavior of the signal and analyze it mathematically\n This analysis is the subject of the following tions\n    Fourier Analysis In the early  th century  the French mathematician Jean-Baptiste Fourier proved that any reasonably behaved periodic function  g(t) with period T  can be constructed as the sum of a (possibly infinite) number of sines and cosines: g(t) = c + n =  Σ ∞ an sin( πnft ) + n =  Σ ∞ bn cos( πnft) ( - ) where f =  /T is the fundamental frequency  an and bn are the sine and cosine amplitudes of the nth harmonics (terms)  and c is a constant\n Such a decomposition is called a Fourier series\n From the Fourier series  the function can be reconstructed\n That is  if the period  T  is known and the amplitudes are given  the original function of time can be found by performing the sums of Eq\n ( - )\n A data signal that has a finite duration  which all of them do  can be handled by just imagining that it repeats the entire pattern over and over forever ( \n  the interval from T to  T is the same as from  to T  etc\n)\n The an amplitudes can be computed for any given g(t) by multiplying both sides of Eq\n ( - ) by sin( πkft ) and then integrating from  to T\n Since  ∫ T sin( πkft) sin( πnft ) dt = ⎧⎨⎩ T /  for k = n  for k ≠ n only one term of the summation survives: an\n The bn summation vanishes completely\n Similarly  by multiplying Eq\n ( - ) by cos( πkft ) and integrating between  and T  we can derive bn\n By just integrating both sides of the equation as it stands  we can find c\n The results of performing these operations are as follows: an = T ∫ T g(t) sin( πnft ) dt bn = T ∫ T g(t) cos( πnft ) dt c = T ∫ T g(t) dt    Bandwidth-Limited Signals The relevance of all of this to data communication is that real channels affect different frequency signals differently\n Let us consider a specific example: the transmission of the ASCII character ‘‘b’’ encoded in an  -bit byte\n The bit pattern that is to be transmitted is    \n The left-hand part of Fig\n  - (a) shows the   THE THEORETICAL BASIS FOR DATA COMMUNICATION   voltage output by the transmitting computer\n The Fourier analysis of this signal yields the coefficients: an = πn  [cos(πn / ) − cos( πn / ) + cos( πn / ) − cos( πn / )] bn = πn  [sin( πn / ) − sin(πn / ) + sin( πn / ) − sin( πn / )] c =  /  The root-mean-square amplitudes  √an  + bn for the first few terms are shown on the right-hand side of Fig\n  - (a)\n These values are of interest because their squares are proportional to the energy transmitted at the corresponding frequency\n No transmission facility can transmit signals without losing some power in the process\n If all the Fourier components were equally diminished  the resulting signal would be reduced in amplitude but not distorted [ \n  it would have the same nice squared-off shape as Fig\n  - (a)]\n Unfortunately  all transmission facilities diminish different Fourier components by different amounts  thus introducing distortion\n Usually  for a wire  the amplitudes are transmitted mostly undiminished from  up to some frequency fc [measured in cycles/ or Hertz (Hz)]  with all frequencies above this cutoff frequency attenuated\n The width of the frequency range transmitted without being strongly attenuated is called the bandwidth\n In practice  the cutoff is not really sharp  so often the quoted bandwidth is from  to the frequency at which the received power has fallen by half\n The bandwidth is a physical property of the transmission medium that depends on  for example  the construction  thickness  and length of a wire or fiber\n Filters are often used to further limit the bandwidth of a signal\n   \n  wireless channels are allowed to use up to roughly   MHz  for example  so   \n  radios filter the signal bandwidth to this size\n As another example  traditional (analog) television channels occupy  MHz each  on a wire or over the air\n This filtering lets more signals share a given region of spectrum  which improves the overall efficiency of the system\n It means that the frequency range for some signals will not start at zero  but this does not matter\n The bandwidth is still the width of the band of frequencies that are passed  and the information that can be carried depends only on this width and not on the starting and ending frequencies\n Signals that run from  up to a maximum frequency are called baseband signals\n Signals that are shifted to occupy a higher range of frequencies  as is the case for all wireless transmissions  are called passband signals\n Now let us consider how the signal of Fig\n  - (a) would look if the bandwidth were so low that only the lowest frequencies were transmitted [ \n  if the function were being approximated by the first few terms of Eq\n ( - )]\n Figure  - (b) shows the signal that results from a channel that allows only the first harmonic   THE PHYSICAL LAYER  \n     Time T    Time rms amplitude       \n   \n  Harmonic number  harmonic  harmonics  harmonics  harmonics     Harmonic number (a) (b) (c) (d) (e) Figure  - \n (a) A binary signal and its root-mean-square Fourier amplitudes\n (b)–(e) Successive approximations to the original signal\n   THE THEORETICAL BASIS FOR DATA COMMUNICATION   (the fundamental  f) to pass through\n Similarly  Fig\n  - (c)–(e) show the spectra and reconstructed functions for higher-bandwidth channels\n For digital transmission  the goal is to receive a signal with just enough fidelity to reconstruct the sequence of bits that was sent\n We can already do this easily in Fig\n  - (e)  so it is wasteful to use more harmonics to receive a more accurate replica\n Given a bit rate of b bits/  the time required to send the  bits in our example  bit at a time is  /b   so the frequency of the first harmonic of this signal is b /  Hz\n An ordinary telephone line  often called a voice-grade line  has an artificially introduced cutoff frequency just above  Hz\n The presence of this restriction means that the number of the highest harmonic passed through is roughly /(b/ )  or  /b (the cutoff is not sharp)\n For some data rates  the numbers work out as shown in Fig\n  - \n From these numbers  it is clear that trying to send at  bps over a voice-grade telephone line will transform Fig\n  - (a) into something looking like Fig\n  - (c)  making accurate reception of the original binary bit stream tricky\n It should be obvious that at data rates much higher than  \n  kbps  there is no hope at all for binary signals  even if the transmission facility is completely noiseless\n In other words  limiting the bandwidth limits the data rate  even for perfect channels\n However  coding schemes that make use of several voltage levels do exist and can achieve higher data rates\n We will discuss these later in this  ter\n Bps T (m) First harmonic (Hz) # Harmonics sent       \n       \n    \n  Figure  - \n Relation between data rate and harmonics for our example\n There is much confusion about bandwidth because it means different things to electrical engineers and to computer scientists\n To electrical engineers  (analog) bandwidth is (as we have described above) a quantity measured in Hz\n To computer scientists  (digital) bandwidth is the maximum data rate of a channel  a quantity measured in bits/\n That data rate is the end result of using the analog bandwidth of a physical channel for digital transmission  and the two are related  as we discuss next\n In this book  it will be clear from the context whether we mean analog bandwidth (Hz) or digital bandwidth (bits/)\n   THE PHYSICAL LAYER  \n     The Maximum Data Rate of a Channel As early as  an AT&T engineer  Henry Nyquist  realized that even a perfect channel has a finite transmission capacity\n He derived an equation expressing the maximum data rate for a finite-bandwidth noiseless channel\n In  Claude Shannon carried Nyquist’s work further and extended it to the case of a channel subject to random (that is  thermodynamic) noise (Shannon  )\n This paper is the most important paper in all of information theory\n We will just briefly summarize their now classical results here\n Nyquist proved that if an arbitrary signal has been run through a low-pass filter of bandwidth B  the filtered signal can be completely reconstructed by making only  B (exact) samples per ond\n Sampling the line faster than  B times per ond is pointless because the higher-frequency components that such sampling could recover have already been filtered out\n If the signal consists of V discrete levels  Nyquist’s theorem states: maximum data rate =  B log  V bits / ( - ) For example  a noiseless  -kHz channel cannot transmit binary ( \n  two-level) signals at a rate exceeding  bps\n So far we have considered only noiseless channels\n If random noise is present  the situation deteriorates rapidly\n And there is always random (thermal) noise present due to the motion of the molecules in the system\n The amount of thermal noise present is measured by the ratio of the signal power to the noise power  called the SNR (Signal-to-Noise Ratio)\n If we denote the signal power by S and the noise power by N  the signal-to-noise ratio is S/N\n Usually  the ratio is expressed on a log scale as the quantity   log  S /N because it can vary over a tremendous range\n The units of this log scale are called decibels (dB)  with ‘‘deci’’ meaning   and ‘‘bel’’ chosen to honor Alexander Graham Bell  who invented the telephone\n An S /N ratio of   is   dB  a ratio of is   dB  a ratio of  is   dB  and so on\n The manufacturers of stereo amplifiers often characterize the bandwidth (frequency range) over which their products are linear by giving the  - dB frequency on each end\n These are the points at which the amplification factor has been approximately halved (because   log  \n ∼∼ − )\n Shannon’s major result is that the maximum data rate or capacity of a noisy channel whose bandwidth is B Hz and whose signal-to-noise ratio is S/N  is given by: maximum number of bits/ = B log  (  + S/N) ( - ) This tells us the best capacities that real channels can have\n For example  ADSL (Asymmetric Digital Subscriber Line)  which provides Internet access over normal telephone lines  uses a bandwidth of around  MHz\n The SNR depends strongly on the distance of the home from the telephone exchange  and an SNR of around   dB for short lines of  to  km is very good\n With these characteristics    THE THEORETICAL BASIS FOR DATA COMMUNICATION   the channel can never transmit much more than   Mbps  no matter how many or how few signal levels are used and no matter how often or how infrequently samples are taken\n In practice  ADSL is specified up to   Mbps  though users often see lower rates\n This data rate is actually very good  with over   years of communications techniques having greatly reduced the gap between the Shannon capacity and the capacity of real systems\n Shannon’s result was derived from information-theory arguments and applies to any channel subject to thermal noise\n Counterexamples should be treated in the same category as perpetual motion machines\n For ADSL to exceed   Mbps  it must either improve the SNR (for example by inserting digital repeaters in the lines closer to the customers) or use more bandwidth  as is done with the evolution to ASDL +  GUIDED TRANSMISSION MEDIA The purpose of the physical layer is to transport bits from one machine to another\n Various physical media can be used for the actual transmission\n Each one has its own niche in terms of bandwidth  delay  cost  and ease of installation and maintenance\n Media are roughly grouped into guided media  such as copper wire and fiber optics  and unguided media  such as terrestrial wireless  satellite  and lasers through the air\n We will look at guided media in this tion  and unguided media in the next tions\n    Magnetic Media One of the most common ways to transport data from one computer to another is to write them onto magnetic tape or removable media ( \n  recordable DVDs)  physically transport the tape or disks to the destination machine  and read them back in again\n Although this method is not as sophisticated as using a geosynchronous communication satellite  it is often more cost effective  especially for applications in which high bandwidth or cost per bit transported is the key factor\n A simple calculation will make this point clear\n An industry-standard Ultrium tape can hold gigabytes\n A box   ×   ×   cm can hold about  of these tapes  for a total capacity of terabytes  or  terabits ( \n  petabits)\n A box of tapes can be delivered anywhere in the United States in   hours by Federal Express and other companies\n The effective bandwidth of this transmission is  terabits/    or a bit over   Gbps\n If the destination is only an hour away by road  the bandwidth is increased to over  Gbps\n No computer network can even approach this\n Of course  networks are getting faster  but tape densities are increasing  too\n If we now look at cost  we get a similar picture\n The cost of an Ultrium tape is around $  when bought in bulk\n A tape can be reused at least   times  so the   THE PHYSICAL LAYER  \n  tape cost is maybe $ per box per usage\n Add to this another $ for shipping (probably much less)  and we have a cost of roughly $ to ship TB\n This amounts to shipping a gigabyte for a little over half a cent\n No network can beat that\n The moral of the story is: Never underestimate the bandwidth of a station wagon full of tapes hurtling down the highway\n    Twisted Pairs Although the bandwidth characteristics of magnetic tape are excellent  the delay characteristics are poor\n Transmission time is measured in minutes or hours  not millionds\n For many applications an online connection is needed\n One of the oldest and still most common transmission media is twisted pair\n A twisted pair consists of two insulated copper wires  typically about  mm thick\n The wires are twisted together in a helical form  just like a DNA molecule\n Twisting is done because two parallel wires constitute a fine antenna\n When the wires are twisted  the waves from different twists cancel out  so the wire radiates less effectively\n A signal is usually carried as the difference in voltage between the two wires in the pair\n This provides better immunity to external noise because the noise tends to affect both wires the same  leaving the differential unchanged\n The most common application of the twisted pair is the telephone system\n Nearly all telephones are connected to the telephone company (telco) office by a twisted pair\n Both telephone calls and ADSL Internet access run over these lines\n Twisted pairs can run several kilometers without amplification  but for longer distances the signal becomes too attenuated and repeaters are needed\n When many twisted pairs run in parallel for a substantial distance  such as all the wires coming from an apartment building to the telephone company office  they are bundled together and encased in a protective sheath\n The pairs in these bundles would interfere with one another if it were not for the twisting\n In parts of the world where telephone lines run on poles above ground  it is common to see bundles several centimeters in diameter\n Twisted pairs can be used for transmitting either analog or digital information\n The bandwidth depends on the thickness of the wire and the distance traveled  but several megabits/ can be achieved for a few kilometers in many cases\n Due to their adequate performance and low cost  twisted pairs are widely used and are likely to remain so for years to come\n Twisted-pair cabling comes in several varieties\n The garden variety deployed in many office buildings is called Category  cabling  or ‘‘Cat  \n’’ A category  twisted pair consists of two insulated wires gently twisted together\n Four such pairs are typically grouped in a plastic sheath to protect the wires and keep them together\n This arrangement is shown in Fig\n  - \n Different LAN standards may use the twisted pairs differently\n For example -Mbps Ethernet uses two (out of the four) pairs  one pair for each direction\n   GUIDED TRANSMISSION MEDIA   Twisted pair Figure  - \n Category  UTP cable with four twisted pairs\n To reach higher speeds  -Gbps Ethernet uses all four pairs in both directions simultaneously; this requires the receiver to factor out the signal that is transmitted locally\n Some general terminology is now in order\n Links that can be used in both directions at the same time  like a two-lane road  are called full-duplex links\n In contrast  links that can be used in either direction  but only one way at a time  like a single-track railroad line\n are called half-duplex links\n A third category consists of links that allow traffic in only one direction  like a one-way street\n They are called simplex links\n Returning to twisted pair  Cat  replaced earlier Category  cables with a similar cable that uses the same connector  but has more twists per meter\n More twists result in less crosstalk and a better-quality signal over longer distances  making the cables more suitable for high-speed computer communication  especially   -Mbps and  -Gbps Ethernet LANs\n New wiring is more likely to be Category  or even Category  \n These categories has more stringent specifications to handle signals with greater bandwidths\n Some cables in Category  and above are rated for signals of MHz and can support the  -Gbps links that will soon be deployed\n Through Category   these wiring types are referred to as UTP (Unshielded Twisted Pair) as they consist simply of wires and insulators\n In contrast to these  Category  cables have shielding on the individual twisted pairs  as well as around the entire cable (but inside the plastic protective sheath)\n Shielding reduces the susceptibility to external interference and crosstalk with other nearby cables to meet demanding performance specifications\n The cables are reminiscent of the high-quality  but bulky and expensive shielded twisted pair cables that IBM introduced in the early s  but which did not prove popular outside of IBM installations\n Evidently  it is time to try again\n    Coaxial Cable Another common transmission medium is the coaxial cable (known to its many friends as just ‘‘coax’’ and pronounced ‘‘co-ax’’)\n It has better shielding and greater bandwidth than unshielded twisted pairs  so it can span longer distances at   THE PHYSICAL LAYER  \n  higher speeds\n Two kinds of coaxial cable are widely used\n One kind   -ohm cable  is commonly used when it is intended for digital transmission from the start\n The other kind   -ohm cable  is commonly used for analog transmission and cable television\n This distinction is based on historical  rather than technical  factors ( \n  early dipole antennas had an impedance of ohms  and it was easy to use existing  :  impedance-matching transformers)\n Starting in the mid- s  cable TV operators began to provide Internet access over cable  which has made  -ohm cable more important for data communication\n A coaxial cable consists of a stiff copper wire as the core  surrounded by an insulating material\n The insulator is encased by a cylindrical conductor  often as a closely woven braided mesh\n The outer conductor is covered in a protective plastic sheath\n A cutaway view of a coaxial cable is shown in Fig\n  - \n Copper core Insulating material Braided outer conductor Protective plastic covering Figure  - \n A coaxial cable\n The construction and shielding of the coaxial cable give it a good combination of high bandwidth and excellent noise immunity\n The bandwidth possible depends on the cable quality and length\n Modern cables have a bandwidth of up to a few GHz\n Coaxial cables used to be widely used within the telephone system for long-distance lines but have now largely been replaced by fiber optics on longhaul routes\n Coax is still widely used for cable television and metropolitan area networks  however\n    Power Lines The telephone and cable television networks are not the only sources of wiring that can be reused for data communication\n There is a yet more common kind of wiring: electrical power lines\n Power lines deliver electrical power to houses  and electrical wiring within houses distributes the power to electrical outlets\n The use of power lines for data communication is an old idea\n Power lines have been used by electricity companies for low-rate communication such as remote metering for many years  as well in the home to control devices ( \n  the X  standard)\n In recent years there has been renewed interest in high-rate communication over these lines  both inside the home as a LAN and outside the home   GUIDED TRANSMISSION MEDIA   for broadband Internet access\n We will concentrate on the most common scenario: using electrical wires inside the home\n The convenience of using power lines for networking should be clear\n Simply plug a TV and a receiver into the wall  which you must do anyway because they need power  and they can send and receive movies over the electrical wiring\n This configuration is shown in Fig\n  - \n There is no other plug or radio\n The data signal is superimposed on the low-frequency power signal (on the active or ‘‘hot’’ wire) as both signals use the wiring at the same time\n Power signal Electric cable Data signal Figure  - \n A network that uses household electrical wiring\n The difficulty with using household electrical wiring for a network is that it was designed to distribute power signals\n This task is quite different than distributing data signals  at which household wiring does a horrible job\n Electrical signals are sent at  –  Hz and the wiring attenuates the much higher frequency (MHz) signals needed for high-rate data communication\n The electrical properties of the wiring vary from one house to the next and change as appliances are turned on and off  which causes data signals to bounce around the wiring\n Transient currents when appliances switch on and off create electrical noise over a wide range of frequencies\n And without the careful twisting of twisted pairs  electrical wiring acts as a fine antenna  picking up external signals and radiating signals of its own\n This behavior means that to meet regulatory requirements  the data signal must exclude licensed frequencies such as the amateur radio bands\n Despite these difficulties  it is practical to send at least Mbps over typical household electrical wiring by using communication schemes that resist impaired frequencies and bursts of errors\n Many products use various proprietary standards for power-line networking  so international standards are actively under development\n    Fiber Optics Many people in the computer industry take enormous pride in how fast computer technology is improving as it follows Moore’s law  which predicts a doubling of the number of transistors per chip roughly every two years (Schaller  THE PHYSICAL LAYER  \n  )\n The original (   ) IBM PC ran at a clock speed of  \n  MHz\n Twentyeight years later  PCs could run a four-core CPU at  GHz\n This increase is a gain of a factor of around  or   per decade\n Impressive\n In the same period  wide area communication links went from   Mbps (a T  line in the telephone system) to Gbps (a modern long distance line)\n This gain is similarly impressive  more than a factor of  and close to   per decade  while at the same time the error rate went from  −  per bit to almost zero\n Furthermore  single CPUs are beginning to approach physical limits  which is why it is now the number of CPUs that is being increased per chip\n In contrast  the achievable bandwidth with fiber technology is in excess of   Gbps (  Tbps) and we are nowhere near reaching these limits\n The current practical limit of around Gbps is due to our inability to convert between electrical and optical signals any faster\n To build higher-capacity links  many channels are simply carried in parallel over a single fiber\n In this tion we will study fiber optics to learn how that transmission technology works\n In the ongoing race between computing and communication  communication may yet win because of fiber optic networks\n The implication of this would be essentially infinite bandwidth and a new conventional wisdom that computers are hopelessly slow so that networks should try to avoid computation at all costs  no matter how much bandwidth that wastes\n This change will take a while to sink in to a generation of computer scientists and engineers taught to think in terms of the low Shannon limits imposed by copper\n Of course  this scenario does not tell the whole story because it does not include cost\n The cost to install fiber over the last mile to reach consumers and bypass the low bandwidth of wires and limited availability of spectrum is tremendous\n It also costs more energy to move bits than to compute\n We may always have islands of inequities where either computation or communication is essentially free\n For example  at the edge of the Internet we throw computation and storage at the problem of compressing and caching content  all to make better use of Internet access links\n Within the Internet  we may do the reverse  with companies such as Google moving huge amounts of data across the network to where it is cheaper to store or compute on it\n Fiber optics are used for long-haul transmission in network backbones  highspeed LANs (although so far  copper has always managed catch up eventually)  and high-speed Internet access such as FttH (Fiber to the Home)\n An optical transmission system has three key components: the light source  the transmission medium  and the detector\n Conventionally  a pulse of light indicates a  bit and the absence of light indicates a  bit\n The transmission medium is an ultra-thin fiber of glass\n The detector generates an electrical pulse when light falls on it\n By attaching a light source to one end of an optical fiber and a detector to the other  we have a unidirectional data transmission system that accepts an electrical signal  converts and transmits it by light pulses  and then reconverts the output to an electrical signal at the receiving end\n   GUIDED TRANSMISSION MEDIA This transmission system would leak light and be useless in practice were it not for an interesting principle of physics\n When a light ray passes from one medium to another—for example  from fused silica to air—the ray is refracted (bent) at the silica/air boundary  as shown in Fig\n  - (a)\n Here we see a light ray incident on the boundary at an angle α  emerging at an angle β \n The amount of refraction depends on the properties of the two media (in particular  their indices of refraction)\n For angles of incidence above a certain critical value  the light is refracted back into the silica; none of it escapes into the air\n Thus  a light ray incident at or above the critical angle is trapped inside the fiber  as shown in Fig\n  - (b)  and can propagate for many kilometers with virtually no loss\n Total internal reflection\n Air/silica boundary Silica Light source Air (a) (b) β  β  β  α  α  α  Figure  - \n (a) Three examples of a light ray from inside a silica fiber impinging on the air/silica boundary at different angles\n (b) Light trapped by total internal reflection\n The sketch of Fig\n  - (b) shows only one trapped ray  but since any light ray incident on the boundary above the critical angle will be reflected internally  many different rays will be bouncing around at different angles\n Each ray is said to have a different mode  so a fiber having this property is called a multimode fiber\n However  if the fiber’s diameter is reduced to a few wavelengths of light the fiber acts like a wave guide and the light can propagate only in a straight line  without bouncing  yielding a single-mode fiber\n Single-mode fibers are more expensive but are widely used for longer distances\n Currently available single-mode fibers can transmit data at Gbps for km without amplification\n Even higher data rates have been achieved in the laboratory for shorter distances\n Transmission of Light Through Fiber Optical fibers are made of glass  which  in turn  is made from sand  an inexpensive raw material available in unlimited amounts\n Glassmaking was known to the ancient Egyptians  but their glass had to be no more than  mm thick or the THE PHYSICAL LAYER  \n  light could not shine through\n Glass transparent enough to be useful for windows was developed during the Renaissance\n The glass used for modern optical fibers is so transparent that if the oceans were full of it instead of water  the seabed would be as visible from the surface as the ground is from an airplane on a clear day\n The attenuation of light through glass depends on the wavelength of the light (as well as on some physical properties of the glass)\n It is defined as the ratio of input to output signal power\n For the kind of glass used in fibers  the attenuation is shown in Fig\n  -  in units of decibels per linear kilometer of fiber\n For example  a factor of two loss of signal power gives an attenuation of   log =  dB\n The figure shows the near-infrared part of the spectrum  which is what is used in practice\n Visible light has slightly shorter wavelengths  from  \n  to  \n  microns\n (  micron is  −  meters\n) The true metric purist would refer to these wavelengths as nm to nm  but we will stick with traditional usage\n                   Wavelength (microns)  \n  μ Band  \n  μ Band  \n  μ Band Attenuation (dB/km)      \n  Figure  - \n Attenuation of light through fiber in the infrared region\n Three wavelength bands are most commonly used at present for optical communication\n They are centered at     and  \n  microns  respectively\n All three bands are   to   GHz wide\n The  \n  -micron band was used first\n It has higher attenuation and so is used for shorter distances  but at that wavelength the lasers and electronics could be made from the same material (gallium arsenide)\n The last two bands have good attenuation properties (less than  % loss per kilometer)\n The  \n  -micron band is now widely used with erbium-doped amplifiers that work directly in the optical domain\n   GUIDED TRANSMISSION MEDIA Light pulses sent down a fiber spread out in length as they propagate\n This spreading is called chromatic dispersion\n The amount of it is wavelength dependent\n One way to keep these spread-out pulses from overlapping is to increase the distance between them  but this can be done only by reducing the signaling rate\n Fortunately  it has been discovered that making the pulses in a special shape related to the reciprocal of the hyperbolic cosine causes nearly all the dispersion effects cancel out  so it is possible to send pulses for thousands of kilometers without appreciable shape distortion\n These pulses are called solitons\n A considerable amount of research is going on to take solitons out of the lab and into the field\n Fiber Cables Fiber optic cables are similar to coax  except without the braid\n Figure  - (a) shows a single fiber viewed from the side\n At the center is the glass core through which the light propagates\n In multimode fibers  the core is typically   microns in diameter  about the thickness of a human hair\n In single-mode fibers  the core is  to   microns\n Jacket (plastic) Core Cladding Sheath Jacket Cladding (glass) Core (glass) (a) (b) Figure  - \n (a) Side view of a single fiber\n (b) End view of a sheath with three fibers\n The core is surrounded by a glass cladding with a lower index of refraction than the core  to keep all the light in the core\n Next comes a thin plastic jacket to protect the cladding\n Fibers are typically grouped in bundles  protected by an outer sheath\n Figure  - (b) shows a sheath with three fibers\n Terrestrial fiber sheaths are normally laid in the ground within a meter of the surface  where they are occasionally subject to attacks by backhoes or gophers\n Near the shore  transoceanic fiber sheaths are buried in trenches by a kind of seaplow\n In deep water  they just lie on the bottom  where they can be snagged by fishing trawlers or attacked by giant squid\n Fibers can be connected in three different ways\n First  they can terminate in connectors and be plugged into fiber sockets\n Connectors lose about   to  % of the light  but they make it easy to reconfigure systems\n ond  they can be spliced mechanically\n Mechanical splices just lay the two carefully cut ends next to each other in a special sleeve and clamp them in THE PHYSICAL LAYER  \n  place\n Alignment can be improved by passing light through the junction and then making small adjustments to maximize the signal\n Mechanical splices take trained personnel about  minutes and result in a  % light loss\n Third  two pieces of fiber can be fused (melted) to form a solid connection\n A fusion splice is almost as good as a single drawn fiber  but even here  a small amount of attenuation occurs\n For all three kinds of splices  reflections can occur at the point of the splice  and the reflected energy can interfere with the signal\n Two kinds of light sources are typically used to do the signaling\n These are LEDs (Light Emitting Diodes) and semiconductor lasers\n They have different properties  as shown in Fig\n  - \n They can be tuned in wavelength by inserting Fabry-Perot or Mach-Zehnder interferometers between the source and the fiber\n Fabry-Perot interferometers are simple resonant cavities consisting of two parallel mirrors\n The light is incident perpendicular to the mirrors\n The length of the cavity selects out those wavelengths that fit inside an integral number of times\n Mach-Zehnder interferometers separate the light into two beams\n The two beams travel slightly different distances\n They are recombined at the end and are in phase for only certain wavelengths\n Item LED Semiconductor laser Data rate Low High Fiber type Multi-mode Multi-mode or single-mode Distance Short Long Lifetime Long life Short life Temperature sensitivity Minor Substantial Cost Low cost Expensive Figure  - \n A comparison of semiconductor diodes and LEDs as light sources\n The receiving end of an optical fiber consists of a photodiode  which gives off an electrical pulse when struck by light\n The response time of photodiodes  which convert the signal from the optical to the electrical domain  limits data rates to about Gbps\n Thermal noise is also an issue  so a pulse of light must carry enough energy to be detected\n By making the pulses powerful enough  the error rate can be made arbitrarily small\n Comparison of Fiber Optics and Copper Wire It is instructive to compare fiber to copper\n Fiber has many advantages\n To start with  it can handle much higher bandwidths than copper\n This alone would require its use in high-end networks\n Due to the low attenuation  repeaters are needed only about every   km on long lines  versus about every  km for copper    GUIDED TRANSMISSION MEDIA resulting in a big cost saving\n Fiber also has the advantage of not being affected by power surges  electromagnetic interference  or power failures\n Nor is it affected by corrosive chemicals in the air  important for harsh factory environments\n Oddly enough  telephone companies like fiber for a different reason: it is thin and lightweight\n Many existing cable ducts are completely full  so there is no room to add new capacity\n Removing all the copper and replacing it with fiber empties the ducts  and the copper has excellent resale value to copper refiners who see it as very high-grade ore\n Also  fiber is much lighter than copper\n One thousand twisted pairs  km long weigh  kg\n Two fibers have more capacity and weigh only kg  which reduces the need for expensive mechanical support systems that must be maintained\n For new routes  fiber wins hands down due to its much lower installation cost\n Finally  fibers do not leak light and are difficult to tap\n These properties give fiber good urity against potential wiretappers\n On the downside  fiber is a less familiar technology requiring skills not all engineers have  and fibers can be damaged easily by being bent too much\n Since optical transmission is inherently unidirectional  two-way communication requires either two fibers or two frequency bands on one fiber\n Finally  fiber interfaces cost more than electrical interfaces\n Nevertheless  the future of all fixed data communication over more than short distances is clearly with fiber\n For a discussion of all aspects of fiber optics and their networks  see Hecht (   )  WIRELESS TRANSMISSION Our age has given rise to information junkies: people who need to be online all the time\n For these mobile users  twisted pair  coax  and fiber optics are of no use\n They need to get their ‘‘hits’’ of data for their laptop  notebook  shirt pocket  palmtop  or wristwatch computers without being tethered to the terrestrial communication infrastructure\n For these users  wireless communication is the answer\n In the following tions  we will look at wireless communication in general\n It has many other important applications besides providing connectivity to users who want to surf the Web from the beach\n Wireless has advantages for even fixed devices in some circumstances\n For example  if running a fiber to a building is difficult due to the terrain (mountains  jungles  swamps  etc\n)  wireless may be better\n It is noteworthy that modern wireless digital communication began in the Hawaiian Islands  where large chunks of Pacific Ocean separated the users from their computer center and the telephone system was inadequate\n    The Electromagnetic Spectrum When electrons move  they create electromagnetic waves that can propagate through space (even in a vacuum)\n These waves were predicted by the British physicist James Clerk Maxwell in  and first observed by the German THE PHYSICAL LAYER  \n  physicist Heinrich Hertz in \n The number of oscillations per ond of a wave is called its frequency  f  and is measured in Hz (in honor of Heinrich Hertz)\n The distance between two conutive maxima (or minima) is called the wavelength  which is universally designated by the Greek letter λ (lambda)\n When an antenna of the appropriate size is attached to an electrical circuit  the electromagnetic waves can be broadcast efficiently and received by a receiver some distance away\n All wireless communication is based on this principle\n In a vacuum  all electromagnetic waves travel at the same speed  no matter what their frequency\n This speed  usually called the speed of light  c  is approximately  × m/  or about  foot (  cm) per nanoond\n (A case could be made for redefining the foot as the distance light travels in a vacuum in  n rather than basing it on the shoe size of some long-dead king\n) In copper or fiber the speed slows to about  /  of this value and becomes slightly frequency dependent\n The speed of light is the ultimate speed limit\n No object or signal can ever move faster than it\n The fundamental relation between f  λ  and c (in a vacuum) is λf = c ( - ) Since c is a constant  if we know f  we can find λ  and vice versa\n As a rule of thumb  when λ is in meters and f is in MHz  λf ∼∼   \n For example -MHz waves are about  meters long  -MHz waves are  \n  meters long  and  \n - meter waves have a frequency of  MHz\n The electromagnetic spectrum is shown in Fig\n  -  \n The radio  microwave  infrared  and visible light portions of the spectrum can all be used for transmitting information by modulating the amplitude  frequency  or phase of the waves\n Ultraviolet light  X-rays  and gamma rays would be even better  due to their higher frequencies  but they are hard to produce and modulate  do not propagate well through buildings  and are dangerous to living things\n The bands listed at the bottom of Fig\n  -  are the official ITU (International Telecommunication Union) names and are based on the wavelengths  so the LF band goes from  km to   km (approximately   kHz to kHz)\n The terms LF  MF  and HF refer to Low  Medium  and High Frequency  respectively\n Clearly  when the names were assigned nobody expected to go above   MHz  so the higher bands were later named the Very  Ultra  Super  Extremely  and Tremendously High Frequency bands\n Beyond that there are no names  but Incredibly  Astonishingly  and Prodigiously High Frequency (IHF  AHF  and PHF) would sound nice\n We know from Shannon [Eq\n ( - )] that the amount of information that a signal such as an electromagnetic wave can carry depends on the received power and is proportional to its bandwidth\n From Fig\n  -  it should now be obvious why networking people like fiber optics so much\n Many GHz of bandwidth are available to tap for data transmission in the microwave band  and even more in fiber because it is further to the right in our logarithmic scale\n As an example  consider the  \n  -micron band of Fig\n  -  which has a width of  \n  microns\n If we use   WIRELESS TRANSMISSION         Radio Microwave Infrared UV X-ray Gamma ray f (Hz) Visible light        f (Hz) Twisted pair Coax Satellite TV Terrestrial microwave Fiber optics Maritime AM radio FM radio Band LF MF HF VHF UHF SHF EHF THF Figure  -  \n The electromagnetic spectrum and its uses for communication\n Eq\n ( - ) to find the start and end frequencies from the start and end wavelengths  we find the frequency range to be about   GHz\n With a reasonable signalto- noise ratio of   dB  this is Tbps\n Most transmissions use a relatively narrow frequency band ( \n  Δf / f <<  )\n They concentrate their signals in this narrow band to use the spectrum efficiently and obtain reasonable data rates by transmitting with enough power\n However  in some cases  a wider band is used  with three variations\n In frequency hopping spread spectrum  the transmitter hops from frequency to frequency hundreds of times per ond\n It is popular for military communication because it makes transmissions hard to detect and next to impossible to jam\n It also offers good resistance to multipath fading and narrowband interference because the receiver will not be stuck on an impaired frequency for long enough to shut down communication\n This robustness makes it useful for crowded parts of the spectrum  such as the ISM bands we will describe shortly\n This technique is used commercially  for example  in Bluetooth and older versions of    As a curious footnote  the technique was coinvented by the Austrian-born sex goddess Hedy Lamarr  the first woman to appear nude in a motion picture (the  Czech film Extase)\n Her first husband was an armaments manufacturer who told her how easy it was to block the radio signals then used to control torpedoes\n When she discovered that he was selling weapons to Hitler  she was horrified  disguised herself as a maid to escape him  and fled to Hollywood to continue her career as a movie actress\n In her spare time  she invented frequency hopping to help the Allied war effort\n Her scheme used   frequencies  the number of keys THE PHYSICAL LAYER  \n  (and frequencies) on the piano\n For their invention  she and her friend  the musical composer George Antheil  received  \n patent  \n However  they were unable to convince the  \n Navy that their invention had any practical use and never received any royalties\n Only years after the patent expired did it become popular\n A ond form of spread spectrum  direct sequence spread spectrum  uses a code sequence to spread the data signal over a wider frequency band\n It is widely used commercially as a spectrally efficient way to let multiple signals share the same frequency band\n These signals can be given different codes  a method called CDMA (Code Division Multiple Access) that we will return to later in this  ter\n This method is shown in contrast with frequency hopping in Fig\n  -  \n It forms the basis of  G mobile phone networks and is also used in GPS (Global Positioning System)\n Even without different codes  direct sequence spread spectrum  like frequency hopping spread spectrum  can tolerate narrowband interference and multipath fading because only a fraction of the desired signal is lost\n It is used in this role in older   \n  b wireless LANs\n For a fascinating and detailed history of spread spectrum communication  see Scholtz (   )\n Ultrawideband underlay (CDMA user with different code) Direct sequence spread spectrum Frequency hopping spread spectrum Frequency (CDMA user with different code) Figure  -  \n Spread spectrum and ultra-wideband (UWB) communication\n A third method of communication with a wider band is UWB (Ultra- WideBand) communication\n UWB sends a series of rapid pulses  varying their positions to communicate information\n The rapid transitions lead to a signal that is spread thinly over a very wide frequency band\n UWB is defined as signals that have a bandwidth of at least MHz or at least  % of the center frequency of their frequency band\n UWB is also shown in Fig\n  -  \n With this much bandwidth  UWB has the potential to communicate at high rates\n Because it is spread across a wide band of frequencies  it can tolerate a substantial amount of relatively strong interference from other narrowband signals\n Just as importantly  since UWB has very little energy at any given frequency when used for short-range transmission  it does not cause harmful interference to those other narrowband radio signals\n It is said to underlay the other signals\n This peaceful coexistence has led to its application in wireless PANs that run at up to  Gbps  although commercial success has been mixed\n It can also be used for imaging through solid objects (ground  walls  and bodies) or as part of precise location systems\n   WIRELESS TRANSMISSION We will now discuss how the various parts of the electromagnetic spectrum of Fig\n  -  are used  starting with radio\n We will assume that all transmissions use a narrow frequency band unless otherwise stated\n    Radio Transmission Radio frequency (RF) waves are easy to generate  can travel long distances  and can penetrate buildings easily  so they are widely used for communication  both indoors and outdoors\n Radio waves also are omnidirectional  meaning that they travel in all directions from the source  so the transmitter and receiver do not have to be carefully aligned physically\n Sometimes omnidirectional radio is good  but sometimes it is bad\n In the s  General Motors decided to equip all its new Cadillacs with computer-controlled antilock brakes\n When the driver stepped on the brake pedal  the computer pulsed the brakes on and off instead of locking them on hard\n One fine day an Ohio Highway Patrolman began using his new mobile radio to call headquarters  and suddenly the Cadillac next to him began behaving like a bucking bronco\n When the officer pulled the car over  the driver claimed that he had done nothing and that the car had gone crazy\n Eventually  a pattern began to emerge: Cadillacs would sometimes go berserk  but only on major highways in Ohio and then only when the Highway Patrol was watching\n For a long  long time General Motors could not understand why Cadillacs worked fine in all the other states and also on minor roads in Ohio\n Only after much searching did they discover that the Cadillac’s wiring made a fine antenna for the frequency used by the Ohio Highway Patrol’s new radio system\n The properties of radio waves are frequency dependent\n At low frequencies  radio waves pass through obstacles well  but the power falls off sharply with distance from the source—at least as fast as  /r  in air—as the signal energy is spread more thinly over a larger surface\n This attenuation is called path loss\n At high frequencies  radio waves tend to travel in straight lines and bounce off obstacles\n Path loss still reduces power  though the received signal can depend strongly on reflections as well\n High-frequency radio waves are also absorbed by rain and other obstacles to a larger extent than are low-frequency ones\n At all frequencies  radio waves are subject to interference from motors and other electrical equipment\n It is interesting to compare the attenuation of radio waves to that of signals in guided media\n With fiber  coax and twisted pair  the signal drops by the same fraction per unit distance  for example   dB per   m for twisted pair\n With radio  the signal drops by the same fraction as the distance doubles  for example  dB per doubling in free space\n This behavior means that radio waves can travel long distances  and interference between users is a problem\n For this reason  all governments tightly regulate the use of radio transmitters  with few notable exceptions  which are discussed later in this  ter\n THE PHYSICAL LAYER  \n  In the VLF  LF  and MF bands  radio waves follow the ground  as illustrated in Fig\n  -  (a)\n These waves can be detected for perhaps  km at the lower frequencies  less at the higher ones\n AM radio broadcasting uses the MF band  which is why the ground waves from Boston AM radio stations cannot be heard easily in New York\n Radio waves in these bands pass through buildings easily  which is why portable radios work indoors\n The main problem with using these bands for data communication is their low bandwidth [see Eq\n ( - )]\n e r e h p s o n o I Earth's surface Earth's surface (a) (b) Ground wave Figure  -  \n (a) In the VLF  LF  and MF bands  radio waves follow the curvature of the earth\n (b) In the HF band  they bounce off the ionosphere\n In the HF and VHF bands  the ground waves tend to be absorbed by the earth\n However  the waves that reach the ionosphere  a layer of charged particles circling the earth at a height of to km  are refracted by it and sent back to earth  as shown in Fig\n  -  (b)\n Under certain atmospheric conditions  the signals can bounce several times\n Amateur radio operators (hams) use these bands to talk long distance\n The military also communicate in the HF and VHF bands\n    Microwave Transmission Above MHz  the waves travel in nearly straight lines and can therefore be narrowly focused\n Concentrating all the energy into a small beam by means of a parabolic antenna (like the familiar satellite TV dish) gives a much higher signalto- noise ratio  but the transmitting and receiving antennas must be accurately aligned with each other\n In addition  this directionality allows multiple transmitters lined up in a row to communicate with multiple receivers in a row without interference  provided some minimum spacing rules are observed\n Before fiber optics  for decades these microwaves formed the heart of the long-distance telephone transmission system\n In fact  MCI  one of AT&T’s first competitors after it was deregulated  built its entire system with microwave communications passing between towers tens of kilometers apart\n Even the company’s name reflected this (MCI stood for Microwave Communications  Inc\n)\n MCI has since gone over to fiber and through a long series of corporate mergers and bankruptcies in the telecommunications shuffle has become part of Verizon\n   WIRELESS TRANSMISSION Microwaves travel in a straight line  so if the towers are too far apart  the earth will get in the way (think about a Seattle-to-Amsterdam link)\n Thus  repeaters are needed periodically\n The higher the towers are  the farther apart they can be\n The distance between repeaters goes up very roughly with the square root of the tower height\n For   -meter-high towers  repeaters can be   km apart\n Unlike radio waves at lower frequencies  microwaves do not pass through buildings well\n In addition  even though the beam may be well focused at the transmitter  there is still some divergence in space\n Some waves may be refracted off low-lying atmospheric layers and may take slightly longer to arrive than the direct waves\n The delayed waves may arrive out of phase with the direct wave and thus cancel the signal\n This effect is called multipath fading and is often a serious problem\n It is weather and frequency dependent\n Some operators keep  % of their channels idle as spares to switch on when multipath fading temporarily wipes out some frequency band\n The demand for more and more spectrum drives operators to yet higher frequencies\n Bands up to   GHz are now in routine use  but at about  GHz a new problem sets in: absorption by water\n These waves are only a few centimeters long and are absorbed by rain\n This effect would be fine if one were planning to build a huge outdoor microwave oven for roasting passing birds  but for communication it is a severe problem\n As with multipath fading  the only solution is to shut off links that are being rained on and route around them\n In summary  microwave communication is so widely used for long-distance telephone communication  mobile phones  television distribution  and other purposes that a severe shortage of spectrum has developed\n It has several key advantages over fiber\n The main one is that no right of way is needed to lay down cables\n By buying a small plot of ground every   km and putting a microwave tower on it  one can bypass the telephone system entirely\n This is how MCI managed to get started as a new long-distance telephone company so quickly\n (Sprint  another early competitor to the deregulated AT&T  went a completely different route: it was formed by the Southern Pacific Railroad  which already owned a large amount of right of way and just buried fiber next to the tracks\n) Microwave is also relatively inexpensive\n Putting up two simple towers (which can be just big poles with four guy wires) and putting antennas on each one may be cheaper than burying   km of fiber through a congested urban area or up over a mountain  and it may also be cheaper than leasing the telephone company’s fiber  especially if the telephone company has not yet even fully paid for the copper it ripped out when it put in the fiber\n The Politics of the Electromagnetic Spectrum To prevent total chaos  there are national and international agreements about who gets to use which frequencies\n Since everyone wants a higher data rate  everyone wants more spectrum\n National governments allocate spectrum for AM THE PHYSICAL LAYER  \n  and FM radio  television  and mobile phones  as well as for telephone companies  police  maritime  navigation  military  government  and many other competing users\n Worldwide  an agency of ITU-R (WRC) tries to coordinate this allocation so devices that work in multiple countries can be manufactured\n However  countries are not bound by ITU-R’s recommendations  and the FCC (Federal Communication Commission)  which does the allocation for the United States  has occasionally rejected ITU-R’s recommendations (usually because they required some politically powerful group to give up some piece of the spectrum)\n Even when a piece of spectrum has been allocated to some use  such as mobile phones  there is the additional issue of which carrier is allowed to use which frequencies\n Three algorithms were widely used in the past\n The oldest algorithm  often called the beauty contest  requires each carrier to explain why its proposal serves the public interest best\n Government officials then decide which of the nice stories they enjoy most\n Having some government official award property worth billions of dollars to his favorite company often leads to bribery  corruption  nepotism  and worse\n Furthermore  even a scrupulously honest government official who thought that a foreign company could do a better job than any of the national companies would have a lot of explaining to do\n This observation led to algorithm   holding a lottery among the interested companies\n The problem with that idea is that companies with no interest in using the spectrum can enter the lottery\n If  say  a fast food restaurant or shoe store chain wins  it can resell the spectrum to a carrier at a huge profit and with no risk\n Bestowing huge windfalls on alert but otherwise random companies has been severely criticized by many  which led to algorithm  : auction off the bandwidth to the highest bidder\n When the British government auctioned off the frequencies needed for third-generation mobile systems in  it expected to get about $  billion\n It actually received about $  billion because the carriers got into a feeding frenzy  scared to death of missing the mobile boat\n This event switched on nearby governments’ greedy bits and inspired them to hold their own auctions\n It worked  but it also left some of the carriers with so much debt that they are close to bankruptcy\n Even in the best cases  it will take many years to recoup the licensing fee\n A completely different approach to allocating frequencies is to not allocate them at all\n Instead  let everyone transmit at will  but regulate the power used so that stations have such a short range that they do not interfere with each other\n Accordingly  most governments have set aside some frequency bands  called the ISM (Industrial  Scientific  Medical) bands for unlicensed usage\n Garage door openers  cordless phones  radio-controlled toys  wireless mice  and numerous other wireless household devices use the ISM bands\n To minimize interference between these uncoordinated devices  the FCC mandates that all devices in the ISM bands limit their transmit power ( \n  to  watt) and use other techniques to spread their signals over a range of frequencies\n Devices may also need to take care to avoid interference with radar installations\n   WIRELESS TRANSMISSION The location of these bands varies somewhat from country to country\n In the United States  for example  the bands that networking devices use in practice without requiring a FCC license are shown in Fig\n  -  \n The   -MHz band was used for early versions of   \n   but it is crowded\n The  \n -GHz band is available in most countries and widely used for   \n  b/g and Bluetooth  though it is subject to interference from microwave ovens and radar installations\n The  -GHz part of the spectrum includes U-NII (Unlicensed National Information Infrastructure) bands\n The  -GHz bands are relatively undeveloped but  since they have the most bandwidth and are used by   \n  a  they are quickly gaining in popularity\n   MHz MHz MHz  \n  GHz  \n  GHz  \n  GHz  \n  GHz  \n   GHz U-NII bands  \n   GHz  \n GHz ISM band  \n  MHz MHz MHz ISM band MHz ISM band Figure  -  \n ISM and U-NII bands used in the United States by wireless devices\n The unlicensed bands have been a roaring success over the past decade\n The ability to use the spectrum freely has unleashed a huge amount of innovation in wireless LANs and PANs  evidenced by the widespread deployment of technologies such as   \n  and Bluetooth\n To continue this innovation  more spectrum is needed\n One exciting development in the  \n is the FCC decision in  to allow unlicensed use of white spaces around MHz\n White spaces are frequency bands that have been allocated but are not being used locally\n The transition from analog to all-digital television broadcasts in the  \n in  freed up white spaces around MHz\n The only difficulty is that  to use the white spaces  unlicensed devices must be able to detect any nearby licensed transmitters  including wireless microphones  that have first rights to use the frequency band\n Another flurry of activity is happening around the  -GHz band\n The FCC opened   GHz to   GHz for unlicensed operation in \n This range is an enormous portion of spectrum  more than all the other ISM bands combined  so it can support the kind of high-speed networks that would be needed to stream high-definition TV through the air across your living room\n At   GHz  radio THE PHYSICAL LAYER  \n  waves are absorbed by oxygen\n This means that signals do not propagate far  making them well suited to short-range networks\n The high frequencies (  GHz is in the Extremely High Frequency or ‘‘millimeter’’ band  just below infrared radiation) posed an initial challenge for equipment makers  but products are now on the market\n    Infrared Transmission Unguided infrared waves are widely used for short-range communication\n The remote controls used for televisions  VCRs  and stereos all use infrared communication\n They are relatively directional  cheap  and easy to build but have a major drawback: they do not pass through solid objects\n (Try standing between your remote control and your television and see if it still works\n) In general  as we go from long-wave radio toward visible light  the waves behave more and more like light and less and less like radio\n On the other hand  the fact that infrared waves do not pass through solid walls well is also a plus\n It means that an infrared system in one room of a building will not interfere with a similar system in adjacent rooms or buildings: you cannot control your neighbor’s television with your remote control\n Furthermore  urity of infrared systems against eavesdropping is better than that of radio systems precisely for this reason\n Therefore  no government license is needed to operate an infrared system  in contrast to radio systems  which must be licensed outside the ISM bands\n Infrared communication has a limited use on the desktop  for example  to connect notebook computers and printers with the IrDA (Infrared Data Association) standard  but it is not a major player in the communication game\n    Light Transmission Unguided optical signaling or free-space optics has been in use for centuries\n Paul Revere used binary optical signaling from the Old North Church just prior to his famous ride\n A more modern application is to connect the LANs in two buildings via lasers mounted on their rooftops\n Optical signaling using lasers is inherently unidirectional  so each end needs its own laser and its own photodetector\n This scheme offers very high bandwidth at very low cost and is relatively ure because it is difficult to tap a narrow laser beam\n It is also relatively easy to install and  unlike microwave transmission  does not require an FCC license\n The laser’s strength  a very narrow beam  is also its weakness here\n Aiming a laser beam  mm wide at a target the size of a pin head meters away requires the marksmanship of a latter-day Annie Oakley\n Usually  lenses are put into the system to defocus the beam slightly\n To add to the difficulty  wind and temperature changes can distort the beam and laser beams also cannot penetrate rain or thick fog  although they normally work well on sunny days\n However  many of these factors are not an issue when the use is to connect two spacecraft\n   WIRELESS TRANSMISSION One of the authors (AST) once attended a conference at a modern hotel in Europe at which the conference organizers thoughtfully provided a room full of terminals to allow the attendees to read their email during boring presentations\n Since the local PTT was unwilling to install a large number of telephone lines for just  days  the organizers put a laser on the roof and aimed it at their university’s computer science building a few kilometers away\n They tested it the night before the conference and it worked perfectly\n At   \n on a bright  sunny day  the link failed completely and stayed down all day\n The pattern repeated itself the next two days\n It was not until after the conference that the organizers discovered the problem: heat from the sun during the daytime caused convection currents to rise up from the roof of the building  as shown in Fig\n  -  \n This turbulent air diverted the beam and made it dance around the detector  much like a shimmering road on a hot day\n The lesson here is that to work well in difficult conditions as well as good conditions  unguided optical links need to be engineered with a sufficient margin of error\n Laser beam misses the detector Laser Photodetector Region of turbulent seeing Heat rising off the building Figure  -  \n Convection currents can interfere with laser communication systems\n A bidirectional system with two lasers is pictured here\n Unguided optical communication may seem like an exotic networking technology today  but it might soon become much more prevalent\n We are surrounded THE PHYSICAL LAYER  \n  by cameras (that sense light) and displays (that emit light using LEDs and other technology)\n Data communication can be layered on top of these displays by encoding information in the pattern at which LEDs turn on and off that is below the threshold of human perception\n Communicating with visible light in this way is inherently safe and creates a low-speed network in the immediate vicinity of the display\n This could enable all sorts of fanciful ubiquitous computing scenarios\n The flashing lights on emergency vehicles might alert nearby traffic lights and vehicles to help clear a path\n Informational signs might broadcast maps\n Even festive lights might broadcast songs that are synchronized with their display  COMMUNICATION SATELLITES In the s and early s  people tried to set up communication systems by bouncing signals off metallized weather balloons\n Unfortunately  the received signals were too weak to be of any practical use\n Then the  \n Navy noticed a kind of permanent weather balloon in the sky—the moon—and built an operational system for ship-to-shore communication by bouncing signals off it\n Further progress in the celestial communication field had to wait until the first communication satellite was launched\n The key difference between an artificial satellite and a real one is that the artificial one can amplify the signals before sending them back  turning a strange curiosity into a powerful communication system\n Communication satellites have some interesting properties that make them attractive for many applications\n In its simplest form  a communication satellite can be thought of as a big microwave repeater in the sky\n It contains several transponders  each of which listens to some portion of the spectrum  amplifies the incoming signal  and then rebroadcasts it at another frequency to avoid interference with the incoming signal\n This mode of operation is known as a bent pipe\n Digital processing can be added to separately manipulate or redirect data streams in the overall band  or digital information can even be received by the satellite and rebroadcast\n Regenerating signals in this way improves performance compared to a bent pipe because the satellite does not amplify noise in the upward signal\n The downward beams can be broad  covering a substantial fraction of the earth’s surface  or narrow  covering an area only hundreds of kilometers in diameter\n According to Kepler’s law  the orbital period of a satellite varies as the radius of the orbit to the  /  power\n The higher the satellite  the longer the period\n Near the surface of the earth  the period is about   minutes\n Consequently  low-orbit satellites pass out of view fairly quickly  so many of them are needed to provide continuous coverage and ground antennas must track them\n At an altitude of about   km  the period is   hours\n At an altitude of    km  the period is about one month  as anyone who has observed the moon regularly can testify\n   COMMUNICATION SATELLITES A satellite’s period is important  but it is not the only issue in determining where to place it\n Another issue is the presence of the Van Allen belts  layers of highly charged particles trapped by the earth’s magnetic field\n Any satellite flying within them would be destroyed fairly quickly by the particles\n These factors lead to three regions in which satellites can be placed safely\n These regions and some of their properties are illustrated in Fig\n  -  \n Below we will briefly describe the satellites that inhabit each of these regions\n Altitude (km) Type        GEO MEO Upper Van Allen belt Lower Van Allen belt LEO Latency (ms)  –   –  Sats needed    Figure  -  \n Communication satellites and some of their properties  including altitude above the earth  round-trip delay time  and number of satellites needed for global coverage\n    Geostationary Satellites In  the science fiction writer Arthur C\n Clarke calculated that a satellite at an altitude of   km in a circular equatorial orbit would appear to remain motionless in the sky  so it would not need to be tracked (Clarke  )\n He went on to describe a complete communication system that used these (manned) geostationary satellites  including the orbits  solar panels  radio frequencies  and launch procedures\n Unfortunately  he concluded that satellites were impractical due to the impossibility of putting power-hungry  fragile vacuum tube amplifiers into orbit  so he never pursued this idea further  although he wrote some science fiction stories about it\n The invention of the transistor changed all that  and the first artificial communication satellite  Telstar  was launched in July \n Since then  communication satellites have become a multibillion dollar business and the only aspect of outer space that has become highly profitable\n These high-flying satellites are often called GEO (Geostationary Earth Orbit) satellites\n THE PHYSICAL LAYER  \n  With current technology  it is unwise to have geostationary satellites spaced much closer than  degrees in the   -degree equatorial plane  to avoid interference\n With a spacing of  degrees  there can only be   /  = of these satellites in the sky at once\n However  each transponder can use multiple frequencies and polarizations to increase the available bandwidth\n To prevent total chaos in the sky  orbit slot allocation is done by ITU\n This process is highly political  with countries barely out of the stone age demanding ‘‘their’’ orbit slots (for the purpose of leasing them to the highest bidder)\n Other countries  however  maintain that national property rights do not extend up to the moon and that no country has a legal right to the orbit slots above its territory\n To add to the fight  commercial telecommunication is not the only application\n Television broadcasters  governments  and the military also want a piece of the orbiting pie\n Modern satellites can be quite large  weighing over  kg and consuming several kilowatts of electric power produced by the solar panels\n The effects of solar  lunar  and planetary gravity tend to move them away from their assigned orbit slots and orientations  an effect countered by on-board rocket motors\n This fine-tuning activity is called station keeping\n However  when the fuel for the motors has been exhausted (typically after about   years) the satellite drifts and tumbles helplessly  so it has to be turned off\n Eventually  the orbit decays and the satellite reenters the atmosphere and burns up (or very rarely crashes to earth)\n Orbit slots are not the only bone of contention\n Frequencies are an issue  too  because the downlink transmissions interfere with existing microwave users\n Consequently  ITU has allocated certain frequency bands to satellite users\n The main ones are listed in Fig\n  -  \n The C band was the first to be designated for commercial satellite traffic\n Two frequency ranges are assigned in it  the lower one for downlink traffic (from the satellite) and the upper one for uplink traffic (to the satellite)\n To allow traffic to go both ways at the same time  two channels are required\n These channels are already overcrowded because they are also used by the common carriers for terrestrial microwave links\n The L and S bands were added by international agreement in \n However  they are narrow and also crowded\n Band Downlink Uplink Bandwidth Problems L  \n  GHz  \n  GHz   MHz Low bandwidth; crowded S  \n  GHz  \n  GHz   MHz Low bandwidth; crowded C  \n  GHz  \n  GHz MHz Terrestrial interference Ku   GHz   GHz MHz Rain Ka   GHz   GHz  MHz Rain  equipment cost Figure  -  \n The principal satellite bands\n   COMMUNICATION SATELLITES The next-highest band available to commercial telecommunication carriers is the Ku (K under) band\n This band is not (yet) congested  and at its higher frequencies  satellites can be spaced as close as  degree\n However  another problem exists: rain\n Water absorbs these short microwaves well\n Fortunately  heavy storms are usually localized  so using several widely separated ground stations instead of just one circumvents the problem  but at the price of extra antennas  extra cables  and extra electronics to enable rapid switching between stations\n Bandwidth has also been allocated in the Ka (K above) band for commercial satellite traffic  but the equipment needed to use it is expensive\n In addition to these commercial bands  many government and military bands also exist\n A modern satellite has around   transponders  most often with a  -MHz bandwidth\n Usually  each transponder operates as a bent pipe  but recent satellites have some on-board processing capacity  allowing more sophisticated operation\n In the earliest satellites  the division of the transponders into channels was static: the bandwidth was simply split up into fixed frequency bands\n Nowadays  each transponder beam is divided into time slots  with various users taking turns\n We will study these two techniques (frequency division multiplexing and time division multiplexing) in detail later in this  ter\n The first geostationary satellites had a single spatial beam that illuminated about  /  of the earth’s surface  called its footprint\n With the enormous decline in the price  size  and power requirements of microelectronics  a much more sophisticated broadcasting strategy has become possible\n Each satellite is equipped with multiple antennas and multiple transponders\n Each downward beam can be focused on a small geographical area  so multiple upward and downward transmissions can take place simultaneously\n Typically  these so-called spot beams are elliptically shaped  and can be as small as a few hundred km in diameter\n A communication satellite for the United States typically has one wide beam for the contiguous   states  plus spot beams for Alaska and Hawaii\n A recent development in the communication satellite world is the development of low-cost microstations  sometimes called VSATs (Very Small Aperture Terminals) (Abramson  )\n These tiny terminals have  -meter or smaller antennas (versus   m for a standard GEO antenna) and can put out about  watt of power\n The uplink is generally good for up to  Mbps  but the downlink is often up to several megabits/\n Direct broadcast satellite television uses this technology for one-way transmission\n In many VSAT systems  the microstations do not have enough power to communicate directly with one another (via the satellite  of course)\n Instead  a special ground station  the hub  with a large  high-gain antenna is needed to relay traffic between VSATs  as shown in Fig\n  -  \n In this mode of operation  either the sender or the receiver has a large antenna and a powerful amplifier\n The trade-off is a longer delay in return for having cheaper end-user stations\n VSATs have great potential in rural areas\n It is not widely appreciated  but over half the world’s population lives more than hour’s walk from the nearest THE PHYSICAL LAYER  \n  Communication satellite    Hub VSAT Figure  -  \n VSATs using a hub\n telephone\n Stringing telephone wires to thousands of small villages is far beyond the budgets of most Third World governments  but installing  -meter VSAT dishes powered by solar cells is often feasible\n VSATs provide the technology that will wire the world\n Communication satellites have several properties that are radically different from terrestrial point-to-point links\n To begin with  even though signals to and from a satellite travel at the speed of light (nearly    km/)  the long round-trip distance introduces a substantial delay for GEO satellites\n Depending on the distance between the user and the ground station and the elevation of the satellite above the horizon  the end-to-end transit time is between and m\n A typical value is m (   m for a VSAT system with a hub)\n For comparison purposes  terrestrial microwave links have a propagation delay of roughly  μ /km  and coaxial cable or fiber optic links have a delay of approximately  μ/km\n The latter are slower than the former because electromagnetic signals travel faster in air than in solid materials\n Another important property of satellites is that they are inherently broadcast media\n It does not cost more to send a message to thousands of stations within a transponder’s footprint than it does to send to one\n For some applications  this property is very useful\n For example  one could imagine a satellite broadcasting popular Web pages to the caches of a large number of computers spread over a wide area\n Even when broadcasting can be simulated with point-to-point lines    COMMUNICATION SATELLITES satellite broadcasting may be much cheaper\n On the other hand  from a privacy point of view  satellites are a complete disaster: everybody can hear everything\n Encryption is essential when urity is required\n Satellites also have the property that the cost of transmitting a message is independent of the distance traversed\n A call across the ocean costs no more to service than a call across the street\n Satellites also have excellent error rates and can be deployed almost instantly  a major consideration for disaster response and military communication\n    Medium-Earth Orbit Satellites At much lower altitudes  between the two Van Allen belts  we find the MEO (Medium-Earth Orbit) satellites\n As viewed from the earth  these drift slowly in longitude  taking something like  hours to circle the earth\n Accordingly  they must be tracked as they move through the sky\n Because they are lower than the GEOs  they have a smaller footprint on the ground and require less powerful transmitters to reach them\n Currently they are used for navigation systems rather than telecommunications  so we will not examine them further here\n The constellation of roughly   GPS (Global Positioning System) satellites orbiting at about   km are examples of MEO satellites\n    Low-Earth Orbit Satellites Moving down in altitude  we come to the LEO (Low-Earth Orbit) satellites\n Due to their rapid motion  large numbers of them are needed for a complete system\n On the other hand  because the satellites are so close to the earth  the ground stations do not need much power  and the round-trip delay is only a few millionds\n The launch cost is substantially cheaper too\n In this tion we will examine two examples of satellite constellations for voice service  Iridium and Globalstar\n For the first   years of the satellite era  low-orbit satellites were rarely used because they zip into and out of view so quickly\n In  Motorola broke new ground by filing an application with the FCC asking for permission to launch   low-orbit satellites for the Iridium project (element   is iridium)\n The plan was later revised to use only   satellites  so the project should have been renamed Dysprosium (element  )  but that probably sounded too much like a disease\n The idea was that as soon as one satellite went out of view  another would replace it\n This proposal set off a feeding frenzy among other communication companies\n All of a sudden  everyone wanted to launch a chain of low-orbit satellites\n After seven years of cobbling together partners and financing  communication service began in November \n Unfortunately  the commercial demand for large  heavy satellite telephones was negligible because the mobile phone network had grown in a spectacular way since \n As a consequence  Iridium was not THE PHYSICAL LAYER  \n  profitable and was forced into bankruptcy in August  in one of the most spectacular corporate fiascos in history\n The satellites and other assets (worth $  billion) were later purchased by an investor for $  million at a kind of extraterrestrial garage sale\n Other satellite business ventures promptly followed suit\n The Iridium service restarted in March  and has been growing ever since\n It provides voice  data  paging  fax  and navigation service everywhere on land  air  and sea  via hand-held devices that communicate directly with the Iridium satellites\n Customers include the maritime  aviation  and oil exploration industries  as well as people traveling in parts of the world lacking a telecom infrastructure ( \n  deserts  mountains  the South Pole  and some Third World countries)\n The Iridium satellites are positioned at an altitude of km  in circular polar orbits\n They are arranged in north-south necklaces  with one satellite every   degrees of latitude  as shown in Fig\n  -  \n Each satellite has a maximum of   cells (spot beams) and a capacity of  channels  some of which are used for paging and navigation  while others are used for data and voice\n Each satellite has four neighbors Figure  -  \n The Iridium satellites form six necklaces around the earth\n With six satellite necklaces the entire earth is covered  as suggested by Fig\n  -  \n An interesting property of Iridium is that communication between distant customers takes place in space  as shown in Fig\n  -  (a)\n Here we see a caller at the North Pole contacting a satellite directly overhead\n Each satellite has four neighbors with which it can communicate  two in the same necklace (shown) and two in adjacent necklaces (not shown)\n The satellites relay the call across this grid until it is finally sent down to the callee at the South Pole\n An alternative design to Iridium is Globalstar\n It is based on   LEO satellites but uses a different switching scheme than that of Iridium\n Whereas Iridium relays calls from satellite to satellite  which requires sophisticated switching equipment in the satellites  Globalstar uses a traditional bent-pipe design\n The call originating at the North Pole in Fig\n  -  (b) is sent back to earth and picked   COMMUNICATION SATELLITES Bent-pipe satellite Satellite switches in space Switching on the ground (a) (b) Figure  -  \n (a) Relaying in space\n (b) Relaying on the ground\n up by the large ground station at Santa’s Workshop\n The call is then routed via a terrestrial network to the ground station nearest the callee and delivered by a bent-pipe connection as shown\n The advantage of this scheme is that it puts much of the complexity on the ground  where it is easier to manage\n Also  the use of large ground station antennas that can put out a powerful signal and receive a weak one means that lower-powered telephones can be used\n After all  the telephone puts out only a few milliwatts of power  so the signal that gets back to the ground station is fairly weak  even after having been amplified by the satellite\n Satellites continue to be launched at a rate of around   per year  including ever-larger satellites that now weigh over  kilograms\n But there are also very small satellites for the more budget-conscious organization\n To make space research more accessible  academics from Cal Poly and Stanford got together in  to define a standard for miniature satellites and an associated launcher that would greatly lower launch costs (Nugent et al\n  )\n CubeSats are satellites in units of   cm ×   cm ×   cm cubes  each weighing no more than  kilogram  that can be launched for as little as $  each\n The launcher flies as a ondary payload on commercial space missions\n It is basically a tube that takes up to three units of cubesats and uses springs to release them into orbit\n Roughly   cubesats have launched so far  with many more in the works\n Most of them communicate with ground stations on the UHF and VHF bands\n    Satellites Versus Fiber A comparison between satellite communication and terrestrial communication is instructive\n As recently as   years ago  a case could be made that the future of communication lay with communication satellites\n After all  the telephone system THE PHYSICAL LAYER  \n  had changed little in the previous years and showed no signs of changing in the next years\n This glacial movement was caused in no small part by the regulatory environment in which the telephone companies were expected to provide good voice service at reasonable prices (which they did)  and in return got a guaranteed profit on their investment\n For people with data to transmit  -bps modems were available\n That was pretty much all there was\n The introduction of competition in  in the United States and somewhat later in Europe changed all that radically\n Telephone companies began replacing their long-haul networks with fiber and introduced high-bandwidth services like ADSL (Asymmetric Digital Subscriber Line)\n They also stopped their long-time practice of charging artificially high prices to long-distance users to subsidize local service\n All of a sudden  terrestrial fiber connections looked like the winner\n Nevertheless  communication satellites have some major niche markets that fiber does not (and  sometimes  cannot) address\n First  when rapid deployment is critical  satellites win easily\n A quick response is useful for military communication systems in times of war and disaster response in times of peace\n Following the massive December  Sumatra earthquake and subsequent tsunami  for example  communications satellites were able to restore communications to first responders within   hours\n This rapid response was possible because there is a developed satellite service provider market in which large players  such as Intelsat with over   satellites  can rent out capacity pretty much anywhere it is needed\n For customers served by existing satellite networks  a VSAT can be set up easily and quickly to provide a megabit/ link to elsewhere in the world\n A ond niche is for communication in places where the terrestrial infrastructure is poorly developed\n Many people nowadays want to communicate everywhere they go\n Mobile phone networks cover those locations with good population density  but do not do an adequate job in other places ( \n  at sea or in the desert)\n Conversely  Iridium provides voice service everywhere on Earth  even at the South Pole\n Terrestrial infrastructure can also be expensive to install  depending on the terrain and necessary rights of way\n Indonesia  for example  has its own satellite for domestic telephone traffic\n Launching one satellite was cheaper than stringing thousands of undersea cables among the   islands in the archipelago\n A third niche is when broadcasting is essential\n A message sent by satellite can be received by thousands of ground stations at once\n Satellites are used to distribute much network TV programming to local stations for this reason\n There is now a large market for satellite broadcasts of digital TV and radio directly to end users with satellite receivers in their homes and cars\n All sorts of other content can be broadcast too\n For example  an organization transmitting a stream of stock  bond  or commodity prices to thousands of dealers might find a satellite system to be much cheaper than simulating broadcasting on the ground\n In short  it looks like the mainstream communication of the future will be terrestrial fiber optics combined with cellular radio  but for some specialized uses    COMMUNICATION SATELLITES satellites are better\n However  there is one caveat that applies to all of this: economics\n Although fiber offers more bandwidth  it is conceivable that terrestrial and satellite communication could compete aggressively on price\n If advances in technology radically cut the cost of deploying a satellite ( \n  if some future space vehicle can toss out dozens of satellites on one launch) or low-orbit satellites catch on in a big way  it is not certain that fiber will win all markets  DIGITAL MODULATION AND MULTIPLEXING Now that we have studied the properties of wired and wireless channels  we turn our attention to the problem of sending digital information\n Wires and wireless channels carry analog signals such as continuously varying voltage  light intensity  or sound intensity\n To send digital information  we must devise analog signals to represent bits\n The process of converting between bits and signals that represent them is called digital modulation\n We will start with schemes that directly convert bits into a signal\n These schemes result in baseband transmission  in which the signal occupies frequencies from zero up to a maximum that depends on the signaling rate\n It is common for wires\n Then we will consider schemes that regulate the amplitude  phase  or frequency of a carrier signal to convey bits\n These schemes result in passband transmission  in which the signal occupies a band of frequencies around the frequency of the carrier signal\n It is common for wireless and optical channels for which the signals must reside in a given frequency band\n Channels are often shared by multiple signals\n After all  it is much more convenient to use a single wire to carry several signals than to install a wire for every signal\n This kind of sharing is called multiplexing\n It can be accomplished in several different ways\n We will present methods for time  frequency  and code division multiplexing\n The modulation and multiplexing techniques we describe in this tion are all widely used for wires  fiber  terrestrial wireless  and satellite channels\n In the following tions  we will look at examples of networks to see them in action\n    Baseband Transmission The most straightforward form of digital modulation is to use a positive voltage to represent a  and a negative voltage to represent a  \n For an optical fiber  the presence of light might represent a  and the absence of light might represent a  \n This scheme is called NRZ (Non-Return-to-Zero)\n The odd name is for historical reasons  and simply means that the signal follows the data\n An example is shown in Fig\n  -  (b)\n Once sent  the NRZ signal propagates down the wire\n At the other end  the receiver converts it into bits by sampling the signal at regular intervals of time\n THE PHYSICAL LAYER  \n  (Clock that is XORed with bits) (a) Bit stream (b) Non-Return to Zero (NRZ) (c) NRZ Invert (NRZI) (d) Manchester (e) Bipolar encoding (also Alternate Mark Inversion  AMI)     Figure  -  \n Line codes: (a) Bits  (b) NRZ  (c) NRZI  (d) Manchester  (e) Bipolar or AMI\n This signal will not look exactly like the signal that was sent\n It will be attenuated and distorted by the channel and noise at the receiver\n To decode the bits  the receiver maps the signal samples to the closest symbols\n For NRZ  a positive voltage will be taken to indicate that a  was sent and a negative voltage will be taken to indicate that a  was sent\n NRZ is a good starting point for our studies because it is simple  but it is seldom used by itself in practice\n More complex schemes can convert bits to signals that better meet engineering considerations\n These schemes are called line codes\n Below  we describe line codes that help with bandwidth efficiency  clock recovery  and DC balance\n Bandwidth Efficiency With NRZ  the signal may cycle between the positive and negative levels up to every  bits (in the case of alternating  s and  s)\n This means that we need a bandwidth of at least B/  Hz when the bit rate is B bits/\n This relation comes from the Nyquist rate [Eq\n ( - )]\n It is a fundamental limit  so we cannot run NRZ faster without using more bandwidth\n Bandwidth is often a limited resource  even for wired channels  Higher-frequency signals are increasingly attenuated  making them less useful  and higher-frequency signals also require faster electronics\n One strategy for using limited bandwidth more efficiently is to use more than two signaling levels\n By using four voltages  for instance  we can send  bits at once as a single symbol\n This design will work as long as the signal at the receiver is sufficiently strong to distinguish the four levels\n The rate at which the signal changes is then half the bit rate  so the needed bandwidth has been reduced\n   DIGITAL MODULATION AND MULTIPLEXING We call the rate at which the signal changes the symbol rate to distinguish it from the bit rate\n The bit rate is the symbol rate multiplied by the number of bits per symbol\n An older name for the symbol rate  particularly in the context of devices called telephone modems that convey digital data over telephone lines  is the baud rate\n In the literature  the terms ‘‘bit rate’’ and ‘‘baud rate’’ are often used incorrectly\n Note that the number of signal levels does not need to be a power of two\n Often it is not  with some of the levels used for protecting against errors and simplifying the design of the receiver\n Clock Recovery For all schemes that encode bits into symbols  the receiver must know when one symbol ends and the next symbol begins to correctly decode the bits\n With NRZ  in which the symbols are simply voltage levels  a long run of  s or  s leaves the signal unchanged\n After a while it is hard to tell the bits apart  as   zeros look much like   zeros unless you have a very accurate clock\n Accurate clocks would help with this problem  but they are an expensive solution for commodity equipment\n Remember  we are timing bits on links that run at many megabits/  so the clock would have to drift less than a fraction of a microond over the longest permitted run\n This might be reasonable for slow links or short messages  but it is not a general solution\n One strategy is to send a separate clock signal to the receiver\n Another clock line is no big deal for computer buses or short cables in which there are many lines in parallel  but it is wasteful for most network links since if we had another line to send a signal we could use it to send data\n A clever trick here is to mix the clock signal with the data signal by XORing them together so that no extra line is needed\n The results are shown in Fig\n  -  (d)\n The clock makes a clock transition in every bit time  so it runs at twice the bit rate\n When it is XORed with the  level it makes a low-to-high transition that is simply the clock\n This transition is a logical  \n When it is XORed with the  level it is inverted and makes a high-tolow transition\n This transition is a logical  \n This scheme is called Manchester encoding and was used for classic Ethernet\n The downside of Manchester encoding is that it requires twice as much bandwidth as NRZ because of the clock  and we have learned that bandwidth often matters\n A different strategy is based on the idea that we should code the data to ensure that there are enough transitions in the signal\n Consider that NRZ will have clock recovery problems only for long runs of  s and  s\n If there are frequent transitions  it will be easy for the receiver to stay synchronized with the incoming stream of symbols\n As a step in the right direction  we can simplify the situation by coding a  as a transition and a  as no transition  or vice versa\n This coding is called NRZI (Non-Return-to-Zero Inverted)  a twist on NRZ\n An example is shown in THE PHYSICAL LAYER  \n  Fig\n  -  (c)\n The popular USB (Universal Serial Bus) standard for connecting computer peripherals uses NRZI\n With it  long runs of  s do not cause a problem\n Of course  long runs of  s still cause a problem that we must fix\n If we were the telephone company  we might simply require that the sender not transmit too many  s\n Older digital telephone lines in the  \n  called T  lines  did in fact require that no more than   conutive  s be sent for them to work correctly\n To really fix the problem we can break up runs of  s by mapping small groups of bits to be transmitted so that groups with successive  s are mapped to slightly longer patterns that do not have too many conutive  s\n A well-known code to do this is called  B/ B\n Every  bits is mapped into a -bit pattern with a fixed translation table\n The five bit patterns are chosen so that there will never be a run of more than three conutive  s\n The mapping is shown in Fig\n  -  \n This scheme adds  % overhead  which is better than the   % overhead of Manchester encoding\n Since there are   input combinations and   output combinations  some of the output combinations are not used\n Putting aside the combinations with too many successive  s  there are still some codes left\n As a bonus  we can use these nondata codes to represent physical layer control signals\n For example  in some uses ‘‘ ’’ represents an idle line and ‘‘ ’’ represents the start of a frame\n Data ( B) Codeword ( B) Data ( B) Codeword ( B)                         Figure  -  \n  B/ B mapping\n An alternative approach is to make the data look random  known as scrambling\n In this case it is very likely that there will be frequent transitions\n A scrambler works by XORing the data with a pseudorandom sequence before it is transmitted\n This mixing will make the data as random as the pseudorandom sequence (assuming it is independent of the pseudorandom sequence)\n The receiver then XORs the incoming bits with the same pseudorandom sequence to recover the real data\n For this to be practical  the pseudorandom sequence must be easy to create\n It is commonly given as the seed to a simple random number generator\n Scrambling is attractive because it adds no bandwidth or time overhead\n In fact  it often helps to condition the signal so that it does not have its energy in   DIGITAL MODULATION AND MULTIPLEXING dominant frequency components (caused by repetitive data patterns) that might radiate electromagnetic interference\n Scrambling helps because random signals tend to be ‘‘white ’’ or have energy spread across the frequency components\n However  scrambling does not guarantee that there will be no long runs\n It is possible to get unlucky occasionally\n If the data are the same as the pseudorandom sequence  they will XOR to all  s\n This outcome does not generally occur with a long pseudorandom sequence that is difficult to predict\n However  with a short or predictable sequence  it might be possible for malicious users to send bit patterns that cause long runs of  s after scrambling and cause links to fail\n Early versions of the standards for sending IP packets over SONET links in the telephone system had this defect (Malis and Simpson  )\n It was possible for users to send certain ‘‘killer packets’’ that were guaranteed to cause problems\n Balanced Signals Signals that have as much positive voltage as negative voltage even over short periods of time are called balanced signals\n They average to zero  which means that they have no DC electrical component\n The lack of a DC component is an advantage because some channels  such as coaxial cable or lines with transformers  strongly attenuate a DC component due to their physical properties\n Also  one method of connecting the receiver to the channel called capacitive coupling passes only the AC portion of a signal\n In either case  if we send a signal whose average is not zero  we waste energy as the DC component will be filtered out\n Balancing helps to provide transitions for clock recovery since there is a mix of positive and negative voltages\n It also provides a simple way to calibrate receivers because the average of the signal can be measured and used as a decision threshold to decode symbols\n With unbalanced signals  the average may be drift away from the true decision level due to a density of  s  for example  which would cause more symbols to be decoded with errors\n A straightforward way to construct a balanced code is to use two voltage levels to represent a logical   (say +  V or −  V) with  V representing a logical zero\n To send a   the transmitter alternates between the +  V and −  V levels so that they always average out\n This scheme is called bipolar encoding\n In telephone networks it is called AMI (Alternate Mark Inversion)  building on old terminology in which a  is called a ‘‘mark’’ and a  is called a ‘‘space\n’’ An example is given in Fig\n  -  (e)\n Bipolar encoding adds a voltage level to achieve balance\n Alternatively we can use a mapping like  B/ B to achieve balance (as well as transitions for clock recovery)\n An example of this kind of balanced code is the  B/  B line code\n It maps  bits of input to   bits of output  so it is  % efficient  just like the  B/ B line code\n The  bits are split into a group of  bits  which is mapped to  bits  and a group of  bits  which is mapped to  bits\n The  -bit and  -bit symbols are THE PHYSICAL LAYER  \n  then concatenated\n In each group  some input patterns can be mapped to balanced output patterns that have the same number of  s and  s\n For example  ‘‘  ’’ is mapped to ‘‘ ’’ which is balanced\n But there are not enough combinations for all output patterns to be balanced\n For these cases  each input pattern is mapped to two output patterns\n One will have an extra  and the alternate will have an extra  \n For example  ‘‘  ’’ is mapped to both ‘‘   ’’ and its complement ‘‘   \n’’ As input bits are mapped to output bits  the encoder remembers the disparity from the previous symbol\n The disparity is the total number of  s or  s by which the signal is out of balance\n The encoder then selects either an output pattern or its alternate to reduce the disparity\n With  B/  B  the disparity will be at most  bits\n Thus  the signal will never be far from balanced\n There will also never be more than five conutive  s or  s  to help with clock recovery\n    Passband Transmission Often  we want to use a range of frequencies that does not start at zero to send information across a channel\n For wireless channels  it is not practical to send very low frequency signals because the size of the antenna needs to be a fraction of the signal wavelength  which becomes large\n In any case  regulatory constraints and the need to avoid interference usually dictate the choice of frequencies\n Even for wires  placing a signal in a given frequency band is useful to let different kinds of signals coexist on the channel\n This kind of transmission is called passband transmission because an arbitrary band of frequencies is used to pass the signal\n Fortunately  our fundamental results from earlier in the  ter are all in terms of bandwidth  or the width of the frequency band\n The absolute frequency values do not matter for capacity\n This means that we can take a baseband signal that occupies  to B Hz and shift it up to occupy a passband of S to S +B Hz without changing the amount of information that it can carry  even though the signal will look different\n To process a signal at the receiver  we can shift it back down to baseband  where it is more convenient to detect symbols\n Digital modulation is accomplished with passband transmission by regulating or modulating a carrier signal that sits in the passband\n We can modulate the amplitude  frequency  or phase of the carrier signal\n Each of these methods has a corresponding name\n In ASK (Amplitude Shift Keying)  two different amplitudes are used to represent  and  \n An example with a nonzero and a zero level is shown in Fig\n  -  (b)\n More than two levels can be used to represent more symbols\n Similarly  with FSK (Frequency Shift Keying)  two or more different tones are used\n The example in Fig\n  -  (c) uses just two frequencies\n In the simplest form of PSK (Phase Shift Keying)  the carrier wave is systematically shifted  or degrees at each symbol period\n Because there are two phases  it is called BPSK (Binary Phase Shift Keying)\n ‘‘Binary’’ here refers to the two symbols  not that the symbols represent  bits\n An example is shown in Fig\n  -  (c)\n A   DIGITAL MODULATION AND MULTIPLEXING better scheme that uses the channel bandwidth more efficiently is to use four shifts   \n   or degrees  to transmit  bits of information per symbol\n This version is called QPSK (Quadrature Phase Shift Keying)\n Phase changes  (a) (b) (c) (d)    Figure  -  \n (a) A binary signal\n (b) Amplitude shift keying\n (c) Frequency shift keying\n (d) Phase shift keying\n We can combine these schemes and use more levels to transmit more bits per symbol\n Only one of frequency and phase can be modulated at a time because they are related  with frequency being the rate of change of phase over time\n Usually  amplitude and phase are modulated in combination\n Three examples are shown in Fig\n  -  \n In each example  the points give the legal amplitude and phase combinations of each symbol\n In Fig\n  -  (a)  we see equidistant dots at  and degrees\n The phase of a dot is indicated by the angle a line from it to the origin makes with the positive x-axis\n The amplitude of a dot is the distance from the origin\n This figure is a representation of QPSK\n This kind of diagram is called a constellation diagram\n In Fig\n  -  (b) we see a modulation scheme with a denser constellation\n Sixteen combinations of amplitudes and phase are used  so the modulation scheme can be used to transmit THE PHYSICAL LAYER  \n  (a)    (b)  (c)  Figure  -  \n (a) QPSK\n (b) QAM-  \n (c) QAM-  \n  bits per symbol\n It is called QAM-   where QAM stands for Quadrature Amplitude Modulation\n Figure  -  (c) is a still denser modulation scheme with   different combinations  so  bits can be transmitted per symbol\n It is called QAM-  \n Even higher-order QAMs are used too\n As you might suspect from these constellations  it is easier to build electronics to produce symbols as a combination of values on each axis than as a combination of amplitude and phase values\n That is why the patterns look like squares rather than concentric circles\n The constellations we have seen so far do not show how bits are assigned to symbols\n When making the assignment  an important consideration is that a small burst of noise at the receiver not lead to many bit errors\n This might happen if we assigned conutive bit values to adjacent symbols\n With QAM-   for example  if one symbol stood for  and the neighboring symbol stood for  if the receiver mistakenly picks the adjacent symbol it will cause all of the bits to be wrong\n A better solution is to map bits to symbols so that adjacent symbols differ in only  bit position\n This mapping is called a Gray code\n Fig\n  -  shows a QAM-  constellation that has been Gray coded\n Now if the receiver decodes the symbol in error  it will make only a single bit error in the expected case that the decoded symbol is close to the transmitted symbol\n    Frequency Division Multiplexing The modulation schemes we have seen let us send one signal to convey bits along a wired or wireless link\n However  economies of scale play an important role in how we use networks\n It costs essentially the same amount of money to install and maintain a high-bandwidth transmission line as a low-bandwidth line between two different offices ( \n  the costs come from having to dig the trench and not from what kind of cable or fiber goes into it)\n Consequently  multiplexing schemes have been developed to share lines among many signals\n   DIGITAL MODULATION AND MULTIPLEXING A B C D E When  is sent: Point Decodes as Bit errors A   B   C   D   E              Q I Figure  -  \n Gray-coded QAM-  \n FDM (Frequency Division Multiplexing) takes advantage of passband transmission to share a channel\n It divides the spectrum into frequency bands  with each user having exclusive possession of some band in which to send their signal\n AM radio broadcasting illustrates FDM\n The allocated spectrum is about  MHz  roughly to  kHz\n Different frequencies are allocated to different logical channels (stations)  each operating in a portion of the spectrum  with the interchannel separation great enough to prevent interference\n For a more detailed example  in Fig\n  -  we show three voice-grade telephone channels multiplexed using FDM\n Filters limit the usable bandwidth to about  Hz per voice-grade channel\n When many channels are multiplexed together  Hz is allocated per channel\n The excess is called a guard band\n It keeps the channels well separated\n First the voice channels are raised in frequency  each by a different amount\n Then they can be combined because no two channels now occupy the same portion of the spectrum\n Notice that even though there are gaps between the channels thanks to the guard bands  there is some overlap between adjacent channels\n The overlap is there because real filters do not have ideal sharp edges\n This means that a strong spike at the edge of one channel will be felt in the adjacent one as nonthermal noise\n This scheme has been used to multiplex calls in the telephone system for many years  but multiplexing in time is now preferred instead\n However  FDM continues to be used in telephone networks  as well as cellular  terrestrial wireless  and satellite networks at a higher level of granularity\n When sending digital data  it is possible to divide the spectrum efficiently without using guard bands\n In OFDM (Orthogonal Frequency Division Multiplexing)  the channel bandwidth is divided into many subcarriers that independently send data ( \n  with QAM)\n The subcarriers are packed tightly together in the frequency domain\n Thus  signals from each subcarrier extend into adjacent ones\n However  as seen in Fig\n  -   the frequency response of each subcarrier is THE PHYSICAL LAYER  \n   Channel  Channel  Channel    Attenuation factor   Frequency (kHz) (c) Channel  Channel  Channel  Frequency (kHz) (b) Frequency (Hz) (a)  Figure  -  \n Frequency division multiplexing\n (a) The original bandwidths\n (b) The bandwidths raised in frequency\n (c) The multiplexed channel\n designed so that it is zero at the center of the adjacent subcarriers\n The subcarriers can therefore be sampled at their center frequencies without interference from their neighbors\n To make this work  a guard time is needed to repeat a portion of the symbol signals in time so that they have the desired frequency response\n However  this overhead is much less than is needed for many guard bands\n Frequency Power f  f  f  f  f  Separation f One OFDM subcarrier(shaded) Figure  -  \n Orthogonal frequency division multiplexing (OFDM)\n The idea of OFDM has been around for a long time  but it is only in the last decade that it has been widely adopted  following the realization that it is possible   DIGITAL MODULATION AND MULTIPLEXING to implement OFDM efficiently in terms of a Fourier transform of digital data over all subcarriers (instead of separately modulating each subcarrier)\n OFDM is used in   \n   cable networks and power line networking  and is planned for fourth-generation cellular systems\n Usually  one high-rate stream of digital information is split into many low-rate streams that are transmitted on the subcarriers in parallel\n This division is valuable because degradations of the channel are easier to cope with at the subcarrier level; some subcarriers may be very degraded and excluded in favor of subcarriers that are received well\n    Time Division Multiplexing An alternative to FDM is TDM (Time Division Multiplexing)\n Here  the users take turns (in a round-robin fashion)  each one periodically getting the entire bandwidth for a little burst of time\n An example of three streams being multiplexed with TDM is shown in Fig\n  -  \n Bits from each input stream are taken in a fixed time slot and output to the aggregate stream\n This stream runs at the sum rate of the individual streams\n For this to work  the streams must be synchronized in time\n Small intervals of guard time analogous to a frequency guard band may be added to accommodate small timing variations\n  Round-robin TDM multiplexer    Guard time  Figure  -  \n Time Division Multiplexing (TDM)\n TDM is used widely as part of the telephone and cellular networks\n To avoid one point of confusion  let us be clear that it is quite different from the alternative STDM (Statistical Time Division Multiplexing)\n The prefix ‘‘statistical’’ is added to indicate that the individual streams contribute to the multiplexed stream not on a fixed schedule  but according to the statistics of their demand\n STDM is packet switching by another name\n    Code Division Multiplexing There is a third kind of multiplexing that works in a completely different way than FDM and TDM\n CDM (Code Division Multiplexing) is a form of spread spectrum communication in which a narrowband signal is spread out over a wider frequency band\n This can make it more tolerant of interference  as well as allowing multiple signals from different users to share the same frequency band\n Because code division multiplexing is mostly used for the latter purpose it is commonly called CDMA (Code Division Multiple Access)\n THE PHYSICAL LAYER  \n  CDMA allows each station to transmit over the entire frequency spectrum all the time\n Multiple simultaneous transmissions are separated using coding theory\n Before getting into the algorithm  let us consider an analogy: an airport lounge with many pairs of people conversing\n TDM is comparable to pairs of people in the room taking turns speaking\n FDM is comparable to the pairs of people speaking at different pitches  some high-pitched and some low-pitched such that each pair can hold its own conversation at the same time as but independently of the others\n CDMA is comparable to each pair of people talking at once  but in a different language\n The French-speaking couple just hones in on the French  rejecting everything that is not French as noise\n Thus  the key to CDMA is to be able to extract the desired signal while rejecting everything else as random noise\n A somewhat simplified description of CDMA follows\n In CDMA  each bit time is subdivided into m short intervals called chips\n Typically  there are   or chips per bit  but in the example given here we will use  chips/bit for simplicity\n Each station is assigned a unique m-bit code called a chip sequence\n For pedagogical purposes  it is convenient to use a bipolar notation to write these codes as sequences of −  and + \n We will show chip sequences in parentheses\n To transmit a  bit  a station sends its chip sequence\n To transmit a  bit  it sends the negation of its chip sequence\n No other patterns are permitted\n Thus  for m =   if station A is assigned the chip sequence (−  −  −  +  +  −  +  + )  it can send a  bit by transmiting the chip sequence and a  by transmitting (+  +  +  −  −  +  −  − )\n It is really signals with these voltage levels that are sent  but it is sufficient for us to think in terms of the sequences\n Increasing the amount of information to be sent from b bits/ to mb chips/ for each station means that the bandwidth needed for CDMA is greater by a factor of m than the bandwidth needed for a station not using CDMA (assuming no changes in the modulation or encoding techniques)\n If we have a  -MHz band available for stations  with FDM each one would have   kHz and could send at   kbps (assuming  bit per Hz)\n With CDMA  each station uses the full  MHz  so the chip rate is chips per bit to spread the station’s bit rate of   kbps across the channel\n In Fig\n  -  (a) and (b) we show the chip sequences assigned to four example stations and the signals that they represent\n Each station has its own unique chip sequence\n Let us use the symbol S to indicate the m-chip vector for station S  and S for its negation\n All chip sequences are pairwise orthogonal  by which we mean that the normalized inner product of any two distinct chip sequences  S and T (written as S T)  is  \n It is known how to generate such orthogonal chip sequences using a method known as Walsh codes\n In mathematical terms  orthogonality of the chip sequences can be expressed as follows: S T ≡ m  i =  Σm SiTi =  ( - )   DIGITAL MODULATION AND MULTIPLEXING In plain English  as many pairs are the same as are different\n This orthogonality property will prove crucial later\n Note that if S T =   then S T is also  \n The normalized inner product of any chip sequence with itself is  : S S = m  i =  Σm SiSi = m  i =  Σm Si  = m  i =  Σm (± )  =  This follows because each of the m terms in the inner product is   so the sum is m\n Also note that S S = − \n (b) A = (–  –  –  +  +  –  +  + ) B = (–  –  +  –  +  +  +  – ) C = (–  +  –  +  +  +  –  – ) D = (–  +  –  –  –  –  +  – ) (a) (c) (d) S  = C = (–  +  –  +  +  +  –  – ) S =B+C =(–  + +  – ) S  = A+B = ( –  +   –   + ) S  = A+B+C = (–  +  –  +  +  –  –  + ) S  = A+B+C+D = (–   –   +   +  – ) S  = A+B+C+D = (–  –   –   –  +  ) S  C = [ + – + + + – – ]/  =  S  C = [ + + + + + + + ]/  =  S  C = [ + + + + – + – ]/  =  S  C = [ + + + + – + – ]/  =  S  C = [ + + + + + – + ]/  =  S  C = [ – + – + – – + ]/  = –  Figure  -  \n (a) Chip sequences for four stations\n (b) Signals the sequences represent (c) Six examples of transmissions\n (d) Recovery of station C’s signal\n During each bit time  a station can transmit a  (by sending its chip sequence)  it can transmit a  (by sending the negative of its chip sequence)  or it can be silent and transmit nothing\n We assume for now that all stations are synchronized in time  so all chip sequences begin at the same instant\n When two or more stations transmit simultaneously  their bipolar sequences add linearly\n For example  if in one chip period three stations output +  and one station outputs −  +  will be received\n One can think of this as signals that add as voltages superimposed on the channel: three stations output +  V and one station outputs −  V  so that  V is received\n For instance  in Fig\n  -  (c) we see six examples of one or more stations transmitting  bit at the same time\n In the first example  C transmits a  bit  so we just get C’s chip sequence\n In the ond example  both B and C transmit  bits  so we get the sum of their bipolar chip sequences  namely: (−  −  +  −  +  +  +  − ) + (−  +  −  +  +  +  −  − ) = (−  +  +  − ) To recover the bit stream of an individual station  the receiver must know that station’s chip sequence in advance\n It does the recovery by computing the normalized inner product of the received chip sequence and the chip sequence of the station whose bit stream it is trying to recover\n If the received chip sequence is S and the receiver is trying to listen to a station whose chip sequence is C  it just computes the normalized inner product  S C\n THE PHYSICAL LAYER  \n  To see why this works  just imagine that two stations  A and C  both transmit a  bit at the same time that B transmits a  bit  as is the case in the third example\n The receiver sees the sum  S = A + B + C  and computes S C = (A + B + C) C = A C + B C + C C =  +  +  =  The first two terms vanish because all pairs of chip sequences have been carefully chosen to be orthogonal  as shown in Eq\n ( - )\n Now it should be clear why this property must be imposed on the chip sequences\n To make the decoding process more concrete  we show six examples in Fig\n  -  (d)\n Suppose that the receiver is interested in extracting the bit sent by station C from each of the six signals S  through S \n It calculates the bit by summing the pairwise products of the received S and the C vector of Fig\n  -  (a) and then taking  /  of the result (since m =  here)\n The examples include cases where C is silent  sends a  bit  and sends a  bit  individually and in combination with other transmissions\n As shown  the correct bit is decoded each time\n It is just like speaking French\n In principle  given enough computing capacity  the receiver can listen to all the senders at once by running the decoding algorithm for each of them in parallel\n In real life  suffice it to say that this is easier said than done  and it is useful to know which senders might be transmitting\n In the ideal  noiseless CDMA system we have studied here  the number of stations that send concurrently can be made arbitrarily large by using longer chip sequences\n For  n stations  Walsh codes can provide  n orthogonal chip sequences of length  n\n However  one significant limitation is that we have assumed that all the chips are synchronized in time at the receiver\n This synchronization is not even approximately true in some applications  such as cellular networks (in which CDMA has been widely deployed starting in the s)\n It leads to different designs\n We will return to this topic later in the  ter and describe how asynchronous CDMA differs from synchronous CDMA\n As well as cellular networks  CDMA is used by satellites and cable networks\n We have glossed over many complicating factors in this brief introduction\n Engineers who want to gain a deep understanding of CDMA should read Viterbi (   ) and Lee and Miller (   )\n These references require quite a bit of background in communication engineering  however  THE PUBLIC SWITCHED TELEPHONE NETWORK When two computers owned by the same company or organization and located close to each other need to communicate  it is often easiest just to run a cable between them\n LANs work this way\n However  when the distances are large or there are many computers or the cables have to pass through a public road or other public right of way  the costs of running private cables are usually prohibitive\n   THE PUBLIC SWITCHED TELEPHONE NETWORK Furthermore  in just about every country in the world  stringing private transmission lines across (or underneath) public property is also illegal\n Consequently  the network designers must rely on the existing telecommunication facilities\n These facilities  especially the PSTN (Public Switched Telephone Network)  were usually designed many years ago  with a completely different goal in mind: transmitting the human voice in a more-or-less recognizable form\n Their suitability for use in computer-computer communication is often marginal at best\n To see the size of the problem  consider that a cheap commodity cable running between two computers can transfer data at  Gbps or more\n In contrast  typical ADSL  the blazingly fast alternative to a telephone modem  runs at around  Mbps\n The difference between the two is the difference between cruising in an airplane and taking a leisurely stroll\n Nonetheless  the telephone system is tightly intertwined with (wide area) computer networks  so it is worth devoting some time to study it in detail\n The limiting factor for networking purposes turns out to be the ‘‘last mile’’ over which customers connect  not the trunks and switches inside the telephone network\n This situation is changing with the gradual rollout of fiber and digital technology at the edge of the network  but it will take time and money\n During the long wait  computer systems designers used to working with systems that give at least three orders of magnitude better performance have devoted much time and effort to figure out how to use the telephone network efficiently\n In the following tions we will describe the telephone system and show how it works\n For additional information about the innards of the telephone system see Bellamy (   )\n    Structure of the Telephone System Soon after Alexander Graham Bell patented the telephone in  (just a few hours ahead of his rival  Elisha Gray)  there was an enormous demand for his new invention\n The initial market was for the sale of telephones  which came in pairs\n It was up to the customer to string a single wire between them\n If a telephone owner wanted to talk to n other telephone owners  separate wires had to be strung to all n houses\n Within a year  the cities were covered with wires passing over houses and trees in a wild jumble\n It became immediately obvious that the model of connecting every telephone to every other telephone  as shown in Fig\n  -  (a)  was not going to work\n To his credit  Bell saw this problem early on and formed the Bell Telephone Company  which opened its first switching office (in New Haven  Connecticut) in \n The company ran a wire to each customer’s house or office\n To make a call  the customer would crank the phone to make a ringing sound in the telephone company office to attract the attention of an operator  who would then manually connect the caller to the callee by using a short jumper cable to connect the caller to the callee\n The model of a single switching office is illustrated in Fig\n  -  (b)\n THE PHYSICAL LAYER  \n  (a) (b) (c) Figure  -  \n (a) Fully interconnected network\n (b) Centralized switch\n (c) Two-level hierarchy\n Pretty soon  Bell System switching offices were springing up everywhere and people wanted to make long-distance calls between cities  so the Bell System began to connect the switching offices\n The original problem soon returned: to connect every switching office to every other switching office by means of a wire between them quickly became unmanageable  so ond-level switching offices were invented\n After a while  multiple ond-level offices were needed  as illustrated in Fig\n  -  (c)\n Eventually  the hierarchy grew to five levels\n By  the three major parts of the telephone system were in place: the switching offices  the wires between the customers and the switching offices (by now balanced  insulated  twisted pairs instead of open wires with an earth return)  and the long-distance connections between the switching offices\n For a short technical history of the telephone system  see Hawley (   )\n While there have been improvements in all three areas since then  the basic Bell System model has remained essentially intact for over years\n The following description is highly simplified but gives the essential flavor nevertheless\n Each telephone has two copper wires coming out of it that go directly to the telephone company’s nearest end office (also called a local central office)\n The distance is typically  to   km  being shorter in cities than in rural areas\n In the United States alone there are about   end offices\n The two-wire connections between each subscriber’s telephone and the end office are known in the trade as the local loop\n If the world’s local loops were stretched out end to end  they would extend to the moon and back  times\n At one time   % of AT&T’s capital value was the copper in the local loops\n AT&T was then  in effect  the world’s largest copper mine\n Fortunately  this fact was not well known in the investment community\n Had it been known  some corporate raider might have bought AT&T  ended all telephone service in the United States  ripped out all the wire  and sold it to a copper refiner for a quick payback\n   THE PUBLIC SWITCHED TELEPHONE NETWORK If a subscriber attached to a given end office calls another subscriber attached to the same end office  the switching mechanism within the office sets up a direct electrical connection between the two local loops\n This connection remains intact for the duration of the call\n If the called telephone is attached to another end office  a different procedure has to be used\n Each end office has a number of outgoing lines to one or more nearby switching centers  called toll offices (or  if they are within the same local area  tandem offices)\n These lines are called toll connecting trunks\n The number of different kinds of switching centers and their topology varies from country to country depending on the country’s telephone density\n If both the caller’s and callee’s end offices happen to have a toll connecting trunk to the same toll office (a likely occurrence if they are relatively close by)  the connection may be established within the toll office\n A telephone network consisting only of telephones (the small dots)  end offices (the large dots)  and toll offices (the squares) is shown in Fig\n  -  (c)\n If the caller and callee do not have a toll office in common  a path will have to be established between two toll offices\n The toll offices communicate with each other via high-bandwidth intertoll trunks (also called interoffice trunks)\n Prior to the  breakup of AT&T  the  \n telephone system used hierarchical routing to find a path  going to higher levels of the hierarchy until there was a switching office in common\n This was then replaced with more flexible  nonhierarchical routing\n Figure  -  shows how a long-distance connection might be routed\n Telephone End office Toll office Intermediate switching office(s) End Telephone office Toll office Local loop Toll connecting trunk Very high bandwidth intertoll trunks Toll connecting trunk Local loop Figure  -  \n A typical circuit route for a long-distance call\n A variety of transmission media are used for telecommunication\n Unlike modern office buildings  where the wiring is commonly Category   local loops to homes mostly consist of Category  twisted pairs  with fiber just starting to appear\n Between switching offices  coaxial cables  microwaves  and especially fiber optics are widely used\n In the past  transmission throughout the telephone system was analog  with the actual voice signal being transmitted as an electrical voltage from source to destination\n With the advent of fiber optics  digital electronics  and computers  all the trunks and switches are now digital  leaving the local loop as the last piece of THE PHYSICAL LAYER  \n  analog technology in the system\n Digital transmission is preferred because it is not necessary to accurately reproduce an analog waveform after it has passed through many amplifiers on a long call\n Being able to correctly distinguish a  from a  is enough\n This property makes digital transmission more reliable than analog\n It is also cheaper and easier to maintain\n In summary  the telephone system consists of three major components:  \n Local loops (analog twisted pairs going to houses and businesses) Trunks (digital fiber optic links connecting the switching offices) Switching offices (where calls are moved from one trunk to another)\n After a short digression on the politics of telephones  we will come back to each of these three components in some detail\n The local loops provide everyone access to the whole system  so they are critical\n Unfortunately  they are also the weakest link in the system\n For the long-haul trunks  the main issue is how to collect multiple calls together and send them out over the same fiber\n This calls for multiplexing  and we apply FDM and TDM to do it\n Finally  there are two fundamentally different ways of doing switching; we will look at both\n    The Politics of Telephones For decades prior to  the Bell System provided both local and long-distance service throughout most of the United States\n In the s  the  \n Federal Government came to believe that this was an illegal monopoly and sued to break it up\n The government won  and on January  AT&T was broken up into AT&T Long Lines BOCs (Bell Operating Companies)  and a few other pieces\n The   BOCs were grouped into seven regional BOCs (RBOCs) to make them economically viable\n The entire nature of telecommunication in the United States was changed overnight by court order (not by an act of Congress)\n The exact specifications of the divestiture were described in the so-called MFJ (Modified Final Judgment)  an oxymoron if ever there was one—if the judgment could be modified  it clearly was not final\n This event led to increased competition  better service  and lower long-distance rates for consumers and businesses\n However  prices for local service rose as the cross subsidies from longdistance calling were eliminated and local service had to become self supporting\n Many other countries have now introduced competition along similar lines\n Of direct relevance to our studies is that the new competitive framework caused a key technical feature to be added to the architecture of the telephone network\n To make it clear who could do what  the United States was divided up into LATAs (Local Access and Transport Areas)\n Very roughly  a LATA is about as big as the area covered by one area code\n Within each LATA  there was one LEC (Local Exchange Carrier) with a monopoly on traditional telephone   THE PUBLIC SWITCHED TELEPHONE NETWORK service within its area\n The most important LECs were the BOCs  although some LATAs contained one or more of the  independent telephone companies operating as LECs\n The new feature was that all inter-LATA traffic was handled by a different kind of company  an IXC (IntereXchange Carrier)\n Originally  AT&T Long Lines was the only serious IXC  but now there are well-established competitors such as Verizon and Sprint in the IXC business\n One of the concerns at the breakup was to ensure that all the IXCs would be treated equally in terms of line quality  tariffs  and the number of digits their customers would have to dial to use them\n The way this is handled is illustrated in Fig\n  -  \n Here we see three example LATAs  each with several end offices\n LATAs  and  also have a small hierarchy with tandem offices (intra-LATA toll offices)\n To local loops IXC # ’s toll office IXC # ’s toll office IXC POP Tandem office End office LATA  LATA  LATA  Figure  -  \n The relationship of LATAs  LECs  and IXCs\n All the circles are LEC switching offices\n Each hexagon belongs to the IXC whose number is in it\n Any IXC that wishes to handle calls originating in a LATA can build a switching office called a POP (Point of Presence) there\n The LEC is required to connect each IXC to every end office  either directly  as in LATAs  and   or indirectly  as in LATA  \n Furthermore  the terms of the connection  both technical and financial  must be identical for all IXCs\n This requirement enables  a subscriber in  say  LATA   to choose which IXC to use for calling subscribers in LATA  \n As part of the MFJ  the IXCs were forbidden to offer local telephone service and the LECs were forbidden to offer inter-LATA telephone service  although THE PHYSICAL LAYER  \n  both were free to enter any other business  such as operating fried chicken restaurants\n In  that was a fairly unambiguous statement\n Unfortunately  technology has a funny way of making the law obsolete\n Neither cable television nor mobile phones were covered by the agreement\n As cable television went from one way to two way and mobile phones exploded in popularity  both LECs and IXCs began buying up or merging with cable and mobile operators\n By  Congress saw that trying to maintain a distinction between the various kinds of companies was no longer tenable and drafted a bill to preserve accessibility for competition but allow cable TV companies  local telephone companies  long-distance carriers  and mobile operators to enter one another’s businesses\n The idea was that any company could then offer its customers a single integrated package containing cable TV  telephone  and information services and that different companies would compete on service and price\n The bill was enacted into law in February  as a major overhaul of telecommunications regulation\n As a result  some BOCs became IXCs and some other companies  such as cable television operators  began offering local telephone service in competition with the LECs\n One interesting property of the  law is the requirement that LECs implement local number portability\n This means that a customer can change local telephone companies without having to get a new telephone number\n Portability for mobile phone numbers (and between fixed and mobile lines) followed suit in \n These provisions removed a huge hurdle for many people  making them much more inclined to switch LECs\n As a result  the  \n telecommunications landscape became much more competitive  and other countries have followed suit\n Often other countries wait to see how this kind of experiment works out in the  \n If it works well  they do the same thing; if it works badly  they try something else\n    The Local Loop: Modems  ADSL  and Fiber It is now time to start our detailed study of how the telephone system works\n Let us begin with the part that most people are familiar with: the two-wire local loop coming from a telephone company end office into houses\n The local loop is also frequently referred to as the ‘‘last mile ’’ although the length can be up to several miles\n It has carried analog information for over years and is likely to continue doing so for some years to come  due to the high cost of converting to digital\n Much effort has been devoted to squeezing data networking out of the copper local loops that are already deployed\n Telephone modems send digital data between computers over the narrow channel the telephone network provides for a voice call\n They were once widely used  but have been largely displaced by broadband technologies such as ADSL that\n reuse the local loop to send digital data from a customer to the end office  where they are siphoned off to the Internet\n   THE PUBLIC SWITCHED TELEPHONE NETWORK Both modems and ADSL must deal with the limitations of old local loops: relatively narrow bandwidth  attenuation and distortion of signals  and susceptibility to electrical noise such as crosstalk\n In some places  the local loop has been modernized by installing optical fiber to (or very close to) the home\n Fiber is the way of the future\n These installations support computer networks from the ground up  with the local loop having ample bandwidth for data services\n The limiting factor is what people will pay  not the physics of the local loop\n In this tion we will study the local loop  both old and new\n We will cover telephone modems  ADSL  and fiber to the home\n Telephone Modems To send bits over the local loop  or any other physical channel for that matter  they must be converted to analog signals that can be transmitted over the channel\n This conversion is accomplished using the methods for digital modulation that we studied in the previous tion\n At the other end of the channel  the analog signal is converted back to bits\n A device that converts between a stream of digital bits and an analog signal that represents the bits is called a modem  which is short for ‘‘modulator demodulator\n’’ Modems come in many varieties: telephone modems  DSL modems  cable modems  wireless modems  etc\n The modem may be built into the computer (which is now common for telephone modems) or be a separate box (which is common for DSL and cable modems)\n Logically  the modem is inserted between the (digital) computer and the (analog) telephone system  as seen in Fig\n  -  \n End office Modem Codec Computer Local loop (analog) Trunk (digital  fiber) Digital line Analog line Codec Modem ISP  ISP  Figure  -  \n The use of both analog and digital transmission for a computerto- computer call\n Conversion is done by the modems and codecs\n Telephone modems are used to send bits between two computers over a voice-grade telephone line  in place of the conversation that usually fills the line\n The main difficulty in doing so is that a voice-grade telephone line is limited to  Hz  about what is sufficient to carry a conversation\n This bandwidth is more than four orders of magnitude less than the bandwidth that is used for Ethernet or THE PHYSICAL LAYER    (WiFi)\n Unsurprisingly  the data rates of telephone modems are also four orders of magnitude less than that of Ethernet and    Let us run the numbers to see why this is the case\n The Nyquist theorem tells us that even with a perfect -Hz line (which a telephone line is decidedly not)  there is no point in sending symbols at a rate faster than  baud\n In practice  most modems send at a rate of  symbols/  or  baud  and focus on getting multiple bits per symbol while allowing traffic in both directions at the same time (by using different frequencies for different directions)\n The humble -bps modem uses  volts for a logical  and  volt for a logical   with  bit per symbol\n One step up  it can use four different symbols  as in the four phases of QPSK  so with  bits/symbol it can get a data rate of  bps\n A long progression of higher rates has been achieved as technology has improved\n Higher rates require a larger set of symbols or constellation\n With many symbols  even a small amount of noise in the detected amplitude or phase can result in an error\n To reduce the chance of errors  standards for the higher-speed modems use some of the symbols for error correction\n The schemes are known as TCM (Trellis Coded Modulation) (Ungerboeck  )\n The V\n  modem standard uses   constellation points to transmit  data bits and  check bit per symbol at  baud to achieve  bps with error correction\n The next step above  bps is   bps\n It is called V\n  bis and transmits  data bits and  check bit per symbol at  baud\n Then comes V\n   which achieves   bps by transmitting   data bits/symbol at  baud\n The constellation now has thousands of points\n The final modem in this series is V\n  bis which uses   data bits/symbol at  baud to achieve   bps\n Why stop here? The reason that standard modems stop at   is that the Shannon limit for the telephone system is about   kbps based on the average length of local loops and the quality of these lines\n Going faster than this would violate the laws of physics (department of thermodynamics)\n However  there is one way we can change the situation\n At the telephone company end office  the data are converted to digital form for transmission within the telephone network (the core of the telephone network converted from analog to digital long ago)\n The  -kbps limit is for the situation in which there are two local loops  one at each end\n Each of these adds noise to the signal\n If we could get rid of one of these local loops  we would increase the SNR and the maximum rate would be doubled\n This approach is how  -kbps modems are made to work\n One end  typically an ISP  gets a high-quality digital feed from the nearest end office\n Thus  when one end of the connection is a high-quality signal  as it is with most ISPs now  the maximum data rate can be as high as   kbps\n Between two home users with modems and analog lines  the maximum is still  \n  kbps\n The reason that  -kbps modems (rather than  -kbps modems) are in use has to do with the Nyquist theorem\n A telephone channel is carried inside the telephone system as digital samples\n Each telephone channel is  Hz wide when   THE PUBLIC SWITCHED TELEPHONE NETWORK the guard bands are included\n The number of samples per ond needed to reconstruct it is thus \n The number of bits per sample in the  \n is   one of which may be used for control purposes  allowing   bits/ of user data\n In Europe  all  bits are available to users  so  -bit/ modems could have been used  but to get international agreement on a standard    was chosen\n The end result is the V\n  and V\n  modem standards\n They provide for a  -kbps downstream channel (ISP to user) and a  \n -kbps and  -kbps upstream channel (user to ISP)  respectively\n The asymmetry is because there is usually more data transported from the ISP to the user than the other way\n It also means that more of the limited bandwidth can be allocated to the downstream channel to increase the chances of it actually working at   kbps\n Digital Subscriber Lines When the telephone industry finally got to   kbps  it patted itself on the back for a job well done\n Meanwhile  the cable TV industry was offering speeds up to   Mbps on shared cables\n As Internet access became an increasingly important part of their business  the telephone companies (LECs) began to realize they needed a more competitive product\n Their answer was to offer new digital services over the local loop\n Initially  there were many overlapping high-speed offerings  all under the general name of xDSL (Digital Subscriber Line)  for various x\n Services with more bandwidth than standard telephone service are sometimes called broadband  although the term really is more of a marketing concept than a specific technical concept\n Later  we will discuss what has become the most popular of these services  ADSL (Asymmetric DSL)\n We will also use the term DSL or xDSL as shorthand for all flavors\n The reason that modems are so slow is that telephones were invented for carrying the human voice and the entire system has been carefully optimized for this purpose\n Data have always been stepchildren\n At the point where each local loop terminates in the end office  the wire runs through a filter that attenuates all frequencies below Hz and above  Hz\n The cutoff is not sharp—   Hz and  Hz are the  -dB points—so the bandwidth is usually quoted as  Hz even though the distance between the  dB points is  Hz\n Data on the wire are thus also restricted to this narrow band\n The trick that makes xDSL work is that when a customer subscribes to it  the incoming line is connected to a different kind of switch  one that does not have this filter  thus making the entire capacity of the local loop available\n The limiting factor then becomes the physics of the local loop  which supports roughly  MHz  not the artificial  Hz bandwidth created by the filter\n Unfortunately  the capacity of the local loop falls rather quickly with distance from the end office as the signal is increasingly degraded along the wire\n It also depends on the thickness and general quality of the twisted pair\n A plot of the THE PHYSICAL LAYER  \n  potential bandwidth as a function of distance is given in Fig\n  -  \n This figure assumes that all the other factors are optimal (new wires  modest bundles  etc\n)\n      Meters  Mbps Figure  -  \n Bandwidth versus distance over Category  UTP for DSL\n The implication of this figure creates a problem for the telephone company\n When it picks a speed to offer  it is simultaneously picking a radius from its end offices beyond which the service cannot be offered\n This means that when distant customers try to sign up for the service  they may be told ‘‘Thanks a lot for your interest  but you live meters too far from the nearest end office to get this service\n Could you please move?’’ The lower the chosen speed is  the larger the radius and the more customers are covered\n But the lower the speed  the less attractive the service is and the fewer the people who will be willing to pay for it\n This is where business meets technology\n The xDSL services have all been designed with certain goals in mind\n First  the services must work over the existing Category  twisted pair local loops\n ond  they must not affect customers’ existing telephones and fax machines\n Third  they must be much faster than   kbps\n Fourth  they should be always on  with just a monthly charge and no per-minute charge\n To meet the technical goals  the available  \n  MHz spectrum on the local loop is divided into independent channels of \n  Hz each\n This arrangement is shown in Fig\n  -  \n The OFDM scheme  which we saw in the previous tion  is used to send data over these channels  though it is often called DMT (Discrete MultiTone) in the context of ADSL\n Channel  is used for POTS (Plain Old Telephone Service)\n Channels  –  are not used  to keep the voice and data signals from interfering with each other\n Of the remaining channels  one is used for upstream control and one is used for downstream control\n The rest are available for user data\n In principle  each of the remaining channels can be used for a full-duplex data stream  but harmonics  crosstalk  and other effects keep practical systems well   THE PUBLIC SWITCHED TELEPHONE NETWORK Power Voice Upstream Downstream  -kHz Channels  kHz Figure  -  \n Operation of ADSL using discrete multitone modulation\n below the theoretical limit\n It is up to the provider to determine how many channels are used for upstream and how many for downstream\n A  /  mix of upstream and downstream is technically possible  but most providers allocate something like  –  % of the bandwidth to the downstream channel since most users download more data than they upload\n This choice gives rise to the ‘‘A’’ in ADSL\n A common split is   channels for upstream and the rest downstream\n It is also possible to have a few of the highest upstream channels be bidirectional for increased bandwidth  although making this optimization requires adding a special circuit to cancel echoes\n The international ADSL standard  known as    was approved in \n It allows speeds of as much as  Mbps downstream and  Mbps upstream\n It was superseded by a ond generation in  called ADSL  with various improvements to allow speeds of as much as   Mbps downstream and  Mbps upstream\n Now we have ADSL +  which doubles the downstream speed to   Mbps by doubling the bandwidth to use  \n  MHz over the twisted pair\n However  the numbers quoted here are best-case speeds for good lines close (within  to  km) to the exchange\n Few lines support these rates  and few providers offer these speeds\n Typically  providers offer something like  Mbps downstream and kbps upstream (standard service)   Mbps downstream and  Mbps upstream (improved service)  and  Mbps downstream and  Mbps upstream (premium service)\n Within each channel  QAM modulation is used at a rate of roughly  symbols/\n The line quality in each channel is constantly monitored and the data rate is adjusted by using a larger or smaller constellation  like those in Fig\n  -  \n Different channels may have different data rates  with up to   bits per symbol sent on a channel with a high SNR  and down to  or no bits per symbol sent on a channel with a low SNR depending on the standard\n A typical ADSL arrangement is shown in Fig\n  -  \n In this scheme  a telephone company technician must install a NID (Network Interface Device) on the customer’s premises\n This small plastic box marks the end of the telephone company’s property and the start of the customer’s property\n Close to the NID (or sometimes combined with it) is a splitter  an analog filter that separates the THE PHYSICAL LAYER  \n   –   -Hz band used by POTS from the data\n The POTS signal is routed to the existing telephone or fax machine\n The data signal is routed to an ADSL modem  which uses digital signal processing to implement OFDM\n Since most ADSL modems are external  the computer must be connected to them at high speed\n Usually  this is done using Ethernet  a USB cable  or    DSLAM Splitter Codec Splitter Telephone To ISP ADSL modem Ethernet Computer Telephone line Telephone company end office Customer premises Voice switch NID Figure  -  \n A typical ADSL equipment configuration\n At the other end of the wire  on the end office side  a corresponding splitter is installed\n Here  the voice portion of the signal is filtered out and sent to the normal voice switch\n The signal above   kHz is routed to a new kind of device called a DSLAM (Digital Subscriber Line Access Multiplexer)  which contains the same kind of digital signal processor as the ADSL modem\n Once the bits have been recovered from the signal  packets are formed and sent off to the ISP\n This complete separation between the voice system and ADSL makes it relatively easy for a telephone company to deploy ADSL\n All that is needed is buying a DSLAM and splitter and attaching the ADSL subscribers to the splitter\n Other high-bandwidth services ( \n  ISDN) require much greater changes to the existing switching equipment\n One disadvantage of the design of Fig\n  -  is the need for a NID and splitter on the customer’s premises\n Installing these can only be done by a telephone company technician  necessitating an expensive ‘‘truck roll’’ ( \n  sending a technician to the customer’s premises)\n Therefore  an alternative  splitterless design  informally called    has also been standardized\n It is the same as Fig\n  -  but without the customer’s splitter\n The existing telephone line is used as is\n The only difference is that a microfilter has to be inserted into each telephone jack   THE PUBLIC SWITCHED TELEPHONE NETWORK between the telephone or ADSL modem and the wire\n The microfilter for the telephone is a low-pass filter eliminating frequencies above  Hz; the microfilter for the ADSL modem is a high-pass filter eliminating frequencies below   kHz\n However  this system is not as reliable as having a splitter  so   can be used only up to  \n  Mbps (versus  Mbps for ADSL with a splitter)\n For more information about ADSL  see Starr (   )\n Fiber To The Home Deployed copper local loops limit the performance of ADSL and telephone modems\n To let them provide faster and better network services  telephone companies are upgrading local loops at every opportunity by installing optical fiber all the way to houses and offices\n The result is called FttH (Fiber To The Home)\n While FttH technology has been available for some time  deployments only began to take off in  with growth in the demand for high-speed Internet from customers used to DSL and cable who wanted to download movies\n Around  % of  \n houses are now connected to FttH with Internet access speeds of up to Mbps\n Several variations of the form ‘‘FttX’’ (where X stands for the basement  curb  or neighborhood) exist\n They are used to note that the fiber deployment may reach close to the house\n In this case  copper (twisted pair or coaxial cable) provides fast enough speeds over the last short distance\n The choice of how far to lay the fiber is an economic one  balancing cost with expected revenue\n In any case  the point is that optical fiber has crossed the traditional barrier of the ‘‘last mile\n’’ We will focus on FttH in our discussion\n Like the copper wires before it  the fiber local loop is passive\n This means no powered equipment is required to amplify or otherwise process signals\n The fiber simply carries signals between the home and the end office\n This in turn reduces cost and improves reliability\n Usually  the fibers from the houses are joined together so that only a single fiber reaches the end office per group of up to houses\n In the downstream direction  optical splitters divide the signal from the end office so that it reaches all the houses\n Encryption is needed for urity if only one house should be able to decode the signal\n In the upstream direction  optical combiners merge the signals from the houses into a single signal that is received at the end office\n This architecture is called a PON (Passive Optical Network)  and it is shown in Fig\n  -  \n It is common to use one wavelength shared between all the houses for downstream transmission  and another wavelength for upstream transmission\n Even with the splitting  the tremendous bandwidth and low attenuation of fiber mean that PONs can provide high rates to users over distances of up to   km\n The actual data rates and other details depend on the type of PON\n Two kinds are common\n GPONs (Gigabit-capable PONs) come from the world of telecommunications  so they are defined by an ITU standard\n EPONs (Ethernet PONs) THE PHYSICAL LAYER  \n  Fiber Optical End office splitter/combiner Rest of network Figure  -  \n Passive optical network for Fiber To The Home\n are more in tune with the world of networking  so they are defined by an IEEE standard\n Both run at around a gigabit and can carry traffic for different services  including Internet  video  and voice\n For example  GPONs provide  \n  Gbps downstream and  \n  or  \n  Gbps upstream\n Some protocol is needed to share the capacity of the single fiber at the end office between the different houses\n The downstream direction is easy\n The end office can send messages to each different house in whatever order it likes\n In the upstream direction  however  messages from different houses cannot be sent at the same time  or different signals would collide\n The houses also cannot hear each other’s transmissions so they cannot listen before transmitting\n The solution is that equipment at the houses requests and is granted time slots to use by equipment in the end office\n For this to work  there is a ranging process to adjust the transmission times from the houses so that all the signals received at the end office are synchronized\n The design is similar to cable modems  which we cover later in this  ter\n For more information on the future of PONs  see Grobe and Elbers (   )\n    Trunks and Multiplexing Trunks in the telephone network are not only much faster than the local loops  they are different in two other respects\n The core of the telephone network carries digital information  not analog information; that is  bits not voice\n This necessitates a conversion at the end office to digital form for transmission over the longhaul trunks\n The trunks carry thousands  even millions  of calls simultaneously\n This sharing is important for achieving economies of scale  since it costs essentially the same amount of money to install and maintain a high-bandwidth trunk as a low-bandwidth trunk between two switching offices\n It is accomplished with versions of TDM and FDM multiplexing\n Below we will briefly examine how voice signals are digitized so that they can be transported by the telephone network\n After that  we will see how TDM is used to carry bits on trunks  including the TDM system used for fiber optics   THE PUBLIC SWITCHED TELEPHONE NETWORK (SONET)\n Then we will turn to FDM as it is applied to fiber optics  which is called wavelength division multiplexing\n Digitizing Voice Signals Early in the development of the telephone network  the core handled voice calls as analog information\n FDM techniques were used for many years to multiplex -Hz voice channels (comprised of  Hz plus guard bands) into larger and larger units\n For example calls in the   kHz–to–   kHz band is known as a group and five groups (a total of   calls) are known as a supergroup  and so on\n These FDM methods are still used over some copper wires and microwave channels\n However  FDM requires analog circuitry and is not amenable to being done by a computer\n In contrast  TDM can be handled entirely by digital electronics  so it has become far more widespread in recent years\n Since TDM can only be used for digital data and the local loops produce analog signals  a conversion is needed from analog to digital in the end office  where all the individual local loops come together to be combined onto outgoing trunks\n The analog signals are digitized in the end office by a device called a codec (short for ‘‘coder-decoder’’)\n The codec makes  samples per ond (   μ/sample) because the Nyquist theorem says that this is sufficient to capture all the information from the  -kHz telephone channel bandwidth\n At a lower sampling rate  information would be lost; at a higher one  no extra information would be gained\n Each sample of the amplitude of the signal is quantized to an  -bit number\n This technique is called PCM (Pulse Code Modulation)\n It forms the heart of the modern telephone system\n As a consequence  virtually all time intervals within the telephone system are multiples of μ\n The standard uncompressed data rate for a voice-grade telephone call is thus  bits every μ  or   kbps\n At the other end of the call  an analog signal is recreated from the quantized samples by playing them out (and smoothing them) over time\n It will not be exactly the same as the original analog signal  even though we sampled at the Nyquist rate  because the samples were quantized\n To reduce the error due to quantization  the quantization levels are unevenly spaced\n A logarithmic scale is used that gives relatively more bits to smaller signal amplitudes and relatively fewer bits to large signal amplitudes\n In this way the error is proportional to the signal amplitude\n Two versions of quantization are widely used: μ-law  used in North America and Japan  and A-law  used in Europe and the rest of the world\n Both versions are specified in standard ITU G An equivalent way to think about this process is to imagine that the dynamic range of the signal (or the ratio between the largest and smallest possible values) is compressed before it is (evenly) quantized  and then expanded when the analog signal is recreated\n For this reason it is called THE PHYSICAL LAYER  \n  companding\n It is also possible to compress the samples after they are digitized so that they require much less than   kbps\n However  we will leave this topic for when we explore audio applications such as voice over IP\n Time Division Multiplexing TDM based on PCM is used to carry multiple voice calls over trunks by sending a sample from each call every μ\n When digital transmission began emerging as a feasible technology  ITU (then called CCITT) was unable to reach agreement on an international standard for PCM\n Consequently  a variety of incompatible schemes are now in use in different countries around the world\n The method used in North America and Japan is the T  carrier  depicted in Fig\n  -  \n (Technically speaking  the format is called DS  and the carrier is called T  but following widespread industry tradition  we will not make that subtle distinction here\n) The T  carrier consists of   voice channels multiplexed together\n Each of the   channels  in turn  gets to insert  bits into the output stream\n Channel  Channel  Channel  Channel  Channel  -bit frame (   μ)  Data bits per channel per sample Bit  is a framing code Bit  is for signaling Figure  -  \n The T  carrier ( \n   Mbps)\n A frame consists of   ×  = bits plus one extra bit for control purposes  yielding bits every μ\n This gives a gross data rate of  \n   Mbps  of which  kbps is for signaling\n The   rd bit is used for frame synchronization and signaling\n In one variation  the   rd bit is used across a group of   frames called an extended superframe\n Six of the bits  in the  th  th   th   th   th  and  th positions  take on the alternating pattern     Normally  the receiver keeps checking for this pattern to make sure that it has not lost synchronization\n Six more bits are used to send an error check code to help the receiver confirm that it is synchronized\n If it does get out of sync  the receiver can scan for the pattern and validate the error check code to get resynchronized\n The remaining     THE PUBLIC SWITCHED TELEPHONE NETWORK bits are used for control information for operating and maintaining the network  such as performance reporting from the remote end\n The T  format has several variations\n The earlier versions sent signaling information in-band  meaning in the same channel as the data  by using some of the data bits\n This design is one form of channel-associated signaling  because each channel has its own private signaling subchannel\n In one arrangement  the least significant bit out of an  -bit sample on each channel is used in every sixth frame\n It has the colorful name of robbed-bit signaling\n The idea is that a few stolen bits will not matter for voice calls\n No one will hear the difference\n For data  however  it is another story\n Delivering the wrong bits is unhelpful  to say the least\n If older versions of T  are used to carry data  only  of  bits  or   kbps can be used in each of the   channels\n Instead  newer versions of T  provide clear channels in which all of the bits may be used to send data\n Clear channels are what businesses who lease a T  line want when they send data across the telephone network in place of voice samples\n Signaling for any voice calls is then handled out-of-band  meaning in a separate channel from the data\n Often  the signaling is done with common-channel signaling in which there is a shared signaling channel\n One of the   channels may be used for this purpose\n Outside North America and Japan  the  \n  -Mbps E  carrier is used instead of T \n This carrier has -bit data samples packed into the basic   -μ frame\n Thirty of the channels are used for information and up to two are used for signaling\n Each group of four frames provides   signaling bits  half of which are used for signaling (whether channel-associated or common-channel) and half of which are used for frame synchronization or are reserved for each country to use as it wishes\n Time division multiplexing allows multiple T  carriers to be multiplexed into higher-order carriers\n Figure  -  shows how this can be done\n At the left we see four T  channels being multiplexed into one T  channel\n The multiplexing at T  and above is done bit for bit  rather than byte for byte with the   voice channels that make up a T  frame\n Four T  streams at  \n   Mbps should generate  \n   Mbps  but T  is actually  \n   Mbps\n The extra bits are used for framing and recovery in case the carrier slips\n T  and T  are widely used by customers  whereas T  and T  are only used within the telephone system itself  so they are not well known\n At the next level  seven T  streams are combined bitwise to form a T  stream\n Then six T  streams are joined to form a T  stream\n At each step a small amount of overhead is added for framing and recovery in case the synchronization between sender and receiver is lost\n Just as there is little agreement on the basic carrier between the United States and the rest of the world  there is equally little agreement on how it is to be multiplexed into higher-bandwidth carriers\n The  \n scheme of stepping up by  and  did not strike everyone else as the way to go  so the ITU standard calls for multiplexing four streams into one stream at each level\n Also  the framing and THE PHYSICAL LAYER  \n       :  :  :   T  streams in  T  stream out  \n   Mbps T  \n   Mbps T   \n   Mbps T \n   Mbps T   T  streams in  T  streams in Figure  -  \n Multiplexing T  streams into higher carriers\n recovery data are different in the  \n and ITU standards\n The ITU hierarchy for    and  channels runs at speeds of    \n   \n and   \n   Mbps\n SONET/SDH In the early days of fiber optics  every telephone company had its own proprietary optical TDM system\n After AT&T was broken up in  local telephone companies had to connect to multiple long-distance carriers  all with different optical TDM systems  so the need for standardization became obvious\n In  Bellcore  the RBOC’s research arm  began working on a standard  called SONET (Synchronous Optical NETwork)\n Later  ITU joined the effort  which resulted in a SONET standard and a set of parallel ITU recommendations (G\n G\n and G\n  ) in \n The ITU recommendations are called SDH (Synchronous Digital Hierarchy) but differ from SONET only in minor ways\n Virtually all the long-distance telephone traffic in the United States  and much of it elsewhere  now uses trunks running SONET in the physical layer\n For additional information about SONET  see Bellamy (   )  Goralski (   )  and Shepard (   )\n The SONET design had four major goals\n First and foremost  SONET had to make it possible for different carriers to interwork\n Achieving this goal required defining a common signaling standard with respect to wavelength  timing  framing structure  and other issues\n ond  some means was needed to unify the  \n  European  and Japanese digital systems  all of which were based on  -kbps PCM channels but combined them in different (and incompatible) ways\n Third  SONET had to provide a way to multiplex multiple digital channels\n At the time SONET was devised  the highest-speed digital carrier actually used widely in the United States was T  at  \n   Mbps\n T  was defined  but not used   THE PUBLIC SWITCHED TELEPHONE NETWORK much  and nothing was even defined above T  speed\n Part of SONET’s mission was to continue the hierarchy to gigabits/ and beyond\n A standard way to multiplex slower channels into one SONET channel was also needed\n Fourth  SONET had to provide support for operations  administration  and maintenance (OAM)  which are needed to manage the network\n Previous systems did not do this very well\n An early decision was to make SONET a traditional TDM system  with the entire bandwidth of the fiber devoted to one channel containing time slots for the various subchannels\n As such  SONET is a synchronous system\n Each sender and receiver is tied to a common clock\n The master clock that controls the system has an accuracy of about  part in   \n Bits on a SONET line are sent out at extremely precise intervals  controlled by the master clock\n The basic SONET frame is a block of bytes put out every μ\n Since SONET is synchronous  frames are emitted whether or not there are any useful data to send\n Having  frames/ exactly matches the sampling rate of the PCM channels used in all digital telephony systems\n The   -byte SONET frames are best described as a rectangle of bytes columns wide by  rows high\n Thus   × =  bits are transmitted  times per ond  for a gross data rate of  \n  Mbps\n This layout is the basic SONET channel  called STS-  (Synchronous Transport Signal- )\n All SONET trunks are multiples of STS- \n The first three columns of each frame are reserved for system management information  as illustrated in Fig\n  -  \n In this block  the first three rows contain the tion overhead; the next six contain the line overhead\n The tion overhead is generated and checked at the start and end of each tion  whereas the line overhead is generated and checked at the start and end of each line\n A SONET transmitter sends back-to-back   -byte frames  without gaps between them  even when there are no data (in which case it sends dummy data)\n From the receiver’s point of view  all it sees is a continuous bit stream  so how does it know where each frame begins? The answer is that the first  bytes of each frame contain a fixed pattern that the receiver searches for\n If it finds this pattern in the same place in a large number of conutive frames  it assumes that it is in sync with the sender\n In theory  a user could insert this pattern into the payload in a regular way  but in practice it cannot be done due to the multiplexing of multiple users into the same frame and other reasons\n The remaining   columns of each frame hold   ×  ×  ×  =  \n   Mbps of user data\n This user data could be voice samples  T  and other carriers swallowed whole  or packets\n SONET is simply a convenient container for transporting bits\n The SPE (Synchronous Payload Envelope)  which carries the user data does not always begin in row   column  \n The SPE can begin anywhere within the frame\n A pointer to the first byte is contained in the first row of the line overhead\n The first column of the SPE is the path overhead ( \n  the header for the end-to-end path sublayer protocol)\n THE PHYSICAL LAYER  \n  Sonet frame (   μ) Sonet frame (   μ)  Rows      Columns  Columns for overhead tion SPE overhead Line overhead Path overhead Figure  -  \n Two back-to-back SONET frames\n The ability to allow the SPE to begin anywhere within the SONET frame and even to span two frames  as shown in Fig\n  -   gives added flexibility to the system\n For example  if a payload arrives at the source while a dummy SONET frame is being constructed  it can be inserted into the current frame instead of being held until the start of the next one\n The SONET/SDH multiplexing hierarchy is shown in Fig\n  -  \n Rates from STS-  to STS-   have been defined  ranging from roughly a T  line to   Gbps\n Even higher rates will surely be defined over time  with OC- at Gbps being the next in line if and when it becomes technologically feasible\n The optical carrier corresponding to STS-n is called OC-n but is bit for bit the same except for a certain bit reordering needed for synchronization\n The SDH names are different  and they start at OC-  because ITU-based systems do not have a rate near  \n  Mbps\n We have shown the common rates  which proceed from OC-  in multiples of four\n The gross data rate includes all the overhead\n The SPE data rate excludes the line and tion overhead\n The user data rate excludes all overhead and counts only the   payload columns\n As an aside  when a carrier  such as OC-  is not multiplexed  but carries the data from only a single source  the letter c (for concatenated) is appended to the designation  so OC-  indicates a   \n  -Mbps carrier consisting of three separate OC-  carriers  but OC- c indicates a data stream from a single source at   \n  Mbps\n The three OC-  streams within an OC- c stream are interleaved by column—first column  from stream   then column  from stream   then column  from stream   followed by column  from stream   and so on—leading to a frame columns wide and  rows deep\n   THE PUBLIC SWITCHED TELEPHONE NETWORK SONET SDH Data rate (Mbps) Electrical Optical Optical Gross SPE User STS-  OC-     \n   STS-  OC-  STM-   \n   STS-  OC-  STM-   \n   STS-  OC-  STM-     \n   STS-   OC-   STM-     \n   STS-   OC-   STM-    \n   \n    \n   Figure  -  \n SONET and SDH multiplex rates\n Wavelength Division Multiplexing A form of frequency division multiplexing is used as well as TDM to harness the tremendous bandwidth of fiber optic channels\n It is called WDM (Wavelength Division Multiplexing)\n The basic principle of WDM on fibers is depicted in Fig\n  -  \n Here four fibers come together at an optical combiner  each with its energy present at a different wavelength\n The four beams are combined onto a single shared fiber for transmission to a distant destination\n At the far end  the beam is split up over as many fibers as there were on the input side\n Each output fiber contains a short  specially constructed core that filters out all but one wavelength\n The resulting signals can be routed to their destination or recombined in different ways for additional multiplexed transport\n There is really nothing new here\n This way of operating is just frequency division multiplexing at very high frequencies  with the term WDM owing to the description of fiber optic channels by their wavelength or ‘‘color’’ rather than frequency\n As long as each channel has its own frequency ( \n  wavelength) range and all the ranges are disjoint  they can be multiplexed together on the long-haul fiber\n The only difference with electrical FDM is that an optical system using a diffraction grating is completely passive and thus highly reliable\n The reason WDM is popular is that the energy on a single channel is typically only a few gigahertz wide because that is the current limit of how fast we can convert between electrical and optical signals\n By running many channels in parallel on different wavelengths  the aggregate bandwidth is increased linearly with the number of channels\n Since the bandwidth of a single fiber band is about   GHz (see Fig\n  - )  there is theoretically room for   -Gbps channels even at  bit/Hz (and higher rates are also possible)\n WDM technology has been progressing at a rate that puts computer technology to shame\n WDM was invented around \n The first commercial systems had eight channels of  \n  Gbps per channel\n By  systems with   channels THE PHYSICAL LAYER  \n  Spectrum on the shared fiber Power λ Fiber  spectrum Power λ Fiber  spectrum Power λ Fiber  spectrum Power λ λ  λ +λ +λ +λ  Fiber  spectrum Power λ Fiber  λ  Fiber  λ  Fiber  Combiner Splitter λ  Long-haul shared fiber λ  λ  λ  Fiber  λ  Filter Figure  -  \n Wavelength division multiplexing\n of  \n  Gbps were on the market\n By  there were products with channels of   Gbps and   channels of   Gbps  capable of moving up to  \n  Tbps\n This bandwidth is enough to transmit   full-length DVD movies per ond\n The channels are also packed tightly on the fiber  with  or as little as   GHz of separation\n Technology demonstrations by companies after bragging rights have shown   times this capacity in the lab  but going from the lab to the field usually takes at least a few years\n When the number of channels is very large and the wavelengths are spaced close together  the system is referred to as DWDM (Dense WDM)\n One of the drivers of WDM technology is the development of all-optical components\n Previously  every km it was necessary to split up all the channels and convert each one to an electrical signal for amplification separately before reconverting them to optical signals and combining them\n Nowadays  all-optical amplifiers can regenerate the entire signal once every  km without the need for multiple opto-electrical conversions\n In the example of Fig\n  -   we have a fixed-wavelength system\n Bits from input fiber  go to output fiber   bits from input fiber  go to output fiber   etc\n However  it is also possible to build WDM systems that are switched in the optical domain\n In such a device  the output filters are tunable using Fabry-Perot or Mach-Zehnder interferometers\n These devices allow the selected frequencies to be changed dynamically by a control computer\n This ability provides a large amount of flexibility to provision many different wavelength paths through the telephone network from a fixed set of fibers\n For more information about optical networks and WDM  see Ramaswami et al\n (   )\n   THE PUBLIC SWITCHED TELEPHONE NETWORK    Switching From the point of view of the average telephone engineer  the phone system is divided into two principal parts: outside plant (the local loops and trunks  since they are physically outside the switching offices) and inside plant (the switches  which are inside the switching offices)\n We have just looked at the outside plant\n Now it is time to examine the inside plant\n Two different switching techniques are used by the network nowadays: circuit switching and packet switching\n The traditional telephone system is based on circuit switching  but packet switching is beginning to make inroads with the rise of voice over IP technology\n We will go into circuit switching in some detail and contrast it with packet switching\n Both kinds of switching are important enough that we will come back to them when we get to the network layer\n Circuit Switching Conceptually  when you or your computer places a telephone call  the switching equipment within the telephone system seeks out a physical path all the way from your telephone to the receiver’s telephone\n This technique is called circuit switching\n It is shown schematically in Fig\n  -  (a)\n Each of the six rectangles represents a carrier switching office (end office  toll office  etc\n)\n In this example  each office has three incoming lines and three outgoing lines\n When a call passes through a switching office  a physical connection is (conceptually) established between the line on which the call came in and one of the output lines  as shown by the dotted lines\n In the early days of the telephone  the connection was made by the operator plugging a jumper cable into the input and output sockets\n In fact  a surprising little story is associated with the invention of automatic circuit switching equipment\n It was invented by a  th-century Missouri undertaker named Almon B\n Strowger\n Shortly after the telephone was invented  when someone died  one of the survivors would call the town operator and say ‘‘Please connect me to an undertaker\n’’ Unfortunately for Mr\n Strowger  there were two undertakers in his town  and the other one’s wife was the town telephone operator\n He quickly saw that either he was going to have to invent automatic telephone switching equipment or he was going to go out of business\n He chose the first option\n For nearly years  the circuit-switching equipment used worldwide was known as Strowger gear\n (History does not record whether the now-unemployed switchboard operator got a job as an information operator  answering questions such as ‘‘What is the phone number of an undertaker?’’) The model shown in Fig\n  -  (a) is highly simplified  of course  because parts of the physical path between the two telephones may  in fact  be microwave or fiber links onto which thousands of calls are multiplexed\n Nevertheless  the basic idea is valid: once a call has been set up  a dedicated path between both ends exists and will continue to exist until the call is finished\n THE PHYSICAL LAYER  \n  (a) (b) Switching office Physical (copper) connection set up when call is made Packets queued for subsequent transmission Computer Computer Figure  -  \n (a) Circuit switching\n (b) Packet switching\n An important property of circuit switching is the need to set up an end-to-end path before any data can be sent\n The elapsed time between the end of dialing and the start of ringing can easily be     more on long-distance or international calls\n During this time interval  the telephone system is hunting for a path  as shown in Fig\n  -  (a)\n Note that before data transmission can even begin  the call request signal must propagate all the way to the destination and be acknowledged\n For many computer applications ( \n  point-of-sale credit verification)  long setup times are undesirable\n As a consequence of the reserved path between the calling parties  once the setup has been completed  the only delay for data is the propagation time for the electromagnetic signal  about  m per  km\n Also as a consequence of the established path  there is no danger of congestion—that is  once the call has been put through  you never get busy signals\n Of course  you might get one before the connection has been established due to lack of switching or trunk capacity\n Packet Switching The alternative to circuit switching is packet switching  shown in Fig\n  -  (b) and described in   With this technology  packets are sent as soon as they are available\n There is no need to set up a dedicated path in advance  unlike   THE PUBLIC SWITCHED TELEPHONE NETWORK Call request signal Data AB trunk A B C (a) D A B C (b) D BC trunk CD trunk Call accept signal Propagation delay Queuing delay Pkt  Pkt  Pkt  Pkt  Pkt  Pkt  Pkt  Pkt  Pkt  Time spent hunting for an outgoing trunk Time Figure  -  \n Timing of events in (a) circuit switching  (b) packet switching\n with circuit switching\n It is up to routers to use store-and-forward transmission to send each packet on its way to the destination on its own\n This procedure is unlike circuit switching  in which the result of the connection setup is the reservation of bandwidth all the way from the sender to the receiver\n All data on the circuit follows this path\n Among other properties  having all the data follow the same path means that it cannot arrive out of order\n With packet switching there is no fixed path  so different packets can follow different paths  depending on network conditions at the time they are sent  and they may arrive out of order\n Packet-switching networks place a tight upper limit on the size of packets\n This ensures that no user can monopolize any transmission line for very long ( \n  many millionds)  so that packet-switched networks can handle interactive traffic\n It also reduces delay since the first packet of a long message can be forwarded before the ond one has fully arrived\n However  the store-and-forward delay of accumulating a packet in the router’s memory before it is sent on to the THE PHYSICAL LAYER  \n  next router exceeds that of circuit switching\n With circuit switching  the bits just flow through the wire continuously\n Packet and circuit switching also differ in other ways\n Because no bandwidth is reserved with packet switching  packets may have to wait to be forwarded\n This introduces queuing delay and congestion if many packets are sent at the same time\n On the other hand  there is no danger of getting a busy signal and being unable to use the network\n Thus  congestion occurs at different times with circuit switching (at setup time) and packet switching (when packets are sent)\n If a circuit has been reserved for a particular user and there is no traffic  its bandwidth is wasted\n It cannot be used for other traffic\n Packet switching does not waste bandwidth and thus is more efficient from a system perspective\n Understanding this trade-off is crucial for comprehending the difference between circuit switching and packet switching\n The trade-off is between guaranteed service and wasting resources versus not guaranteeing service and not wasting resources\n Packet switching is more fault tolerant than circuit switching\n In fact  that is why it was invented\n If a switch goes down  all of the circuits using it are terminated and no more traffic can be sent on any of them\n With packet switching  packets can be routed around dead switches\n A final difference between circuit and packet switching is the charging algorithm\n With circuit switching  charging has historically been based on distance and time\n For mobile phones  distance usually does not play a role  except for international calls  and time plays only a coarse role ( \n  a calling plan with  free minutes costs more than one with  free minutes and sometimes nights or weekends are cheap)\n With packet switching  connect time is not an issue  but the volume of traffic is\n For home users  ISPs usually charge a flat monthly rate because it is less work for them and their customers can understand this model  but backbone carriers charge regional networks based on the volume of their traffic\n The differences are summarized in Fig\n  -  \n Traditionally  telephone networks have used circuit switching to provide high-quality telephone calls  and computer networks have used packet switching for simplicity and efficiency\n However  there are notable exceptions\n Some older computer networks have been circuit switched under the covers ( \n  X\n  ) and some newer telephone networks use packet switching with voice over IP technology\n This looks just like a standard telephone call on the outside to users  but inside the network packets of voice data are switched\n This approach has let upstarts market cheap international calls via calling cards  though perhaps with lower call quality than the incumbents  THE MOBILE TELEPHONE SYSTEM The traditional telephone system  even if it someday gets multigigabit end-toend fiber  will still not be able to satisfy a growing group of users: people on the go\n People now expect to make phone calls and to use their phones to check   THE MOBILE TELEPHONE SYSTEM Item Circuit switched Packet switched Call setup Required Not needed Dedicated physical path Yes No Each packet follows the same route Yes No Packets arrive in order Yes No Is a switch crash fatal Yes No Bandwidth available Fixed Dynamic Time of possible congestion At setup time On every packet Potentially wasted bandwidth Yes No Store-and-forward transmission No Yes Charging Per minute Per packet Figure  -  \n A comparison of circuit-switched and packet-switched networks\n email and surf the Web from airplanes  cars  swimming pools  and while jogging in the park\n Consequently  there is a tremendous amount of interest in wireless telephony\n In the following tions we will study this topic in some detail\n The mobile phone system is used for wide area voice and data communication\n Mobile phones (sometimes called cell phones) have gone through three distinct generations  widely called  G  G  and  G\n The generations are:  \n Analog voice Digital voice Digital voice and data (Internet  email  etc\n)\n (Mobile phones should not be confused with cordless phones that consist of a base station and a handset sold as a set for use within the home\n These are never used for networking  so we will not examine them further\n) Although most of our discussion will be about the technology of these systems  it is interesting to note how political and tiny marketing decisions can have a huge impact\n The first mobile system was devised in the  \n by AT&T and mandated for the whole country by the FCC\n As a result  the entire  \n had a single (analog) system and a mobile phone purchased in California also worked in New York\n In contrast  when mobile phones came to Europe  every country devised its own system  which resulted in a fiasco\n Europe learned from its mistake and when digital came around  the government- run PTTs got together and standardized on a single system (GSM)  so any European mobile phone will work anywhere in Europe\n By then  the  \n had decided that government should not be in the standardization business  so it left digital to the marketplace\n This decision resulted in different equipment manufacturers producing different kinds of mobile phones\n As a consequence  in the  \n THE PHYSICAL LAYER  \n  two major—and completely incompatible—digital mobile phone systems were deployed  as well as other minor systems\n Despite an initial lead by the  \n  mobile phone ownership and usage in Europe is now far greater than in the  \n Having a single system that works anywhere in Europe and with any provider is part of the reason  but there is more\n A ond area where the  \n and Europe differed is in the humble matter of phone numbers\n In the  \n  mobile phones are mixed in with regular (fixed) telephones\n Thus  there is no way for a caller to see if  say  (  )   - is a fixed telephone (cheap or free call) or a mobile phone (expensive call)\n To keep people from getting nervous about placing calls  the telephone companies decided to make the mobile phone owner pay for incoming calls\n As a consequence  many people hesitated buying a mobile phone for fear of running up a big bill by just receiving calls\n In Europe  mobile phone numbers have a special area code (analogous to and numbers) so they are instantly recognizable\n Consequently  the usual rule of ‘‘caller pays’’ also applies to mobile phones in Europe (except for international calls  where costs are split)\n A third issue that has had a large impact on adoption is the widespread use of prepaid mobile phones in Europe (up to  % in some areas)\n These can be purchased in many stores with no more formality than buying a digital camera\n You pay and you go\n They are preloaded with a balance of  for example or   euros and can be recharged (using a ret PIN code) when the balance drops to zero\n As a consequence  practically every teenager and many small children in Europe have (usually prepaid) mobile phones so their parents can locate them  without the danger of the child running up a huge bill\n If the mobile phone is used only occasionally  its use is essentially free since there is no monthly charge or charge for incoming calls\n    First-Generation ( G) Mobile Phones: Analog Voice Enough about the politics and marketing aspects of mobile phones\n Now let us look at the technology  starting with the earliest system\n Mobile radiotelephones were used sporadically for maritime and military communication during the early decades of the  th century\n In  the first system for car-based telephones was set up in St\n Louis\n This system used a single large transmitter on top of a tall building and had a single channel  used for both sending and receiving\n To talk  the user had to push a button that enabled the transmitter and disabled the receiver\n Such systems  known as push-to-talk systems  were installed in several cities beginning in the late s\n CB radio  taxis  and police cars often use this technology\n In the s  IMTS (Improved Mobile Telephone System) was installed\n It  too  used a high-powered (  -watt) transmitter on top of a hill but it had two frequencies  one for sending and one for receiving  so the push-to-talk button was   THE MOBILE TELEPHONE SYSTEM no longer needed\n Since all communication from the mobile telephones went inbound on a different channel than the outbound signals  the mobile users could not hear each other (unlike the push-to-talk system used in taxis)\n IMTS supported   channels spread out from MHz to MHz\n Due to the small number of channels  users often had to wait a long time before getting a dial tone\n Also  due to the large power of the hilltop transmitters  adjacent systems had to be several hundred kilometers apart to avoid interference\n All in all  the limited capacity made the system impractical\n Advanced Mobile Phone System All that changed with AMPS (Advanced Mobile Phone System)  invented by Bell Labs and first installed in the United States in \n It was also used in England  where it was called TACS  and in Japan  where it was called MCS-L \n AMPS was formally retired in  but we will look at it to understand the context for the  G and  G systems that improved on it\n In all mobile phone systems  a geographic region is divided up into cells  which is why the devices are sometimes called cell phones\n In AMPS  the cells are typically   to   km across; in digital systems  the cells are smaller\n Each cell uses some set of frequencies not used by any of its neighbors\n The key idea that gives cellular systems far more capacity than previous systems is the use of relatively small cells and the reuse of transmission frequencies in nearby (but not adjacent) cells\n Whereas an IMTS system km across can have only one call on each frequency  an AMPS system might have  -km cells in the same area and be able to have   to   calls on each frequency  in widely separated cells\n Thus  the cellular design increases the system capacity by at least an order of magnitude  more as the cells get smaller\n Furthermore  smaller cells mean that less power is needed  which leads to smaller and cheaper transmitters and handsets\n The idea of frequency reuse is illustrated in Fig\n  -  (a)\n The cells are normally roughly circular  but they are easier to model as hexagons\n In Fig\n  -  (a)  the cells are all the same size\n They are grouped in units of seven cells\n Each letter indicates a group of frequencies\n Notice that for each frequency set  there is a buffer about two cells wide where that frequency is not reused  providing for good separation and low interference\n Finding locations high in the air to place base station antennas is a major issue\n This problem has led some telecommunication carriers to forge alliances with the Roman Catholic Church  since the latter owns a substantial number of exalted potential antenna sites worldwide  all conveniently under a single management\n In an area where the number of users has grown to the point that the system is overloaded  the power can be reduced and the overloaded cells split into smaller THE PHYSICAL LAYER  \n  G F A B C D E G F A B C D E G F A B C D E (a) (b) Figure  -  \n (a) Frequencies are not reused in adjacent cells\n (b) To add more users  smaller cells can be used\n microcells to permit more frequency reuse  as shown in Fig\n  -  (b)\n Telephone companies sometimes create temporary microcells  using portable towers with satellite links at sporting events  rock concerts  and other places where large numbers of mobile users congregate for a few hours\n At the center of each cell is a base station to which all the telephones in the cell transmit\n The base station consists of a computer and transmitter/receiver connected to an antenna\n In a small system  all the base stations are connected to a single device called an MSC (Mobile Switching Center) or MTSO (Mobile Telephone Switching Office)\n In a larger one  several MSCs may be needed  all of which are connected to a ond-level MSC  and so on\n The MSCs are essentially end offices as in the telephone system  and are in fact connected to at least one telephone system end office\n The MSCs communicate with the base stations  each other  and the PSTN using a packet-switching network\n At any instant  each mobile telephone is logically in one specific cell and under the control of that cell’s base station\n When a mobile telephone physically leaves a cell  its base station notices the telephone’s signal fading away and asks all the surrounding base stations how much power they are getting from it\n When the answers come back  the base station then transfers ownership to the cell getting the strongest signal; under most conditions that is the cell where the telephone is now located\n The telephone is then informed of its new boss  and if a call is in progress  it is asked to switch to a new channel (because the old one is not reused in any of the adjacent cells)\n This process  called handoff  takes about m\n Channel assignment is done by the MSC  the nerve center of the system\n The base stations are really just dumb radio relays\n   THE MOBILE TELEPHONE SYSTEM Channels AMPS uses FDM to separate the channels\n The system uses full-duplex channels  each consisting of a pair of simplex channels\n This arrangement is known as FDD (Frequency Division Duplex)\n The simplex channels from to MHz are used for mobile to base station transmission  and simplex channels from to MHz are used for base station to mobile transmission\n Each of these simplex channels is   kHz wide\n The channels are divided into four categories\n Control channels (base to mobile) are used to manage the system\n Paging channels (base to mobile) alert mobile users to calls for them\n Access channels (bidirectional) are used for call setup and channel assignment\n Finally  data channels (bidirectional) carry voice  fax  or data\n Since the same frequencies cannot be reused in nearby cells and   channels are reserved in each cell for control  the actual number of voice channels available per cell is much smaller than  typically about  \n Call Management Each mobile telephone in AMPS has a  -bit serial number and a  -digit telephone number in its programmable read-only memory\n The telephone number is represented as a  -digit area code in   bits and a  -digit subscriber number in   bits\n When a phone is switched on  it scans a preprogrammed list of   control channels to find the most powerful signal\n The phone then broadcasts its  -bit serial number and  -bit telephone number\n Like all the control information in AMPS  this packet is sent in digital form  multiple times  and with an error-correcting code  even though the voice channels themselves are analog\n When the base station hears the announcement  it tells the MSC  which records the existence of its new customer and also informs the customer’s home MSC of his current location\n During normal operation  the mobile telephone reregisters about once every   minutes\n To make a call  a mobile user switches on the phone  enters the number to be called on the keypad  and hits the SEND button\n The phone then transmits the number to be called and its own identity on the access channel\n If a collision occurs there  it tries again later\n When the base station gets the request  it informs the MSC\n If the caller is a customer of the MSC’s company (or one of its partners)  the MSC looks for an idle channel for the call\n If one is found  the channel number is sent back on the control channel\n The mobile phone then automatically switches to the selected voice channel and waits until the called party picks up the phone\n Incoming calls work differently\n To start with  all idle phones continuously listen to the paging channel to detect messages directed at them\n When a call is placed to a mobile phone (either from a fixed phone or another mobile phone)  a packet is sent to the callee’s home MSC to find out where it is\n A packet is then THE PHYSICAL LAYER  \n  sent to the base station in its current cell  which sends a broadcast on the paging channel of the form ‘‘Unit are you there?’’ The called phone responds with a ‘‘Yes’’ on the access channel\n The base then says something like: ‘‘Unit call for you on channel  \n’’ At this point  the called phone switches to channel  and starts making ringing sounds (or playing some melody the owner was given as a birthday present)\n    ond-Generation ( G) Mobile Phones: Digital Voice The first generation of mobile phones was analog; the ond generation is digital\n Switching to digital has several advantages\n It provides capacity gains by allowing voice signals to be digitized and compressed\n It improves urity by allowing voice and control signals to be encrypted\n This in turn deters fraud and eavesdropping  whether from intentional scanning or echoes of other calls due to RF propagation\n Finally  it enables new services such as text messaging\n Just as there was no worldwide standardization during the first generation  there was also no worldwide standardization during the ond  either\n Several different systems were developed  and three have been widely deployed\n DAMPS (Digital Advanced Mobile Phone System) is a digital version of AMPS that coexists with AMPS and uses TDM to place multiple calls on the same frequency channel\n It is described in International Standard IS-  and its successor IS-  \n GSM (Global System for Mobile communications) has emerged as the dominant system  and while it was slow to catch on in the  \n it is now used virtually everywhere in the world\n Like D-AMPS  GSM is based on a mix of FDM and TDM\n CDMA (Code Division Multiple Access)  described in International Standard IS-   is a completely different kind of system and is based on neither FDM mor TDM\n While CDMA has not become the dominant  G system  its technology has become the basis for  G systems\n Also  the name PCS (Personal Communications Services) is sometimes used in the marketing literature to indicate a ond-generation ( \n  digital) system\n Originally it meant a mobile phone using the  MHz band  but that distinction is rarely made now\n We will now describe GSM  since it is the dominant  G system\n In the next tion we will have more to say about CDMA when we describe  G systems\n GSM—The Global System for Mobile Communications GSM started life in the s as an effort to produce a single European  G standard\n The task was assigned to a telecommunications group called (in French) Groupe Speciale´ Mobile\n The first GSM systems were deployed starting in  and were a quick success\n It soon became clear that GSM was going to be more than a European success  with uptake stretching to countries as far away as Australia  so GSM was renamed to have a more worldwide appeal\n   THE MOBILE TELEPHONE SYSTEM GSM and the other mobile phone systems we will study retain from  G systems a design based on cells  frequency reuse across cells  and mobility with handoffs as subscribers move\n It is the details that differ\n Here  we will briefly discuss some of the main properties of GSM\n However  the printed GSM standard is over  [sic] pages long\n A large fraction of this material relates to engineering aspects of the system  especially the design of receivers to handle multipath signal propagation  and synchronizing transmitters and receivers\n None of this will be even mentioned here\n Fig\n  -  shows that the GSM architecture is similar to the AMPS architecture  though the components have different names\n The mobile itself is now divided into the handset and a removable chip with subscriber and account information called a SIM card  short for Subscriber Identity Module\n It is the SIM card that activates the handset and contains rets that let the mobile and the network identify each other and encrypt conversations\n A SIM card can be removed and plugged into a different handset to turn that handset into your mobile as far as the network is concerned\n VLR MSC Air interface Cell tower and base station SIM PSTN card Handset BSC HLR BSC Figure  -  \n GSM mobile network architecture\n The mobile talks to cell base stations over an air interface that we will describe in a moment\n The cell base stations are each connected to a BSC (Base Station Controller) that controls the radio resources of cells and handles handoff\n The BSC in turn is connected to an MSC (as in AMPS) that routes calls and connects to the PSTN (Public Switched Telephone Network)\n To be able to route calls  the MSC needs to know where mobiles can currently be found\n It maintains a database of nearby mobiles that are associated with the cells it manages\n This database is called the VLR (Visitor Location Register)\n There is also a database in the mobile network that gives the last known location of each mobile\n It is called the HLR (Home Location Register)\n This database is used to route incoming calls to the right locations\n Both databases must be kept up to date as mobiles move from cell to cell\n We will now describe the air interface in some detail\n GSM runs on a range of frequencies worldwide  including   and  MHz\n More spectrum is allocated than for AMPS in order to support a much larger number of users\n GSM THE PHYSICAL LAYER  \n  is a frequency division duplex cellular system  like AMPS\n That is  each mobile transmits on one frequency and receives on another  higher frequency (  MHz higher for GSM versus   MHz higher for AMPS)\n However  unlike with AMPS  with GSM a single frequency pair is split by time-division multiplexing into time slots\n In this way it is shared by multiple mobiles\n To handle multiple mobiles  GSM channels are much wider than the AMPS channels (  -kHz versus   kHz)\n One   -kHz channel is shown in Fig\n  -  \n A GSM system operating in the   -MHz region has pairs of simplex channels\n Each simplex channel is kHz wide and supports eight separate connections on it  using time division multiplexing\n Each currently active station is assigned one time slot on one channel pair\n Theoretically  channels can be supported in each cell  but many of them are not available  to avoid frequency conflicts with neighboring cells\n In Fig\n  -   the eight shaded time slots all belong to the same connection  four of them in each direction\n Transmitting and receiving does not happen in the same time slot because the GSM radios cannot transmit and receive at the same time and it takes time to switch from one to the other\n If the mobile device assigned to   \n /  \n  MHz and time slot  wanted to transmit to the base station  it would use the lower four shaded slots (and the ones following them in time)  putting some data in each slot until all the data had been sent\n   \n  MHz   \n  MHz   \n  MHz   \n  MHz   \n  MHz   \n  MHz Frequency Base to mobile Mobile to base    Channel TDM frame Time Figure  -  \n GSM uses frequency channels  each of which uses an eightslot TDM system\n The TDM slots shown in Fig\n  -  are part of a complex framing hierarchy\n Each TDM slot has a specific structure  and groups of TDM slots form multiframes  also with a specific structure\n A simplified version of this hierarchy is shown in Fig\n  -  \n Here we can see that each TDM slot consists of a   -bit data frame that occupies the channel for μ (including a  -μ guard time   THE MOBILE TELEPHONE SYSTEM after each slot)\n Each data frame starts and ends with three  bits  for frame delineation purposes\n It also contains two  -bit Information fields  each one having a control bit that indicates whether the following Information field is for voice or data\n Between the Information fields is a  -bit Sync (training) field that is used by the receiver to synchronize to the sender’s frame boundaries\n CTL            -Bit multiframe sent in m    -Bit TDM frame sent in  \n   m  \n  –bit (  μ) guard time Reserved for future use Information Sync Information   -Bit data frame sent in μ Bits    Voice/data bit Figure  -  \n A portion of the GSM framing structure\n A data frame is transmitted in μ  but a transmitter is only allowed to send one data frame every  \n   m  since it is sharing the channel with seven other stations\n The gross rate of each channel is    bps  divided among eight users\n However  as with AMPS  the overhead eats up a large fraction of the bandwidth  ultimately leaving  \n  kbps worth of payload per user before error correction\n After error correction kbps is left for speech\n While this is substantially less than   kbps PCM for uncompressed voice signals in the fixed telephone network  compression on the mobile device can reach these levels with little loss of quality\n As can be seen from Fig\n  -   eight data frames make up a TDM frame and   TDM frames make up a   -m multiframe\n Of the   TDM frames in a multiframe  slot   is used for control and slot   is reserved for future use  so only   are available for user traffic\n However  in addition to the  -slot multiframe shown in Fig\n  -   a  -slot multiframe (not shown) is also used\n Some of these slots are used to hold several control channels used to manage the system\n The broadcast control channel is a continuous stream of output from the base station containing the base station’s identity and the channel status\n All mobile stations monitor their signal strength to see when they have moved into a new cell\n THE PHYSICAL LAYER  \n  The dedicated control channel is used for location updating  registration  and call setup\n In particular  each BSC maintains a database of mobile stations currently under its jurisdiction  the VLR\n Information needed to maintain the VLR is sent on the dedicated control channel\n Finally  there is the common control channel  which is split up into three logical subchannels\n The first of these subchannels is the paging channel  which the base station uses to announce incoming calls\n Each mobile station monitors it continuously to watch for calls it should answer\n The ond is the random access channel  which allows users to request a slot on the dedicated control channel\n If two requests collide  they are garbled and have to be retried later\n Using the dedicated control channel slot  the station can set up a call\n The assigned slot is announced on the third subchannel  the access grant channel\n Finally  GSM differs from AMPS in how handoff is handled\n In AMPS  the MSC manages it completely without help from the mobile devices\n With time slots in GSM  the mobile is neither sending nor receiving most of the time\n The idle slots are an opportunity for the mobile to measure signal quality to other nearby base stations\n It does so and sends this information to the BSC\n The BSC can use it to determine when a mobile is leaving one cell and entering another so it can perform the handoff\n This design is called MAHO (Mobile Assisted HandOff)\n    Third-Generation ( G) Mobile Phones: Digital Voice and Data The first generation of mobile phones was analog voice  and the ond generation was digital voice\n The third generation of mobile phones  or  G as it is called  is all about digital voice and data\n A number of factors are driving the industry\n First  data traffic already exceeds voice traffic on the fixed network and is growing exponentially  whereas voice traffic is essentially flat\n Many industry experts expect data traffic to dominate voice on mobile devices as well soon\n ond  the telephone  entertainment  and computer industries have all gone digital and are rapidly converging\n Many people are drooling over lightweight  portable devices that act as a telephone  music and video player  email terminal  Web interface  gaming machine  and more  all with worldwide wireless connectivity to the Internet at high bandwidth\n Apple’s iPhone is a good example of this kind of  G device\n With it  people get hooked on wireless data services  and AT&T wireless data volumes are rising steeply with the popularity of iPhones\n The trouble is  the iPhone uses a  \n G network (an enhanced  G network  but not a true  G network) and there is not enough data capacity to keep users happy\n  G mobile telephony is all about providing enough wireless bandwidth to keep these future users happy\n ITU tried to get a bit more specific about this vision starting back around \n It issued a blueprint for getting there called IMT-  where IMT stood   THE MOBILE TELEPHONE SYSTEM for International Mobile Telecommunications\n The basic services that the IMT- network was supposed to provide to its users are:  \n High-quality voice transmission Messaging (replacing email  fax  SMS  chat  etc\n) Multimedia (playing music  viewing videos  films  television  etc\n) Internet access (Web surfing  including pages with audio and video)\n Additional services might be video conferencing  telepresence  group game playing  and m-commerce (waving your telephone at the cashier to pay in a store)\n Furthermore  all these services are supposed to be available worldwide (with automatic connection via a satellite when no terrestrial network can be located)  instantly (always on)  and with quality of service guarantees\n ITU envisioned a single worldwide technology for IMT-  so manufacturers could build a single device that could be sold and used anywhere in the world (like CD players and computers and unlike mobile phones and televisions)\n Having a single technology would also make life much simpler for network operators and would encourage more people to use the services\n Format wars  such as the Betamax versus VHS battle with videorecorders  are not good for business\n As it turned out  this was a bit optimistic\n The number  stood for three things: ( ) the year it was supposed to go into service  ( ) the frequency it was supposed to operate at (in MHz)  and ( ) the bandwidth the service should have (in kbps)\n It did not make it on any of the three counts\n Nothing was implemented by \n ITU recommended that all governments reserve spectrum at  GHz so devices could roam seamlessly from country to country\n China reserved the required bandwidth but nobody else did\n Finally  it was recognized that  Mbps is not currently feasible for users who are too mobile (due to the difficulty of performing handoffs quickly enough)\n More realistic is  Mbps for stationary indoor users (which will compete head-on with ADSL)  kbps for people walking  and kbps for connections in cars\n Despite these initial setbacks  much has been accomplished since then\n Several IMT proposals were made and  after some winnowing  it came down to two main ones\n The first one  WCDMA (Wideband CDMA)  was proposed by Ericsson and was pushed by the European Union  which called it UMTS (Universal Mobile Telecommunications System)\n The other contender was CDMA  proposed by Qualcomm\n Both of these systems are more similar than different in that they are based on broadband CDMA; WCDMA uses  -MHz channels and CDMA uses  \n  - MHz channels\n If the Ericsson and Qualcomm engineers were put in a room and told to come to a common design  they probably could find one fairly quickly\n The trouble is that the real problem is not engineering  but politics (as usual)\n Europe wanted a system that interworked with GSM  whereas the  \n wanted a THE PHYSICAL LAYER  \n  system that was compatible with one already widely deployed in the  \n (IS-  )\n Each side also supported its local company (Ericsson is based in Sweden; Qualcomm is in California)\n Finally  Ericsson and Qualcomm were involved in numerous lawsuits over their respective CDMA patents\n Worldwide   –  % of mobile subscribers already use  G technologies\n In North America and Europe  around a third of mobile subscribers are  G\n Japan was an early adopter and now nearly all mobile phones in Japan are  G\n These figures include the deployment of both UMTS and CDMA  and  G continues to be one great cauldron of activity as the market shakes out\n To add to the confusion  UMTS became a single  G standard with multiple incompatible options  including CDMA   \n This change was an effort to unify the various camps  but it just papers over the technical differences and obscures the focus of ongoing efforts\n We will use UMTS to mean WCDMA  as distinct from CDMA   \n We will focus our discussion on the use of CDMA in cellular networks  as it is the distinguishing feature of both systems\n CDMA is neither FDM nor TDM but a kind of mix in which each user sends on the same frequency band at the same time\n When it was first proposed for cellular systems  the industry gave it approximately the same reaction that Columbus first got from Queen Isabella when he proposed reaching India by sailing in the wrong direction\n However  through the persistence of a single company  Qualcomm  CDMA succeeded as a  G system (IS-  ) and matured to the point that it became the technical basis for  G\n To make CDMA work in the mobile phone setting requires more than the basic CDMA technique that we described in the previous tion\n Specifically  we described synchronous CDMA  in which the chip sequences are exactly orthogonal\n This design works when all users are synchronized on the start time of their chip sequences  as in the case of the base station transmitting to mobiles\n The base station can transmit the chip sequences starting at the same time so that the signals will be orthogonal and able to be separated\n However  it is difficult to synchronize the transmissions of independent mobile phones\n Without care  their transmissions would arrive at the base station at different times  with no guarantee of orthogonality\n To let mobiles send to the base station without synchronization  we want code sequences that are orthogonal to each other at all possible offsets  not simply when they are aligned at the start\n While it is not possible to find sequences that are exactly orthogonal for this general case  long pseudorandom sequences come close enough\n They have the property that  with high probability  they have a low cross-correlation with each other at all offsets\n This means that when one sequence is multiplied by another sequence and summed up to compute the inner product  the result will be small; it would be zero if they were orthogonal\n (Intuitively  random sequences should always look different from each other\n Multiplying them together should then produce a random signal  which will sum to a small result\n) This lets a receiver filter unwanted transmissions out of the received signal\n Also  the auto-correlation of   THE MOBILE TELEPHONE SYSTEM pseudorandom sequences is also small  with high probability  except at a zero offset\n This means that when one sequence is multiplied by a delayed copy of itself and summed  the result will be small  except when the delay is zero\n (Intuitively  a delayed random sequence looks like a different random sequence  and we are back to the cross-correlation case\n) This lets a receiver lock onto the beginning of the wanted transmission in the received signal\n The use of pseudorandom sequences lets the base station receive CDMA messages from unsynchronized mobiles\n However  an implicit assumption in our discussion of CDMA is that the power levels of all mobiles are the same at the receiver\n If they are not  a small cross-correlation with a powerful signal might overwhelm a large auto-correlation with a weak signal\n Thus  the transmit power on mobiles must be controlled to minimize interference between competing signals\n It is this interference that limits the capacity of CDMA systems\n The power levels received at a base station depend on how far away the transmitters are as well as how much power they transmit\n There may be many mobile stations at varying distances from the base station\n A good heuristic to equalize the received power is for each mobile station to transmit to the base station at the inverse of the power level it receives from the base station\n In other words  a mobile station receiving a weak signal from the base station will use more power than one getting a strong signal\n For more accuracy  the base station also gives each mobile feedback to increase  decrease  or hold steady its transmit power\n The feedback is frequent ( times per ond) because good power control is important to minimize interference\n Another improvement over the basic CDMA scheme we described earlier is to allow different users to send data at different rates\n This trick is accomplished naturally in CDMA by fixing the rate at which chips are transmitted and assigning users chip sequences of different lengths\n For example  in WCDMA  the chip rate is  \n  Mchips/ and the spreading codes vary from  to chips\n With a   - chip code  around   kbps is left after error correction  and this capacity is sufficient for a voice call\n With a  -chip code  the user data rate is close to  Mbps\n Intermediate-length codes give intermediate rates; to get to multiple Mbps  the mobile must use more than one  -MHz channel at once\n Now let us describe the advantages of CDMA  given that we have dealt with the problems of getting it to work\n It has three main advantages\n First  CDMA can improve capacity by taking advantage of small periods when some transmitters are silent\n In polite voice calls  one party is silent while the other talks\n On average  the line is busy only  % of the time\n However  the pauses may be small and are difficult to predict\n With TDM or FDM systems  it is not possible to reassign time slots or frequency channels quickly enough to benefit from these small silences\n However  in CDMA  by simply not transmitting one user lowers the interference for other users  and it is likely that some fraction of users will not be transmitting in a busy cell at any given time\n Thus CDMA takes advantage of expected silences to allow a larger number of simultaneous calls\n THE PHYSICAL LAYER  \n  ond  with CDMA each cell uses the same frequencies\n Unlike GSM and AMPS  FDM is not needed to separate the transmissions of different users\n This eliminates complicated frequency planning tasks and improves capacity\n It also makes it easy for a base station to use multiple directional antennas  or tored antennas  instead of an omnidirectional antenna\n Directional antennas concentrate a signal in the intended direction and reduce the signal  and hence interference  in other directions\n This in turn increases capacity\n Three tor designs are common\n The base station must track the mobile as it moves from tor to tor\n This tracking is easy with CDMA because all frequencies are used in all tors\n Third  CDMA facilitates soft handoff  in which the mobile is acquired by the new base station before the previous one signs off\n In this way there is no loss of continuity\n Soft handoff is shown in Fig\n  -  \n It is easy with CDMA because all frequencies are used in each cell\n The alternative is a hard handoff  in which the old base station drops the call before the new one acquires it\n If the new one is unable to acquire it ( \n  because there is no available frequency)  the call is disconnected abruptly\n Users tend to notice this  but it is inevitable occasionally with the current design\n Hard handoff is the norm with FDM designs to avoid the cost of having the mobile transmit or receive on two frequencies simultaneously\n (a) (b) (c) Figure  -  \n Soft handoff (a) before  (b) during  and (c) after\n Much has been written about  G  most of it praising it as the greatest thing since sliced bread\n Meanwhile  many operators have taken cautious steps in the direction of  G by going to what is sometimes called  \n G  although  \n G might be more accurate\n One such system is EDGE (Enhanced Data rates for GSM Evolution)  which is just GSM with more bits per symbol\n The trouble is  more bits per symbol also means more errors per symbol  so EDGE has nine different schemes for modulation and error correction  differing in terms of how much of the bandwidth is devoted to fixing the errors introduced by the higher speed\n EDGE is one step along an evolutionary path that is defined from GSM to WCDMA\n Similarly  there is an evolutionary path defined for operators to upgrade from IS-  to CDMA networks\n Even though  G networks are not fully deployed yet  some researchers regard  G as a done deal\n These people are already working on  G systems under the   THE MOBILE TELEPHONE SYSTEM name of LTE (Long Term Evolution)\n Some of the proposed features of  G include: high bandwidth; ubiquity (connectivity everywhere); seamless integration with other wired and wireless IP networks  including   \n  access points; adaptive resource and spectrum management; and high quality of service for multimedia\n For more information see Astely et al\n (   ) and Larmo et al\n (   )\n Meanwhile  wireless networks with  G levels of performance are already available\n The main example is   \n   also known as WiMAX\n For an overview of mobile WiMAX see Ahmadi (   )\n To say the industry is in a state of flux is a huge understatement\n Check back in a few years to see what has happened  CABLE TELEVISION We have now studied both the fixed and wireless telephone systems in a fair amount of detail\n Both will clearly play a major role in future networks\n But there is another major player that has emerged over the past decade for Internet access: cable television networks\n Many people nowadays get their telephone and Internet service over cable\n In the following tions we will look at cable television as a network in more detail and contrast it with the telephone systems we have just studied\n Some relevant references for more information are Donaldson and Jones (   )  Dutta-Roy (   )  and Fellows and Jones (   )\n    Community Antenna Television Cable television was conceived in the late s as a way to provide better reception to people living in rural or mountainous areas\n The system initially consisted of a big antenna on top of a hill to pluck the television signal out of the air  an amplifier  called the headend  to strengthen it  and a coaxial cable to deliver it to people’s houses  as illustrated in Fig\n  -  \n Tap Coaxial cable Drop cable Headend Antenna for picking up distant signals Figure  -  \n An early cable television system\n In the early years  cable television was called Community Antenna Television\n It was very much a mom-and-pop operation; anyone handy with electronics THE PHYSICAL LAYER  \n  could set up a service for his town  and the users would chip in to pay the costs\n As the number of subscribers grew  additional cables were spliced onto the original cable and amplifiers were added as needed\n Transmission was one way  from the headend to the users\n By  thousands of independent systems existed\n In  Time Inc\n started a new channel  Home Box Office  with new content (movies) distributed only on cable\n Other cable-only channels followed  focusing on news  sports  cooking  and many other topics\n This development gave rise to two changes in the industry\n First  large corporations began buying up existing cable systems and laying new cable to acquire new subscribers\n ond  there was now a need to connect multiple systems  often in distant cities  in order to distribute the new cable channels\n The cable companies began to lay cable between the cities to connect them all into a single system\n This pattern was analogous to what happened in the telephone industry   years earlier with the connection of previously isolated end offices to make long-distance calling possible\n    Internet over Cable Over the course of the years the cable system grew and the cables between the various cities were replaced by high-bandwidth fiber  similar to what happened in the telephone system\n A system with fiber for the long-haul runs and coaxial cable to the houses is called an HFC (Hybrid Fiber Coax) system\n The electrooptical converters that interface between the optical and electrical parts of the system are called fiber nodes\n Because the bandwidth of fiber is so much greater than that of coax  a fiber node can feed multiple coaxial cables\n Part of a modern HFC system is shown in Fig\n  -  (a)\n Over the past decade  many cable operators decided to get into the Internet access business  and often the telephony business as well\n Technical differences between the cable plant and telephone plant had an effect on what had to be done to achieve these goals\n For one thing  all the one-way amplifiers in the system had to be replaced by two-way amplifiers to support upstream as well as downstream transmissions\n While this was happening  early Internet over cable systems used the cable television network for downstream transmissions and a dialup connection via the telephone network for upstream transmissions\n It was a clever workaround  but not much of a network compared to what it could be\n However  there is another difference between the HFC system of Fig\n  -  (a) and the telephone system of Fig\n  -  (b) that is much harder to remove\n Down in the neighborhoods  a single cable is shared by many houses  whereas in the telephone system  every house has its own private local loop\n When used for television broadcasting  this sharing is a natural fit\n All the programs are broadcast on the cable and it does not matter whether there are   viewers or   viewers\n When the same cable is used for Internet access  however  it matters a lot if there are   users or  \n If one user decides to download a very large file  that bandwidth is potentially being taken away from other users\n The more users there   CABLE TELEVISION Copper twisted pair Switch Toll office Headend High-bandwidth fiber trunk End office Local loop (a) (b) House High-bandwidth fiber trunk Coaxial cable House Tap Fiber node Fiber Fiber Figure  -  \n (a) Cable television\n (b) The fixed telephone system\n are  the more competition there is for bandwidth\n The telephone system does not have this particular property: downloading a large file over an ADSL line does not reduce your neighbor’s bandwidth\n On the other hand  the bandwidth of coax is much higher than that of twisted pairs  so you can get lucky if your neighbors do not use the Internet much\n The way the cable industry has tackled this problem is to split up long cables and connect each one directly to a fiber node\n The bandwidth from the headend to each fiber node is effectively infinite  so as long as there are not too many subscribers on each cable segment  the amount of traffic is manageable\n Typical THE PHYSICAL LAYER  \n  cables nowadays have   – houses  but as more and more people subscribe to Internet over cable  the load may become too great  requiring more splitting and more fiber nodes\n    Spectrum Allocation Throwing off all the TV channels and using the cable infrastructure strictly for Internet access would probably generate a fair number of irate customers  so cable companies are hesitant to do this\n Furthermore  most cities heavily regulate what is on the cable  so the cable operators would not be allowed to do this even if they really wanted to\n As a consequence  they needed to find a way to have television and Internet peacefully coexist on the same cable\n The solution is to build on frequency division multiplexing\n Cable television channels in North America occupy the  –   MHz region (except for FM radio  from   to MHz)\n These channels are  -MHz wide  including guard bands  and can carry one traditional analog television channel or several digital television channels\n In Europe the low end is usually   MHz and the channels are  –  MHz wide for the higher resolution required by PAL and AM  but otherwise the allocation scheme is similar\n The low part of the band is not used\n Modern cables can also operate well above MHz  often at up to MHz or more\n The solution chosen was to introduce upstream channels in the  –  MHz band (slightly higher in Europe) and use the frequencies at the high end for the downstream signals\n The cable spectrum is illustrated in Fig\n  -  \n  TV TV Downstream data Downstream frequencies Upstream data Upstream frequencies FM    MHz  Figure  -  \n Frequency allocation in a typical cable TV system used for Internet access\n Note that since the television signals are all downstream  it is possible to use upstream amplifiers that work only in the  –  MHz region and downstream amplifiers that work only at   MHz and up  as shown in the figure\n Thus  we get an asymmetry in the upstream and downstream bandwidths because more spectrum is available above television than below it\n On the other hand  most users want more downstream traffic  so cable operators are not unhappy with this fact   CABLE TELEVISION of life\n As we saw earlier  telephone companies usually offer an asymmetric DSL service  even though they have no technical reason for doing so\n In addition to upgrading the amplifiers  the operator has to upgrade the headend  too  from a dumb amplifier to an intelligent digital computer system with a high-bandwidth fiber interface to an ISP\n Often the name gets upgraded as well  from ‘‘headend’’ to CMTS (Cable Modem Termination System)\n In the following text  we will refrain from doing a name upgrade and stick with the traditional ‘‘headend\n’’    Cable Modems Internet access requires a cable modem  a device that has two interfaces on it: one to the computer and one to the cable network\n In the early years of cable Internet  each operator had a proprietary cable modem  which was installed by a cable company technician\n However  it soon became apparent that an open standard would create a competitive cable modem market and drive down prices  thus encouraging use of the service\n Furthermore  having the customers buy cable modems in stores and install them themselves (as they do with wireless access points) would eliminate the dreaded truck rolls\n Consequently  the larger cable operators teamed up with a company called CableLabs to produce a cable modem standard and to test products for compliance\n This standard  called DOCSIS (Data Over Cable Service Interface Specification)  has mostly replaced proprietary modems\n DOCSIS version  \n  came out in  and was soon followed by DOCSIS  \n  in \n It increased upstream rates to better support symmetric services such as IP telephony\n The most recent version of the standard is DOCSIS  \n  which came out in \n It uses more bandwidth to increase rates in both directions\n The European version of these standards is called EuroDOCSIS\n Not all cable operators like the idea of a standard  however  since many of them were making good money leasing their modems to their captive customers\n An open standard with dozens of manufacturers selling cable modems in stores ends this lucrative practice\n The modem-to-computer interface is straightforward\n It is normally Ethernet  or occasionally USB\n The other end is more complicated as it uses all of FDM  TDM  and CDMA to share the bandwidth of the cable between subscribers\n When a cable modem is plugged in and powered up  it scans the downstream channels looking for a special packet periodically put out by the headend to provide system parameters to modems that have just come online\n Upon finding this packet  the new modem announces its presence on one of the upstream channels\n The headend responds by assigning the modem to its upstream and downstream channels\n These assignments can be changed later if the headend deems it necessary to balance the load\n The use of  -MHz or  -MHz channels is the FDM part\n Each cable modem sends data on one upstream and one downstream channel  or multiple channels THE PHYSICAL LAYER  \n  under DOCSIS   The usual scheme is to take each  (or  ) MHz downstream channel and modulate it with QAM-  or  if the cable quality is exceptionally good  QAM-  \n With a  -MHz channel and QAM-   we get about   Mbps\n When the overhead is subtracted  the net payload is about   Mbps\n With QAM-  the net payload is about   Mbps\n The European values are  /  larger\n For upstream  there is more RF noise because the system was not originally designed for data  and noise from multiple subscribers is funneled to the headend  so a more conservative scheme is used\n This ranges from QPSK to QAM- where some of the symbols are used for error protection with Trellis Coded Modulation\n With fewer bits per symbol on the upstream  the asymmetry between upstream and downstream rates is much more than suggested by Fig\n  -  \n TDM is then used to share bandwidth on the upstream across multiple subscribers\n Otherwise their transmissions would collide at the headend\n Time is divided into minislots and different subscribers send in different minislots\n To make this work  the modem determines its distance from the headend by sending it a special packet and seeing how long it takes to get the response\n This process is called ranging\n It is important for the modem to know its distance to get the timing right\n Each upstream packet must fit in one or more conutive minislots at the headend when it is received\n The headend announces the start of a new round of minislots periodically  but the starting gun is not heard at all modems simultaneously due to the propagation time down the cable\n By knowing how far it is from the headend  each modem can compute how long ago the first minislot really started\n Minislot length is network dependent\n A typical payload is  bytes\n During initialization  the headend assigns each modem to a minislot to use for requesting upstream bandwidth\n When a computer wants to send a packet  it transfers the packet to the modem  which then requests the necessary number of minislots for it\n If the request is accepted  the headend puts an acknowledgement on the downstream channel telling the modem which minislots have been reserved for its packet\n The packet is then sent  starting in the minislot allocated to it\n Additional packets can be requested using a field in the header\n As a rule  multiple modems will be assigned the same minislot  which leads to contention\n Two different possibilities exist for dealing with it\n The first is that CDMA is used to share the minislot between subscribers\n This solves the contention problem because all subscribers with a CDMA code sequence can send at the same time  albeit at a reduced rate\n The ond option is that CDMA is not used  in which case there may be no acknowledgement to the request because of a collision\n In this case  the modem just waits a random time and tries again\n After each successive failure  the randomization time is doubled\n (For readers already somewhat familiar with networking  this algorithm is just slotted ALOHA with binary exponential backoff\n Ethernet cannot be used on cable because stations cannot sense the medium\n We will come back to these issues in  ) The downstream channels are managed differently from the upstream channels\n For starters  there is only one sender (the headend)  so there is no contention   CABLE TELEVISION and no need for minislots  which is actually just statistical time division multiplexing\n For another  the amount of traffic downstream is usually much larger than upstream  so a fixed packet size of bytes is used\n Part of that is a Reed- Solomon error-correcting code and some other overhead  leaving a user payload of bytes\n These numbers were chosen for compatibility with digital television using MPEG-  so the TV and downstream data channels are formatted the same way\n Logically  the connections are as depicted in Fig\n  -  \n Figure  -  \n Typical details of the upstream and downstream channels in North America\n    ADSL Versus Cable Which is better  ADSL or cable? That is like asking which operating system is better\n Or which language is better\n Or which religion\n Which answer you get depends on whom you ask\n Let us compare ADSL and cable on a few points\n Both use fiber in the backbone  but they differ on the edge\n Cable uses coax; ADSL uses twisted pair\n The theoretical carrying capacity of coax is hundreds of times more than twisted pair\n However  the full capacity of the cable is not available for data users because much of the cable’s bandwidth is wasted on useless stuff such as television programs\n In practice  it is hard to generalize about effective capacity\n ADSL providers give specific statements about the bandwidth ( \n   Mbps downstream  kbps upstream) and generally achieve about  % of it consistently\n Cable providers may artificially cap the bandwidth to each user to help them make performance predictions  but they cannot really give guarantees because the effective capacity depends on how many people are currently active on the user’s cable segment\n Sometimes it may be better than ADSL and sometimes it may be worse\n What can be annoying  though  is the unpredictability\n Having great service one minute does not guarantee great service the next minute since the biggest bandwidth hog in town may have just turned on his computer\n THE PHYSICAL LAYER  \n  As an ADSL system acquires more users  their increasing numbers have little effect on existing users  since each user has a dedicated connection\n With cable  as more subscribers sign up for Internet service  performance for existing users will drop\n The only cure is for the cable operator to split busy cables and connect each one to a fiber node directly\n Doing so costs time and money  so there are business pressures to avoid it\n As an aside  we have already studied another system with a shared channel like cable: the mobile telephone system\n Here  too  a group of users—we could call them cellmates—share a fixed amount of bandwidth\n For voice traffic  which is fairly smooth  the bandwidth is rigidly divided in fixed chunks among the active users using FDM and TDM\n But for data traffic  this rigid division is very inefficient because data users are frequently idle  in which case their reserved bandwidth is wasted\n As with cable  a more dynamic means is used to allocate the shared bandwidth\n Availability is an issue on which ADSL and cable differ\n Everyone has a telephone  but not all users are close enough to their end offices to get ADSL\n On the other hand  not everyone has cable  but if you do have cable and the company provides Internet access  you can get it\n Distance to the fiber node or headend is not an issue\n It is also worth noting that since cable started out as a television distribution medium  few businesses have it\n Being a point-to-point medium  ADSL is inherently more ure than cable\n Any cable user can easily read all the packets going down the cable\n For this reason  any decent cable provider will encrypt all traffic in both directions\n Nevertheless  having your neighbor get your encrypted messages is still less ure than having him not get anything at all\n The telephone system is generally more reliable than cable\n For example  it has backup power and continues to work normally even during a power outage\n With cable  if the power to any amplifier along the chain fails  all downstream users are cut off instantly\n Finally  most ADSL providers offer a choice of ISPs\n Sometimes they are even required to do so by law\n Such is not always the case with cable operators\n The conclusion is that ADSL and cable are much more alike than they are different\n They offer comparable service and  as competition between them heats up  probably comparable prices  SUMMARY The physical layer is the basis of all networks\n Nature imposes two fundamental limits on all channels  and these determine their bandwidth\n These limits are the Nyquist limit  which deals with noiseless channels  and the Shannon limit  which deals with noisy channels\n   SUMMARY Transmission media can be guided or unguided\n The principal guided media are twisted pair  coaxial cable  and fiber optics\n Unguided media include terrestrial radio  microwaves  infrared  lasers through the air  and satellites\n Digital modulation methods send bits over guided and unguided media as analog signals\n Line codes operate at baseband  and signals can be placed in a passband by modulating the amplitude  frequency  and phase of a carrier\n Channels can be shared between users with time  frequency and code division multiplexing\n A key element in most wide area networks is the telephone system\n Its main components are the local loops  trunks  and switches\n ADSL offers speeds up to   Mbps over the local loop by dividing it into many subcarriers that run in parallel\n This far exceeds the rates of telephone modems\n PONs bring fiber to the home for even greater access rates than ADSL\n Trunks carry digital information\n They are multiplexed with WDM to provision many high capacity links over individual fibers  as well as with TDM to share each high rate link between users\n Both circuit switching and packet switching are important\n For mobile applications  the fixed telephone system is not suitable\n Mobile phones are currently in widespread use for voice  and increasingly for data\n They have gone through three generations\n The first generation  G  was analog and dominated by AMPS\n  G was digital  with GSM presently the most widely deployed mobile phone system in the world\n  G is digital and based on broadband CDMA  with WCDMA and also CDMA now being deployed\n An alternative system for network access is the cable television system\n It has gradually evolved from coaxial cable to hybrid fiber coax  and from television to television and Internet\n Potentially  it offers very high bandwidth  but the bandwidth in practice depends heavily on the other users because it is shared\n PROBLEMS  \n Compute the Fourier coefficients for the function f(t) = t (  ≤ t ≤  ) A noiseless  -kHz channel is sampled every  m\n What is the maximum data rate? How does the maximum data rate change if the channel is noisy  with a signal-to-noise ratio of   dB?  \n Television channels are  MHz wide\n How many bits/ can be sent if four-level digital signals are used? Assume a noiseless channel If a binary signal is sent over a  -kHz channel whose signal-to-noise ratio is   dB  what is the maximum achievable data rate?  \n What signal-to-noise ratio is needed to put a T  carrier on a  -kHz line?  \n What are the advantages of fiber optics over copper as a transmission medium? Is there any downside of using fiber optics over copper? THE PHYSICAL LAYER  \n   \n How much bandwidth is there in  \n  microns of spectrum at a wavelength of  micron?  \n It is desired to send a sequence of computer screen images over an optical fiber\n The screen is  ×  pixels  each pixel being   bits\n There are   screen images per ond\n How much bandwidth is needed  and how many microns of wavelength are needed for this band at  \n  microns?  \n Is the Nyquist theorem true for high-quality single-mode optical fiber or only for copper wire?  \n Radio antennas often work best when the diameter of the antenna is equal to the wavelength of the radio wave\n Reasonable antennas range from  cm to  meters in diameter\n What frequency range does this cover?  \n A laser beam  mm wide is aimed at a detector  mm wide m away on the roof of a building\n How much of an angular diversion (in degrees) does the laser have to have before it misses the detector?  \n The   low-orbit satellites in the Iridium project are divided into six necklaces around the earth\n At the altitude they are using  the period is   minutes\n What is the average interval for handoffs for a stationary transmitter?  \n Calculate the end-to-end transit time for a packet for both GEO (altitude:   km)  MEO (altitude:   km) and LEO (altitude: km) satellites What is the latency of a call originating at the North Pole to reach the South Pole if the call is routed via Iridium satellites? Assume that the switching time at the satellites is   microonds and earth’s radius is  km What is the minimum bandwidth needed to achieve a data rate of B bits/ if the signal is transmitted using NRZ  MLT-  and Manchester encoding? Explain your answer Prove that in  B/ B encoding  a signal transition will occur at least every four bit times How many end office codes were there pre-  when each end office was named by its three-digit area code and the first three digits of the local number? Area codes started with a digit in the range  –  had a  or  as the ond digit  and ended with any digit\n The first two digits of a local number were always in the range  – \n The third digit could be any digit A simple telephone system consists of two end offices and a single toll office to which each end office is connected by a  -MHz full-duplex trunk\n The average telephone is used to make four calls per  -hour workday\n The mean call duration is  min\n Ten percent of the calls are long distance ( \n  pass through the toll office)\n What is the maximum number of telephones an end office can support? (Assume  kHz per circuit\n) Explain why a telephone company may decide to support a lesser number of telephones than this maximum number at the end office A regional telephone company has   million subscribers\n Each of their telephones is connected to a central office by a copper twisted pair\n The average length of these twisted pairs is   km\n How much is the copper in the local loops worth? Assume  \n  PROBLEMS that the cross tion of each strand is a circle  mm in diameter  the density of copper is  \n  grams/cm  and that copper sells for $  per kilogram Is an oil pipeline a simplex system  a half-duplex system  a full-duplex system  or none of the above? What about a river or a walkie-talkie-style communication?  \n The cost of a fast microprocessor has dropped to the point where it is now possible to put one in each modem\n How does that affect the handling of telephone line errors? Does it negate the need for error checking/correction in layer  ?  \n A modem constellation diagram similar to Fig\n  -  has data points at the following coordinates: (   )  (  − )  (−   )  and (−  − )\n How many bps can a modem with these parameters achieve at  symbols/ond?  \n What is the maximum bit rate achievable in a V\n  standard modem if the baud rate is  and no error correction is used?  \n How many frequencies does a full-duplex QAM-  modem use?  \n Ten signals  each requiring  Hz  are multiplexed onto a single channel using FDM\n What is the minimum bandwidth required for the multiplexed channel? Assume that the guard bands are Hz wide Why has the PCM sampling time been set at μ?  \n What is the percent overhead on a T  carrier? That is  what percent of the  \n   Mbps are not delivered to the end user? How does it relate to the percent overhead in OC-  or OC-   lines?  \n Compare the maximum data rate of a noiseless  -kHz channel using (a) Analog encoding ( \n  QPSK) with  bits per sample\n (b) The T  PCM system If a T  carrier system slips and loses track of where it is  it tries to resynchronize using the first bit in each frame\n How many frames will have to be inspected on average to resynchronize with a probability of  \n   of being wrong?  \n What is the difference  if any  between the demodulator part of a modem and the coder part of a codec? (After all  both convert analog signals to digital ones\n)  \n SONET clocks have a drift rate of about  part in   \n How long does it take for the drift to equal the width of  bit? Do you see any practical implications of this calculation? If so  what?  \n How long will it take to transmit a  -GB file from one VSAT to another using a hub as shown in Figure  -  ? Assume that the uplink is  Mbps  the downlink is  Mbps  and circuit switching is used with  \n   circuit setup time Calculate the transmit time in the previous problem if packet switching is used instead\n Assume that the packet size is   KB  the switching delay in the satellite and hub is   microonds  and the packet header size is   bytes In Fig\n  -   the user data rate for OC-  is stated to be   \n   Mbps\n Show how this number can be derived from the SONET OC-  parameters\n What will be the gross  SPE  and user data rates of an OC- line? THE PHYSICAL LAYER   To accommodate lower data rates than STS-  SONET has a system of virtual tributaries (VTs)\n A VT is a partial payload that can be inserted into an STS-  frame and combined with other partial payloads to fill the data frame\n VT \n  uses  columns  VT  uses  columns  VT  uses  columns  and VT  uses   columns of an STS-  frame\n Which VT can accommodate (a) A DS-  service ( \n   Mbps)? (b) European CEPT-  service ( \n   Mbps)? (c) A DS-  service ( \n   Mbps)?  \n What is the available user bandwidth in an OC-  c connection?  \n Three packet-switching networks each contain n nodes\n The first network has a star topology with a central switch  the ond is a (bidirectional) ring  and the third is fully interconnected  with a wire from every node to every other node\n What are the best-  average-  and worst-case transmission paths in hops?  \n Compare the delay in sending an x-bit message over a k-hop path in a circuit-switched network and in a (lightly loaded) packet-switched network\n The circuit setup time is s   the propagation delay is d  per hop  the packet size is p bits  and the data rate is b bps\n Under what conditions does the packet network have a lower delay? Also  explain the conditions under which a packet-switched network is preferable to a circuitswitched network Suppose that x bits of user data are to be transmitted over a k-hop path in a packetswitched network as a series of packets  each containing p data bits and h header bits  with x >> p + h\n The bit rate of the lines is b bps and the propagation delay is negligible\n What value of p minimizes the total delay?  \n In a typical mobile phone system with hexagonal cells  it is forbidden to reuse a frequency band in an adjacent cell\n If frequencies are available  how many can be used in a given cell?  \n The actual layout of cells is seldom as regular that as shown in Fig\n  -  \n Even the shapes of individual cells are typically irregular\n Give a possible reason why this might be\n How do these irregular shapes affect frequency assignment to each cell?  \n Make a rough estimate of the number of PCS microcells m in diameter it would take to cover San Francisco (   square km) Sometimes when a mobile user crosses the boundary from one cell to another  the current call is abruptly terminated  even though all transmitters and receivers are functioning perfectly\n Why?  \n Suppose that A  B  and C are simultaneously transmitting  bits  using a CDMA system with the chip sequences of Fig\n  -  (a)\n What is the resulting chip sequence?  \n Consider a different way of looking at the orthogonality property of CDMA chip sequences\n Each bit in a pair of sequences can match or not match\n Express the orthogonality property in terms of matches and mismatches A CDMA receiver gets the following chips: (−  +  −  +  −  −  +  + )\n Assuming the chip sequences defined in Fig\n  -  (a)  which stations transmitted  and which bits did each one send?  \n  PROBLEMS  \n In Figure  -   there are four stations that can transmit\n Suppose four more stations are added\n Provide the chip sequences of these stations At the low end  the telephone system is star shaped  with all the local loops in a neighborhood converging on an end office\n In contrast  cable television consists of a single long cable snaking its way past all the houses in the same neighborhood\n Suppose that a future TV cable were  -Gbps fiber instead of copper\n Could it be used to simulate the telephone model of everybody having their own private line to the end office? If so  how many one-telephone houses could be hooked up to a single fiber?  \n A cable company decides to provide Internet access over cable in a neighborhood consisting of  houses\n The company uses a coaxial cable and spectrum allocation allowing Mbps downstream bandwidth per cable\n To attract customers  the company decides to guarantee at least  Mbps downstream bandwidth to each house at any time\n Describe what the cable company needs to do to provide this guarantee Using the spectral allocation shown in Fig\n  -  and the information given in the text  how many Mbps does a cable system allocate to upstream and how many to downstream?  \n How fast can a cable user receive data if the network is otherwise idle? Assume that the user interface is (a)  -Mbps Ethernet (b)   -Mbps Ethernet (c)  -Mbps Wireless Multiplexing STS-  multiple data streams  called tributaries  plays an important role in SONET\n A  :  multiplexer multiplexes three input STS-  tributaries onto one output STS-  stream\n This multiplexing is done byte for byte\n That is  the first three output bytes are the first bytes of tributaries  and   respectively\n the next three output bytes are the ond bytes of tributaries  and   respectively  and so on\n Write a program that simulates this  :  multiplexer\n Your program should consist of five processes\n The main process creates four processes  one each for the three STS-  tributaries and one for the multiplexer\n Each tributary process reads in an STS-  frame from an input file as a sequence of bytes\n They send their frames (byte by byte) to the multiplexer process\n The multiplexer process receives these bytes and outputs an STS-  frame (byte by byte) by writing it to standard output\n Use pipes for communication among processes Write a program to implement CDMA\n Assume that the length of a chip sequence is eight and the number of stations transmitting is four\n Your program consists of three sets of processes: four transmitter processes (t  t  t  and t )  one joiner process  and four receiver processes (r  r  r  and r )\n The main program  which also acts as the joiner process first reads four chip sequences (bipolar notation) from the standard input and a sequence of  bits (  bit per transmitter process to be transmitted)  and forks off four pairs of transmitter and receiver processes\n Each pair of transmitter/receiver processes (t  r ; t  r ; t  r ; t  r ) is assigned one chip sequence and each transmitter process is assigned  bit (first bit to t  ond bit to t  and so on)\n Next  each transmitter process computes the signal to be transmitted (a sequence of  bits) and sends it to the joiner process\n After receiving signals from all four transmitter processes  the joiner process combines the signals and sends the combined signal to THE PHYSICAL LAYER  \n  the four receiver processes\n Each receiver process then computes the bit it has received and prints it to standard output\n Use pipes for communication between processes\n  THE DATA LINK LAYER In this  ter we will study the design principles for the ond layer in our model  the data link layer\n This study deals with algorithms for achieving reliable  efficient communication of whole units of information called frames (rather than individual bits  as in the physical layer) between two adjacent machines\n By adjacent  we mean that the two machines are connected by a communication channel that acts conceptually like a wire ( \n  a coaxial cable  telephone line  or wireless channel)\n The essential property of a channel that makes it ‘‘wire-like’’ is that the bits are delivered in exactly the same order in which they are sent\n At first you might think this problem is so trivial that there is nothing to study—machine A just puts the bits on the wire  and machine B just takes them off\n Unfortunately  communication channels make errors occasionally\n Furthermore  they have only a finite data rate  and there is a nonzero propagation delay between the time a bit is sent and the time it is received\n These limitations have important implications for the efficiency of the data transfer\n The protocols used for communications must take all these factors into consideration\n These protocols are the subject of this  ter\n After an introduction to the key design issues present in the data link layer  we will start our study of its protocols by looking at the nature of errors and how they can be detected and corrected\n Then we will study a series of increasingly complex protocols  each one solving more and more of the problems present in this layer\n Finally  we will conclude with some examples of data link protocols\n    THE DATA LINK LAYER  \n   \n  DATA LINK LAYER DESIGN ISSUES The data link layer uses the services of the physical layer to send and receive bits over communication channels\n It has a number of functions  including:  \n Providing a well-defined service interface to the network layer Dealing with transmission errors Regulating the flow of data so that slow receivers are not swamped by fast senders\n To accomplish these goals  the data link layer takes the packets it gets from the network layer and encapsulates them into frames for transmission\n Each frame contains a frame header  a payload field for holding the packet  and a frame trailer  as illustrated in Fig\n  - \n Frame management forms the heart of what the data link layer does\n In the following tions we will examine all the abovementioned issues in detail\n Header Payload field Trailer Frame Sending machine Packet Packet Receiving machine Header Payload field Trailer Figure  - \n Relationship between packets and frames\n Although this  ter is explicitly about the data link layer and its protocols  many of the principles we will study here  such as error control and flow control  are found in transport and other protocols as well\n That is because reliability is an overall goal  and it is achieved when all the layers work together\n In fact  in many networks  these functions are found mostly in the upper layers  with the data link layer doing the minimal job that is ‘‘good enough\n’’ However  no matter where they are found  the principles are pretty much the same\n They often show up in their simplest and purest forms in the data link layer  making this a good place to examine them in detail\n    Services Provided to the Network Layer The function of the data link layer is to provide services to the network layer\n The principal service is transferring data from the network layer on the source machine to the network layer on the destination machine\n On the source machine is   DATA LINK LAYER DESIGN ISSUES an entity  call it a process  in the network layer that hands some bits to the data link layer for transmission to the destination\n The job of the data link layer is to transmit the bits to the destination machine so they can be handed over to the network layer there  as shown in Fig\n  - (a)\n The actual transmission follows the path of Fig\n  - (b)  but it is easier to think in terms of two data link layer processes communicating using a data link protocol\n For this reason  we will implicitly use the model of Fig\n  - (a) throughout this  ter\n      Host  Host  Host  Host  Virtual data path Actual data path (a) (b) Figure  - \n (a) Virtual communication\n (b) Actual communication\n The data link layer can be designed to offer various services\n The actual services that are offered vary from protocol to protocol\n Three reasonable possibilities that we will consider in turn are:  \n Unacknowledged connectionless service Acknowledged connectionless service Acknowledged connection-oriented service\n Unacknowledged connectionless service consists of having the source machine send independent frames to the destination machine without having the destination machine acknowledge them\n Ethernet is a good example of a data link layer that provides this class of service\n No logical connection is established beforehand or released afterward\n If a frame is lost due to noise on the line  no THE DATA LINK LAYER  \n  attempt is made to detect the loss or recover from it in the data link layer\n This class of service is appropriate when the error rate is very low  so recovery is left to higher layers\n It is also appropriate for real-time traffic  such as voice  in which late data are worse than bad data\n The next step up in terms of reliability is acknowledged connectionless service\n When this service is offered  there are still no logical connections used  but each frame sent is individually acknowledged\n In this way  the sender knows whether a frame has arrived correctly or been lost\n If it has not arrived within a specified time interval  it can be sent again\n This service is useful over unreliable channels  such as wireless systems\n   \n  (WiFi) is a good example of this class of service\n It is perhaps worth emphasizing that providing acknowledgements in the data link layer is just an optimization  never a requirement\n The network layer can always send a packet and wait for it to be acknowledged by its peer on the remote machine\n If the acknowledgement is not forthcoming before the timer expires  the sender can just send the entire message again\n The trouble with this strategy is that it can be inefficient\n Links usually have a strict maximum frame length imposed by the hardware  and known propagation delays\n The network layer does not know these parameters\n It might send a large packet that is broken up into  say frames  of which  are lost on average\n It would then take a very long time for the packet to get through\n Instead  if individual frames are acknowledged and retransmitted  then errors can be corrected more directly and more quickly\n On reliable channels  such as fiber  the overhead of a heavyweight data link protocol may be unnecessary  but on (inherently unreliable) wireless channels it is well worth the cost\n Getting back to our services  the most sophisticated service the data link layer can provide to the network layer is connection-oriented service\n With this service  the source and destination machines establish a connection before any data are transferred\n Each frame sent over the connection is numbered  and the data link layer guarantees that each frame sent is indeed received\n Furthermore  it guarantees that each frame is received exactly once and that all frames are received in the right order\n Connection-oriented service thus provides the network layer processes with the equivalent of a reliable bit stream\n It is appropriate over long  unreliable links such as a satellite channel or a long-distance telephone circuit\n If acknowledged connectionless service were used  it is conceivable that lost acknowledgements could cause a frame to be sent and received several times  wasting bandwidth\n When connection-oriented service is used  transfers go through three distinct phases\n In the first phase  the connection is established by having both sides initialize variables and counters needed to keep track of which frames have been received and which ones have not\n In the ond phase  one or more frames are actually transmitted\n In the third and final phase  the connection is released  freeing up the variables  buffers  and other resources used to maintain the connection\n   DATA LINK LAYER DESIGN ISSUES    Framing To provide service to the network layer  the data link layer must use the service provided to it by the physical layer\n What the physical layer does is accept a raw bit stream and attempt to deliver it to the destination\n If the channel is noisy  as it is for most wireless and some wired links  the physical layer will add some redundancy to its signals to reduce the bit error rate to a tolerable level\n However  the bit stream received by the data link layer is not guaranteed to be error free\n Some bits may have different values and the number of bits received may be less than  equal to  or more than the number of bits transmitted\n It is up to the data link layer to detect and  if necessary  correct errors\n The usual approach is for the data link layer to break up the bit stream into discrete frames  compute a short token called a checksum for each frame  and include the checksum in the frame when it is transmitted\n (Checksum algorithms will be discussed later in this  ter\n) When a frame arrives at the destination  the checksum is recomputed\n If the newly computed checksum is different from the one contained in the frame  the data link layer knows that an error has occurred and takes steps to deal with it ( \n  discarding the bad frame and possibly also sending back an error report)\n Breaking up the bit stream into frames is more difficult than it at first appears\n A good design must make it easy for a receiver to find the start of new frames while using little of the channel bandwidth\n We will look at four methods:  \n Byte count Flag bytes with byte stuffing Flag bits with bit stuffing Physical layer coding violations\n The first framing method uses a field in the header to specify the number of bytes in the frame\n When the data link layer at the destination sees the byte count  it knows how many bytes follow and hence where the end of the frame is\n This technique is shown in Fig\n  - (a) for four small example frames of sizes  and  bytes  respectively\n The trouble with this algorithm is that the count can be garbled by a transmission error\n For example  if the byte count of  in the ond frame of Fig\n  - (b) becomes a  due to a single bit flip  the destination will get out of synchronization\n It will then be unable to locate the correct start of the next frame\n Even if the checksum is incorrect so the destination knows that the frame is bad  it still has no way of telling where the next frame starts\n Sending a frame back to the source asking for a retransmission does not help either  since the destination does not know how many bytes to skip over to get to the start of the retransmission\n For this reason  the byte count method is rarely used by itself\n THE DATA LINK LAYER  \n  (b) (a)              Byte count One byte Error Frame bytes Frame  Frame bytes Frame  (Wrong) Frame bytes Frame bytes Now a byte count Figure  - \n A byte stream\n (a) Without errors\n (b) With one error\n The ond framing method gets around the problem of resynchronization after an error by having each frame start and end with special bytes\n Often the same byte  called a flag byte  is used as both the starting and ending delimiter\n This byte is shown in Fig\n  - (a) as FLAG\n Two conutive flag bytes indicate the end of one frame and the start of the next\n Thus  if the receiver ever loses synchronization it can just search for two flag bytes to find the end of the current frame and the start of the next frame\n However  there is a still a problem we have to solve\n It may happen that the flag byte occurs in the data  especially when binary data such as photographs or songs are being transmitted\n This situation would interfere with the framing\n One way to solve this problem is to have the sender’s data link layer insert a special escape byte (ESC) just before each ‘‘accidental’’ flag byte in the data\n Thus  a framing flag byte can be distinguished from one in the data by the absence or presence of an escape byte before it\n The data link layer on the receiving end removes the escape bytes before giving the data to the network layer\n This technique is called byte stuffing\n Of course  the next question is: what happens if an escape byte occurs in the middle of the data? The answer is that it  too  is stuffed with an escape byte\n At the receiver  the first escape byte is removed  leaving the data byte that follows it (which might be another escape byte or the flag byte)\n Some examples are shown in Fig\n  - (b)\n In all cases  the byte sequence delivered after destuffing is exactly the same as the original byte sequence\n We can still search for a frame boundary by looking for two flag bytes in a row  without bothering to undo escapes\n The byte-stuffing scheme depicted in Fig\n  -  is a slight simplification of the one used in PPP (Point-to-Point Protocol)  which is used to carry packets over communications links\n We will discuss PPP near the end of this  ter\n   DATA LINK LAYER DESIGN ISSUES A ESC FLAG B A ESC ESC B A ESC ESC ESC FLAG B A ESC ESC ESC ESC B A FLAG B A ESC B A ESC FLAG B A ESC ESC B FLAG Header Payload field Trailer FLAG Original bytes After stuffing (a) (b) Figure  - \n (a) A frame delimited by flag bytes\n (b) Four examples of byte sequences before and after byte stuffing\n The third method of delimiting the bit stream gets around a disadvantage of byte stuffing  which is that it is tied to the use of  -bit bytes\n Framing can be also be done at the bit level  so frames can contain an arbitrary number of bits made up of units of any size\n It was developed for the once very popular HDLC (Highlevel Data Link Control) protocol\n Each frame begins and ends with a special bit pattern  or  x E in hexadecimal\n This pattern is a flag byte\n Whenever the sender’s data link layer encounters five conutive  s in the data  it automatically stuffs a  bit into the outgoing bit stream\n This bit stuffing is analogous to byte stuffing  in which an escape byte is stuffed into the outgoing character stream before a flag byte in the data\n It also ensures a minimum density of transitions that help the physical layer maintain synchronization\n USB (Universal Serial Bus) uses bit stuffing for this reason\n When the receiver sees five conutive incoming  bits  followed by a  bit  it automatically destuffs ( \n  deletes) the  bit\n Just as byte stuffing is completely transparent to the network layer in both computers  so is bit stuffing\n If the user data contain the flag pattern   this flag is transmitted as  but stored in the receiver’s memory as    \n Figure  -  gives an example of bit stuffing\n With bit stuffing  the boundary between two frames can be unambiguously recognized by the flag pattern\n Thus  if the receiver loses track of where it is  all it has to do is scan the input for flag sequences  since they can only occur at frame boundaries and never within the data\n THE DATA LINK LAYER  \n              Stuffed bits (a) (b) (c)         Figure  - \n Bit stuffing\n (a) The original data\n (b) The data as they appear on the line\n (c) The data as they are stored in the receiver’s memory after destuffing\n With both bit and byte stuffing  a side effect is that the length of a frame now depends on the contents of the data it carries\n For instance  if there are no flag bytes in the data  bytes might be carried in a frame of roughly bytes\n If  however  the data consists solely of flag bytes  each flag byte will be escaped and the frame will become roughly bytes long\n With bit stuffing  the increase would be roughly  \n % as  bit is added to every byte\n The last method of framing is to use a shortcut from the physical layer\n We saw in  \n  that the encoding of bits as signals often includes redundancy to help the receiver\n This redundancy means that some signals will not occur in regular data\n For example  in the  B/ B line code  data bits are mapped to  signal bits to ensure sufficient bit transitions\n This means that   out of the   signal possibilities are not used\n We can use some reserved signals to indicate the start and end of frames\n In effect  we are using ‘‘coding violations’’ to delimit frames\n The beauty of this scheme is that  because they are reserved signals  it is easy to find the start and end of frames and there is no need to stuff the data\n Many data link protocols use a combination of these methods for safety\n A common pattern used for Ethernet and   \n  is to have a frame begin with a well-defined pattern called a preamble\n This pattern might be quite long (  bits is typical for   \n  ) to allow the receiver to prepare for an incoming packet\n The preamble is then followed by a length ( \n  count) field in the header that is used to locate the end of the frame\n    Error Control Having solved the problem of marking the start and end of each frame  we come to the next problem: how to make sure all frames are eventually delivered to the network layer at the destination and in the proper order\n Assume for the moment that the receiver can tell whether a frame that it receives contains correct or faulty information (we will look at the codes that are used to detect and correct transmission errors in  )\n For unacknowledged connectionless service it might be fine if the sender just kept outputting frames without regard to whether   DATA LINK LAYER DESIGN ISSUES they were arriving properly\n But for reliable  connection-oriented service it would not be fine at all\n The usual way to ensure reliable delivery is to provide the sender with some feedback about what is happening at the other end of the line\n Typically  the protocol calls for the receiver to send back special control frames bearing positive or negative acknowledgements about the incoming frames\n If the sender receives a positive acknowledgement about a frame  it knows the frame has arrived safely\n On the other hand  a negative acknowledgement means that something has gone wrong and the frame must be transmitted again\n An additional complication comes from the possibility that hardware troubles may cause a frame to vanish completely ( \n  in a noise burst)\n In this case  the receiver will not react at all  since it has no reason to react\n Similarly  if the acknowledgement frame is lost  the sender will not know how to proceed\n It should be clear that a protocol in which the sender transmits a frame and then waits for an acknowledgement  positive or negative  will hang forever if a frame is ever lost due to  for example  malfunctioning hardware or a faulty communication channel\n This possibility is dealt with by introducing timers into the data link layer\n When the sender transmits a frame  it generally also starts a timer\n The timer is set to expire after an interval long enough for the frame to reach the destination  be processed there  and have the acknowledgement propagate back to the sender\n Normally  the frame will be correctly received and the acknowledgement will get back before the timer runs out  in which case the timer will be canceled\n However  if either the frame or the acknowledgement is lost  the timer will go off  alerting the sender to a potential problem\n The obvious solution is to just transmit the frame again\n However  when frames may be transmitted multiple times there is a danger that the receiver will accept the same frame two or more times and pass it to the network layer more than once\n To prevent this from happening  it is generally necessary to assign sequence numbers to outgoing frames  so that the receiver can distinguish retransmissions from originals\n The whole issue of managing the timers and sequence numbers so as to ensure that each frame is ultimately passed to the network layer at the destination exactly once  no more and no less  is an important part of the duties of the data link layer (and higher layers)\n Later in this  ter  we will look at a series of increasingly sophisticated examples to see how this management is done\n    Flow Control Another important design issue that occurs in the data link layer (and higher layers as well) is what to do with a sender that systematically wants to transmit frames faster than the receiver can accept them\n This situation can occur when the sender is running on a fast  powerful computer and the receiver is running on a slow  low-end machine\n A common situation is when a smart phone requests a Web page from a far more powerful server  which then turns on the fire hose and THE DATA LINK LAYER  \n  blasts the data at the poor helpless phone until it is completely swamped\n Even if the transmission is error free  the receiver may be unable to handle the frames as fast as they arrive and will lose some\n Clearly  something has to be done to prevent this situation\n Two approaches are commonly used\n In the first one  feedback-based flow control  the receiver sends back information to the sender giving it permission to send more data  or at least telling the sender how the receiver is doing\n In the ond one  rate-based flow control  the protocol has a built-in mechanism that limits the rate at which senders may transmit data  without using feedback from the receiver\n In this  ter we will study feedback-based flow control schemes  primarily because rate-based schemes are only seen as part of the transport layer (  \n  )\n Feedback-based schemes are seen at both the link layer and higher layers\n The latter is more common these days  in which case the link layer hardware is designed to run fast enough that it does not cause loss\n For example  hardware implementations of the link layer as NICs (Network Interface Cards) are sometimes said to run at ‘‘wire speed ’’ meaning that they can handle frames as fast as they can arrive on the link\n Any overruns are then not a link problem  so they are handled by higher layers\n Various feedback-based flow control schemes are known  but most of them use the same basic principle\n The protocol contains well-defined rules about when a sender may transmit the next frame\n These rules often prohibit frames from being sent until the receiver has granted permission  either implicitly or explicitly\n For example  when a connection is set up the receiver might say: ‘‘You may send me n frames now  but after they have been sent  do not send any more until I have told you to continue\n’’ We will examine the details shortly  ERROR DETECTION AND CORRECTION We saw in  \n  that communication channels have a range of characteristics\n Some channels  like optical fiber in telecommunications networks  have tiny error rates so that transmission errors are a rare occurrence\n But other channels  especially wireless links and aging local loops  have error rates that are orders of magnitude larger\n For these links  transmission errors are the norm\n They cannot be avoided at a reasonable expense or cost in terms of performance\n The conclusion is that transmission errors are here to stay\n We have to learn how to deal with them\n Network designers have developed two basic strategies for dealing with errors\n Both add redundant information to the data that is sent\n One strategy is to include enough redundant information to enable the receiver to deduce what the transmitted data must have been\n The other is to include only enough redundancy to allow the receiver to deduce that an error has occurred (but not which error)   ERROR DETECTION AND CORRECTION and have it request a retransmission\n The former strategy uses error-correcting codes and the latter uses error-detecting codes\n The use of error-correcting codes is often referred to as FEC (Forward Error Correction)\n Each of these techniques occupies a different ecological niche\n On channels that are highly reliable  such as fiber  it is cheaper to use an error-detecting code and just retransmit the occasional block found to be faulty\n However  on channels such as wireless links that make many errors  it is better to add redundancy to each block so that the receiver is able to figure out what the originally transmitted block was\n FEC is used on noisy channels because retransmissions are just as likely to be in error as the first transmission\n A key consideration for these codes is the type of errors that are likely to occur\n Neither error-correcting codes nor error-detecting codes can handle all possible errors since the redundant bits that offer protection are as likely to be received in error as the data bits (which can compromise their protection)\n It would be nice if the channel treated redundant bits differently than data bits  but it does not\n They are all just bits to the channel\n This means that to avoid undetected errors the code must be strong enough to handle the expected errors\n One model is that errors are caused by extreme values of thermal noise that overwhelm the signal briefly and occasionally  giving rise to isolated single-bit errors\n Another model is that errors tend to come in bursts rather than singly\n This model follows from the physical processes that generate them—such as a deep fade on a wireless channel or transient electrical interference on a wired channel/ Both models matter in practice  and they have different trade-offs\n Having the errors come in bursts has both advantages and disadvantages over isolated singlebit errors\n On the advantage side  computer data are always sent in blocks of bits\n Suppose that the block size was  bits and the error rate was  \n   per bit\n If errors were independent  most blocks would contain an error\n If the errors came in bursts of  however  only one block in would be affected  on average\n The disadvantage of burst errors is that when they do occur they are much harder to correct than isolated errors\n Other types of errors also exist\n Sometimes  the location of an error will be known  perhaps because the physical layer received an analog signal that was far from the expected value for a  or  and declared the bit to be lost\n This situation is called an erasure channel\n It is easier to correct errors in erasure channels than in channels that flip bits because even if the value of the bit has been lost  at least we know which bit is in error\n However  we often do not have the benefit of erasures\n We will examine both error-correcting codes and error-detecting codes next\n Please keep two points in mind  though\n First  we cover these codes in the link layer because this is the first place that we have run up against the problem of reliably transmitting groups of bits\n However  the codes are widely used because reliability is an overall concern\n Error-correcting codes are also seen in the physical layer  particularly for noisy channels  and in higher layers  particularly for THE DATA LINK LAYER  \n  real-time media and content distribution\n Error-detecting codes are commonly used in link  network  and transport layers\n The ond point to bear in mind is that error codes are applied mathematics\n Unless you are particularly adept at Galois fields or the properties of sparse matrices  you should get codes with good properties from a reliable source rather than making up your own\n In fact  this is what many protocol standards do  with the same codes coming up again and again\n In the material below  we will study a simple code in detail and then briefly describe advanced codes\n In this way  we can understand the trade-offs from the simple code and talk about the codes that are used in practice via the advanced codes\n    Error-Correcting Codes We will examine four different error-correcting codes:  \n Hamming codes Binary convolutional codes Reed-Solomon codes Low-Density Parity Check codes\n All of these codes add redundancy to the information that is sent\n A frame consists of m data ( \n  message) bits and r redundant ( \n check) bits\n In a block code  the r check bits are computed solely as a function of the m data bits with which they are associated  as though the m bits were looked up in a large table to find their corresponding r check bits\n In a systematic code  the m data bits are sent directly  along with the check bits  rather than being encoded themselves before they are sent\n In a linear code  the r check bits are computed as a linear function of the m data bits\n Exclusive OR (XOR) or modulo  addition is a popular choice\n This means that encoding can be done with operations such as matrix multiplications or simple logic circuits\n The codes we will look at in this tion are linear  systematic block codes unless otherwise noted\n Let the total length of a block be n ( \n  n = m + r)\n We will describe this as an (n m) code\n An n-bit unit containing data and check bits is referred to as an nbit codeword\n The code rate  or simply rate  is the fraction of the codeword that carries information that is not redundant  or m/n\n The rates used in practice vary widely\n They might be  /  for a noisy channel  in which case half of the received information is redundant  or close to  for a high-quality channel  with only a small number of check bits added to a large message\n To understand how errors can be handled  it is necessary to first look closely at what an error really is\n Given any two codewords that may be transmitted or received—say  and    —it is possible to determine how many   ERROR DETECTION AND CORRECTION corresponding bits differ\n In this case   bits differ\n To determine how many bits differ  just XOR the two codewords and count the number of  bits in the result\n For example:      The number of bit positions in which two codewords differ is called the Hamming distance (Hamming  )\n Its significance is that if two codewords are a Hamming distance d apart  it will require d single-bit errors to convert one into the other\n Given the algorithm for computing the check bits  it is possible to construct a complete list of the legal codewords  and from this list to find the two codewords with the smallest Hamming distance\n This distance is the Hamming distance of the complete code\n In most data transmission applications  all  m possible data messages are legal  but due to the way the check bits are computed  not all of the  n possible codewords are used\n In fact  when there are r check bits  only the small fraction of  m / n or  / r of the possible messages will be legal codewords\n It is the sparseness with which the message is embedded in the space of codewords that allows the receiver to detect and correct errors\n The error-detecting and error-correcting properties of a block code depend on its Hamming distance\n To reliably detect d errors  you need a distance d +  code because with such a code there is no way that d single-bit errors can change a valid codeword into another valid codeword\n When the receiver sees an illegal codeword  it can tell that a transmission error has occurred\n Similarly  to correct d errors  you need a distance  d +  code because that way the legal codewords are so far apart that even with d changes the original codeword is still closer than any other codeword\n This means the original codeword can be uniquely determined based on the assumption that a larger number of errors are less likely\n As a simple example of an error-correcting code  consider a code with only four valid codewords:      and   This code has a distance of   which means that it can correct double errors or detect quadruple errors\n If the codeword   arrives and we expect only single- or double-bit errors  the receiver will know that the original must have been  \n If  however  a triple error changes   into    the error will not be corrected properly\n Alternatively  if we expect all of these errors  we can detect them\n None of the received codewords are legal codewords so an error must have occurred\n It should be apparent that in this example we cannot both correct double errors and detect quadruple errors because this would require us to interpret a received codeword in two different ways\n THE DATA LINK LAYER  \n  In our example  the task of decoding by finding the legal codeword that is closest to the received codeword can be done by inspection\n Unfortunately  in the most general case where all codewords need to be evaluated as candidates  this task can be a time-consuming search\n Instead  practical codes are designed so that they admit shortcuts to find what was likely the original codeword\n Imagine that we want to design a code with m message bits and r check bits that will allow all single errors to be corrected\n Each of the  m legal messages has n illegal codewords at a distance of  from it\n These are formed by systematically inverting each of the n bits in the n-bit codeword formed from it\n Thus  each of the  m legal messages requires n +  bit patterns dedicated to it\n Since the total number of bit patterns is  n  we must have (n +  ) m ≤  n\n Using n = m + r  this requirement becomes (m + r +  ) ≤  r ( - ) Given m  this puts a lower limit on the number of check bits needed to correct single errors\n This theoretical lower limit can  in fact  be achieved using a method due to Hamming (   )\n In Hamming codes the bits of the codeword are numbered conutively  starting with bit  at the left end  bit  to its immediate right  and so on\n The bits that are powers of  (   etc\n) are check bits\n The rest (  etc\n) are filled up with the m data bits\n This pattern is shown for an (   ) Hamming code with  data bits and  check bits in Fig\n  - \n Each check bit forces the modulo  sum  or parity  of some collection of bits  including itself  to be even (or odd)\n A bit may be included in several check bit computations\n To see which check bits the data bit in position k contributes to  rewrite k as a sum of powers of  \n For example =  +  +  and   =  +  +  +  \n A bit is checked by just those check bits occurring in its expansion ( \n  bit   is checked by bits  and  )\n In the example  the check bits are computed for even parity sums for a message that is the ASCII letter ‘‘A\n’’ Sent codeword Received codeword     p  p  m  p  m  m  m  p  m  m  m  Check bits Channel    bit error Syndrome    Check results A    Flip bit  A    Message Message Figure  - \n Example of an ( ) Hamming code correcting a single-bit error\n This construction gives a code with a Hamming distance of   which means that it can correct single errors (or detect double errors)\n The reason for the very careful numbering of message and check bits becomes apparent in the decoding   ERROR DETECTION AND CORRECTION process\n When a codeword arrives  the receiver redoes the check bit computations including the values of the received check bits\n We call these the check results\n If the check bits are correct then  for even parity sums  each check result should be zero\n In this case the codeword is accepted as valid\n If the check results are not all zero  however  an error has been detected\n The set of check results forms the error syndrome that is used to pinpoint and correct the error\n In Fig\n  -  a single-bit error occurred on the channel so the check results are  and  for k =  and   respectively\n This gives a syndrome of  or  +  = \n By the design of the scheme  this means that the fifth bit is in error\n Flipping the incorrect bit (which might be a check bit or a data bit) and discarding the check bits gives the correct message of an ASCII ‘‘A\n’’ Hamming distances are valuable for understanding block codes  and Hamming codes are used in error-correcting memory\n However  most networks use stronger codes\n The ond code we will look at is a convolutional code\n This code is the only one we will cover that is not a block code\n In a convolutional code  an encoder processes a sequence of input bits and generates a sequence of output bits\n There is no natural message size or encoding boundary as in a block code\n The output depends on the current and previous input bits\n That is  the encoder has memory\n The number of previous bits on which the output depends is called the constraint length of the code\n Convolutional codes are specified in terms of their rate and constraint length\n Convolutional codes are widely used in deployed networks  for example  as part of the GSM mobile phone system  in satellite communications  and in    As an example  a popular convolutional code is shown in Fig\n  - \n This code is known as the NASA convolutional code of r =  /  and k =   since it was first used for the Voyager space missions starting in \n Since then it has been liberally reused  for example  as part of    Input bit Output bit  S  S  S  S  S  S  Output bit  Figure  - \n The NASA binary convolutional code used in    In Fig\n  -  each input bit on the left-hand side produces two output bits on the right-hand side that are XOR sums of the input and internal state\n Since it deals with bits and performs linear operations  this is a binary  linear convolutional code\n Since  input bit produces  output bits  the code rate is  / \n It is not systematic since none of the output bits is simply the input bit\n THE DATA LINK LAYER  \n  The internal state is kept in six memory registers\n Each time another bit is input the values in the registers are shifted to the right\n For example  if is input and the initial state is all zeros  the internal state  written left to right  will become    and   after the first  ond  and third bits have been input\n The output bits will be followed by and then  \n It takes seven shifts to flush an input completely so that it does not affect the output\n The constraint length of this code is thus k =  \n A convolutional code is decoded by finding the sequence of input bits that is most likely to have produced the observed sequence of output bits (which includes any errors)\n For small values of k  this is done with a widely used algorithm developed by Viterbi (Forney  )\n The algorithm walks the observed sequence  keeping for each step and for each possible internal state the input sequence that would have produced the observed sequence with the fewest errors\n The input sequence requiring the fewest errors at the end is the most likely message\n Convolutional codes have been popular in practice because it is easy to factor the uncertainty of a bit being a  or a  into the decoding\n For example  suppose − V is the logical  level and + V is the logical  level  we might receive  \n V and − \n V for  bits\n Instead of mapping these signals to  and  right away  we would like to treat  \n V as ‘‘very likely a  ’’ and − \n V as ‘‘maybe a  ’’ and correct the sequence as a whole\n Extensions of the Viterbi algorithm can work with these uncertainties to provide stronger error correction\n This approach of working with the uncertainty of a bit is called soft-decision decoding\n Conversely  deciding whether each bit is a  or a  before subsequent error correction is called hard-decision decoding\n The third kind of error-correcting code we will describe is the Reed-Solomon code\n Like Hamming codes  Reed-Solomon codes are linear block codes  and they are often systematic too\n Unlike Hamming codes  which operate on individual bits  Reed-Solomon codes operate on m bit symbols\n Naturally  the mathematics are more involved  so we will describe their operation by analogy\n Reed-Solomon codes are based on the fact that every n degree polynomial is uniquely determined by n +  points\n For example  a line having the form ax + b is determined by two points\n Extra points on the same line are redundant  which is helpful for error correction\n Imagine that we have two data points that represent a line and we send those two data points plus two check points chosen to lie on the same line\n If one of the points is received in error  we can still recover the data points by fitting a line to the received points\n Three of the points will lie on the line  and one point  the one in error  will not\n By finding the line we have corrected the error\n Reed-Solomon codes are actually defined as polynomials that operate over finite fields  but they work in a similar manner\n For m bit symbols  the codewords are  m−  symbols long\n A popular choice is to make m =  so that symbols are bytes\n A codeword is then bytes long\n The (   ) code is widely used; it adds   redundant symbols to data symbols\n Decoding with error correction   ERROR DETECTION AND CORRECTION is done with an algorithm developed by Berlekamp and Massey that can efficiently perform the fitting task for moderate-length codes (Massey  )\n Reed-Solomon codes are widely used in practice because of their strong error-correction properties  particularly for burst errors\n They are used for DSL  data over cable  satellite communications  and perhaps most ubiquitously on CDs  DVDs  and Blu-ray discs\n Because they are based on m bit symbols  a single-bit error and an m-bit burst error are both treated simply as one symbol error\n When  t redundant symbols are added  a Reed-Solomon code is able to correct up to t errors in any of the transmitted symbols\n This means  for example  that the (   ) code  which has   redundant symbols  can correct up to   symbol errors\n Since the symbols may be conutive and they are each  bits  an error burst of up to bits can be corrected\n The situation is even better if the error model is one of erasures ( \n  a scratch on a CD that obliterates some symbols)\n In this case  up to  t errors can be corrected\n Reed-Solomon codes are often used in combination with other codes such as a convolutional code\n The thinking is as follows\n Convolutional codes are effective at handling isolated bit errors  but they will fail  likely with a burst of errors  if there are too many errors in the received bit stream\n By adding a Reed-Solomon code within the convolutional code  the Reed-Solomon decoding can mop up the error bursts  a task at which it is very good\n The overall code then provides good protection against both single and burst errors\n The final error-correcting code we will cover is the LDPC (Low-Density Parity Check) code\n LDPC codes are linear block codes that were invented by Robert Gallagher in his doctoral thesis (Gallagher  )\n Like most theses  they were promptly forgotten  only to be reinvented in  when advances in computing power had made them practical\n In an LDPC code  each output bit is formed from only a fraction of the input bits\n This leads to a matrix representation of the code that has a low density of  s  hence the name for the code\n The received codewords are decoded with an approximation algorithm that iteratively improves on a best fit of the received data to a legal codeword\n This corrects errors\n LDPC codes are practical for large block sizes and have excellent error-correction abilities that outperform many other codes (including the ones we have looked at) in practice\n For this reason they are rapidly being included in new protocols\n They are part of the standard for digital video broadcasting Gbps Ethernet  power-line networks  and the latest version of    Expect to see more of them in future networks\n    Error-Detecting Codes Error-correcting codes are widely used on wireless links  which are notoriously noisy and error prone when compared to optical fibers\n Without error-correcting codes  it would be hard to get anything through\n However  over fiber or THE DATA LINK LAYER  \n  high-quality copper  the error rate is much lower  so error detection and retransmission is usually more efficient there for dealing with the occasional error\n We will examine three different error-detecting codes\n They are all linear  systematic block codes:  \n Parity Checksums Cyclic Redundancy Checks (CRCs)\n To see how they can be more efficient than error-correcting codes  consider the first error-detecting code  in which a single parity bit is appended to the data\n The parity bit is chosen so that the number of  bits in the codeword is even (or odd)\n Doing this is equivalent to computing the (even) parity bit as the modulo  sum or XOR of the data bits\n For example  when    is sent in even parity  a bit is added to the end to make it    \n With odd parity    becomes    \n A code with a single parity bit has a distance of   since any single-bit error produces a codeword with the wrong parity\n This means that it can detect single-bit errors\n Consider a channel on which errors are isolated and the error rate is  −  per bit\n This may seem a tiny error rate  but it is at best a fair rate for a long wired cable that is challenging for error detection\n Typical LAN links provide bit error rates of  −  \n Let the block size be  bits\n To provide error correction for -bit blocks  we know from Eq\n ( - ) that   check bits are needed\n Thus  a megabit of data would require   check bits\n To merely detect a block with a single  -bit error  one parity bit per block will suffice\n Once every  blocks  a block will be found to be in error and an extra block ( bits) will have to be transmitted to repair the error\n The total overhead for the error detection and retransmission method is only  bits per megabit of data  versus   bits for a Hamming code\n One difficulty with this scheme is that a single parity bit can only reliably detect a single-bit error in the block\n If the block is badly garbled by a long burst error  the probability that the error will be detected is only  \n  which is hardly acceptable\n The odds can be improved considerably if each block to be sent is regarded as a rectangular matrix n bits wide and k bits high\n Now  if we compute and send one parity bit for each row  up to k bit errors will be reliably detected as long as there is at most one error per row\n However  there is something else we can do that provides better protection against burst errors: we can compute the parity bits over the data in a different order than the order in which the data bits are transmitted\n Doing so is called interleaving\n In this case  we will compute a parity bit for each of the n columns and send all the data bits as k rows  sending the rows from top to bottom and the bits in each row from left to right in the usual manner\n At the last row  we send the n parity bits\n This transmission order is shown in Fig\n  -  for n =  and k =  \n   ERROR DETECTION AND CORRECTION Burst error Channel Transmit order Parity bits    N c l w o r k Parity errors    N e t w o r k                 Figure  - \n Interleaving of parity bits to detect a burst error\n Interleaving is a general technique to convert a code that detects (or corrects) isolated errors into a code that detects (or corrects) burst errors\n In Fig\n  -  when a burst error of length n =  occurs  the bits that are in error are spread across different columns\n (A burst error does not imply that all the bits are wrong; it just implies that at least the first and last are wrong\n In Fig\n  - bits were flipped over a range of  bits\n) At most  bit in each of the n columns will be affected  so the parity bits on those columns will detect the error\n This method uses n parity bits on blocks of kn data bits to detect a single burst error of length n or less\n A burst of length n +  will pass undetected  however  if the first bit is inverted  the last bit is inverted  and all the other bits are correct\n If the block is badly garbled by a long burst or by multiple shorter bursts  the probability that any of the n columns will have the correct parity by accident is  \n  so the probability of a bad block being accepted when it should not be is  −n\n The ond kind of error-detecting code  the checksum  is closely related to groups of parity bits\n The word ‘‘checksum’’ is often used to mean a group of check bits associated with a message  regardless of how are calculated\n A group of parity bits is one example of a checksum\n However  there are other  stronger checksums based on a running sum of the data bits of the message\n The checksum is usually placed at the end of the message  as the complement of the sum function\n This way  errors may be detected by summing the entire received codeword  both data bits and checksum\n If the result comes out to be zero  no error has been detected\n One example of a checksum is the  -bit Internet checksum used on all Internet packets as part of the IP protocol (Braden et al\n  )\n This checksum is a sum of the message bits divided into  -bit words\n Because this method operates on words rather than on bits  as in parity  errors that leave the parity unchanged can still alter the sum and be detected\n For example  if the lowest order bit in two different words is flipped from a  to a   a parity check across these bits would fail to detect an error\n However  two  s will be added to the  -bit checksum to produce a different result\n The error can then be detected\n THE DATA LINK LAYER  \n  The Internet checksum is computed in one’s complement arithmetic instead of as the modulo sum\n In one’s complement arithmetic  a negative number is the bitwise complement of its positive counterpart\n Modern computers run two’s complement arithmetic  in which a negative number is the one’s complement plus one\n On a two’s complement computer  the one’s complement sum is equivalent to taking the sum modulo and adding any overflow of the high order bits back into the low-order bits\n This algorithm gives a more uniform coverage of the data by the checksum bits\n Otherwise  two high-order bits can be added  overflow  and be lost without changing the sum\n There is another benefit  too\n One’s complement has two representations of zero  all  s and all  s\n This allows one value ( \n  all  s) to indicate that there is no checksum  without the need for another field\n For decades  it has always been assumed that frames to be checksummed contain random bits\n All analyses of checksum algorithms have been made under this assumption\n Inspection of real data by Partridge et al\n (   ) has shown this assumption to be quite wrong\n As a consequence  undetected errors are in some cases much more common than had been previously thought\n The Internet checksum in particular is efficient and simple but provides weak protection in some cases precisely because it is a simple sum\n It does not detect the deletion or addition of zero data  nor swapping parts of the message  and it provides weak protection against message splices in which parts of two packets are put together\n These errors may seem very unlikely to occur by random processes  but they are just the sort of errors that can occur with buggy hardware\n A better choice is Fletcher’s checksum (Fletcher  )\n It includes a positional component  adding the product of the data and its position to the running sum\n This provides stronger detection of changes in the position of data\n Although the two preceding schemes may sometimes be adequate at higher layers  in practice  a third and stronger kind of error-detecting code is in widespread use at the link layer: the CRC (Cyclic Redundancy Check)  also known as a polynomial code\n Polynomial codes are based upon treating bit strings as representations of polynomials with coefficients of  and  only\n A k-bit frame is regarded as the coefficient list for a polynomial with k terms  ranging from x k −  to x  \n Such a polynomial is said to be of degree k −  \n The high-order (leftmost) bit is the coefficient of x k −   the next bit is the coefficient of x k −   and so on\n For example    has  bits and thus represents a six-term polynomial with coefficients   and  :  x  +  x  +  x  +  x  +  x  +  x  \n Polynomial arithmetic is done modulo   according to the rules of algebraic field theory\n It does not have carries for addition or borrows for subtraction\n Both addition and subtraction are identical to exclusive OR\n For example:      +  +  −  −       Long division is carried out in exactly the same way as it is in binary except that   ERROR DETECTION AND CORRECTION the subtraction is again done modulo  \n A divisor is said ‘‘to go into’’ a dividend if the dividend has as many bits as the divisor\n When the polynomial code method is employed  the sender and receiver must agree upon a generator polynomial  G(x)  in advance\n Both the high- and loworder bits of the generator must be  \n To compute the CRC for some frame with m bits corresponding to the polynomial M(x)  the frame must be longer than the generator polynomial\n The idea is to append a CRC to the end of the frame in such a way that the polynomial represented by the checksummed frame is divisible by G(x)\n When the receiver gets the checksummed frame  it tries dividing it by G(x)\n If there is a remainder  there has been a transmission error\n The algorithm for computing the CRC is as follows:  \n Let r be the degree of G(x)\n Append r zero bits to the low-order end of the frame so it now contains m + r bits and corresponds to the polynomial x rM(x) Divide the bit string corresponding to G(x) into the bit string corresponding to x rM(x)  using modulo  division Subtract the remainder (which is always r or fewer bits) from the bit string corresponding to x rM(x) using modulo  subtraction\n The result is the checksummed frame to be transmitted\n Call its polynomial T(x)\n Figure  -  illustrates the calculation for a frame   using the generator G(x) = x  + x +  \n It should be clear that T(x) is divisible (modulo  ) by G(x)\n In any division problem  if you diminish the dividend by the remainder  what is left over is divisible by the divisor\n For example  in base if you divide    by    the remainder is \n If you then subtract  from  what is left over (  ) is divisible by  \n Now let us analyze the power of this method\n What kinds of errors will be detected? Imagine that a transmission error occurs  so that instead of the bit string for T(x) arriving  T(x) + E(x) arrives\n Each  bit in E(x) corresponds to a bit that has been inverted\n If there are k  bits in E(x)  k single-bit errors have occurred\n A single burst error is characterized by an initial   a mixture of  s and  s  and a final   with all other bits being  \n Upon receiving the checksummed frame  the receiver divides it by G(x); that is  it computes [T(x) + E(x)]/G(x)\n T(x)/G(x) is   so the result of the computation is simply E(x)/G(x)\n Those errors that happen to correspond to polynomials containing G(x) as a factor will slip by; all other errors will be caught\n If there has been a single-bit error  E(x) = x i  where i determines which bit is in error\n If G(x) contains two or more terms  it will never divide into E(x)  so all single-bit errors will be detected\n THE DATA LINK LAYER  \n                                Remainder Quotient (thrown away) Frame with four zeros appended      Frame with four zeros appended minus remainder Transmitted frame:  Frame:      Generator: Figure  - \n Example calculation of the CRC\n If there have been two isolated single-bit errors  E(x) = x i + x j  where i > j\n Alternatively  this can be written as E(x) = x j(x i − j +  )\n If we assume that G(x) is not divisible by x  a sufficient condition for all double errors to be detected is that G(x) does not divide x k +  for any k up to the maximum value of i − j ( \n  up to the maximum frame length)\n Simple  low-degree polynomials that give protection to long frames are known\n For example  x   + x   +  will not divide x k +  for any value of k below  \n If there are an odd number of bits in error  E(X) contains an odd number of terms ( \n  x  + x  +   but not x  +  )\n Interestingly  no polynomial with an odd number of terms has x +  as a factor in the modulo  system\n By making x +  a factor of G(x)  we can catch all errors with an odd number of inverted bits\n Finally  and importantly  a polynomial code with r check bits will detect all burst errors of length ≤ r\n A burst error of length k can be represented by x i(x k −  +  \n +  )  where i determines how far from the right-hand end of the received frame the burst is located\n If G(x) contains an x  term  it will not have x i as a factor  so if the degree of the parenthesized expression is less than the degree of G(x)  the remainder can never be zero\n   ERROR DETECTION AND CORRECTION If the burst length is r +   the remainder of the division by G(x) will be zero if and only if the burst is identical to G(x)\n By definition of a burst  the first and last bits must be   so whether it matches depends on the r −  intermediate bits\n If all combinations are regarded as equally likely  the probability of such an incorrect frame being accepted as valid is ½r −  \n It can also be shown that when an error burst longer than r +  bits occurs or when several shorter bursts occur  the probability of a bad frame getting through unnoticed is ½r  assuming that all bit patterns are equally likely\n Certain polynomials have become international standards\n The one used in IEEE followed the example of Ethernet and is x   + x   + x   + x   + x   + x   + x   + x   + x  + x  + x  + x  + x  + x  +  Among other desirable properties  it has the property that it detects all bursts of length   or less and all bursts affecting an odd number of bits\n It has been used widely since the s\n However  this does not mean it is the best choice\n Using an exhaustive computational search  Castagnoli et al\n (   ) and Koopman (   ) found the best CRCs\n These CRCs have a Hamming distance of  for typical message sizes  while the IEEE standard CRC-  has a Hamming distance of only  \n Although the calculation required to compute the CRC may seem complicated  it is easy to compute and verify CRCs in hardware with simple shift register circuits (Peterson and Brown  )\n In practice  this hardware is nearly always used\n Dozens of networking standards include various CRCs  including virtually all LANs ( \n  Ethernet \n  ) and point-to-point links ( \n  packets over SONET)  ELEMENTARY DATA LINK PROTOCOLS To introduce the subject of protocols  we will begin by looking at three protocols of increasing complexity\n For interested readers  a simulator for these and subsequent protocols is available via the Web (see the preface)\n Before we look at the protocols  it is useful to make explicit some of the assumptions underlying the model of communication\n To start with  we assume that the physical layer  data link layer  and network layer are independent processes that communicate by passing messages back and forth\n A common implementation is shown in Fig\n  -  \n The physical layer process and some of the data link layer process run on dedicate hardware called a NIC (Network Interface Card)\n The rest of the link layer process and the network layer process run on the main CPU as part of the operating system  with the software for the link layer process often taking the form of a device driver\n However  other implementations are also possible ( \n  three processes offloaded to dedicated hardware called a network accelerator  or three processes running on the THE DATA LINK LAYER  \n  main CPU on a software-defined ratio)\n Actually  the preferred implementation changes from decade to decade with technology trade-offs\n In any event  treating the three layers as separate processes makes the discussion conceptually cleaner and also serves to emphasize the independence of the layers\n Network Cable (medium) PHY Link Link Application Network Interface Card (NIC) Driver Operating system Computer Figure  -  \n Implementation of the physical  data link  and network layers\n Another key assumption is that machine A wants to send a long stream of data to machine B  using a reliable  connection-oriented service\n Later  we will consider the case where B also wants to send data to A simultaneously\n A is assumed to have an infinite supply of data ready to send and never has to wait for data to be produced\n Instead  when A’s data link layer asks for data  the network layer is always able to comply immediately\n (This restriction  too  will be dropped later\n) We also assume that machines do not crash\n That is  these protocols deal with communication errors  but not the problems caused by computers crashing and rebooting\n As far as the data link layer is concerned  the packet passed across the interface to it from the network layer is pure data  whose every bit is to be delivered to the destination’s network layer\n The fact that the destination’s network layer may interpret part of the packet as a header is of no concern to the data link layer\n When the data link layer accepts a packet  it encapsulates the packet in a frame by adding a data link header and trailer to it (see Fig\n  - )\n Thus  a frame consists of an embedded packet  some control information (in the header)  and a checksum (in the trailer)\n The frame is then transmitted to the data link layer on the other machine\n We will assume that there exist suitable library procedures to physical layer to send a frame and from physical layer to receive a frame\n These procedures compute and append or check the checksum (which is usually done in hardware) so that we do not need to worry about it as part of the protocols we develop in this tion\n They might use the CRC algorithm discussed in the previous tion  for example\n Initially  the receiver has nothing to do\n It just sits around waiting for something to happen\n In the example protocols throughout this  ter we will indicate that the data link layer is waiting for something to happen by the procedure call   ELEMENTARY DATA LINK PROTOCOLS #define MAX PKT  /* determines packet size in bytes */ typedef enum {false  true} boolean; /* boolean type */ typedef unsigned int seq nr; /* sequence or ack numbers */ typedef struct {unsigned char data[MAX PKT];} packet; /* packet definition */ typedef enum {data  ack  nak} frame kind; /* frame kind definition */ typedef struct { /* frames are transported in this layer */ frame kind kind; /* what kind of frame is it? */ seq nr seq; /* sequence number */ seq nr ack; /* acknowledgement number */ packet info; /* the network layer packet */ } frame; /* Wait for an event to happen; return its type in event\n */ void wait for event(event type *event); /* Fetch a packet from the network layer for transmission on the channel\n */ void from network layer(packet *p); /* Deliver information from an inbound frame to the network layer\n */ void to network layer(packet *p); /* Go get an inbound frame from the physical layer and copy it to r\n */ void from physical layer(frame *r); /* Pass the frame to the physical layer for transmission\n */ void to physical layer(frame *s); /* Start the clock running and enable the timeout event\n */ void start timer(seq nr k); /* Stop the clock and disable the timeout event\n */ void stop timer(seq nr k); /* Start an auxiliary timer and enable the ack timeout event\n */ void start ack timer(void); /* Stop the auxiliary timer and disable the ack timeout event\n */ void stop ack timer(void); /* Allow the network layer to cause a network layer ready event\n */ void enable network layer(void); /* Forbid the network layer from causing a network layer ready event\n */ void disable network layer(void); /* Macro inc is expanded in-line: increment k circularly\n */ #define inc(k) if (k < MAX SEQ) k = k +  ; else k =  Figure  -  \n Some definitions needed in the protocols to follow\n These definitions are located in the file  \n THE DATA LINK LAYER  \n  wait for event(&event)\n This procedure only returns when something has happened ( \n  a frame has arrived)\n Upon return  the variable event tells what happened\n The set of possible events differs for the various protocols to be described and will be defined separately for each protocol\n Note that in a more realistic situation  the data link layer will not sit in a tight loop waiting for an event  as we have suggested  but will receive an interrupt  which will cause it to stop whatever it was doing and go handle the incoming frame\n Nevertheless  for simplicity we will ignore all the details of parallel activity within the data link layer and assume that it is dedicated full time to handling just our one channel\n When a frame arrives at the receiver  the checksum is recomputed\n If the checksum in the frame is incorrect ( \n  there was a transmission error)  the data link layer is so informed (event = cksum err)\n If the inbound frame arrived undamaged  the data link layer is also informed (event = frame arrival ) so that it can acquire the frame for inspection using from physical layer\n As soon as the receiving data link layer has acquired an undamaged frame  it checks the control information in the header  and  if everything is all right  passes the packet portion to the network layer\n Under no circumstances is a frame header ever given to a network layer\n There is a good reason why the network layer must never be given any part of the frame header: to keep the network and data link protocols completely separate\n As long as the network layer knows nothing at all about the data link protocol or the frame format  these things can be changed without requiring changes to the network layer’s software\n This happens whenever a new NIC is installed in a computer\n Providing a rigid interface between the network and data link layers greatly simplifies the design task because communication protocols in different layers can evolve independently\n Figure  -  shows some declarations (in C) common to many of the protocols to be discussed later\n Five data structures are defined there: boolean  seq nr  packet  frame kind  and frame\n A boolean is an enumerated type and can take on the values true and false\n A seq nr is a small integer used to number the frames so that we can tell them apart\n These sequence numbers run from  up to and including MAX SEQ  which is defined in each protocol needing it\n A packet is the unit of information exchanged between the network layer and the data link layer on the same machine  or between network layer peers\n In our model it always contains MAX PKT bytes  but more realistically it would be of variable length\n A frame is composed of four fields: kind  seq  ack  and info  the first three of which contain control information and the last of which may contain actual data to be transferred\n These control fields are collectively called the frame header\n The kind field tells whether there are any data in the frame  because some of the protocols distinguish frames containing only control information from those containing data as well\n The seq and ack fields are used for sequence numbers and acknowledgements  respectively; their use will be described in more detail later\n The info field of a data frame contains a single packet; the info field of a   ELEMENTARY DATA LINK PROTOCOLS control frame is not used\n A more realistic implementation would use a variablelength info field  omitting it altogether for control frames\n Again  it is important to understand the relationship between a packet and a frame\n The network layer builds a packet by taking a message from the transport layer and adding the network layer header to it\n This packet is passed to the data link layer for inclusion in the info field of an outgoing frame\n When the frame arrives at the destination  the data link layer extracts the packet from the frame and passes the packet to the network layer\n In this manner  the network layer can act as though machines can exchange packets directly\n A number of procedures are also listed in Fig\n  -  \n These are library routines whose details are implementation dependent and whose inner workings will not concern us further in the following discussions\n The procedure wait for event sits in a tight loop waiting for something to happen  as mentioned earlier\n The procedures to network layer and from network layer are used by the data link layer to pass packets to the network layer and accept packets from the network layer  respectively\n Note that from physical layer and to physical layer pass frames between the data link layer and the physical layer\n In other words  to network layer and from network layer deal with the interface between layers  and   whereas from physical layer and to physical layer deal with the interface between layers  and  \n In most of the protocols  we assume that the channel is unreliable and loses entire frames upon occasion\n To be able to recover from such calamities  the sending data link layer must start an internal timer or clock whenever it sends a frame\n If no reply has been received within a certain predetermined time interval  the clock times out and the data link layer receives an interrupt signal\n In our protocols this is handled by allowing the procedure wait for event to return event = timeout\n The procedures start timer and stop timer turn the timer on and off  respectively\n Timeout events are possible only when the timer is running and before stop timer is called\n It is explicitly permitted to call start timer while the timer is running; such a call simply resets the clock to cause the next timeout after a full timer interval has elapsed (unless it is reset or turned off)\n The procedures start ack timer and stop ack timer control an auxiliary timer used to generate acknowledgements under certain conditions\n The procedures enable network layer and disable network layer are used in the more sophisticated protocols  where we no longer assume that the network layer always has packets to send\n When the data link layer enables the network layer  the network layer is then permitted to interrupt when it has a packet to be sent\n We indicate this with event = network layer ready\n When the network layer is disabled  it may not cause such events\n By being careful about when it enables and disables its network layer  the data link layer can prevent the network layer from swamping it with packets for which it has no buffer space\n Frame sequence numbers are always in the range  to MAX SEQ (inclusive)  where MAX SEQ is different for the different protocols\n It is frequently necessary THE DATA LINK LAYER  \n  to advance a sequence number by  circularly ( \n  MAX SEQ is followed by  )\n The macro inc performs this incrementing\n It has been defined as a macro because it is used in-line within the critical path\n As we will see later  the factor limiting network performance is often protocol processing  so defining simple operations like this as macros does not affect the readability of the code but does improve performance\n The declarations of Fig\n  -  are part of each of the protocols we will discuss shortly\n To save space and to provide a convenient reference  they have been extracted and listed together  but conceptually they should be merged with the protocols themselves\n In C  this merging is done by putting the definitions in a special header file  in this case    and using the #include facility of the C preprocessor to include them in the protocol files\n    A Utopian Simplex Protocol As an initial example we will consider a protocol that is as simple as it can be because it does not worry about the possibility of anything going wrong\n Data are transmitted in one direction only\n Both the transmitting and receiving network layers are always ready\n Processing time can be ignored\n Infinite buffer space is available\n And best of all  the communication channel between the data link layers never damages or loses frames\n This thoroughly unrealistic protocol  which we will nickname ‘‘Utopia ’’ is simply to show the basic structure on which we will build\n It’s implementation is shown in Fig\n  -  \n The protocol consists of two distinct procedures  a sender and a receiver\n The sender runs in the data link layer of the source machine  and the receiver runs in the data link layer of the destination machine\n No sequence numbers or acknowledgements are used here  so MAX SEQ is not needed\n The only event type possible is frame arrival ( \n  the arrival of an undamaged frame)\n The sender is in an infinite while loop just pumping data out onto the line as fast as it can\n The body of the loop consists of three actions: go fetch a packet from the (always obliging) network layer  construct an outbound frame using the variable s  and send the frame on its way\n Only the info field of the frame is used by this protocol  because the other fields have to do with error and flow control and there are no errors or flow control restrictions here\n The receiver is equally simple\n Initially  it waits for something to happen  the only possibility being the arrival of an undamaged frame\n Eventually  the frame arrives and the procedure wait for event returns  with event set to frame arrival (which is ignored anyway)\n The call to from physical layer removes the newly arrived frame from the hardware buffer and puts it in the variable r  where the receiver code can get at it\n Finally  the data portion is passed on to the network layer  and the data link layer settles back to wait for the next frame  effectively suspending itself until the frame arrives\n   ELEMENTARY DATA LINK PROTOCOLS /* Protocol  (Utopia) provides for data transmission in one direction only  from sender to receiver\n The communication channel is assumed to be error free and the receiver is assumed to be able to process all the input infinitely quickly\n Consequently  the sender just sits in a loop pumping data out onto the line as fast as it can\n */ typedef enum {frame arrival} event type; #include " " void sender (void) { frame s; /* buffer for an outbound frame */ packet buffer; /* buffer for an outbound packet */ while (true) { from network layer(&buffer); /* go get something to send */   = buffer; /* copy it into s for transmission */ to physical layer(&s); /* send it on its way */ } /* Tomorrow  and tomorrow  and tomorrow  Creeps in this petty pace from day to day To the last syllable of recorded time\n – Macbeth  V  v */ } void receiver (void) { frame r; event type event; /* filled in by wait  but not used here */ while (true) { wait for event(&event); /* only possibility is frame arrival */ from physical layer(&r); /* go get the inbound frame */ to network layer(& ); /* pass the data to the network layer */ } } Figure  -  \n A utopian simplex protocol\n The utopia protocol is unrealistic because it does not handle either flow control or error correction\n Its processing is close to that of an unacknowledged connectionless service that relies on higher layers to solve these problems  though even an unacknowledged connectionless service would do some error detection\n    A Simplex Stop-and-Wait Protocol for an Error-Free Channel Now we will tackle the problem of preventing the sender from flooding the receiver with frames faster than the latter is able to process them\n This situation can easily happen in practice so being able to prevent it is of great importance\n THE DATA LINK LAYER  \n  The communication channel is still assumed to be error free  however  and the data traffic is still simplex\n One solution is to build the receiver to be powerful enough to process a continuous stream of back-to-back frames (or  equivalently  define the link layer to be slow enough that the receiver can keep up)\n It must have sufficient buffering and processing abilities to run at the line rate and must be able to pass the frames that are received to the network layer quickly enough\n However  this is a worst-case solution\n It requires dedicated hardware and can be wasteful of resources if the utilization of the link is mostly low\n Moreover  it just shifts the problem of dealing with a sender that is too fast elsewhere; in this case to the network layer\n A more general solution to this problem is to have the receiver provide feedback to the sender\n After having passed a packet to its network layer  the receiver sends a little dummy frame back to the sender which  in effect  gives the sender permission to transmit the next frame\n After having sent a frame  the sender is required by the protocol to bide its time until the little dummy ( \n  acknowledgement) frame arrives\n This delay is a simple example of a flow control protocol\n Protocols in which the sender sends one frame and then waits for an acknowledgement before proceeding are called stop-and-wait\n Figure  -  gives an example of a simplex stop-and-wait protocol\n Although data traffic in this example is simplex  going only from the sender to the receiver  frames do travel in both directions\n Consequently  the communication channel between the two data link layers needs to be capable of bidirectional information transfer\n However  this protocol entails a strict alternation of flow: first the sender sends a frame  then the receiver sends a frame  then the sender sends another frame  then the receiver sends another one  and so on\n A halfduplex physical channel would suffice here\n As in protocol   the sender starts out by fetching a packet from the network layer  using it to construct a frame  and sending it on its way\n But now  unlike in protocol   the sender must wait until an acknowledgement frame arrives before looping back and fetching the next packet from the network layer\n The sending data link layer need not even inspect the incoming frame as there is only one possibility\n The incoming frame is always an acknowledgement\n The only difference between receiver  and receiver  is that after delivering a packet to the network layer  receiver  sends an acknowledgement frame back to the sender before entering the wait loop again\n Because only the arrival of the frame back at the sender is important  not its contents  the receiver need not put any particular information in it\n    A Simplex Stop-and-Wait Protocol for a Noisy Channel Now let us consider the normal situation of a communication channel that makes errors\n Frames may be either damaged or lost completely\n However  we assume that if a frame is damaged in transit  the receiver hardware will detect this   ELEMENTARY DATA LINK PROTOCOLS /* Protocol  (Stop-and-wait) also provides for a one-directional flow of data from sender to receiver\n The communication channel is once again assumed to be error free  as in protocol  \n However  this time the receiver has only a finite buffer capacity and a finite processing speed  so the protocol must explicitly prevent the sender from flooding the receiver with data faster than it can be handled\n */ typedef enum {frame arrival} event type; #include " " void sender (void) { frame s; /* buffer for an outbound frame */ packet buffer; /* buffer for an outbound packet */ event type event; /* frame arrival is the only possibility */ while (true) { from network layer(&buffer); /* go get something to send */   = buffer; /* copy it into s for transmission */ to physical layer(&s); /* bye-bye little frame */ wait for event(&event); /* do not proceed until given the go ahead */ } } void receiver (void) { frame r  s; /* buffers for frames */ event type event; /* frame arrival is the only possibility */ while (true) { wait for event(&event); /* only possibility is frame arrival */ from physical layer(&r); /* go get the inbound frame */ to network layer(& ); /* pass the data to the network layer */ to physical layer(&s); /* send a dummy frame to awaken sender */ } } Figure  -  \n A simplex stop-and-wait protocol\n when it computes the checksum\n If the frame is damaged in such a way that the checksum is nevertheless correct—an unlikely occurrence—this protocol (and all other protocols) can fail ( \n  deliver an incorrect packet to the network layer)\n At first glance it might seem that a variation of protocol  would work: adding a timer\n The sender could send a frame  but the receiver would only send an acknowledgement frame if the data were correctly received\n If a damaged frame arrived at the receiver  it would be discarded\n After a while the sender would time out and send the frame again\n This process would be repeated until the frame finally arrived intact\n This scheme has a fatal flaw in it though\n Think about the problem and try to discover what might go wrong before reading further\n THE DATA LINK LAYER  \n  To see what might go wrong  remember that the goal of the data link layer is to provide error-free  transparent communication between network layer processes\n The network layer on machine A gives a series of packets to its data link layer  which must ensure that an identical series of packets is delivered to the network layer on machine B by its data link layer\n In particular  the network layer on B has no way of knowing that a packet has been lost or duplicated  so the data link layer must guarantee that no combination of transmission errors  however unlikely  can cause a duplicate packet to be delivered to a network layer\n Consider the following scenario:  \n The network layer on A gives packet  to its data link layer\n The packet is correctly received at B and passed to the network layer on B\n B sends an acknowledgement frame back to A The acknowledgement frame gets lost completely\n It just never arrives at all\n Life would be a great deal simpler if the channel mangled and lost only data frames and not control frames  but sad to say  the channel is not very discriminating The data link layer on A eventually times out\n Not having received an acknowledgement  it (incorrectly) assumes that its data frame was lost or damaged and sends the frame containing packet  again The duplicate frame also arrives intact at the data link layer on B and is unwittingly passed to the network layer there\n If A is sending a file to B  part of the file will be duplicated ( \n  the copy of the file made by B will be incorrect and the error will not have been detected)\n In other words  the protocol will fail\n Clearly  what is needed is some way for the receiver to be able to distinguish a frame that it is seeing for the first time from a retransmission\n The obvious way to achieve this is to have the sender put a sequence number in the header of each frame it sends\n Then the receiver can check the sequence number of each arriving frame to see if it is a new frame or a duplicate to be discarded\n Since the protocol must be correct and the sequence number field in the header is likely to be small to use the link efficiently  the question arises: what is the minimum number of bits needed for the sequence number? The header might provide  bit  a few bits   byte  or multiple bytes for a sequence number depending on the protocol\n The important point is that it must carry sequence numbers that are large enough for the protocol to work correctly  or it is not much of a protocol\n The only ambiguity in this protocol is between a frame  m  and its direct successor  m +  \n If frame m is lost or damaged  the receiver will not acknowledge it  so the sender will keep trying to send it\n Once it has been correctly received  the receiver will send an acknowledgement to the sender\n It is here that the potential   ELEMENTARY DATA LINK PROTOCOLS trouble crops up\n Depending upon whether the acknowledgement frame gets back to the sender correctly or not  the sender may try to send m or m +  \n At the sender  the event that triggers the transmission of frame m +  is the arrival of an acknowledgement for frame m\n But this situation implies that m −  has been correctly received  and furthermore that its acknowledgement has also been correctly received by the sender\n Otherwise  the sender would not have begun with m  let alone have been considering m +  \n As a consequence  the only ambiguity is between a frame and its immediate predecessor or successor  not between the predecessor and successor themselves\n A  -bit sequence number (  or  ) is therefore sufficient\n At each instant of time  the receiver expects a particular sequence number next\n When a frame containing the correct sequence number arrives  it is accepted and passed to the network layer  then acknowledged\n Then the expected sequence number is incremented modulo  ( \n   becomes  and  becomes  )\n Any arriving frame containing the wrong sequence number is rejected as a duplicate\n However  the last valid acknowledgement is repeated so that the sender can eventually discover that the frame has been received\n An example of this kind of protocol is shown in Fig\n  -  \n Protocols in which the sender waits for a positive acknowledgement before advancing to the next data item are often called ARQ (Automatic Repeat reQuest) or PAR (Positive Acknowledgement with Retransmission)\n Like protocol   this one also transmits data only in one direction\n Protocol  differs from its predecessors in that both sender and receiver have a variable whose value is remembered while the data link layer is in the wait state\n The sender remembers the sequence number of the next frame to send in next frame to send; the receiver remembers the sequence number of the next frame expected in frame expected\n Each protocol has a short initialization phase before entering the infinite loop\n After transmitting a frame  the sender starts the timer running\n If it was already running  it will be reset to allow another full timer interval\n The interval should be chosen to allow enough time for the frame to get to the receiver  for the receiver to process it in the worst case  and for the acknowledgement frame to propagate back to the sender\n Only when that interval has elapsed is it safe to assume that either the transmitted frame or its acknowledgement has been lost  and to send a duplicate\n If the timeout interval is set too short  the sender will transmit unnecessary frames\n While these extra frames will not affect the correctness of the protocol  they will hurt performance\n After transmitting a frame and starting the timer  the sender waits for something exciting to happen\n Only three possibilities exist: an acknowledgement frame arrives undamaged  a damaged acknowledgement frame staggers in  or the timer expires\n If a valid acknowledgement comes in  the sender fetches the next packet from its network layer and puts it in the buffer  overwriting the previous packet\n It also advances the sequence number\n If a damaged frame arrives or the THE DATA LINK LAYER  \n  timer expires  neither the buffer nor the sequence number is changed so that a duplicate can be sent\n In all cases  the contents of the buffer (either the next packet or a duplicate) are then sent\n When a valid frame arrives at the receiver  its sequence number is checked to see if it is a duplicate\n If not  it is accepted  passed to the network layer  and an acknowledgement is generated\n Duplicates and damaged frames are not passed to the network layer  but they do cause the last correctly received frame to be acknowledged to signal the sender to advance to the next frame or retransmit a damaged frame  SLIDING WINDOW PROTOCOLS In the previous protocols  data frames were transmitted in one direction only\n In most practical situations  there is a need to transmit data in both directions\n One way of achieving full-duplex data transmission is to run two instances of one of the previous protocols  each using a separate link for simplex data traffic (in different directions)\n Each link is then comprised of a ‘‘forward’’ channel (for data) and a ‘‘reverse’’ channel (for acknowledgements)\n In both cases the capacity of the reverse channel is almost entirely wasted\n A better idea is to use the same link for data in both directions\n After all  in protocols  and  it was already being used to transmit frames both ways  and the reverse channel normally has the same capacity as the forward channel\n In this model the data frames from A to B are intermixed with the acknowledgement frames from A to B\n By looking at the kind field in the header of an incoming frame  the receiver can tell whether the frame is data or an acknowledgement\n Although interleaving data and control frames on the same link is a big improvement over having two separate physical links  yet another improvement is possible\n When a data frame arrives  instead of immediately sending a separate control frame  the receiver restrains itself and waits until the network layer passes it the next packet\n The acknowledgement is attached to the outgoing data frame (using the ack field in the frame header)\n In effect  the acknowledgement gets a free ride on the next outgoing data frame\n The technique of temporarily delaying outgoing acknowledgements so that they can be hooked onto the next outgoing data frame is known as piggybacking\n The principal advantage of using piggybacking over having distinct acknowledgement frames is a better use of the available channel bandwidth\n The ack field in the frame header costs only a few bits  whereas a separate frame would need a header  the acknowledgement  and a checksum\n In addition  fewer frames sent generally means a lighter processing load at the receiver\n In the next protocol to be examined  the piggyback field costs only  bit in the frame header\n It rarely costs more than a few bits\n However  piggybacking introduces a complication not present with separate acknowledgements\n How long should the data link layer wait for a packet onto   SLIDING WINDOW PROTOCOLS /* Protocol  (PAR) allows unidirectional data flow over an unreliable channel\n */ #define MAX SEQ  /* must be  for protocol  */ typedef enum {frame arrival  cksum err  timeout} event type; #include " " void sender (void) { seq nr next frame to send; /* seq number of next outgoing frame */ frame s; /* scratch variable */ packet buffer; /* buffer for an outbound packet */ event type event; next frame to send =  ; /* initialize outbound sequence numbers */ from network layer(&buffer); /* fetch first packet */ while (true) {   = buffer; /* construct a frame for transmission */   = next frame to send; /* insert sequence number in frame */ to physical layer(&s); /* send it on its way */ start timer( ); /* if answer takes too long  time out */ wait for event(&event); /* frame arrival  cksum err  timeout */ if (event == frame arrival) { from physical layer(&s); /* get the acknowledgement */ if (  == next frame to send) { stop timer( ); /* turn the timer off */ from network layer(&buffer); /* get the next one to send */ inc(next frame to send); /* invert next frame to send */ } } } } void receiver (void) { seq nr frame expected; frame r  s; event type event; frame expected =  ; while (true) { wait for event(&event); /* possibilities: frame arrival  cksum err */ if (event == frame arrival) { /* a valid frame has arrived */ from physical layer(&r); /* go get the newly arrived frame */ if (  == frame expected) { /* this is what we have been waiting for */ to network layer(& ); /* pass the data to the network layer */ inc(frame expected); /* next time expect the other sequence nr */ }   =  − frame expected; /* tell which frame is being acked */ to physical layer(&s); /* send acknowledgement */ } } } Figure  -  \n A positive acknowledgement with retransmission protocol\n THE DATA LINK LAYER  \n  which to piggyback the acknowledgement? If the data link layer waits longer than the sender’s timeout period  the frame will be retransmitted  defeating the whole purpose of having acknowledgements\n If the data link layer were an oracle and could foretell the future  it would know when the next network layer packet was going to come in and could decide either to wait for it or send a separate acknowledgement immediately  depending on how long the projected wait was going to be\n Of course  the data link layer cannot foretell the future  so it must resort to some ad hoc scheme  such as waiting a fixed number of millionds\n If a new packet arrives quickly  the acknowledgement is piggybacked onto it\n Otherwise  if no new packet has arrived by the end of this time period  the data link layer just sends a separate acknowledgement frame\n The next three protocols are bidirectional protocols that belong to a class called sliding window protocols\n The three differ among themselves in terms of efficiency  complexity  and buffer requirements  as discussed later\n In these  as in all sliding window protocols  each outbound frame contains a sequence number  ranging from  up to some maximum\n The maximum is usually  n −  so the sequence number fits exactly in an n-bit field\n The stop-and-wait sliding window protocol uses n =   restricting the sequence numbers to  and   but more sophisticated versions can use an arbitrary n\n The essence of all sliding window protocols is that at any instant of time  the sender maintains a set of sequence numbers corresponding to frames it is permitted to send\n These frames are said to fall within the sending window\n Similarly  the receiver also maintains a receiving window corresponding to the set of frames it is permitted to accept\n The sender’s window and the receiver’s window need not have the same lower and upper limits or even have the same size\n In some protocols they are fixed in size  but in others they can grow or shrink over the course of time as frames are sent and received\n Although these protocols give the data link layer more freedom about the order in which it may send and receive frames  we have definitely not dropped the requirement that the protocol must deliver packets to the destination network layer in the same order they were passed to the data link layer on the sending machine\n Nor have we changed the requirement that the physical communication channel is ‘‘wire-like ’’ that is  it must deliver all frames in the order sent\n The sequence numbers within the sender’s window represent frames that have been sent or can be sent but are as yet not acknowledged\n Whenever a new packet arrives from the network layer  it is given the next highest sequence number  and the upper edge of the window is advanced by one\n When an acknowledgement comes in  the lower edge is advanced by one\n In this way the window continuously maintains a list of unacknowledged frames\n Figure  -  shows an example\n Since frames currently within the sender’s window may ultimately be lost or damaged in transit  the sender must keep all of these frames in its memory for possible retransmission\n Thus  if the maximum window size is n  the sender needs n buffers to hold the unacknowledged frames\n If the window ever grows to its   SLIDING WINDOW PROTOCOLS Sender Receiver                    (a) (b) (c) (d) Figure  -  \n A sliding window of size   with a  -bit sequence number\n (a) Initially\n (b) After the first frame has been sent\n (c) After the first frame has been received\n (d) After the first acknowledgement has been received\n maximum size  the sending data link layer must forcibly shut off the network layer until another buffer becomes free\n The receiving data link layer’s window corresponds to the frames it may accept\n Any frame falling within the window is put in the receiver’s buffer\n When a frame whose sequence number is equal to the lower edge of the window is received  it is passed to the network layer and the window is rotated by one\n Any frame falling outside the window is discarded\n In all of these cases  a subsequent acknowledgement is generated so that the sender may work out how to proceed\n Note that a window size of  means that the data link layer only accepts frames in order  but for larger windows this is not so\n The network layer  in contrast  is always fed data in the proper order  regardless of the data link layer’s window size\n Figure  -  shows an example with a maximum window size of  \n Initially  no frames are outstanding  so the lower and upper edges of the sender’s window are equal  but as time goes on  the situation progresses as shown\n Unlike the sender’s window  the receiver’s window always remains at its initial size  rotating as the next frame is accepted and delivered to the network layer\n    A One-Bit Sliding Window Protocol Before tackling the general case  let us examine a sliding window protocol with a window size of  \n Such a protocol uses stop-and-wait since the sender transmits a frame and waits for its acknowledgement before sending the next one\n THE DATA LINK LAYER  \n  Figure  -  depicts such a protocol\n Like the others  it starts out by defining some variables\n Next frame to send tells which frame the sender is trying to send\n Similarly  frame expected tells which frame the receiver is expecting\n In both cases   and  are the only possibilities\n /* Protocol  (Sliding window) is bidirectional\n */ #define MAX SEQ  /* must be  for protocol  */ typedef enum {frame arrival  cksum err  timeout} event type; #include " " void protocol  (void) { seq nr next frame to send; /*  or  only */ seq nr frame expected; /*  or  only */ frame r  s; /* scratch variables */ packet buffer; /* current packet being sent */ event type event; next frame to send =  ; /* next frame on the outbound stream */ frame expected =  ; /* frame expected next */ from network layer(&buffer); /* fetch a packet from the network layer */   = buffer; /* prepare to send the initial frame */   = next frame to send; /* insert sequence number into frame */   =  − frame expected; /* piggybacked ack */ to physical layer(&s); /* transmit the frame */ start timer( ); /* start the timer running */ while (true) { wait for event(&event); /* frame arrival  cksum err  or timeout */ if (event == frame arrival) { /* a frame has arrived undamaged */ from physical layer(&r); /* go get it */ if (  == frame expected) { /* handle inbound frame stream */ to network layer(& ); /* pass packet to network layer */ inc(frame expected); /* invert seq number expected next */ } if (  == next frame to send) { /* handle outbound frame stream */ stop timer( ); /* turn the timer off */ from network layer(&buffer); /* fetch new pkt from network layer */ inc(next frame to send); /* invert sender’s sequence number */ } }   = buffer; /* construct outbound frame */   = next frame to send; /* insert sequence number into it */   =  − frame expected; /* seq number of last received frame */ to physical layer(&s); /* transmit a frame */ start timer( ); /* start the timer running */ } } Figure  -  \n A  -bit sliding window protocol\n   SLIDING WINDOW PROTOCOLS Under normal circumstances  one of the two data link layers goes first and transmits the first frame\n In other words  only one of the data link layer programs should contain the to physical layer and start timer procedure calls outside the main loop\n The starting machine fetches the first packet from its network layer  builds a frame from it  and sends it\n When this (or any) frame arrives  the receiving data link layer checks to see if it is a duplicate  just as in protocol  \n If the frame is the one expected  it is passed to the network layer and the receiver’s window is slid up\n The acknowledgement field contains the number of the last frame received without error\n If this number agrees with the sequence number of the frame the sender is trying to send  the sender knows it is done with the frame stored in buffer and can fetch the next packet from its network layer\n If the sequence number disagrees  it must continue trying to send the same frame\n Whenever a frame is received  a frame is also sent back\n Now let us examine protocol  to see how resilient it is to pathological scenarios\n Assume that computer A is trying to send its frame  to computer B and that B is trying to send its frame  to A\n Suppose that A sends a frame to B  but A’s timeout interval is a little too short\n Consequently  A may time out repeatedly  sending a series of identical frames  all with seq =  and ack =  \n When the first valid frame arrives at computer B  it will be accepted and frame expected will be set to a value of  \n All the subsequent frames received will be rejected because B is now expecting frames with sequence number   not  \n Furthermore  since all the duplicates will have ack =  and B is still waiting for an acknowledgement of   B will not go and fetch a new packet from its network layer\n After every rejected duplicate comes in  B will send A a frame containing seq =  and ack =  \n Eventually  one of these will arrive correctly at A  causing A to begin sending the next packet\n No combination of lost frames or premature timeouts can cause the protocol to deliver duplicate packets to either network layer  to skip a packet  or to deadlock\n The protocol is correct\n However  to show how subtle protocol interactions can be  we note that a peculiar situation arises if both sides simultaneously send an initial packet\n This synchronization difficulty is illustrated by Fig\n  -  \n In part (a)  the normal operation of the protocol is shown\n In (b) the peculiarity is illustrated\n If B waits for A’s first frame before sending one of its own  the sequence is as shown in (a)  and every frame is accepted\n However  if A and B simultaneously initiate communication  their first frames cross  and the data link layers then get into situation (b)\n In (a) each frame arrival brings a new packet for the network layer; there are no duplicates\n In (b) half of the frames contain duplicates  even though there are no transmission errors\n Similar situations can occur as a result of premature timeouts  even when one side clearly starts first\n In fact  if multiple premature timeouts occur  frames may be sent three or more times  wasting valuable bandwidth\n THE DATA LINK LAYER  \n  A sends (  A ) A gets (  B )* A sends (  A ) B gets (  A )* B sends (  B ) B gets (  A )* B sends (  B ) B gets (  A )* B sends (  B ) B gets (  A )* B sends (  B ) A gets (  B )* A sends (  A ) A gets (  B )* A sends (  A ) A sends (  A ) A gets (  B )* A sends (  A ) B gets (  A ) B sends (  B ) B sends (  B ) B gets (  A )* B sends (  B ) B gets (  A )* B sends (  B ) B gets (  A ) B sends (  B ) A gets (  B ) A sends (  A ) A gets (  B )* A sends (  A ) Time (a) (b) Figure  -  \n Two scenarios for protocol  \n (a) Normal case\n (b) Abnormal case\n The notation is (seq  ack  packet number)\n An asterisk indicates where a network layer accepts a packet\n    A Protocol Using Go-Back-N Until now we have made the tacit assumption that the transmission time required for a frame to arrive at the receiver plus the transmission time for the acknowledgement to come back is negligible\n Sometimes this assumption is clearly false\n In these situations the long round-trip time can have important implications for the efficiency of the bandwidth utilization\n As an example  consider a  -kbps satellite channel with a   -m round-trip propagation delay\n Let us imagine trying to use protocol  to send -bit frames via the satellite\n At t =  the sender starts sending the first frame\n At t =   m the frame has been completely sent\n Not until t = m has the frame fully arrived at the receiver  and not until t = m has the acknowledgement arrived back at the sender  under the best of circumstances (of no waiting in the receiver and a short acknowledgement frame)\n This means that the sender was blocked   /   or  % of the time\n In other words  only  % of the available bandwidth was used\n Clearly  the combination of a long transit time  high bandwidth  and short frame length is disastrous in terms of efficiency\n The problem described here can be viewed as a consequence of the rule requiring a sender to wait for an acknowledgement before sending another frame\n If we relax that restriction  much better efficiency can be achieved\n Basically  the solution lies in allowing the sender to transmit up to w frames before blocking  instead of just  \n With a large enough choice of w the sender will be able to continuously transmit frames since the acknowledgements will arrive for previous frames before the window becomes full  preventing the sender from blocking\n   SLIDING WINDOW PROTOCOLS To find an appropriate value for w we need to know how many frames can fit inside the channel as they propagate from sender to receiver\n This capacity is determined by the bandwidth in bits/ multiplied by the one-way transit time  or the bandwidth-delay product of the link\n We can divide this quantity by the number of bits in a frame to express it as a number of frames\n Call this quantity BD\n Then w should be set to  BD +  \n Twice the bandwidth-delay is the number of frames that can be outstanding if the sender continuously sends frames when the round-trip time to receive an acknowledgement is considered\n The ‘‘+ ’’ is because an acknowledgement frame will not be sent until after a complete frame is received\n For the example link with a bandwidth of   kbps and a one-way transit time of m  the bandwidth-delay product is  \n  kbit or  \n  frames of  bits each\n  BD +  is then   frames\n Assume the sender begins sending frame  as before and sends a new frame every   m\n By the time it has finished sending   frames  at t = m  the acknowledgement for frame  will have just arrived\n Thereafter  acknowledgements will arrive every   m  so the sender will always get permission to continue just when it needs it\n From then onwards or   unacknowledged frames will always be outstanding\n Put in other terms  the sender’s maximum window size is  \n For smaller window sizes  the utilization of the link will be less than   % since the sender will be blocked sometimes\n We can write the utilization as the fraction of time that the sender is not blocked: link utilization ≤  +  BD w This value is an upper bound because it does not allow for any frame processing time and treats the acknowledgement frame as having zero length  since it is usually short\n The equation shows the need for having a large window w whenever the bandwidth-delay product is large\n If the delay is high  the sender will rapidly exhaust its window even for a moderate bandwidth  as in the satellite example\n If the bandwidth is high  even for a moderate delay the sender will exhaust its window quickly unless it has a large window ( \n  a  -Gbps link with  -m delay holds  megabit)\n With stop-and-wait for which w =   if there is even one frame’s worth of propagation delay the efficiency will be less than  %\n This technique of keeping multiple frames in flight is an example of pipelining\n Pipelining frames over an unreliable communication channel raises some serious issues\n First  what happens if a frame in the middle of a long stream is damaged or lost? Large numbers of succeeding frames will arrive at the receiver before the sender even finds out that anything is wrong\n When a damaged frame arrives at the receiver  it obviously should be discarded  but what should the receiver do with all the correct frames following it? Remember that the receiving data link layer is obligated to hand packets to the network layer in sequence\n THE DATA LINK LAYER  \n  Two basic approaches are available for dealing with errors in the presence of pipelining  both of which are shown in Fig\n  -  \n    E D D D D D D      Timeout interval Error Frames discarded by data link layer Frames buffered by data link layer Ack  Ack  Time (a) (b)    E        Error Ack  Ack  Nak    Ack  Ack Ack  Ack  Ack  Ack   Ack   Ack   Ack   Ack  Ack  Ack  Ack  Ack  Ack  Figure  -  \n Pipelining and error recovery\n Effect of an error when (a) receiver’s window size is  and (b) receiver’s window size is large\n One option  called go-back-n  is for the receiver simply to discard all subsequent frames  sending no acknowledgements for the discarded frames\n This strategy corresponds to a receive window of size  \n In other words  the data link layer refuses to accept any frame except the next one it must give to the network layer\n If the sender’s window fills up before the timer runs out  the pipeline will begin to empty\n Eventually  the sender will time out and retransmit all unacknowledged frames in order  starting with the damaged or lost one\n This approach can waste a lot of bandwidth if the error rate is high\n In Fig\n  -  (b) we see go-back-n for the case in which the receiver’s window is large\n Frames  and  are correctly received and acknowledged\n Frame   however  is damaged or lost\n The sender  unaware of this problem  continues to send frames until the timer for frame  expires\n Then it backs up to frame  and starts over with it  sending  etc\n all over again\n The other general strategy for handling errors when frames are pipelined is called selective repeat\n When it is used  a bad frame that is received is discarded  but any good frames received after it are accepted and buffered\n When the sender times out  only the oldest unacknowledged frame is retransmitted\n If that frame   SLIDING WINDOW PROTOCOLS arrives correctly  the receiver can deliver to the network layer  in sequence  all the frames it has buffered\n Selective repeat corresponds to a receiver window larger than  \n This approach can require large amounts of data link layer memory if the window is large\n Selective repeat is often combined with having the receiver send a negative acknowledgement (NAK) when it detects an error  for example  when it receives a checksum error or a frame out of sequence\n NAKs stimulate retransmission before the corresponding timer expires and thus improve performance\n In Fig\n  -  (b)  frames  and  are again correctly received and acknowledged and frame  is lost\n When frame  arrives at the receiver  the data link layer there notices that it has missed a frame  so it sends back a NAK for  but buffers  \n When frames  and  arrive  they  too  are buffered by the data link layer instead of being passed to the network layer\n Eventually  the NAK  gets back to the sender  which immediately resends frame  \n When that arrives  the data link layer now has  and  and can pass all of them to the network layer in the correct order\n It can also acknowledge all frames up to and including   as shown in the figure\n If the NAK should get lost  eventually the sender will time out for frame  and send it (and only it) of its own accord  but that may be a quite a while later\n These two alternative approaches are trade-offs between efficient use of bandwidth and data link layer buffer space\n Depending on which resource is scarcer  one or the other can be used\n Figure  -  shows a go-back-n protocol in which the receiving data link layer only accepts frames in order; frames following an error are discarded\n In this protocol  for the first time we have dropped the assumption that the network layer always has an infinite supply of packets to send\n When the network layer has a packet it wants to send  it can cause a network layer ready event to happen\n However  to enforce the flow control limit on the sender window or the number of unacknowledged frames that may be outstanding at any time  the data link layer must be able to keep the network layer from bothering it with more work\n The library procedures enable network layer and disable network layer do this job\n The maximum number of frames that may be outstanding at any instant is not the same as the size of the sequence number space\n For go-back-n  MAX SEQ frames may be outstanding at any instant  even though there are MAX SEQ +  distinct sequence numbers (which are   \n  MAX SEQ)\n We will see an even tighter restriction for the next protocol  selective repeat\n To see why this restriction is required  consider the following scenario with MAX SEQ =  :  \n The sender sends frames  through   A piggybacked acknowledgement for  comes back to the sender The sender sends another eight frames  again with sequence numbers  through   Now another piggybacked acknowledgement for frame  comes in\n THE DATA LINK LAYER  \n  /* Protocol  (Go-back-n) allows multiple outstanding frames\n The sender may transmit up to MAX SEQ frames without waiting for an ack\n In addition  unlike in the previous protocols  the network layer is not assumed to have a new packet all the time\n Instead  the network layer causes a network layer ready event when there is a packet to send\n */ #define MAX SEQ  typedef enum {frame arrival  cksum err  timeout  network layer ready} event type; #include " " static boolean between(seq nr a  seq nr b  seq nr c) { /* Return true if a <= b < c circularly; false otherwise\n */ if (((a <= b) && (b < c)) || ((c < a) && (a <= b)) || ((b < c) && (c < a))) return(true); else return(false); } static void send data(seq nr frame nr  seq nr frame expected  packet buffer[ ]) { /* Construct and send a data frame\n */ frame s; /* scratch variable */   = buffer[frame nr]; /* insert packet into frame */   = frame nr; /* insert sequence number into frame */   = (frame expected + MAX SEQ) % (MAX SEQ +  ); /* piggyback ack */ to physical layer(&s); /* transmit the frame */ start timer(frame nr); /* start the timer running */ } void protocol (void) { seq nr next frame to send; /* MAX SEQ >  ; used for outbound stream */ seq nr ack expected; /* oldest frame as yet unacknowledged */ seq nr frame expected; /* next frame expected on inbound stream */ frame r; /* scratch variable */ packet buffer[MAX SEQ +  ]; /* buffers for the outbound stream */ seq nr nbuffered; /* number of output buffers currently in use */ seq nr i; /* used to index into the buffer array */ event type event; enable network layer(); /* allow network layer ready events */ ack expected =  ; /* next ack expected inbound */ next frame to send =  ; /* next frame going out */ frame expected =  ; /* number of frame expected inbound */ nbuffered =  ; /* initially no packets are buffered */ while (true) { wait for event(&event); /* four possibilities: see event type above */   SLIDING WINDOW PROTOCOLS switch(event) { case network layer ready: /* the network layer has a packet to send */ /* Accept  save  and transmit a new frame\n */ from network layer(&buffer[next frame to send]); /* fetch new packet */ nbuffered = nbuffered +  ; /* expand the sender’s window */ send data(next frame to send  frame expected  buffer);/* transmit the frame */ inc(next frame to send); /* advance sender’s upper window edge */ break; case frame arrival: /* a data or control frame has arrived */ from physical layer(&r); /* get incoming frame from physical layer */ if (  == frame expected) { /* Frames are accepted only in order\n */ to network layer(& ); /* pass packet to network layer */ inc(frame expected); /* advance lower edge of receiver’s window */ } /* Ack n implies n −   n −   etc\n Check for this\n */ while (between(ack expected     next frame to send)) { /* Handle piggybacked ack\n */ nbuffered = nbuffered −  ; /* one frame fewer buffered */ stop timer(ack expected); /* frame arrived intact; stop timer */ inc(ack expected); /* contract sender’s window */ } break; case cksum err: break; /* just ignore bad frames */ case timeout: /* trouble; retransmit all outstanding frames */ next frame to send = ack expected; /* start retransmitting here */ for (i =  ; i <= nbuffered; i++) { send data(next frame to send  frame expected  buffer);/* resend frame */ inc(next frame to send); /* prepare to send the next one */ } } if (nbuffered < MAX SEQ) enable network layer(); else disable network layer(); } } Figure  -  \n A sliding window protocol using go-back-n\n The question is this: did all eight frames belonging to the ond batch arrive successfully  or did all eight get lost (counting discards following an error as lost)? In both cases the receiver would be sending frame  as the acknowledgement\n THE DATA LINK LAYER  \n  The sender has no way of telling\n For this reason the maximum number of outstanding frames must be restricted to MAX SEQ\n Although protocol  does not buffer the frames arriving after an error  it does not escape the problem of buffering altogether\n Since a sender may have to retransmit all the unacknowledged frames at a future time  it must hang on to all transmitted frames until it knows for sure that they have been accepted by the receiver\n When an acknowledgement comes in for frame n  frames n −   n −   and so on are also automatically acknowledged\n This type of acknowledgement is called a cumulative acknowledgement\n This property is especially important when some of the previous acknowledgement-bearing frames were lost or garbled\n Whenever any acknowledgement comes in  the data link layer checks to see if any buffers can now be released\n If buffers can be released ( \n  there is some room available in the window)  a previously blocked network layer can now be allowed to cause more network layer ready events\n For this protocol  we assume that there is always reverse traffic on which to piggyback acknowledgements\n Protocol  does not need this assumption since it sends back one frame every time it receives a frame  even if it has already sent that frame\n In the next protocol we will solve the problem of one-way traffic in an elegant way\n Because protocol  has multiple outstanding frames  it logically needs multiple timers  one per outstanding frame\n Each frame times out independently of all the other ones\n However  all of these timers can easily be simulated in software using a single hardware clock that causes interrupts periodically\n The pending timeouts form a linked list  with each node of the list containing the number of clock ticks until the timer expires  the frame being timed  and a pointer to the next node\n  :  :  \n  :  :  \n      Real time Pointer to next timeout Frame being timed Ticks to go (a) (b) Figure  -  \n Simulation of multiple timers in software\n (a) The queued timeouts\n (b) The situation after the first timeout has expired\n As an illustration of how the timers could be implemented  consider the example of Fig\n  -  (a)\n Assume that the clock ticks once every  m\n Initially    SLIDING WINDOW PROTOCOLS the real time is  :  :  \n  ; three timeouts are pending  at  :  :  \n  :  :  \n and  :  :   Every time the hardware clock ticks  the real time is updated and the tick counter at the head of the list is decremented\n When the tick counter becomes zero  a timeout is caused and the node is removed from the list  as shown in Fig\n  -  (b)\n Although this organization requires the list to be scanned when start timer or stop timer is called  it does not require much work per tick\n In protocol   both of these routines have been given a parameter indicating which frame is to be timed\n    A Protocol Using Selective Repeat The go-back-n protocol works well if errors are rare  but if the line is poor it wastes a lot of bandwidth on retransmitted frames\n An alternative strategy  the selective repeat protocol  is to allow the receiver to accept and buffer the frames following a damaged or lost one\n In this protocol  both sender and receiver maintain a window of outstanding and acceptable sequence numbers  respectively\n The sender’s window size starts out at  and grows to some predefined maximum\n The receiver’s window  in contrast  is always fixed in size and equal to the predetermined maximum\n The receiver has a buffer reserved for each sequence number within its fixed window\n Associated with each buffer is a bit (arrived ) telling whether the buffer is full or empty\n Whenever a frame arrives  its sequence number is checked by the function between to see if it falls within the window\n If so and if it has not already been received  it is accepted and stored\n This action is taken without regard to whether or not the frame contains the next packet expected by the network layer\n Of course  it must be kept within the data link layer and not passed to the network layer until all the lower-numbered frames have already been delivered to the network layer in the correct order\n A protocol using this algorithm is given in Fig\n  -  \n Nonsequential receive introduces further constraints on frame sequence numbers compared to protocols in which frames are only accepted in order\n We can illustrate the trouble most easily with an example\n Suppose that we have a  -bit sequence number  so that the sender is permitted to transmit up to seven frames before being required to wait for an acknowledgement\n Initially  the sender’s and receiver’s windows are as shown in Fig\n  -  (a)\n The sender now transmits frames  through  \n The receiver’s window allows it to accept any frame with a sequence number between  and  inclusive\n All seven frames arrive correctly  so the receiver acknowledges them and advances its window to allow receipt of     or   as shown in Fig\n  -  (b)\n All seven buffers are marked empty\n It is at this point that disaster strikes in the form of a lightning bolt hitting the telephone pole and wiping out all the acknowledgements\n The protocol should operate correctly despite this disaster\n The sender eventually times out and retransmits frame  \n When this frame arrives at the receiver  a check is made to see if it falls within the receiver’s window\n Unfortunately  in Fig\n  -  (b) frame  is THE DATA LINK LAYER  \n  /* Protocol  (Selective repeat) accepts frames out of order but passes packets to the network layer in order\n Associated with each outstanding frame is a timer\n When the timer expires  only that frame is retransmitted  not all the outstanding frames  as in protocol  \n */ #define MAX SEQ  /* should be  ˆn −  */ #define NR BUFS ((MAX SEQ +  )/ ) typedef enum {frame arrival  cksum err  timeout  network layer ready  ack timeout} event type; #include " " boolean no nak = true; /* no nak has been sent yet */ seq nr oldest frame = MAX SEQ +  ; /* initial value is only for the simulator */ static boolean between(seq nr a  seq nr b  seq nr c) { /* Same as between in protocol   but shorter and more obscure\n */ return ((a <= b) && (b < c)) || ((c < a) && (a <= b)) || ((b < c) && (c < a)); } static void send frame(frame kind fk  seq nr frame nr  seq nr frame expected  packet buffer[ ]) { /* Construct and send a data  ack  or nak frame\n */ frame s; /* scratch variable */   = fk; /* kind == data  ack  or nak */ if (fk == data)   = buffer[frame nr % NR BUFS];   = frame nr; /* only meaningful for data frames */   = (frame expected + MAX SEQ) % (MAX SEQ +  ); if (fk == nak) no nak = false; /* one nak per frame  please */ to physical layer(&s); /* transmit the frame */ if (fk == data) start timer(frame nr % NR BUFS); stop ack timer(); /* no need for separate ack frame */ } void protocol (void) { seq nr ack expected; /* lower edge of sender’s window */ seq nr next frame to send; /* upper edge of sender’s window +  */ seq nr frame expected; /* lower edge of receiver’s window */ seq nr too far; /* upper edge of receiver’s window +  */ int i; /* index into buffer pool */ frame r; /* scratch variable */ packet out buf[NR BUFS]; /* buffers for the outbound stream */ packet in buf[NR BUFS]; /* buffers for the inbound stream */ boolean arrived[NR BUFS]; /* inbound bit map */ seq nr nbuffered; /* how many output buffers currently used */ event type event; enable network layer(); /* initialize */ ack expected =  ; /* next ack expected on the inbound stream */ next frame to send =  ; /* number of next outgoing frame */ frame expected =  ; too far = NR BUFS; nbuffered =  ; /* initially no packets are buffered */ for (i =  ; i < NR BUFS; i++) arrived[i] = false;   SLIDING WINDOW PROTOCOLS while (true) { wait for event(&event); /* five possibilities: see event type above */ switch(event) { case network layer ready: /* accept  save  and transmit a new frame */ nbuffered = nbuffered +  ; /* expand the window */ from network layer(&out buf[next frame to send % NR BUFS]); /* fetch new packet */ send frame(data  next frame to send  frame expected  out buf);/* transmit the frame */ inc(next frame to send); /* advance upper window edge */ break; case frame arrival: /* a data or control frame has arrived */ from physical layer(&r); /* fetch incoming frame from physical layer */ if (  == data) { /* An undamaged frame has arrived\n */ if ((  != frame expected) && no nak) send frame(nak frame expected  out buf); else start ack timer(); if (between(frame expected   too far) && (arrived[ %NR BUFS]==false)) { /* Frames may be accepted in any order\n */ arrived[  % NR BUFS] = true; /* mark buffer as full */ in buf[  % NR BUFS] =  ; /* insert data into buffer */ while (arrived[frame expected % NR BUFS]) { /* Pass frames and advance window\n */ to network layer(&in buf[frame expected % NR BUFS]); no nak = true; arrived[frame expected % NR BUFS] = false; inc(frame expected); /* advance lower edge of receiver’s window */ inc(too far); /* advance upper edge of receiver’s window */ start ack timer(); /* to see if a separate ack is needed */ } } } if(( ==nak) && between(ack expected ( + )%(MAX SEQ+ ) next frame to send)) send frame(data  ( + ) % (MAX SEQ +  )  frame expected  out buf); while (between(ack expected     next frame to send)) { nbuffered = nbuffered −  ; /* handle piggybacked ack */ stop timer(ack expected % NR BUFS); /* frame arrived intact */ inc(ack expected); /* advance lower edge of sender’s window */ } break; case cksum err: if (no nak) send frame(nak frame expected  out buf); /* damaged frame */ break; case timeout: send frame(data  oldest frame  frame expected  out buf); /* we timed out */ break; case ack timeout: send frame(ack  frame expected  out buf); /* ack timer expired; send ack */ } if (nbuffered < NR BUFS) enable network layer(); else disable network layer(); } } Figure  -  \n A sliding window protocol using selective repeat\n THE DATA LINK LAYER  \n  within the new window  so it is accepted as a new frame\n The receiver also sends a (piggybacked) acknowledgement for frame   since  through  have been received\n The sender is happy to learn that all its transmitted frames did actually arrive correctly  so it advances its window and immediately sends frames     and  \n Frame  will be accepted by the receiver and its packet will be passed directly to the network layer\n Immediately thereafter  the receiving data link layer checks to see if it has a valid frame  already  discovers that it does  and passes the old buffered packet to the network layer as if it were a new packet\n Consequently  the network layer gets an incorrect packet  and the protocol fails\n The essence of the problem is that after the receiver advanced its window  the new range of valid sequence numbers overlapped the old one\n Consequently  the following batch of frames might be either duplicates (if all the acknowledgements were lost) or new ones (if all the acknowledgements were received)\n The poor receiver has no way of distinguishing these two cases\n The way out of this dilemma lies in making sure that after the receiver has advanced its window there is no overlap with the original window\n To ensure that there is no overlap  the maximum window size should be at most half the range of the sequence numbers\n This situation is shown in Fig\n  -  (c) and Fig\n  -  (d)\n With  bits  the sequence numbers range from  to  \n Only four unacknowledged frames should be outstanding at any instant\n That way  if the receiver has just accepted frames  through  and advanced its window to permit acceptance of frames  through   it can unambiguously tell if subsequent frames are retransmissions (  through  ) or new ones (  through  )\n In general  the window size for protocol  will be (MAX SEQ +  )/ \n An interesting question is: how many buffers must the receiver have? Under no conditions will it ever accept frames whose sequence numbers are below the lower edge of the window or frames whose sequence numbers are above the upper edge of the window\n Consequently  the number of buffers needed is equal to the window size  not to the range of sequence numbers\n In the preceding example of a  -bit sequence number  four buffers  numbered  through   are needed\n When frame i arrives  it is put in buffer i mod  \n Notice that although i and (i +  ) mod  are ‘‘competing’’ for the same buffer  they are never within the window at the same time  because that would imply a window size of at least  \n For the same reason  the number of timers needed is equal to the number of buffers  not to the size of the sequence space\n Effectively  a timer is associated with each buffer\n When the timer runs out  the contents of the buffer are retransmitted\n Protocol  also relaxes the implicit assumption that the channel is heavily loaded\n We made this assumption in protocol  when we relied on frames being sent in the reverse direction on which to piggyback acknowledgements\n If the reverse traffic is light  the acknowledgements may be held up for a long period of time  which can cause problems\n In the extreme  if there is a lot of traffic in one   SLIDING WINDOW PROTOCOLS Sender Receiver                    (a) (b) (c) (d) Figure  -  \n (a) Initial situation with a window of size \n (b) After  frames have been sent and received but not acknowledged\n (c) Initial situation with a window size of  \n (d) After  frames have been sent and received but not acknowledged\n direction and no traffic in the other direction  the protocol will block when the sender window reaches its maximum\n To relax this assumption  an auxiliary timer is started by start ack timer after an in-sequence data frame arrives\n If no reverse traffic has presented itself before this timer expires  a separate acknowledgement frame is sent\n An interrupt due to the auxiliary timer is called an ack timeout event\n With this arrangement  traffic flow in only one direction is possible because the lack of reverse data frames onto which acknowledgements can be piggybacked is no longer an obstacle\n Only one auxiliary timer exists  and if start ack timer is called while the timer is running  it has no effect\n The timer is not reset or extended since its purpose is to provide some minimum rate of acknowledgements\n It is essential that the timeout associated with the auxiliary timer be appreciably shorter than the timeout used for timing out data frames\n This condition is required to ensure that a correctly received frame is acknowledged early enough that the frame’s retransmission timer does not expire and retransmit the frame\n Protocol  uses a more efficient strategy than protocol  for dealing with errors\n Whenever the receiver has reason to suspect that an error has occurred  it sends a negative acknowledgement (NAK) frame back to the sender\n Such a frame is a request for retransmission of the frame specified in the NAK\n In two cases  the receiver should be suspicious: when a damaged frame arrives or a frame other than the expected one arrives (potential lost frame)\n To avoid making multiple requests for retransmission of the same lost frame  the receiver should keep track of whether a NAK has already been sent for a given frame\n The variable no nak in protocol  is true if no NAK has been sent yet for frame expected\n If the NAK gets mangled or lost  no real harm is done  since the sender will eventually time out and retransmit the missing frame anyway\n If the wrong frame arrives after a NAK has been sent and lost  no nak will be true and the auxiliary timer will be started\n When it expires  an ACK will be sent to resynchronize the sender to the receiver’s current status\n THE DATA LINK LAYER  \n  In some situations  the time required for a frame to propagate to the destination  be processed there  and have the acknowledgement come back is (nearly) constant\n In these situations  the sender can adjust its timer to be ‘‘tight ’’ just slightly larger than the normal time interval expected between sending a frame and receiving its acknowledgement\n NAKs are not useful in this case\n However  in other situations the time can be highly variable\n For example  if the reverse traffic is sporadic  the time before acknowledgement will be shorter when there is reverse traffic and longer when there is not\n The sender is faced with the choice of either setting the interval to a small value (and risking unnecessary retransmissions)  or setting it to a large value (and going idle for a long period after an error)\n Both choices waste bandwidth\n In general  if the standard deviation of the acknowledgement interval is large compared to the interval itself  the timer is set ‘‘loose’’ to be conservative\n NAKs can then appreciably speed up retransmission of lost or damaged frames\n Closely related to the matter of timeouts and NAKs is the question of determining which frame caused a timeout\n In protocol   it is always ack expected  because it is always the oldest\n In protocol   there is no trivial way to determine who timed out\n Suppose that frames  through  have been transmitted  meaning that the list of outstanding frames is   in order from oldest to youngest\n Now imagine that  times out   (a new frame) is transmitted   times out   times out  and  (another new frame) is transmitted\n At this point the list of outstanding frames is  from oldest to youngest\n If all inbound traffic ( \n  acknowledgement- bearing frames) is lost for a while  the seven outstanding frames will time out in that order\n To keep the example from getting even more complicated than it already is  we have not shown the timer administration\n Instead  we just assume that the variable oldest frame is set upon timeout to indicate which frame timed out  EXAMPLE DATA LINK PROTOCOLS Within a single building  LANs are widely used for interconnection  but most wide-area network infrastructure is built up from point-to-point lines\n In  \n   we will look at LANs\n Here we will examine the data link protocols found on point-to-point lines in the Internet in two common situations\n The first situation is when packets are sent over SONET optical fiber links in wide-area networks\n These links are widely used  for example  to connect routers in the different locations of an ISP’s network\n The ond situation is for ADSL links running on the local loop of the telephone network at the edge of the Internet\n These links connect millions of individuals and businesses to the Internet\n The Internet needs point-to-point links for these uses  as well as dial-up modems  leased lines  and cable modems  and so on\n A standard protocol called PPP   EXAMPLE DATA LINK PROTOCOLS (Point-to-Point Protocol) is used to send packets over these links\n PPP is defined in RFC  and further elaborated in RFC  and other RFCs (Simpson  a  b)\n SONET and ADSL links both apply PPP  but in different ways\n    Packet over SONET SONET  which we covered in \n    is the physical layer protocol that is most commonly used over the wide-area optical fiber links that make up the backbone of communications networks  including the telephone system\n It provides a bitstream that runs at a well-defined rate  for example  \n  Gbps for an OC-  link\n This bitstream is organized as fixed-size byte payloads that recur every μ  whether or not there is user data to send\n To carry packets across these links  some framing mechanism is needed to distinguish occasional packets from the continuous bitstream in which they are transported\n PPP runs on IP routers to provide this mechanism  as shown in Fig\n  -  \n IP SONET PPP Optical fiber Router IP packet PPP frame SONET payload SONET payload (a) (b) IP SONET PPP Figure  -  \n Packet over SONET\n (a) A protocol stack\n (b) Frame relationships\n PPP improves on an earlier  simpler protocol called SLIP (Serial Line Internet Protocol) and is used to handle error detection link configuration  support multiple protocols  permit authentication  and more\n With a wide set of options  PPP provides three main features:  \n A framing method that unambiguously delineates the end of one frame and the start of the next one\n The frame format also handles error detection A link control protocol for bringing lines up  testing them  negotiating options  and bringing them down again gracefully when they are no longer needed\n This protocol is called LCP (Link Control Protocol) A way to negotiate network-layer options in a way that is independent of the network layer protocol to be used\n The method chosen is to have a different NCP (Network Control Protocol) for each network layer supported\n THE DATA LINK LAYER  \n  The PPP frame format was chosen to closely resemble the frame format of HDLC (High-level Data Link Control)  a widely used instance of an earlier family of protocols  since there was no need to reinvent the wheel\n The primary difference between PPP and HDLC is that PPP is byte oriented rather than bit oriented\n In particular  PPP uses byte stuffing and all frames are an integral number of bytes\n HDLC uses bit stuffing and allows frames of  say   \n  bytes\n There is a ond major difference in practice  however\n HDLC provides reliable transmission with a sliding window  acknowledgements  and timeouts in the manner we have studied\n PPP can also provide reliable transmission in noisy environments  such as wireless networks; the exact details are defined in RFC \n However  this is rarely done in practice\n Instead  an ‘‘unnumbered mode’’ is nearly always used in the Internet to provide connectionless unacknowledged service\n The PPP frame format is shown in Fig\n  -  \n All PPP frames begin with the standard HDLC flag byte of  x E (   )\n The flag byte is stuffed if it occurs within the Payload field using the escape byte  x D\n The following byte is the escaped byte XORed with  x   which flips the  th bit\n For example  x D  x E is the escape sequence for the flag byte  x E\n This means the start and end of frames can be searched for simply by scanning for the byte  x E since it will not occur elsewhere\n The destuffing rule when receiving a frame is to look for  x D  remove it  and XOR the following byte with  x  \n Also  only one flag byte is needed between frames\n Multiple flag bytes can be used to fill the link when there are no frames to be sent\n After the start-of-frame flag byte comes the Address field\n This field is always set to the binary value  to indicate that all stations are to accept the frame\n Using this value avoids the issue of having to assign data link addresses\n Flag  Flag  Address  Control Protocol  Payload Checksum Bytes    or  Variable  or Figure  -  \n The PPP full frame format for unnumbered mode operation\n The Address field is followed by the Control field  the default value of which is    \n This value indicates an unnumbered frame\n Since the Address and Control fields are always constant in the default configuration  LCP provides the necessary mechanism for the two parties to negotiate an option to omit them altogether and save  bytes per frame\n The fourth PPP field is the Protocol field\n Its job is to tell what kind of packet is in the Payload field\n Codes starting with a  bit are defined for IP version   IP version   and other network layer protocols that might be used  such as IPX and   EXAMPLE DATA LINK PROTOCOLS AppleTalk\n Codes starting with a  bit are used for PPP configuration protocols  including LCP and a different NCP for each network layer protocol supported\n The default size of the Protocol field is  bytes  but it can be negotiated down to  byte using LCP\n The designers were perhaps overly cautious in thinking that someday there might be more than protocols in use\n The Payload field is variable length  up to some negotiated maximum\n If the length is not negotiated using LCP during line setup  a default length of  bytes is used\n Padding may follow the payload if it is needed\n After the Payload field comes the Checksum field  which is normally  bytes  but a  -byte checksum can be negotiated\n The  -byte checksum is in fact the same  -bit CRC whose generator polynomial is given at the end of \n   \n The  - byte checksum is also an industry-standard CRC\n PPP is a framing mechanism that can carry the packets of multiple protocols over many types of physical layers\n To use PPP over SONET  the choices to make are spelled out in RFC  (Malis and Simpson  )\n A  -byte checksum is used  since this is the primary means of detecting transmission errors over the physical  link  and network layers\n It is recommended that the Address  Control  and Protocol fields not be compressed  since SONET links already run at relatively high rates\n There is also one unusual feature\n The PPP payload is scrambled (as described in \n   ) before it is inserted into the SONET payload\n Scrambling XORs the payload with a long pseudorandom sequence before it is transmitted\n The issue is that the SONET bitstream needs frequent bit transitions for synchronization\n These transitions come naturally with the variation in voice signals  but in data communication the user chooses the information that is sent and might send a packet with a long run of  s\n With scrambling  the likelihood of a user being able to cause problems by sending a long run of  s is made extremely low\n Before PPP frames can be carried over SONET lines  the PPP link must be established and configured\n The phases that the link goes through when it is brought up  used  and taken down again are shown in Fig\n  -  \n The link starts in the DEAD state  which means that there is no connection at the physical layer\n When a physical layer connection is established  the link moves to ESTABLISH\n At this point  the PPP peers exchange a series of LCP packets  each carried in the Payload field of a PPP frame  to select the PPP options for the link from the possibilities mentioned above\n The initiating peer proposes options  and the responding peer either accepts or rejects them  in whole or part\n The responder can also make alternative proposals\n If LCP option negotiation is successful  the link reaches the AUTHENTICATE state\n Now the two parties can check each other’s identities  if desired\n If authentication is successful  the NETWORK state is entered and a series of NCP packets are sent to configure the network layer\n It is difficult to generalize about the NCP protocols because each one is specific to some network layer protocol and allows configuration requests to be made that are specific to that protocol\n THE DATA LINK LAYER  \n  DEAD NETWORK TERMINATE OPEN ESTABLISH AUTHENTICATE Carrier detected Both sides agree on options Authentication successful NCP configuration Carrier dropped Failed Failed Done Figure  -  \n State diagram for bringing a PPP link up and down\n For IP  for example  the assignment of IP addresses to both ends of the link is the most important possibility\n Once OPEN is reached  data transport can take place\n It is in this state that IP packets are carried in PPP frames across the SONET line\n When data transport is finished  the link moves into the TERMINATE state  and from there it moves back to the DEAD state when the physical layer connection is dropped\n    ADSL (Asymmetric Digital Subscriber Loop) ADSL connects millions of home subscribers to the Internet at megabit/ rates over the same telephone local loop that is used for plain old telephone service\n In \n    we described how a device called a DSL modem is added on the home side\n It sends bits over the local loop to a device called a DSLAM (DSL Access Multiplexer)  pronounced ‘‘dee-slam ’’ in the telephone company’s local office\n Now we will explore in more detail how packets are carried over ADSL links\n The overall picture for the protocols and devices used with ADSL is shown in Fig\n  -  \n Different protocols are deployed in different networks  so we have chosen to show the most popular scenario\n Inside the home  a computer such as a PC sends IP packets to the DSL modem using a link layer like Ethernet\n The DSL modem then sends the IP packets over the local loop to the DSLAM using the protocols that we are about to study\n At the DSLAM (or a router connected to it depending on the implementation) the IP packets are extracted and enter an ISP network so that they may reach any destination on the Internet\n The protocols shown over the ADSL link in Fig\n  -  start at the bottom with the ADSL physical layer\n They are based on a digital modulation scheme called   EXAMPLE DATA LINK PROTOCOLS AAL  ADSL Local loop ATM PPP DSLAM (with router) AAL  ADSL ATM PPP DSL modem PC Ethernet Internet Customer’s home ISP’s office Ethernet IP Link IP Figure  -  \n ADSL protocol stacks\n orthogonal frequency division multiplexing (also known as discrete multitone)  as we saw in    \n Near the top of the stack  just below the IP network layer  is PPP\n This protocol is the same PPP that we have just studied for packet over SONET transports\n It works in the same way to establish and configure the link and carry IP packets\n In between ADSL and PPP are ATM and AAL \n These are new protocols that we have not seen before\n ATM (Asynchronous Transfer Mode) was designed in the early s and launched with incredible hype\n It promised a network technology that would solve the world’s telecommunications problems by merging voice  data  cable television  telegraph  carrier pigeon  tin cans connected by strings  tom toms  and everything else into an integrated system that could do everything for everyone\n This did not happen\n In large part  the problems of ATM were similar to those we described concerning the OSI protocols  that is  bad timing  technology  implementation  and politics\n Nevertheless  ATM was much more successful than OSI\n While it has not taken over the world  it remains widely used in niches including broadband access lines such as DSL  and WAN links inside telephone networks\n ATM is a link layer that is based on the transmission of fixed-length cells of information\n The ‘‘Asynchronous’’ in its name means that the cells do not always need to be sent in the way that bits are continuously sent over synchronous lines  as in SONET\n Cells only need to be sent when there is information to carry\n ATM is a connection-oriented technology\n Each cell carries a virtual circuit identifier in its header and devices use this identifier to forward cells along the paths of established connections\n The cells are each   bytes long  consisting of a  -byte payload plus a  -byte header\n By using small cells  ATM can flexibly divide the bandwidth of a physical layer link among different users in fine slices\n This ability is useful when  for example  sending both voice and data over one link without having long data packets that would cause large variations in the delay of the voice samples\n The unusual choice for the cell length ( \n  compared to the more natural choice of a THE DATA LINK LAYER  \n  power of  ) is an indication of just how political the design of ATM was\n The  -byte size for the payload was a compromise to resolve a deadlock between Europe  which wanted  -byte cells  and the  \n  which wanted  -byte cells\n A brief overview of ATM is given by Siu and Jain (   )\n To send data over an ATM network  it needs to be mapped into a sequence of cells\n This mapping is done with an ATM adaptation layer in a process called segmentation and reassembly\n Several adaptation layers have been defined for different services  ranging from periodic voice samples to packet data\n The main one used for packet data is AAL  (ATM Adaptation Layer  )\n An AAL  frame is shown in Fig\n  -  \n Instead of a header  it has a trailer that gives the length and has a  -byte CRC for error detection\n Naturally  the CRC is the same one used for PPP and IEEE LANs like Ethernet\n Wang and Crowcroft (   ) have shown that it is strong enough to detect nontraditional errors such as cell reordering\n As well as a payload  the AAL  frame has padding\n This rounds out the overall length to be a multiple of   bytes so that the frame can be evenly divided into cells\n No addresses are needed on the frame as the virtual circuit identifier carried in each cell will get it to the right destination\n PPP protocol PPP payload Pad Unused Length CRC Bytes  or to  AAL  trailer Variable AAL  payload Figure  -  \n AAL  frame carrying PPP data\n Now that we have described ATM  we have only to describe how PPP makes use of ATM in the case of ADSL\n It is done with yet another standard called PPPoA (PPP over ATM)\n This standard is not really a protocol (so it does not appear in Fig\n  -  ) but more a specification of how to work with both PPP and AAL  frames\n It is described in RFC  (Gross et al\n  )\n Only the PPP protocol and payload fields are placed in the AAL  payload  as shown in Fig\n  -  \n The protocol field indicates to the DSLAM at the far end whether the payload is an IP packet or a packet from another protocol such as LCP\n The far end knows that the cells contain PPP information because an ATM virtual circuit is set up for this purpose\n Within the AAL  frame  PPP framing is not needed as it would serve no purpose; ATM and AAL  already provide the framing\n More framing would be worthless\n The PPP CRC is also not needed because AAL  already includes the very same CRC\n This error detection mechanism supplements the ADSL physical layer coding of a Reed-Solomon code for error correction and a  -byte CRC for the detection of any remaining errors not otherwise caught\n This scheme has a much more sophisticated error-recovery mechanism than when packets are sent over a SONET line because ADSL is a much noisier channel\n   SUMMARY  \n  SUMMARY The task of the data link layer is to convert the raw bit stream offered by the physical layer into a stream of frames for use by the network layer\n The link layer can present this stream with varying levels of reliability  ranging from connectionless  unacknowledged service to reliable  connection-oriented service\n Various framing methods are used  including byte count  byte stuffing  and bit stuffing\n Data link protocols can provide error control to detect or correct damaged frames and to retransmit lost frames\n To prevent a fast sender from overrunning a slow receiver  the data link protocol can also provide flow control\n The sliding window mechanism is widely used to integrate error control and flow control in a simple way\n When the window size is  packet  the protocol is stop-and-wait\n Codes for error correction and detection add redundant information to messages by using a variety of mathematical techniques\n Convolutional codes and Reed-Solomon codes are widely deployed for error correction  with low-density parity check codes increasing in popularity\n The codes for error detection that are used in practice include cyclic redundancy checks and checksums\n All these codes can be applied at the link layer  as well as at the physical layer and higher layers\n We examined a series of protocols that provide a reliable link layer using acknowledgements and retransmissions  or ARQ (Automatic Repeat reQuest)  under more realistic assumptions\n Starting from an error-free environment in which the receiver can handle any frame sent to it  we introduced flow control  followed by error control with sequence numbers and the stop-and-wait algorithm\n Then we used the sliding window algorithm to allow bidirectional communication and introduce the concept of piggybacking\n The last two protocols pipeline the transmission of multiple frames to prevent the sender from blocking on a link with a long propagation delay\n The receiver can either discard all frames other than the next one in sequence  or buffer out-of-order frames and send negative acknowledgements for greater bandwidth efficiency\n The former strategy is a go-back-n protocol  and the latter strategy is a selective repeat protocol\n The Internet uses PPP as the main data link protocol over point-to-point lines\n It provides a connectionless unacknowledged service  using flag bytes to delimit frames and a CRC for error detection\n It is used to carry packets across a range of links  including SONET links in wide-area networks and ADSL links for the home\n PROBLEMS  \n An upper-layer packet is split into   frames  each of which has an  % chance of arriving undamaged\n If no error control is done by the data link protocol  how many times must the message be sent on average to get the entire thing through? THE DATA LINK LAYER  \n   \n The following character encoding is used in a data link protocol: A:  B:  FLAG:  ESC:  Show the bit sequence transmitted (in binary) for the four-character frame A B ESC FLAG when each of the following framing methods is used: (a) Byte count\n (b) Flag bytes with byte stuffing\n (c) Starting and ending flag bytes with bit stuffing The following data fragment occurs in the middle of a data stream for which the bytestuffing algorithm described in the text is used: A B ESC C ESC FLAG FLAG D\n What is the output after stuffing?  \n What is the maximum overhead in byte-stuffing algorithm?  \n One of your classmates  Scrooge  has pointed out that it is wasteful to end each frame with a flag byte and then begin the next one with a ond flag byte\n One flag byte could do the job as well  and a byte saved is a byte earned\n Do you agree?  \n A bit string     needs to be transmitted at the data link layer\n What is the string actually transmitted after bit stuffing?  \n Can you think of any circumstances under which an open-loop protocol ( \n  a Hamming code) might be preferable to the feedback-type protocols discussed throughout this  ter?  \n To provide more reliability than a single parity bit can give  an error-detecting coding scheme uses one parity bit for checking all the odd-numbered bits and a ond parity bit for all the even-numbered bits\n What is the Hamming distance of this code?  \n Sixteen-bit messages are transmitted using a Hamming code\n How many check bits are needed to ensure that the receiver can detect and correct single-bit errors? Show the bit pattern transmitted for the message    \n Assume that even parity is used in the Hamming code A  -bit Hamming code whose hexadecimal value is  xE F arrives at a receiver\n What was the original value in hexadecimal? Assume that not more than  bit is in error One way of detecting errors is to transmit data as a block of n rows of k bits per row and add parity bits to each row and each column\n The bitin the lower-right corner is a parity bit that checks its row and its column\n Will this scheme detect all single errors? Double errors? Triple errors? Show that this scheme cannot detect some four-bit errors Suppose that data are transmitted in blocks of sizes  bits\n What is the maximum error rate under which error detection and retransmission mechanism (  parity bit per block) is better than using Hamming code? Assume that bit errors are independent of one another and no bit error occurs during retransmission A block of bits with n rows and k columns uses horizontal and vertical parity bits for error detection\n Suppose that exactly  bits are inverted due to transmission errors\n Derive an expression for the probability that the error will be undetected  PROBLEMS  \n Using the convolutional coder of Fig\n  -  what is the output sequence when the input sequence is  (left to right) and the internal state is initially all zero?  \n Suppose that a message    is transmitted using Internet Checksum ( -bit word)\n What is the value of the checksum?  \n What is the remainder obtained by dividing x  + x  +  by the generator polynomial x  +  ?  \n A bit stream  is transmitted using the standard CRC method described in the text\n The generator polynomial is x  +  \n Show the actual bit string transmitted\n Suppose that the third bit from the left is inverted during transmission\n Show that this error is detected at the receiver’s end\n Give an example of bit errors in the bit string transmitted that will not be detected by the receiver A -bit message is sent that contains data bits and   CRC bits\n CRC is computed using the IEEE standardized   -degree CRC polynomial\n For each of the following  explain whether the errors during message transmission will be detected by the receiver: (a) There was a single-bit error\n (b) There were two isolated bit errors\n (c) There were   isolated bit errors\n (d) There were   isolated bit errors\n (e) There was a  -bit long burst error\n (f) There was a  -bit long burst error In the discussion of ARQ protocol in tion    a scenario was outlined that resulted in the receiver accepting two copies of the same frame due to a loss of acknowledgement frame\n Is it possible that a receiver may accept multiple copies of the same frame when none of the frames (message or acknowledgement) are lost?  \n A channel has a bit rate of  kbps and a propagation delay of   m\n For what range of frame sizes does stop-and-wait give an efficiency of at least  %?  \n In protocol   is it possible for the sender to start the timer when it is already running? If so  how might this occur? If not  why is it impossible?  \n A -km-long T  trunk is used to transmit  -byte frames using protocol  \n If the propagation speed is  μ/km  how many bits should the sequence numbers be?  \n Imagine a sliding window protocol using so many bits for sequence numbers that wraparound never occurs\n What relations must hold among the four window edges and the window size  which is constant and the same for both the sender and the receiver?  \n If the procedure between in protocol  checked for the condition a ≤ b ≤ c instead of the condition a ≤ b < c  would that have any effect on the protocol’s correctness or efficiency? Explain your answer In protocol   when a data frame arrives  a check is made to see if the sequence number differs from the one expected and no nak is true\n If both conditions hold  a NAK is sent\n Otherwise  the auxiliary timer is started\n Suppose that the else clause were omitted\n Would this change affect the protocol’s correctness? THE DATA LINK LAYER   Suppose that the three-statement while loop near the end of protocol  was removed from the code\n Would this affect the correctness of the protocol or just the performance? Explain your answer The distance from earth to a distant planet is approximately  ×  m\n What is the channel utilization if a stop-and-wait protocol is used for frame transmission on a   Mbps point-to-point link? Assume that the frame size is   KB and the speed of light is  × m/s In the previous problem  suppose a sliding window protocol is used instead\n For what send window size will the link utilization be   %? You may ignore the protocol processing times at the sender and the receiver In protocol   the code for frame arrival has a tion used for NAKs\n This tion is invoked if the incoming frame is a NAK and another condition is met\n Give a scenario where the presence of this other condition is essential Consider the operation of protocol  over a  -Mbps perfect ( \n  error-free) line\n The maximum frame size is  bits\n New packets are generated  ond apart\n The timeout interval is   m\n If the special acknowledgement timer were eliminated  unnecessary timeouts would occur\n How many times would the average message be transmitted?  \n In protocol   MAX SEQ =  n −  \n While this condition is obviously desirable to make efficient use of header bits  we have not demonstrated that it is essential\n Does the protocol work correctly for MAX SEQ =   for example?  \n Frames of  bits are sent over a  -Mbps channel using a geostationary satellite whose propagation time from the earth is m\n Acknowledgements are always piggybacked onto data frames\n The headers are very short\n Three-bit sequence numbers are used\n What is the maximum achievable channel utilization for (a) Stop-and-wait? (b) Protocol  ? (c) Protocol  ?  \n Compute the fraction of the bandwidth that is wasted on overhead (headers and retransmissions) for protocol  on a heavily loaded  -kbps satellite channel with data frames consisting of   header and  data bits\n Assume that the signal propagation time from the earth to the satellite is m\n ACK frames never occur\n NAK frames are   bits\n The error rate for data frames is  %  and the error rate for NAK frames is negligible\n The sequence numbers are  bits Consider an error-free  -kbps satellite channel used to send   -byte data frames in one direction  with very short acknowledgements coming back the other way\n What is the maximum throughput for window sizes of  and   ? The earth-satellite propagation time is m A   -km-long cable runs at the T  data rate\n The propagation speed in the cable is  /  the speed of light in vacuum\n How many bits fit in the cable?  \n Give at least one reason why PPP uses byte stuffing instead of bit stuffing to prevent accidental flag bytes within the payload from causing confusion  PROBLEMS  \n What is the minimum overhead to send an IP packet using PPP? Count only the overhead introduced by PPP itself  not the IP header overhead\n What is the maximum overhead?  \n A   -byte IP packet is transmitted over a local loop using ADSL protocol stack\n How many ATM cells will be transmitted? Briefly describe their contents The goal of this lab exercise is to implement an error-detection mechanism using the standard CRC algorithm described in the text\n Write two programs  generator and verifier\n The generator program reads from standard input a line of ASCII text containing an n-bit message consisting of a string of  s and  s\n The ond line is the kbit polynomial  also in ASCII\n It outputs to standard output a line of ASCII text with n + k  s and  s representing the message to be transmitted\n Then it outputs the polynomial  just as it read it in\n The verifier program reads in the output of the generator program and outputs a message indicating whether it is correct or not\n Finally  write a program  alter  that inverts  bit on the first line depending on its argument (the bit number counting the leftmost bit as  ) but copies the rest of the two lines correctly\n By typing generator <file | verifier you should see that the message is correct  but by typing generator <file | alter arg | verifier you should get the error message\n This page intentionally left blank  THE MEDIUM ACCESS CONTROL SUBLAYER Network links can be divided into two categories: those using point-to-point connections and those using broadcast channels\n We studied point-to-point links in  \n  ; this  ter deals with broadcast links and their protocols\n In any broadcast network  the key issue is how to determine who gets to use the channel when there is competition for it\n To make this point  consider a conference call in which six people  on six different telephones  are all connected so that each one can hear and talk to all the others\n It is very likely that when one of them stops speaking  two or more will start talking at once  leading to chaos\n In a face-to-face meeting  chaos is avoided by external means\n For example  at a meeting  people raise their hands to request permission to speak\n When only a single channel is available  it is much harder to determine who should go next\n Many protocols for solving the problem are known\n They form the contents of this  ter\n In the literature  broadcast channels are sometimes referred to as multiaccess channels or random access channels\n The protocols used to determine who goes next on a multiaccess channel belong to a sublayer of the data link layer called the MAC (Medium Access Control) sublayer\n The MAC sublayer is especially important in LANs  particularly wireless ones because wireless is naturally a broadcast channel\n WANs  in contrast  use point-to-point links  except for satellite networks\n Because multiaccess channels and LANs are so closely related  in this  ter we will discuss LANs in    THE MEDIUM ACCESS CONTROL SUBLAYER  \n  general  including a few issues that are not strictly part of the MAC sublayer  but the main subject here will be control of the channel\n Technically  the MAC sublayer is the bottom part of the data link layer  so logically we should have studied it before examining all the point-to-point protocols in   Nevertheless  for most people  it is easier to understand protocols involving multiple parties after two-party protocols are well understood\n For that reason we have deviated slightly from a strict bottom-up order of presentation  THE CHANNEL ALLOCATION PROBLEM The central theme of this  ter is how to allocate a single broadcast channel among competing users\n The channel might be a portion of the wireless spectrum in a geographic region  or a single wire or optical fiber to which multiple nodes are connected\n It does not matter\n In both cases  the channel connects each user to all other users and any user who makes full use of the channel interferes with other users who also wish to use the channel\n We will first look at the shortcomings of static allocation schemes for bursty traffic\n Then  we will lay out the key assumptions used to model the dynamic schemes that we examine in the following tions\n    Static Channel Allocation The traditional way of allocating a single channel  such as a telephone trunk  among multiple competing users is to chop up its capacity by using one of the multiplexing schemes we described in   such as FDM (Frequency Division Multiplexing)\n If there are N users  the bandwidth is divided into N equal-sized portions  with each user being assigned one portion\n Since each user has a private frequency band  there is now no interference among users\n When there is only a small and constant number of users  each of which has a steady stream or a heavy load of traffic  this division is a simple and efficient allocation mechanism\n A wireless example is FM radio stations\n Each station gets a portion of the FM band and uses it most of the time to broadcast its signal\n However  when the number of senders is large and varying or the traffic is bursty  FDM presents some problems\n If the spectrum is cut up into N regions and fewer than N users are currently interested in communicating  a large piece of valuable spectrum will be wasted\n And if more than N users want to communicate  some of them will be denied permission for lack of bandwidth  even if some of the users who have been assigned a frequency band hardly ever transmit or receive anything\n Even assuming that the number of users could somehow be held constant at N  dividing the single available channel into some number of static subchannels is   THE CHANNEL ALLOCATION PROBLEM inherently inefficient\n The basic problem is that when some users are quiescent  their bandwidth is simply lost\n They are not using it  and no one else is allowed to use it either\n A static allocation is a poor fit to most computer systems  in which data traffic is extremely bursty  often with peak traffic to mean traffic ratios of : \n Consequently  most of the channels will be idle most of the time\n The poor performance of static FDM can easily be seen with a simple queueing theory calculation\n Let us start by finding the mean time delay  T  to send a frame onto a channel of capacity C bps\n We assume that the frames arrive randomly with an average arrival rate of λ frames/  and that the frames vary in length with an average length of  /μ bits\n With these parameters  the service rate of the channel is μC frames/\n A standard queueing theory result is T = μC − λ  (For the curious  this result is for an ‘‘M/M/ ’’ queue\n It requires that the randomness of the times between frame arrivals and the frame lengths follow an exponential distribution  or equivalently be the result of a Poisson process\n) In our example  if C is Mbps  the mean frame length  /μ  is   bits  and the frame arrival rate  λ  is  frames/  then T = μ\n Note that if we ignored the queueing delay and just asked how long it takes to send a  - bit frame on a   -Mbps network  we would get the (incorrect) answer of μ\n That result only holds when there is no contention for the channel\n Now let us divide the single channel into N independent subchannels  each with capacity C /N bps\n The mean input rate on each of the subchannels will now be λ/N\n Recomputing T  we get TN = μ(C /N) − (λ/N)  = μC − λ N = NT ( - ) The mean delay for the divided channel is N times worse than if all the frames were somehow magically arranged orderly in a big central queue\n This same result says that a bank lobby full of ATM machines is better off having a single queue feeding all the machines than a separate queue in front of each machine\n Precisely the same arguments that apply to FDM also apply to other ways of statically dividing the channel\n If we were to use time division multiplexing (TDM) and allocate each user every Nth time slot  if a user does not use the allocated slot  it would just lie fallow\n The same would hold if we split up the networks physically\n Using our previous example again  if we were to replace the   -Mbps network with   networks of   Mbps each and statically allocate each user to one of them  the mean delay would jump from μ to  m\n Since none of the traditional static channel allocation methods work well at all with bursty traffic  we will now explore dynamic methods\n THE MEDIUM ACCESS CONTROL SUBLAYER  \n     Assumptions for Dynamic Channel Allocation Before we get to the first of the many channel allocation methods in this  ter  it is worthwhile to carefully formulate the allocation problem\n Underlying all the work done in this area are the following five key assumptions:  \n Independent Traffic\n The model consists of N independent stations ( \n  computers  telephones)  each with a program or user that generates frames for transmission\n The expected number of frames generated in an interval of length Δt is λΔt  where λ is a constant (the arrival rate of new frames)\n Once a frame has been generated  the station is blocked and does nothing until the frame has been successfully transmitted Single Channel\n A single channel is available for all communication\n All stations can transmit on it and all can receive from it\n The stations are assumed to be equally capable  though protocols may assign them different roles ( \n  priorities) Observable Collisions\n If two frames are transmitted simultaneously  they overlap in time and the resulting signal is garbled\n This event is called a collision\n All stations can detect that a collision has occurred\n A collided frame must be transmitted again later\n No errors other than those generated by collisions occur Continuous or Slotted Time\n Time may be assumed continuous  in which case frame transmission can begin at any instant\n Alternatively  time may be slotted or divided into discrete intervals (called slots)\n Frame transmissions must then begin at the start of a slot\n A slot may contain  or more frames  corresponding to an idle slot  a successful transmission  or a collision  respectively Carrier Sense or No Carrier Sense\n With the carrier sense assumption  stations can tell if the channel is in use before trying to use it\n No station will attempt to use the channel while it is sensed as busy\n If there is no carrier sense  stations cannot sense the channel before trying to use it\n They just go ahead and transmit\n Only later can they determine whether the transmission was successful\n Some discussion of these assumptions is in order\n The first one says that frame arrivals are independent  both across stations and at a particular station  and that frames are generated unpredictably but at a constant rate\n Actually  this assumption is not a particularly good model of network traffic  as it is well known that packets come in bursts over a range of time scales (Paxson and Floyd  ; and Leland et al\n  )\n Nonetheless  Poisson models  as they are frequently called  are useful because they are mathematically tractable\n They help us analyze   THE CHANNEL ALLOCATION PROBLEM protocols to understand roughly how performance changes over an operating range and how it compares with other designs\n The single-channel assumption is the heart of the model\n No external ways to communicate exist\n Stations cannot raise their hands to request that the teacher call on them  so we will have to come up with better solutions\n The remaining three assumptions depend on the engineering of the system  and we will say which assumptions hold when we examine a particular protocol\n The collision assumption is basic\n Stations need some way to detect collisions if they are to retransmit frames rather than let them be lost\n For wired channels  node hardware can be designed to detect collisions when they occur\n The stations can then terminate their transmissions prematurely to avoid wasting capacity\n This detection is much harder for wireless channels  so collisions are usually inferred after the fact by the lack of an expected acknowledgement frame\n It is also possible for some frames involved in a collision to be successfully received  depending on the details of the signals and the receiving hardware\n However  this situation is not the common case  so we will assume that all frames involved in a collision are lost\n We will also see protocols that are designed to prevent collisions from occurring in the first place\n The reason for the two alternative assumptions about time is that slotted time can be used to improve performance\n However  it requires the stations to follow a master clock or synchronize their actions with each other to divide time into discrete intervals\n Hence  it is not always available\n We will discuss and analyze systems with both kinds of time\n For a given system  only one of them holds\n Similarly  a network may have carrier sensing or not have it\n Wired networks will generally have carrier sense\n Wireless networks cannot always use it effectively because not every station may be within radio range of every other station\n Similarly  carrier sense will not be available in other settings in which a station cannot communicate directly with other stations  for example a cable modem in which stations must communicate via the cable headend\n Note that the word ‘‘carrier’’ in this sense refers to a signal on the channel and has nothing to do with the common carriers ( \n  telephone companies) that date back to the days of the Pony Express\n To avoid any misunderstanding  it is worth noting that no multiaccess protocol guarantees reliable delivery\n Even in the absence of collisions  the receiver may have copied some of the frame incorrectly for various reasons\n Other parts of the link layer or higher layers provide reliability  MULTIPLE ACCESS PROTOCOLS Many algorithms for allocating a multiple access channel are known\n In the following tions  we will study a small sample of the more interesting ones and give some examples of how they are commonly used in practice\n THE MEDIUM ACCESS CONTROL SUBLAYER  \n     ALOHA The story of our first MAC starts out in pristine Hawaii in the early s\n In this case  ‘‘pristine’’ can be interpreted as ‘‘not having a working telephone system\n’’ This did not make life more pleasant for researcher Norman Abramson and his colleagues at the University of Hawaii who were trying to connect users on remote islands to the main computer in Honolulu\n Stringing their own cables under the Pacific Ocean was not in the cards  so they looked for a different solution\n The one they found used short-range radios  with each user terminal sharing the same upstream frequency to send frames to the central computer\n It included a simple and elegant method to solve the channel allocation problem\n Their work has been extended by many researchers since then (Schwartz and Abramson  )\n Although Abramson’s work  called the ALOHA system  used groundbased radio broadcasting  the basic idea is applicable to any system in which uncoordinated users are competing for the use of a single shared channel\n We will discuss two versions of ALOHA here: pure and slotted\n They differ with respect to whether time is continuous  as in the pure version  or divided into discrete slots into which all frames must fit\n Pure ALOHA The basic idea of an ALOHA system is simple: let users transmit whenever they have data to be sent\n There will be collisions  of course  and the colliding frames will be damaged\n Senders need some way to find out if this is the case\n In the ALOHA system  after each station has sent its frame to the central computer  this computer rebroadcasts the frame to all of the stations\n A sending station can thus listen for the broadcast from the hub to see if its frame has gotten through\n In other systems  such as wired LANs  the sender might be able to listen for collisions while transmitting\n If the frame was destroyed  the sender just waits a random amount of time and sends it again\n The waiting time must be random or the same frames will collide over and over  in lockstep\n Systems in which multiple users share a common channel in a way that can lead to conflicts are known as contention systems\n A sketch of frame generation in an ALOHA system is given in Fig\n  - \n We have made the frames all the same length because the throughput of ALOHA systems is maximized by having a uniform frame size rather than by allowing variable- length frames\n Whenever two frames try to occupy the channel at the same time  there will be a collision (as seen in Fig\n  - ) and both will be garbled\n If the first bit of a new frame overlaps with just the last bit of a frame that has almost finished  both frames will be totally destroyed ( \n  have incorrect checksums) and both will have to be retransmitted later\n The checksum does not (and should not) distinguish between a total loss and a near miss\n Bad is bad\n   MULTIPLE ACCESS PROTOCOLS User A B C D E Collision Time Collision Figure  - \n In pure ALOHA  frames are transmitted at completely arbitrary times\n An interesting question is: what is the efficiency of an ALOHA channel? In other words  what fraction of all transmitted frames escape collisions under these chaotic circumstances? Let us first consider an infinite collection of users typing at their terminals (stations)\n A user is always in one of two states: typing or waiting\n Initially  all users are in the typing state\n When a line is finished  the user stops typing  waiting for a response\n The station then transmits a frame containing the line over the shared channel to the central computer and checks the channel to see if it was successful\n If so  the user sees the reply and goes back to typing\n If not  the user continues to wait while the station retransmits the frame over and over until it has been successfully sent\n Let the ‘‘frame time’’ denote the amount of time needed to transmit the standard  fixed-length frame ( \n  the frame length divided by the bit rate)\n At this point  we assume that the new frames generated by the stations are well modeled by a Poisson distribution with a mean of N frames per frame time\n (The infinitepopulation assumption is needed to ensure that N does not decrease as users become blocked\n) If N >   the user community is generating frames at a higher rate than the channel can handle  and nearly every frame will suffer a collision\n For reasonable throughput  we would expect  < N <  \n In addition to the new frames  the stations also generate retransmissions of frames that previously suffered collisions\n Let us further assume that the old and new frames combined are well modeled by a Poisson distribution  with mean of G frames per frame time\n Clearly  G ≥ N\n At low load ( \n  N ∼∼  )  there will be few collisions  hence few retransmissions  so G ∼∼ N\n At high load  there will be many collisions  so G > N\n Under all loads  the throughput  S  is just the offered load  G  times the probability  P  of a transmission succeeding—that is  S = GP  where P  is the probability that a frame does not suffer a collision\n A frame will not suffer a collision if no other frames are sent within one frame time of its start  as shown in Fig\n  - \n Under what conditions will the THE MEDIUM ACCESS CONTROL SUBLAYER  \n  shaded frame arrive undamaged? Let t be the time required to send one frame\n If any other user has generated a frame between time t  and t  + t  the end of that frame will collide with the beginning of the shaded one\n In fact  the shaded frame’s fate was already sealed even before the first bit was sent  but since in pure ALOHA a station does not listen to the channel before transmitting  it has no way of knowing that another frame was already underway\n Similarly  any other frame started between t  + t and t  +  t will bump into the end of the shaded frame\n Collides with the start of the shaded frame Collides with the end of the shaded frame t t  t + t t +  t t +  t Time Vulnerable Figure  - \n Vulnerable period for the shaded frame\n The probability that k frames are generated during a given frame time  in which G frames are expected  is given by the Poisson distribution Pr[k ] = k! Gk e −G ( - ) so the probability of zero frames is just e −G\n In an interval two frame times long  the mean number of frames generated is  G\n The probability of no frames being initiated during the entire vulnerable period is thus given by P  = e − G\n Using S = GP  we get S = Ge− G The relation between the offered traffic and the throughput is shown in Fig\n  - \n The maximum throughput occurs at G =  \n  with S =  / e  which is about   In other words  the best we can hope for is a channel utilization of  %\n This result is not very encouraging  but with everyone transmitting at will  we could hardly have expected a   % success rate\n Slotted ALOHA Soon after ALOHA came onto the scene  Roberts (   ) published a method for doubling the capacity of an ALOHA system\n His proposal was to divide time into discrete intervals called slots  each interval corresponding to one frame\n This   MULTIPLE ACCESS PROTOCOLS  \n   \n   \n       G (attempts per packet time)    S (throughput per frame time) Slotted ALOHA: S = Ge–G Pure ALOHA: S = Ge– G Figure  - \n Throughput versus offered traffic for ALOHA systems\n approach requires the users to agree on slot boundaries\n One way to achieve synchronization would be to have one special station emit a pip at the start of each interval  like a clock\n In Roberts’ method  which has come to be known as slotted ALOHA—in contrast to Abramson’s pure ALOHA—a station is not permitted to send whenever the user types a line\n Instead  it is required to wait for the beginning of the next slot\n Thus  the continuous time ALOHA is turned into a discrete time one\n This halves the vulnerable period\n To see this  look at Fig\n  -  and imagine the collisions that are now possible\n The probability of no other traffic during the same slot as our test frame is then e −G  which leads to S = Ge−G ( - ) As you can see from Fig\n  -  slotted ALOHA peaks at G =   with a throughput of S =  /e or about  \n twice that of pure ALOHA\n If the system is operating at G =   the probability of an empty slot is  \n   (from Eq\n  - )\n The best we can hope for using slotted ALOHA is  % of the slots empty   % successes  and  % collisions\n Operating at higher values of G reduces the number of empties but increases the number of collisions exponentially\n To see how this rapid growth of collisions with G comes about  consider the transmission of a test frame\n The probability that it will avoid a collision is e −G  which is the probability that all the other stations are silent in that slot\n The probability of a collision is then just  − e −G\n The probability of a transmission requiring exactly k attempts ( \n  k −  collisions followed by one success) is Pk = e −G(  − e −G)k −  The expected number of transmissions  E  per line typed at a terminal is then E = k =  Σ ∞ kPk = k =  Σ ∞ ke −G(  − e −G)k −  = eG THE MEDIUM ACCESS CONTROL SUBLAYER  \n  As a result of the exponential dependence of E upon G  small increases in the channel load can drastically reduce its performance\n Slotted ALOHA is notable for a reason that may not be initially obvious\n It was devised in the s  used in a few early experimental systems  then almost forgotten\n When Internet access over the cable was invented  all of a sudden there was a problem of how to allocate a shared channel among multiple competing users\n Slotted ALOHA was pulled out of the garbage can to save the day\n Later  having multiple RFID tags talk to the same RFID reader presented another variation on the same problem\n Slotted ALOHA  with a dash of other ideas mixed in  again came to the rescue\n It has often happened that protocols that are perfectly valid fall into disuse for political reasons ( \n  some big company wants everyone to do things its way) or due to ever-changing technology trends\n Then  years later some clever person realizes that a long-discarded protocol solves his current problem\n For this reason  in this  ter we will study a number of elegant protocols that are not currently in widespread use but might easily be used in future applications  provided that enough network designers are aware of them\n Of course  we will also study many protocols that are in current use as well\n    Carrier Sense Multiple Access Protocols With slotted ALOHA  the best channel utilization that can be achieved is  /e\n This low result is hardly surprising  since with stations transmitting at will  without knowing what the other stations are doing there are bound to be many collisions\n In LANs  however  it is often possible for stations to detect what other stations are doing  and thus adapt their behavior accordingly\n These networks can achieve a much better utilization than  /e\n In this tion  we will discuss some protocols for improving performance\n Protocols in which stations listen for a carrier ( \n  a transmission) and act accordingly are called carrier sense protocols\n A number of them have been proposed  and they were long ago analyzed in detail\n For example  see Kleinrock and Tobagi (   )\n Below we will look at several versions of carrier sense protocols\n Persistent and Nonpersistent CSMA The first carrier sense protocol that we will study here is called  -persistent CSMA (Carrier Sense Multiple Access)\n That is a bit of a mouthful for the simplest CSMA scheme\n When a station has data to send  it first listens to the channel to see if anyone else is transmitting at that moment\n If the channel is idle  the stations sends its data\n Otherwise  if the channel is busy  the station just waits until it becomes idle\n Then the station transmits a frame\n If a collision occurs  the   MULTIPLE ACCESS PROTOCOLS station waits a random amount of time and starts all over again\n The protocol is called  -persistent because the station transmits with a probability of  when it finds the channel idle\n You might expect that this scheme avoids collisions except for the rare case of simultaneous sends  but it in fact it does not\n If two stations become ready in the middle of a third station’s transmission  both will wait politely until the transmission ends  and then both will begin transmitting exactly simultaneously  resulting in a collision\n If they were not so impatient  there would be fewer collisions\n More subtly  the propagation delay has an important effect on collisions\n There is a chance that just after a station begins sending  another station will become ready to send and sense the channel\n If the first station’s signal has not yet reached the ond one  the latter will sense an idle channel and will also begin sending  resulting in a collision\n This chance depends on the number of frames that fit on the channel  or the bandwidth-delay product of the channel\n If only a tiny fraction of a frame fits on the channel  which is the case in most LANs since the propagation delay is small  the chance of a collision happening is small\n The larger the bandwidth-delay product  the more important this effect becomes  and the worse the performance of the protocol\n Even so  this protocol has better performance than pure ALOHA because both stations have the decency to desist from interfering with the third station’s frame\n Exactly the same holds for slotted ALOHA\n A ond carrier sense protocol is nonpersistent CSMA\n In this protocol  a conscious attempt is made to be less greedy than in the previous one\n As before  a station senses the channel when it wants to send a frame  and if no one else is sending  the station begins doing so itself\n However  if the channel is already in use  the station does not continually sense it for the purpose of seizing it immediately upon detecting the end of the previous transmission\n Instead  it waits a random period of time and then repeats the algorithm\n Consequently  this algorithm leads to better channel utilization but longer delays than  -persistent CSMA\n The last protocol is p-persistent CSMA\n It applies to slotted channels and works as follows\n When a station becomes ready to send  it senses the channel\n If it is idle  it transmits with a probability p\n With a probability q =  − p  it defers until the next slot\n If that slot is also idle  it either transmits or defers again  with probabilities p and q\n This process is repeated until either the frame has been transmitted or another station has begun transmitting\n In the latter case  the unlucky station acts as if there had been a collision ( \n  it waits a random time and starts again)\n If the station initially senses that the channel is busy  it waits until the next slot and applies the above algorithm\n IEEE   \n  uses a refinement of p-persistent CSMA that we will discuss in \n   Figure  -  shows the computed throughput versus offered traffic for all three protocols  as well as for pure and slotted ALOHA\n THE MEDIUM ACCESS CONTROL SUBLAYER  \n               S (throughput per packet time) G (attempts per packet time) Pure ALOHA Slotted ALOHA  -persistent CSMA  \n -persistent CSMA  \n -persistent CSMA Nonpersistent CSMA  \n  -persistent CSMA Figure  - \n Comparison of the channel utilization versus load for various random access protocols\n CSMA with Collision Detection Persistent and nonpersistent CSMA protocols are definitely an improvement over ALOHA because they ensure that no station begins to transmit while the channel is busy\n However  if two stations sense the channel to be idle and begin transmitting simultaneously  their signals will still collide\n Another improvement is for the stations to quickly detect the collision and abruptly stop transmitting  (rather than finishing them) since they are irretrievably garbled anyway\n This strategy saves time and bandwidth\n This protocol  known as CSMA/CD (CSMA with Collision Detection)  is the basis of the classic Ethernet LAN  so it is worth devoting some time to looking at it in detail\n It is important to realize that collision detection is an analog process\n The station’s hardware must listen to the channel while it is transmitting\n If the signal it reads back is different from the signal it is putting out  it knows that a collision is occurring\n The implications are that a received signal must not be tiny compared to the transmitted signal (which is difficult for wireless  as received signals may be  times weaker than transmitted signals) and that the modulation must be chosen to allow collisions to be detected ( \n  a collision of two  - volt signals may well be impossible to detect)\n CSMA/CD  as well as many other LAN protocols  uses the conceptual model of Fig\n  - \n At the point marked t   a station has finished transmitting its frame\n Any other station having a frame to send may now attempt to do so\n If two or more stations decide to transmit simultaneously  there will be a collision\n If a station detects a collision  it aborts its transmission  waits a random period of time  and then tries again (assuming that no other station has started transmitting in the   MULTIPLE ACCESS PROTOCOLS meantime)\n Therefore  our model for CSMA/CD will consist of alternating contention and transmission periods  with idle periods occurring when all stations are quiet ( \n  for lack of work)\n Contention slots Contention period Transmission period Idle period to Frame Frame Frame Frame Time Figure  - \n CSMA/CD can be in contention  transmission  or idle state\n Now let us look at the details of the contention algorithm\n Suppose that two stations both begin transmitting at exactly time t  \n How long will it take them to realize that they have collided? The answer is vital to determining the length of the contention period and hence what the delay and throughput will be\n The minimum time to detect the collision is just the time it takes the signal to propagate from one station to the other\n Based on this information  you might think that a station that has not heard a collision for a time equal to the full cable propagation time after starting its transmission can be sure it has seized the cable\n By ‘‘seized ’’ we mean that all other stations know it is transmitting and will not interfere\n This conclusion is wrong\n Consider the following worst-case scenario\n Let the time for a signal to propagate between the two farthest stations be τ\n At t   one station begins transmitting\n At t  + τ − ε  an instant before the signal arrives at the most distant station  that station also begins transmitting\n Of course  it detects the collision almost instantly and stops  but the little noise burst caused by the collision does not get back to the original station until time  τ − ε\n In other words  in the worst case a station cannot be sure that it has seized the channel until it has transmitted for  τ without hearing a collision\n With this understanding  we can think of CSMA/CD contention as a slotted ALOHA system with a slot width of  τ\n On a  -km long coaxial cable  τ∼∼  μ\n The difference for CSMA/CD compared to slotted ALOHA is that slots in which only one station transmits ( \n  in which the channel is seized) are followed by the rest of a frame\n This difference will greatly improve performance if the frame time is much longer than the propagation time\n    Collision-Free Protocols Although collisions do not occur with CSMA/CD once a station has unambiguously captured the channel  they can still occur during the contention period\n These collisions adversely affect the system performance  especially when the THE MEDIUM ACCESS CONTROL SUBLAYER  \n  bandwidth-delay product is large  such as when the cable is long ( \n  large τ) and the frames are short\n Not only do collisions reduce bandwidth  but they make the time to send a frame variable  which is not a good fit for real-time traffic such as voice over IP\n CSMA/CD is also not universally applicable\n In this tion  we will examine some protocols that resolve the contention for the channel without any collisions at all  not even during the contention period\n Most of these protocols are not currently used in major systems  but in a rapidly changing field  having some protocols with excellent properties available for future systems is often a good thing\n In the protocols to be described  we assume that there are exactly N stations  each programmed with a unique address from  to N −  \n It does not matter that some stations may be inactive part of the time\n We also assume that propagation delay is negligible\n The basic question remains: which station gets the channel after a successful transmission? We continue using the model of Fig\n  -  with its discrete contention slots\n A Bit-Map Protocol In our first collision-free protocol  the basic bit-map method  each contention period consists of exactly N slots\n If station  has a frame to send  it transmits a  bit during the slot  \n No other station is allowed to transmit during this slot\n Regardless of what station  does  station  gets the opportunity to transmit a  bit during slot   but only if it has a frame queued\n In general  station j may announce that it has a frame to send by inserting a  bit into slot j\n After all N slots have passed by  each station has complete knowledge of which stations wish to transmit\n At that point  they begin transmitting frames in numerical order (see Fig\n  - )\n            Contention slots  Frames  Contention slots  d Figure  - \n The basic bit-map protocol\n Since everyone agrees on who goes next  there will never be any collisions\n After the last ready station has transmitted its frame  an event all stations can easily monitor  another N-bit contention period is begun\n If a station becomes ready just after its bit slot has passed by  it is out of luck and must remain silent until every station has had a chance and the bit map has come around again\n   MULTIPLE ACCESS PROTOCOLS Protocols like this in which the desire to transmit is broadcast before the actual transmission are called reservation protocols because they reserve channel ownership in advance and prevent collisions\n Let us briefly analyze the performance of this protocol\n For convenience  we will measure time in units of the contention bit slot  with data frames consisting of d time units\n Under conditions of low load  the bit map will simply be repeated over and over  for lack of data frames\n Consider the situation from the point of view of a low-numbered station  such as  or  \n Typically  when it becomes ready to send  the ‘‘current’’ slot will be somewhere in the middle of the bit map\n On average  the station will have to wait N /  slots for the current scan to finish and another full N slots for the following scan to run to completion before it may begin transmitting\n The prospects for high-numbered stations are brighter\n Generally  these will only have to wait half a scan (N /  bit slots) before starting to transmit\n Highnumbered stations rarely have to wait for the next scan\n Since low-numbered stations must wait on average  \n N slots and high-numbered stations must wait on average  \n N slots  the mean for all stations is N slots\n The channel efficiency at low load is easy to compute\n The overhead per frame is N bits and the amount of data is d bits  for an efficiency of d /(d + N)\n At high load  when all the stations have something to send all the time  the Nbit contention period is prorated over N frames  yielding an overhead of only  bit per frame  or an efficiency of d /(d +  )\n The mean delay for a frame is equal to the sum of the time it queues inside its station  plus an additional (N −  )d + N once it gets to the head of its internal queue\n This interval is how long it takes to wait for all other stations to have their turn sending a frame and another bitmap\n Token Passing The essence of the bit-map protocol is that it lets every station transmit a frame in turn in a predefined order\n Another way to accomplish the same thing is to pass a small message called a token from one station to the next in the same predefined order\n The token represents permission to send\n If a station has a frame queued for transmission when it receives the token  it can send that frame before it passes the token to the next station\n If it has no queued frame  it simply passes the token\n In a token ring protocol  the topology of the network is used to define the order in which stations send\n The stations are connected one to the next in a single ring\n Passing the token to the next station then simply consists of receiving the token in from one direction and transmitting it out in the other direction  as seen in Fig\n  - \n Frames are also transmitted in the direction of the token\n This way they will circulate around the ring and reach whichever station is the destination\n However  to stop the frame circulating indefinitely (like the token)  some station needs THE MEDIUM ACCESS CONTROL SUBLAYER  \n  to remove it from the ring\n This station may be either the one that originally sent the frame  after it has gone through a complete cycle  or the station that was the intended recipient of the frame\n Direction of transmission Station Token Figure  - \n Token ring\n Note that we do not need a physical ring to implement token passing\n The channel connecting the stations might instead be a single long bus\n Each station then uses the bus to send the token to the next station in the predefined sequence\n Possession of the token allows a station to use the bus to send one frame  as before\n This protocol is called token bus\n The performance of token passing is similar to that of the bit-map protocol  though the contention slots and frames of one cycle are now intermingled\n After sending a frame  each station must wait for all N stations (including itself) to send the token to their neighbors and the other N −  stations to send a frame  if they have one\n A subtle difference is that  since all positions in the cycle are equivalent  there is no bias for low- or high-numbered stations\n For token ring  each station is also sending the token only as far as its neighboring station before the protocol takes the next step\n Each token does not need to propagate to all stations before the protocol advances to the next step\n Token rings have cropped up as MAC protocols with some consistency\n An early token ring protocol (called ‘‘Token Ring’’ and standardized as IEEE   \n ) was popular in the s as an alternative to classic Ethernet\n In the s  a much faster token ring called FDDI (Fiber Distributed Data Interface) was beaten out by switched Ethernet\n In the s  a token ring called RPR (Resilient Packet Ring) was defined as IEEE   \n  to standardize the mix of metropolitan area rings in use by ISPs\n We wonder what the s will have to offer\n Binary Countdown A problem with the basic bit-map protocol  and by extension token passing  is that the overhead is  bit per station  so it does not scale well to networks with thousands of stations\n We can do better than that by using binary station addresses with a channel that combines transmissions\n A station wanting to use the   MULTIPLE ACCESS PROTOCOLS channel now broadcasts its address as a binary bit string  starting with the highorder bit\n All addresses are assumed to be the same length\n The bits in each address position from different stations are BOOLEAN ORed together by the channel when they are sent at the same time\n We will call this protocol binary countdown\n It was used in Datakit (Fraser  )\n It implicitly assumes that the transmission delays are negligible so that all stations see asserted bits essentially instantaneously\n To avoid conflicts  an arbitration rule must be applied: as soon as a station sees that a high-order bit position that is  in its address has been overwritten with a   it gives up\n For example  if stations     and  are all trying to get the channel  in the first bit time the stations transmit  and   respectively\n These are ORed together to form a  \n Stations  and  see the  and know that a higher-numbered station is competing for the channel  so they give up for the current round\n Stations  and  continue\n The next bit is   and both stations continue\n The next bit is   so station  gives up\n The winner is station  because it has the highest address\n After winning the bidding  it may now transmit a frame  after which another bidding cycle starts\n The protocol is illustrated in Fig\n  - \n It has the property that higher- numbered stations have a higher priority than lower-numbered stations  which may be either good or bad  depending on the context\n  – – –    Bit time  – – –  –    Result    Stations  and  see this  and give up Station  sees this  and gives up Figure  - \n The binary countdown protocol\n A dash indicates silence\n The channel efficiency of this method is d /(d + log  N)\n If  however  the frame format has been cleverly chosen so that the sender’s address is the first field in the frame  even these log  N bits are not wasted  and the efficiency is   %\n Binary countdown is an example of a simple  elegant  and efficient protocol that is waiting to be rediscovered\n Hopefully  it will find a new home some day\n THE MEDIUM ACCESS CONTROL SUBLAYER  \n     Limited-Contention Protocols We have now considered two basic strategies for channel acquisition in a broadcast network: contention  as in CSMA  and collision-free protocols\n Each strategy can be rated as to how well it does with respect to the two important performance measures  delay at low load and channel efficiency at high load\n Under conditions of light load  contention ( \n  pure or slotted ALOHA) is preferable due to its low delay (since collisions are rare)\n As the load increases  contention becomes increasingly less attractive because the overhead associated with channel arbitration becomes greater\n Just the reverse is true for the collision-free protocols\n At low load  they have relatively high delay but as the load increases  the channel efficiency improves (since the overheads are fixed)\n Obviously  it would be nice if we could combine the best properties of the contention and collision-free protocols  arriving at a new protocol that used contention at low load to provide low delay  but used a collision-free technique at high load to provide good channel efficiency\n Such protocols  which we will call limited-contention protocols  do in fact exist  and will conclude our study of carrier sense networks\n Up to now  the only contention protocols we have studied have been symmetric\n That is  each station attempts to acquire the channel with some probability  p  with all stations using the same p\n Interestingly enough  the overall system performance can sometimes be improved by using a protocol that assigns different probabilities to different stations\n Before looking at the asymmetric protocols  let us quickly review the performance of the symmetric case\n Suppose that k stations are contending for channel access\n Each has a probability p of transmitting during each slot\n The probability that some station successfully acquires the channel during a given slot is the probability that any one station transmits  with probability p  and all other k −  stations defer  each with probability  − p\n This value is kp(  − p)k −  \n To find the optimal value of p  we differentiate with respect to p  set the result to zero  and solve for p\n Doing so  we find that the best value of p is  /k\n Substituting p =  /k  we get Pr[success with optimal p] = ⎧⎪⎩ k k −  ⎫⎪⎭ k −  ( - ) This probability is plotted in Fig\n  - \n For small numbers of stations  the chances of success are good  but as soon as the number of stations reaches even five  the probability has dropped close to its asymptotic value of  /e\n From Fig\n  -  it is fairly obvious that the probability of some station acquiring the channel can be increased only by decreasing the amount of competition\n The limited-contention protocols do precisely that\n They first divide the stations into (not necessarily disjoint) groups\n Only the members of group  are permitted   MULTIPLE ACCESS PROTOCOLS          Probability of success Number of ready stations Figure  - \n Acquisition probability for a symmetric contention channel\n to compete for slot  \n If one of them succeeds  it acquires the channel and transmits its frame\n If the slot lies fallow or if there is a collision  the members of group  contend for slot   etc\n By making an appropriate division of stations into groups  the amount of contention for each slot can be reduced  thus operating each slot near the left end of Fig\n  - \n The trick is how to assign stations to slots\n Before looking at the general case  let us consider some special cases\n At one extreme  each group has but one member\n Such an assignment guarantees that there will never be collisions because at most one station is contending for any given slot\n We have seen such protocols before ( \n  binary countdown)\n The next special case is to assign two stations per group\n The probability that both will try to transmit during a slot is p  which for a small p is negligible\n As more and more stations are assigned to the same slot  the probability of a collision grows  but the length of the bit-map scan needed to give everyone a chance shrinks\n The limiting case is a single group containing all stations ( \n  slotted ALOHA)\n What we need is a way to assign stations to slots dynamically  with many stations per slot when the load is low and few (or even just one) station per slot when the load is high\n The Adaptive Tree Walk Protocol One particularly simple way of performing the necessary assignment is to use the algorithm devised by the  \n Army for testing soldiers for syphilis during World War II (Dorfman  )\n In short  the Army took a blood sample from N soldiers\n A portion of each sample was poured into a single test tube\n This mixed sample was then tested for antibodies\n If none were found  all the soldiers in the group were declared healthy\n If antibodies were present  two new mixed samples THE MEDIUM ACCESS CONTROL SUBLAYER  \n  were prepared  one from soldiers  through N/  and one from the rest\n The process was repeated recursively until the infected soldiers were determined\n For the computerized version of this algorithm (Capetanakis  )  it is convenient to think of the stations as the leaves of a binary tree  as illustrated in Fig\n  -  \n In the first contention slot following a successful frame transmission  slot   all stations are permitted to try to acquire the channel\n If one of them does so  fine\n If there is a collision  then during slot  only those stations falling under node  in the tree may compete\n If one of them acquires the channel  the slot following the frame is reserved for those stations under node  \n If  on the other hand  two or more stations under node  want to transmit  there will be a collision during slot   in which case it is node  ’s turn during slot  \n  A B C D E F G H Stations Figure  -  \n The tree for eight stations\n In essence  if a collision occurs during slot   the entire tree is searched  depth first  to locate all ready stations\n Each bit slot is associated with some particular node in the tree\n If a collision occurs  the search continues recursively with the node’s left and right children\n If a bit slot is idle or if only one station transmits in it  the searching of its node can stop because all ready stations have been located\n (Were there more than one  there would have been a collision\n) When the load on the system is heavy  it is hardly worth the effort to dedicate slot  to node  because that makes sense only in the unlikely event that precisely one station has a frame to send\n Similarly  one could argue that nodes  and  should be skipped as well for the same reason\n Put in more general terms  at what level in the tree should the search begin? Clearly  the heavier the load  the farther down the tree the search should begin\n We will assume that each station has a good estimate of the number of ready stations  q  for example  from monitoring recent traffic\n To proceed  let us number the levels of the tree from the top  with node  in Fig\n  -  at level   nodes  and  at level   etc\n Notice that each node at level i   MULTIPLE ACCESS PROTOCOLS has a fraction  −i of the stations below it\n If the q ready stations are uniformly distributed  the expected number of them below a specific node at level i is just  −iq\n Intuitively  we would expect the optimal level to begin searching the tree to be the one at which the mean number of contending stations per slot is   that is  the level at which  −iq =  \n Solving this equation  we find that i = log  q\n Numerous improvements to the basic algorithm have been discovered and are discussed in some detail by Bertsekas and Gallager (   )\n For example  consider the case of stations G and H being the only ones wanting to transmit\n At node  a collision will occur  so  will be tried and discovered idle\n It is pointless to probe node  since it is guaranteed to have a collision (we know that two or more stations under  are ready and none of them are under   so they must all be under  )\n The probe of  can be skipped and  tried next\n When this probe also turns up nothing   can be skipped and node G tried next\n    Wireless LAN Protocols A system of laptop computers that communicate by radio can be regarded as a wireless LAN  as we discussed in \n   \n Such a LAN is an example of a broadcast channel\n It also has somewhat different properties than a wired LAN  which leads to different MAC protocols\n In this tion  we will examine some of these protocols\n In   we will look at   \n  (WiFi) in detail\n A common configuration for a wireless LAN is an office building with access points (APs) strategically placed around the building\n The APs are wired together using copper or fiber and provide connectivity to the stations that talk to them\n If the transmission power of the APs and laptops is adjusted to have a range of tens of meters  nearby rooms become like a single cell and the entire building becomes like the cellular telephony systems we studied in  \n   except that each cell only has one channel\n This channel is shared by all the stations in the cell  including the AP\n It typically provides megabit/ bandwidths  up to Mbps\n We have already remarked that wireless systems cannot normally detect a collision while it is occurring\n The received signal at a station may be tiny  perhaps a million times fainter than the signal that is being transmitted\n Finding it is like looking for a ripple on the ocean\n Instead  acknowledgements are used to discover collisions and other errors after the fact\n There is an even more important difference between wireless LANs and wired LANs\n A station on a wireless LAN may not be able to transmit frames to or receive frames from all other stations because of the limited radio range of the stations\n In wired LANs  when one station sends a frame  all other stations receive it\n The absence of this property in wireless LANs causes a variety of complications\n We will make the simplifying assumption that each radio transmitter has some fixed range  represented by a circular coverage region within which another station can sense and receive the station’s transmission\n It is important to realize that THE MEDIUM ACCESS CONTROL SUBLAYER  \n  in practice coverage regions are not nearly so regular because the propagation of radio signals depends on the environment\n Walls and other obstacles that attenuate and reflect signals may cause the range to differ markedly in different directions\n But a simple circular model will do for our purposes\n A naive approach to using a wireless LAN might be to try CSMA: just listen for other transmissions and only transmit if no one else is doing so\n The trouble is  this protocol is not really a good way to think about wireless because what matters for reception is interference at the receiver  not at the sender\n To see the nature of the problem  consider Fig\n  -   where four wireless stations are illustrated\n For our purposes  it does not matter which are APs and which are laptops\n The radio range is such that A and B are within each other’s range and can potentially interfere with one another\n C can also potentially interfere with both B and D  but not with A\n Radio range (a) (b) Radio range A B C D A B C D Figure  -  \n A wireless LAN\n (a) A and C are hidden terminals when transmitting to B\n (b) B and C are exposed terminals when transmitting to A and D\n First consider what happens when A and C transmit to B  as depicted in Fig\n  -  (a)\n If A sends and then C immediately senses the medium  it will not hear A because A is out of range\n Thus C will falsely conclude that it can transmit to B\n If C does start transmitting  it will interfere at B  wiping out the frame from A\n (We assume here that no CDMA-type scheme is used to provide multiple channels  so collisions garble the signal and destroy both frames\n) We want a MAC protocol that will prevent this kind of collision from happening because it wastes bandwidth\n The problem of a station not being able to detect a potential competitor for the medium because the competitor is too far away is called the hidden terminal problem\n Now let us look at a different situation: B transmitting to A at the same time that C wants to transmit to D  as shown in Fig\n  -  (b)\n If C senses the medium  it will hear a transmission and falsely conclude that it may not send to D (shown as a dashed line)\n In fact  such a transmission would cause bad reception only in the zone between B and C  where neither of the intended receivers is located\n We want a MAC protocol that prevents this kind of deferral from happening because it wastes bandwidth\n The problem is called the exposed terminal problem\n The difficulty is that  before starting a transmission  a station really wants to know whether there is radio activity around the receiver\n CSMA merely tells it   MULTIPLE ACCESS PROTOCOLS whether there is activity near the transmitter by sensing the carrier\n With a wire  all signals propagate to all stations  so this distinction does not exist\n However  only one transmission can then take place at once anywhere in the system\n In a system based on short-range radio waves  multiple transmissions can occur simultaneously if they all have different destinations and these destinations are out of range of one another\n We want this concurrency to happen as the cell gets larger and larger  in the same way that people at a party should not wait for everyone in the room to go silent before they talk; multiple conversations can take place at once in a large room as long as they are not directed to the same location\n An early and influential protocol that tackles these problems for wireless LANs is MACA (Multiple Access with Collision Avoidance) (Karn  )\n The basic idea behind it is for the sender to stimulate the receiver into outputting a short frame  so stations nearby can detect this transmission and avoid transmitting for the duration of the upcoming (large) data frame\n This technique is used instead of carrier sense\n MACA is illustrated in Fig\n  -  \n Let us see how A sends a frame to B\n A starts by sending an RTS (Request To Send) frame to B  as shown in Fig\n  -  (a)\n This short frame (  bytes) contains the length of the data frame that will eventually follow\n Then B replies with a CTS (Clear To Send) frame  as shown in Fig\n  -  (b)\n The CTS frame contains the data length (copied from the RTS frame)\n Upon receipt of the CTS frame  A begins transmission\n (a) (b) Range of A's transmitter A RTS E C B D A CTS E C B D Range of B's transmitter Figure  -  \n The MACA protocol\n (a) A sending an RTS to B\n (b) B responding with a CTS to A\n Now let us see how stations overhearing either of these frames react\n Any station hearing the RTS is clearly close to A and must remain silent long enough for the CTS to be transmitted back to A without conflict\n Any station hearing the CTS is clearly close to B and must remain silent during the upcoming data transmission  whose length it can tell by examining the CTS frame\n THE MEDIUM ACCESS CONTROL SUBLAYER  \n  In Fig\n  -   C is within range of A but not within range of B\n Therefore  it hears the RTS from A but not the CTS from B\n As long as it does not interfere with the CTS  it is free to transmit while the data frame is being sent\n In contrast  D is within range of B but not A\n It does not hear the RTS but does hear the CTS\n Hearing the CTS tips it off that it is close to a station that is about to receive a frame  so it defers sending anything until that frame is expected to be finished\n Station E hears both control messages and  like D  must be silent until the data frame is complete\n Despite these precautions  collisions can still occur\n For example  B and C could both send RTS frames to A at the same time\n These will collide and be lost\n In the event of a collision  an unsuccessful transmitter ( \n  one that does not hear a CTS within the expected time interval) waits a random amount of time and tries again later  ETHERNET We have now finished our discussion of channel allocation protocols in the abstract  so it is time to see how these principles apply to real systems\n Many of the designs for personal  local  and metropolitan area networks have been standardized under the name of IEEE   \n A few have survived but many have not  as we saw in Fig\n  -  \n Some people who believe in reincarnation think that Charles Darwin came back as a member of the IEEE Standards Association to weed out the unfit\n The most important of the survivors are   \n  (Ethernet) and   \n  (wireless LAN)\n Bluetooth (wireless PAN) is widely deployed but has now been standardized outside of    With   \n  (wireless MAN)  it is too early to tell\n Please consult the  th edition of this book to find out\n We will begin our study of real systems with Ethernet  probably the most ubiquitous kind of computer network in the world\n Two kinds of Ethernet exist: classic Ethernet  which solves the multiple access problem using the techniques we have studied in this  ter; and switched Ethernet  in which devices called switches are used to connect different computers\n It is important to note that  while they are both referred to as Ethernet  they are quite different\n Classic Ethernet is the original form and ran at rates from  to   Mbps\n Switched Ethernet is what Ethernet has become and runs at   and   Mbps  in forms called fast Ethernet  gigabit Ethernet  and   gigabit Ethernet\n In practice  only switched Ethernet is used nowadays\n We will discuss these historical forms of Ethernet in chronological order showing how they developed\n Since Ethernet and IEEE   \n  are identical except for a minor difference (which we will discuss shortly)  many people use the terms ‘‘Ethernet’’ and ‘‘IEEE   \n ’’ interchangeably\n We will do so  too\n For more information about Ethernet  see Spurgeon (   )\n   ETHERNET    Classic Ethernet Physical Layer The story of Ethernet starts about the same time as that of ALOHA  when a student named Bob Metcalfe got his bachelor’s degree at  \n and then moved up the river to get his  \n at Harvard\n During his studies  he was exposed to Abramson’s work\n He became so interested in it that after graduating from Harvard  he decided to spend the summer in Hawaii working with Abramson before starting work at Xerox PARC (Palo Alto Research Center)\n When he got to PARC  he saw that the researchers there had designed and built what would later be called personal computers\n But the machines were isolated\n Using his knowledge of Abramson’s work  he  together with his colleague David Boggs  designed and implemented the first local area network (Metcalfe and Boggs  )\n It used a single long  thick coaxial cable and ran at  Mbps\n They called the system Ethernet after the luminiferous ether  through which electromagnetic radiation was once thought to propagate\n (When the  th-century British physicist James Clerk Maxwell discovered that electromagnetic radiation could be described by a wave equation  scientists assumed that space must be filled with some ethereal medium in which the radiation was propagating\n Only after the famous Michelson-Morley experiment in  did physicists discover that electromagnetic radiation could propagate in a vacuum\n) The Xerox Ethernet was so successful that DEC  Intel  and Xerox drew up a standard in  for a  -Mbps Ethernet  called the DIX standard\n With a minor change  the DIX standard became the IEEE   \n  standard in \n Unfortunately for Xerox  it already had a history of making seminal inventions (such as the personal computer) and then failing to commercialize on them  a story told in Fumbling the Future (Smith and Alexander  )\n When Xerox showed little interest in doing anything with Ethernet other than helping standardize it  Metcalfe formed his own company  Com  to sell Ethernet adapters for PCs\n It sold many millions of them\n Classic Ethernet snaked around the building as a single long cable to which all the computers were attached\n This architecture is shown in Fig\n  -  \n The first variety  popularly called thick Ethernet  resembled a yellow garden hose  with markings every  \n  meters to show where to attach computers\n (The   \n  standard did not actually require the cable to be yellow  but it did suggest it\n) It was succeeded by thin Ethernet  which bent more easily and made connections using industry-standard BNC connectors\n Thin Ethernet was much cheaper and easier to install  but it could run for only meters per segment (instead of m with thick Ethernet)  each of which could handle only   machines (instead of   )\n Each version of Ethernet has a maximum cable length per segment ( \n  unamplified length) over which the signal will propagate\n To allow larger networks  multiple cables can be connected by repeaters\n A repeater is a physical layer device that receives  amplifies ( \n  regenerates)  and retransmits signals in both directions\n As far as the software is concerned  a series of cable segments THE MEDIUM ACCESS CONTROL SUBLAYER  \n  Ether Transceiver Interface cable Figure  -  \n Architecture of classic Ethernet\n connected by repeaters is no different from a single cable (except for a small amount of delay introduced by the repeaters)\n Over each of these cables  information was sent using the Manchester encoding we studied in \n   An Ethernet could contain multiple cable segments and multiple repeaters  but no two transceivers could be more than  \n  km apart and no path between any two transceivers could traverse more than four repeaters\n The reason for this restriction was so that the MAC protocol  which we will look at next  would work correctly\n    Classic Ethernet MAC Sublayer Protocol The format used to send frames is shown in Fig\n  -  \n First comes a Preamble of  bytes  each containing the bit pattern  (with the exception of the last byte  in which the last  bits are set to  )\n This last byte is called the Start of Frame delimiter for    The Manchester encoding of this pattern produces a  -MHz square wave for  \n  μ to allow the receiver’s clock to synchronize with the sender’s\n The last two  bits tell the receiver that the rest of the frame is about to start\n (a) Preamble Bytes Type Data Pad Checksum Destination address Source address  -  - (b) Preamble Length Data Pad Checksum Destination address Source address Figure  -  \n Frame formats\n (a) Ethernet (DIX)\n (b) IEEE    Next come two addresses  one for the destination and one for the source\n They are each  bytes long\n The first transmitted bit of the destination address is a  for   ETHERNET ordinary addresses and a  for group addresses\n Group addresses allow multiple stations to listen to a single address\n When a frame is sent to a group address  all the stations in the group receive it\n Sending to a group of stations is called multicasting\n The special address consisting of all  bits is reserved for broadcasting\n A frame containing all  s in the destination field is accepted by all stations on the network\n Multicasting is more selective  but it involves group management to define which stations are in the group\n Conversely  broadcasting does not differentiate between stations at all  so it does not require any group management\n An interesting feature of station source addresses is that they are globally unique  assigned centrally by IEEE to ensure that no two stations anywhere in the world have the same address\n The idea is that any station can uniquely address any other station by just giving the right  -bit number\n To do this  the first  bytes of the address field are used for an OUI (Organizationally Unique Identifier)\n Values for this field are assigned by IEEE and indicate a manufacturer\n Manufacturers are assigned blocks of addresses\n The manufacturer assigns the last  bytes of the address and programs the complete address into the NIC before it is sold\n Next comes the Type or Length field  depending on whether the frame is Ethernet or IEEE    Ethernet uses a Type field to tell the receiver what to do with the frame\n Multiple network-layer protocols may be in use at the same time on the same machine  so when an Ethernet frame arrives  the operating system has to know which one to hand the frame to\n The Type field specifies which process to give the frame to\n For example  a type code of  x means that the data contains an IPv  packet\n IEEE   \n  in its wisdom  decided that this field would carry the length of the frame  since the Ethernet length was determined by looking inside the data—a layering violation if ever there was one\n Of course  this meant there was no way for the receiver to figure out what to do with an incoming frame\n That problem was handled by the addition of another header for the LLC (Logical Link Control) protocol within the data\n It uses  bytes to convey the  bytes of protocol type information\n Unfortunately  by the time   \n  was published  so much hardware and software for DIX Ethernet was already in use that few manufacturers and users were enthusiastic about repackaging the Type and Length fields\n In  IEEE threw in the towel and said that both ways were fine with it\n Fortunately  all the Type fields in use before  had values greater than  then well established as the maximum data size\n Now the rule is that any number there less than or equal to  x   (   ) can be interpreted as Length  and any number greater than  x   can be interpreted as Type\n Now IEEE can maintain that everyone is using its standard and everybody else can keep on doing what they were already doing (not bothering with LLC) without feeling guilty about it\n Next come the data  up to  bytes\n This limit was chosen somewhat arbitrarily at the time the Ethernet standard was cast in stone  mostly based on the fact THE MEDIUM ACCESS CONTROL SUBLAYER  \n  that a transceiver needs enough RAM to hold an entire frame and RAM was expensive in \n A larger upper limit would have meant more RAM  and hence a more expensive transceiver\n In addition to there being a maximum frame length  there is also a minimum frame length\n While a data field of  bytes is sometimes useful  it causes a problem\n When a transceiver detects a collision  it truncates the current frame  which means that stray bits and pieces of frames appear on the cable all the time\n To make it easier to distinguish valid frames from garbage  Ethernet requires that valid frames must be at least   bytes long  from destination address to checksum  including both\n If the data portion of a frame is less than   bytes  the Pad field is used to fill out the frame to the minimum size\n Another (and more important) reason for having a minimum length frame is to prevent a station from completing the transmission of a short frame before the first bit has even reached the far end of the cable  where it may collide with another frame\n This problem is illustrated in Fig\n  -  \n At time   station A  at one end of the network  sends off a frame\n Let us call the propagation time for this frame to reach the other end τ\n Just before the frame gets to the other end ( \n  at time τ − ε)  the most distant station  B  starts transmitting\n When B detects that it is receiving more power than it is putting out  it knows that a collision has occurred  so it aborts its transmission and generates a  -bit noise burst to warn all other stations\n In other words  it jams the ether to make sure the sender does not miss the collision\n At about time  τ  the sender sees the noise burst and aborts its transmission  too\n It then waits a random time before trying again\n Packet starts A at time  B A B Packet almost at B at Collision at time A B Noise burst gets back to A at  A B (a) (b) (c) (d) Figure  -  \n Collision detection can take as long as  τ\n If a station tries to transmit a very short frame  it is conceivable that a collision will occur  but the transmission will have completed before the noise burst gets back to the station at  τ\n The sender will then incorrectly conclude that the frame was successfully sent\n To prevent this situation from occurring  all frames must take more than  τ to send so that the transmission is still taking place when   ETHERNET the noise burst gets back to the sender\n For a  -Mbps LAN with a maximum length of  meters and four repeaters (from the   \n  specification)  the round-trip time (including time to propagate through the four repeaters) has been determined to be nearly   μ in the worst case\n Therefore  the shortest allowed frame must take at least this long to transmit\n At   Mbps  a bit takes n  so bits is the smallest frame that is guaranteed to work\n To add some margin of safety  this number was rounded up to bits or   bytes\n The final field is the Checksum\n It is a  -bit CRC of the kind we studied in \n   In fact  it is defined exactly by the generator polynomial we gave there  which popped up for PPP  ADSL  and other links too\n This CRC is an errordetecting code that is used to determine if the bits of the frame have been received correctly\n It just does error detection  with the frame dropped if an error is detected\n CSMA/CD with Binary Exponential Backoff Classic Ethernet uses the  -persistent CSMA/CD algorithm that we studied in \n   This descriptor just means that stations sense the medium when they have a frame to send and send the frame as soon as the medium becomes idle\n They monitor the channel for collisions as they send\n If there is a collision  they abort the transmission with a short jam signal and retransmit after a random interval\n Let us now see how the random interval is determined when a collision occurs  as it is a new method\n The model is still that of Fig\n  - \n After a collision  time is divided into discrete slots whose length is equal to the worst-case roundtrip propagation time on the ether ( τ)\n To accommodate the longest path allowed by Ethernet  the slot time has been set to bit times  or  \n  μ\n After the first collision  each station waits either  or  slot times at random before trying again\n If two stations collide and each one picks the same random number  they will collide again\n After the ond collision  each one picks either  or  at random and waits that number of slot times\n If a third collision occurs (the probability of this happening is  \n  )  the next time the number of slots to wait is chosen at random from the interval  to   −  \n In general  after i collisions  a random number between  and  i −  is chosen  and that number of slots is skipped\n However  after   collisions have been reached  the randomization interval is frozen at a maximum of  slots\n After   collisions  the controller throws in the towel and reports failure back to the computer\n Further recovery is up to higher layers\n This algorithm  called binary exponential backoff  was chosen to dynamically adapt to the number of stations trying to send\n If the randomization interval for all collisions were  the chance of two stations colliding for a ond time would be negligible  but the average wait after a collision would be hundreds of slot times  introducing significant delay\n On the other hand  if each station always THE MEDIUM ACCESS CONTROL SUBLAYER  \n  delayed for either  or  slots  then if stations ever tried to send at once they would collide over and over until   of them picked  and the remaining station picked  \n This might take years\n By having the randomization interval grow exponentially as more and more conutive collisions occur  the algorithm ensures a low delay when only a few stations collide but also ensures that the collisions are resolved in a reasonable interval when many stations collide\n Truncating the backoff at  keeps the bound from growing too large\n If there is no collision  the sender assumes that the frame was probably successfully delivered\n That is  neither CSMA/CD nor Ethernet provides acknowledgements\n This choice is appropriate for wired and optical fiber channels that have low error rates\n Any errors that do occur must then be detected by the CRC and recovered by higher layers\n For wireless channels that have more errors  we will see that acknowledgements are used\n    Ethernet Performance Now let us briefly examine the performance of classic Ethernet under conditions of heavy and constant load  that is  with k stations always ready to transmit\n A rigorous analysis of the binary exponential backoff algorithm is complicated\n Instead  we will follow Metcalfe and Boggs (   ) and assume a constant retransmission probability in each slot\n If each station transmits during a contention slot with probability p  the probability A that some station acquires the channel in that slot is A = kp(  − p)k −  ( - ) A is maximized when p =  /k  with A →  /e as k →∞\n The probability that the contention interval has exactly j slots in it is A(  − A)j −   so the mean number of slots per contention is given by j =  Σ ∞ jA(  − A)j −  = A  Since each slot has a duration  τ  the mean contention interval  w  is  τ/A\n Assuming optimal p  the mean number of contention slots is never more than e  so w is at most  τe ∼∼  \n τ\n If the mean frame takes P  to transmit  when many stations have frames to send  Channel efficiency = P +  τ/A P ( - ) Here we see where the maximum cable distance between any two stations enters into the performance figures\n The longer the cable  the longer the contention interval  which is why the Ethernet standard specifies a maximum cable length\n   ETHERNET It is instructive to formulate Eq\n ( - ) in terms of the frame length  F  the network bandwidth  B  the cable length  L  and the speed of signal propagation  c  for the optimal case of e contention slots per frame\n With P = F/B  Eq\n ( - ) becomes Channel efficiency =  +  BLe /cF  ( - ) When the ond term in the denominator is large  network efficiency will be low\n More specifically  increasing network bandwidth or distance (the BL product) reduces efficiency for a given frame size\n Unfortunately  much research on network hardware is aimed precisely at increasing this product\n People want high bandwidth over long distances (fiber optic MANs  for example)  yet classic Ethernet implemented in this manner is not the best system for these applications\n We will see other ways of implementing Ethernet in the next tion\n In Fig\n  -   the channel efficiency is plotted versus the number of ready stations for  τ =  \n  μ and a data rate of   Mbps  using Eq\n ( - )\n With a  - byte slot time  it is not surprising that  -byte frames are not efficient\n On the other hand  with -byte frames and an asymptotic value of e  -byte slots per contention interval  the contention period is bytes long and the efficiency is  %\n This result is much better than the  % efficiency of slotted ALOHA          \n  Number of stations trying to send Channel efficiency     -byte frames   -byte frames   -byte frames   -byte frames  -byte frames Figure  -  \n Efficiency of Ethernet at   Mbps with   -bit slot times\n It is probably worth mentioning that there has been a large amount of theoretical performance analysis of Ethernet (and other networks)\n Most of the results should be taken with a grain (or better yet  a metric ton) of salt  for two reasons\n THE MEDIUM ACCESS CONTROL SUBLAYER  \n  First  virtually all of the theoretical work assumes Poisson traffic\n As researchers have begun looking at real data  it now appears that network traffic is rarely Poisson\n Instead  it is self-similar or bursty over a range of time scales (Paxson and Floyd  ; and Leland et al\n  )\n What this means is that averaging over long periods of time does not smooth out the traffic\n As well as using questionable models  many of the analyses focus on the ‘‘interesting’’ performance cases of abnormally high load\n Boggs et al\n (   ) showed by experimentation that Ethernet works well in reality  even at moderately high load\n    Switched Ethernet Ethernet soon began to evolve away from the single long cable architecture of classic Ethernet\n The problems associated with finding breaks or loose connections drove it toward a different kind of wiring pattern  in which each station has a dedicated cable running to a central hub\n A hub simply connects all the attached wires electrically  as if they were soldered together\n This configuration is shown in Fig\n  -  (a)\n Port Line Hub Switch (a) (b) Port Line Figure  -  \n (a) Hub\n (b) Switch\n The wires were telephone company twisted pairs  since most office buildings were already wired this way and normally plenty of spares were available\n This reuse was a win  but it did reduce the maximum cable run from the hub to meters (   meters if high quality Category  twisted pairs were used)\n Adding or removing a station is simpler in this configuration  and cable breaks can be detected easily\n With the advantages of being able to use existing wiring and ease of maintenance  twisted-pair hubs quickly became the dominant form of Ethernet\n However  hubs do not increase capacity because they are logically equivalent to the single long cable of classic Ethernet\n As more and more stations are added  each station gets a decreasing share of the fixed capacity\n Eventually  the LAN will saturate\n One way out is to go to a higher speed  say  from   Mbps to Mbps   Gbps  or even higher speeds\n But with the growth of multimedia and powerful servers  even a  -Gbps Ethernet can become saturated\n   ETHERNET Fortunately  there is an another way to deal with increased load: switched Ethernet\n The heart of this system is a switch containing a high-speed backplane that connects all of the ports  as shown in Fig\n  -  (b)\n From the outside  a switch looks just like a hub\n They are both boxes  typically with  to   ports  each with a standard RJ-  connector for a twisted-pair cable\n Each cable connects the switch or hub to a single computer  as shown in Fig\n  -  \n A switch has the same advantages as a hub  too\n It is easy to add or remove a new station by plugging or unplugging a wire  and it is easy to find most faults since a flaky cable or port will usually affect just one station\n There is still a shared component that can fail—the switch itself—but if all stations lose connectivity the IT folks know what to do to fix the problem: replace the whole switch\n Switch Twisted pair Switch ports Hub Figure  -  \n An Ethernet switch\n Inside the switch  however  something very different is happening\n Switches only output frames to the ports for which those frames are destined\n When a switch port receives an Ethernet frame from a station  the switch checks the Ethernet addresses to see which port the frame is destined for\n This step requires the switch to be able to work out which ports correspond to which addresses  a process that we will describe in   when we get to the general case of switches connected to other switches\n For now  just assume that the switch knows the frame’s destination port\n The switch then forwards the frame over its high-speed backplane to the destination port\n The backplane typically runs at many Gbps  using a proprietary protocol that does not need to be standardized because it is entirely hidden inside the switch\n The destination port then transmits the frame on the wire so that it reaches the intended station\n None of the other ports even knows the frame exists\n What happens if more than one of the stations or ports wants to send a frame at the same time? Again  switches differ from hubs\n In a hub  all stations are in the same collision domain\n They must use the CSMA/CD algorithm to schedule their transmissions\n In a switch  each port is its own independent collision domain\n In the common case that the cable is full duplex  both the station and the port can send a frame on the cable at the same time  without worrying about other ports and stations\n Collisions are now impossible and CSMA/CD is not needed\n However  if the cable is half duplex  the station and the port must contend for transmission with CSMA/CD in the usual way\n THE MEDIUM ACCESS CONTROL SUBLAYER  \n  A switch improves performance over a hub in two ways\n First  since there are no collisions  the capacity is used more efficiently\n ond  and more importantly  with a switch multiple frames can be sent simultaneously (by different stations)\n These frames will reach the switch ports and travel over the switch’s backplane to be output on the proper ports\n However  since two frames might be sent to the same output port at the same time  the switch must have buffering so that it can temporarily queue an input frame until it can be transmitted to the output port\n Overall  these improvements give a large performance win that is not possible with a hub\n The total system throughput can often be increased by an order of magnitude  depending on the number of ports and traffic patterns\n The change in the ports on which frames are output also has urity benefits\n Most LAN interfaces have a promiscuous mode  in which all frames are given to each computer  not just those addressed to it\n With a hub  every computer that is attached can see the traffic sent between all of the other computers\n Spies and busybodies love this feature\n With a switch  traffic is forwarded only to the ports where it is destined\n This restriction provides better isolation so that traffic will not easily escape and fall into the wrong hands\n However  it is better to encrypt traffic if urity is really needed\n Because the switch just expects standard Ethernet frames on each input port  it is possible to use some of the ports as concentrators\n In Fig\n  -   the port in the upper-right corner is connected not to a single station  but to a  -port hub instead\n As frames arrive at the hub  they contend for the ether in the usual way  including collisions and binary backoff\n Successful frames make it through the hub to the switch and are treated there like any other incoming frames\n The switch does not know they had to fight their way in\n Once in the switch  they are sent to the correct output line over the high-speed backplane\n It is also possible that the correct destination was one on the lines attached to the hub  in which case the frame has already been delivered so the switch just drops it\n Hubs are simpler and cheaper than switches  but due to falling switch prices they have become an endangered species\n Modern networks largely use switched Ethernet\n Nevertheless  legacy hubs still exist\n    Fast Ethernet At the same time that switches were becoming popular  the speed of  -Mbps Ethernet was coming under pressure\n At first Mbps seemed like heaven  just as cable modems seemed like heaven to the users of telephone modems\n But the novelty wore off quickly\n As a kind of corollary to Parkinson’s Law (‘‘Work expands to fill the time available for its completion’’)  it seemed that data expanded to fill the bandwidth available for their transmission\n Many installations needed more bandwidth and thus had numerous  -Mbps LANs connected by a maze of repeaters  hubs  and switches  although to the network managers it sometimes felt that they were being held together by bubble   ETHERNET gum and chicken wire\n But even with Ethernet switches  the maximum bandwidth of a single computer was limited by the cable that connected it to the switch port\n It was in this environment that IEEE reconvened the   \n  committee in  with instructions to come up with a faster LAN\n One proposal was to keep   \n  exactly as it was  but just make it go faster\n Another proposal was to redo it totally and give it lots of new features  such as real-time traffic and digitized voice  but just keep the old name (for marketing reasons)\n After some wrangling  the committee decided to keep   \n  the way it was  and just make it go faster\n This strategy would get the job done before the technology changed and avoid unforeseen problems with a brand new design\n The new design would also be backwardcompatible with existing Ethernet LANs\n The people behind the losing proposal did what any self-respecting computer-industry people would have done under these circumstances: they stomped off and formed their own committee and standardized their LAN anyway (eventually as   \n  )\n It flopped miserably\n The work was done quickly (by standards committees’ norms)  and the result \n u  was approved by IEEE in June \n Technically \n u is not a new standard  but an addendum to the existing   \n  standard (to emphasize its backward compatibility)\n This strategy is used a lot\n Since practically everyone calls it fast Ethernet  rather than   \n u  we will do that  too\n The basic idea behind fast Ethernet was simple: keep all the old frame formats  interfaces  and procedural rules  but reduce the bit time from n to   n\n Technically  it would have been possible to copy  -Mbps classic Ethernet and still detect collisions on time by just reducing the maximum cable length by a factor of  \n However  the advantages of twisted-pair wiring were so overwhelming that fast Ethernet is based entirely on this design\n Thus  all fast Ethernet systems use hubs and switches; multidrop cables with vampire taps or BNC connectors are not permitted\n Nevertheless  some choices still had to be made  the most important being which wire types to support\n One contender was Category  twisted pair\n The argument for it was that practically every office in the Western world had at least four Category  (or better) twisted pairs running from it to a telephone wiring closet within meters\n Sometimes two such cables existed\n Thus  using Category  twisted pair would make it possible to wire up desktop computers using fast Ethernet without having to rewire the building  an enormous advantage for many organizations\n The main disadvantage of a Category  twisted pair is its inability to carry Mbps over meters  the maximum computer-to-hub distance specified for  -Mbps hubs\n In contrast  Category  twisted pair wiring can handle m easily  and fiber can go much farther\n The compromise chosen was to allow all three possibilities  as shown in Fig\n  -   but to pep up the Category  solution to give it the additional carrying capacity needed\n The Category  UTP scheme  called   Base-T  used a signaling speed of   MHz  only  % faster than standard Ethernet’s   MHz\n (Remember that THE MEDIUM ACCESS CONTROL SUBLAYER  \n  Name Cable Max\n segment Advantages   Base-T  Twisted pair m Uses category  UTP   Base-TX Twisted pair m Full duplex at Mbps (Cat  UTP)   Base-FX Fiber optics  m Full duplex at Mbps; long runs Figure  -  \n The original fast Ethernet cabling\n Manchester encoding  discussed in   requires two clock periods for each of the   million bits sent each ond\n) However  to achieve the necessary bit rate Base-T  requires four twisted pairs\n Of the four pairs  one is always to the hub  one is always from the hub  and the other two are switchable to the current transmission direction\n To get Mbps out of the three twisted pairs in the transmission direction  a fairly involved scheme is used on each twisted pair\n It involves sending ternary digits with three different voltage levels\n This scheme is not likely to win any prizes for elegance  and we will skip the details\n However  since standard telephone wiring for decades has had four twisted pairs per cable  most offices are able to use the existing wiring plant\n Of course  it means giving up your office telephone  but that is surely a small price to pay for faster email\n   Base-T  fell by the wayside as many office buildings were rewired with Category  UTP for   Base-TX Ethernet  which came to dominate the market\n This design is simpler because the wires can handle clock rates of MHz\n Only two twisted pairs per station are used  one to the hub and one from it\n Neither straight binary coding ( \n  NRZ) nor Manchester coding is used\n Instead  the  B/ B encoding we described in   \n  is used\n  data bits are encoded as  signal bits and sent at MHz to provide Mbps\n This scheme is simple but has sufficient transitions for synchronization and uses the bandwidth of the wire relatively well\n The   Base-TX system is full duplex; stations can transmit at Mbps on one twisted pair and receive at Mbps on another twisted pair at the same time\n The last option Base-FX  uses two strands of multimode fiber  one for each direction  so it  too  can run full duplex with Mbps in each direction\n In this setup  the distance between a station and the switch can be up to  km\n Fast Ethernet allows interconnection by either hubs or switches\n To ensure that the CSMA/CD algorithm continues to work  the relationship between the minimum frame size and maximum cable length must be maintained as the network speed goes up from   Mbps to Mbps\n So  either the minimum frame size of   bytes must go up or the maximum cable length of  m must come down  proportionally\n The easy choice was for the maximum distance between any two stations to come down by a factor of since a hub with   -m cables falls within this new maximum already\n However  -km   Base-FX cables are   ETHERNET too long to permit a   -Mbps hub with the normal Ethernet collision algorithm\n These cables must instead be connected to a switch and operate in a full-duplex mode so that there are no collisions\n Users quickly started to deploy fast Ethernet  but they were not about to throw away  -Mbps Ethernet cards on older computers\n As a consequence  virtually all fast Ethernet switches can handle a mix of  -Mbps and   -Mbps stations\n To make upgrading easy  the standard itself provides a mechanism called autonegotiation that lets two stations automatically negotiate the optimum speed (  or Mbps) and duplexity (half or full)\n It works well most of the time but is known to lead to duplex mismatch problems when one end of the link autonegotiates but the other end does not and is set to full-duplex mode (Shalunov and Carlson  )\n Most Ethernet products use this feature to configure themselves\n    Gigabit Ethernet The ink was barely dry on the fast Ethernet standard when the committee began working on a yet faster Ethernet  quickly dubbed gigabit Ethernet\n IEEE ratified the most popular form as   \n ab in \n Below we will discuss some of the key features of gigabit Ethernet\n More information is given by Spurgeon (   )\n The committee’s goals for gigabit Ethernet were essentially the same as the committee’s goals for fast Ethernet: increase performance tenfold while maintaining compatibility with all existing Ethernet standards\n In particular  gigabit Ethernet had to offer unacknowledged datagram service with both unicast and broadcast  use the same  -bit addressing scheme already in use  and maintain the same frame format  including the minimum and maximum frame sizes\n The final standard met all these goals\n Like fast Ethernet  all configurations of gigabit Ethernet use point-to-point links\n In the simplest configuration  illustrated in Fig\n  -  (a)  two computers are directly connected to each other\n The more common case  however  uses a switch or a hub connected to multiple computers and possibly additional switches or hubs  as shown in Fig\n  -  (b)\n In both configurations  each individual Ethernet cable has exactly two devices on it  no more and no fewer\n Also like fast Ethernet  gigabit Ethernet supports two different modes of operation: full-duplex mode and half-duplex mode\n The ‘‘normal’’ mode is fullduplex mode  which allows traffic in both directions at the same time\n This mode is used when there is a central switch connected to computers (or other switches) on the periphery\n In this configuration  all lines are buffered so each computer and switch is free to send frames whenever it wants to\n The sender does not have to sense the channel to see if anybody else is using it because contention is impossible\n On the line between a computer and a switch  the computer is the only possible sender to the switch  and the transmission will succeed even if the switch is currently sending a frame to the computer (because the line is full duplex)\n Since THE MEDIUM ACCESS CONTROL SUBLAYER  \n  Switch or hub Ethernet (a) (b) Ethernet Computer Figure  -  \n (a) A two-station Ethernet\n (b) A multistation Ethernet\n no contention is possible  the CSMA/CD protocol is not used  so the maximum length of the cable is determined by signal strength issues rather than by how long it takes for a noise burst to propagate back to the sender in the worst case\n Switch\%es are free to mix and match speeds\n Autonegotiation is supported just as in fast Ethernet  only now the choice is among  and  Mbps\n The other mode of operation  half-duplex  is used when the computers are connected to a hub rather than a switch\n A hub does not buffer incoming frames\n Instead  it electrically connects all the lines internally  simulating the multidrop cable used in classic Ethernet\n In this mode  collisions are possible  so the standard CSMA/CD protocol is required\n Because a  -byte frame (the shortest allowed) can now be transmitted times faster than in classic Ethernet  the maximum cable length must be times less  or   meters  to maintain the essential property that the sender is still transmitting when the noise burst gets back to it  even in the worst case\n With a -meter-long cable  the sender of a  -byte frame at  Gbps would be long finished before the frame got even a tenth of the way to the other end  let alone to the end and back\n This length restriction was painful enough that two features were added to the standard to increase the maximum cable length to meters  which is probably enough for most offices\n The first feature  called carrier extension  essentially tells the hardware to add its own padding after the normal frame to extend the frame to bytes\n Since this padding is added by the sending hardware and removed by the receiving hardware  the software is unaware of it  meaning that no changes are needed to existing software\n The downside is that using bytes worth of bandwidth to transmit   bytes of user data (the payload of a  -byte frame) has a line efficiency of only  %\n The ond feature  called frame bursting  allows a sender to transmit a concatenated sequence of multiple frames in a single transmission\n If the total burst is less than bytes  the hardware pads it again\n If enough frames are waiting for transmission  this scheme is very efficient and preferred over carrier extension\n   ETHERNET In all fairness  it is hard to imagine an organization buying modern computers with gigabit Ethernet cards and then connecting them with an old-fashioned hub to simulate classic Ethernet with all its collisions\n Gigabit Ethernet interfaces and switches used to be expensive  but their prices fell rapidly as sales volumes picked up\n Still  backward compatibility is sacred in the computer industry  so the committee was required to put it in\n Today  most computers ship with an Ethernet interface that is capable of  - -  and -Mbps operation and compatible with all of them\n Gigabit Ethernet supports both copper and fiber cabling  as listed in Fig\n  -  \n Signaling at or near  Gbps requires encoding and sending a bit every nanoond\n This trick was initially accomplished with short  shielded copper cables (the Base-CX version) and optical fibers\n For the optical fibers  two wavelengths are permitted and result in two different versions:  \n  microns (short  for Base-SX) and  \n  microns (long  for Base-LX)\n Name Cable Max\n segment Advantages Base-SX Fiber optics m Multimode fiber (  \n  microns) Base-LX Fiber optics  m Single (  μ) or multimode (  \n  μ) Base-CX  Pairs of STP   m Shielded twisted pair Base-T  Pairs of UTP m Standard category  UTP Figure  -  \n Gigabit Ethernet cabling\n Signaling at the short wavelength can be achieved with cheaper LEDs\n It is used with multimode fiber and is useful for connections within a building  as it can run up to m for  -micron fiber\n Signaling at the long wavelength requires more expensive lasers\n On the other hand  when combined with singlemode (  -micron) fiber  the cable length can be up to  km\n This limit allows long distance connections between buildings  such as for a campus backbone  as a dedicated point-to-point link\n Later variations of the standard allowed even longer links over single-mode fiber\n To send bits over these versions of gigabit Ethernet  the  B/  B encoding we described in   was borrowed from another networking technology called Fibre Channel\n That scheme encodes  bits of data into  -bit codewords that are sent over the wire or fiber  hence the name  B/  B\n The codewords were chosen so that they could be balanced ( \n  have the same number of  s and  s) with sufficient transitions for clock recovery\n Sending the coded bits with NRZ requires a signaling bandwidth of  % more than that required for the uncoded bits  a big improvement over the   % expansion of Manchester coding\n However  all of these options required new copper or fiber cables to support the faster signaling\n None of them made use of the large amount of Category  UTP that had been installed along with fast Ethernet\n Within a year  Base-T THE MEDIUM ACCESS CONTROL SUBLAYER  \n  came along to fill this gap  and it has been the most popular form of gigabit Ethernet ever since\n People apparently dislike rewiring their buildings\n More complicated signaling is needed to make Ethernet run at  Mbps over Category  wires\n To start  all four twisted pairs in the cable are used  and each pair is used in both directions at the same time by using digital signal processing to separate signals\n Over each wire  five voltage levels that carry  bits are used for signaling at Msymbols/\n The mapping to produce the symbols from the bits is not straightforward\n It involves scrambling  for transitions  followed by an error correcting code in which four values are embedded into five signal levels\n A speed of  Gbps is quite fast\n For example  if a receiver is busy with some other task for even  m and does not empty the input buffer on some line  up to  frames may have accumulated in that gap\n Also  when a computer on a gigabit Ethernet is shipping data down the line to a computer on a classic Ethernet  buffer overruns are very likely\n As a consequence of these two observations  gigabit Ethernet supports flow control\n The mechanism consists of one end sending a special control frame to the other end telling it to pause for some period of time\n These PAUSE control frames are normal Ethernet frames containing a type of  x   \n Pauses are given in units of the minimum frame time\n For gigabit Ethernet  the time unit is n  allowing for pauses as long as  \n  m\n There is one more extension that was introduced along with gigabit Ethernet\n Jumbo frames allow for frames to be longer than  bytes  usually up to  KB\n This extension is proprietary\n It is not recognized by the standard because if it is used then Ethernet is no longer compatible with earlier versions  but most vendors support it anyway\n The rationale is that  bytes is a short unit at gigabit speeds\n By manipulating larger blocks of information  the frame rate can be decreased  along with the processing associated with it  such as interrupting the processor to say that a frame has arrived  or splitting up and recombining messages that were too long to fit in one Ethernet frame\n     -Gigabit Ethernet As soon as gigabit Ethernet was standardized  the committee got bored and wanted to get back to work\n IEEE told them to start on  -gigabit Ethernet\n This work followed much the same pattern as the previous Ethernet standards  with standards for fiber and shielded copper cable appearing first in  and  followed by the standard for copper twisted pair in \n   Gbps is a truly prodigious speed  x faster than the original Ethernet\n Where could it be needed? The answer is inside data centers and exchanges to connect high-end routers  switches  and servers  as well as in long-distance  high bandwidth trunks between offices that are enabling entire metropolitan area networks based on Ethernet and fiber\n The long distance connections use optical fiber  while the short connections may use copper or fiber\n   ETHERNET All versions of  -gigabit Ethernet support only full-duplex operation\n CSMA/CD is no longer part of the design  and the standards concentrate on the details of physical layers that can run at very high speed\n Compatibility still matters  though  so  -gigabit Ethernet interfaces autonegotiate and fall back to the highest speed supported by both ends of the line\n The main kinds of  -gigabit Ethernet are listed in Fig\n  -  \n Multimode fiber with the  \n  μ (short) wavelength is used for medium distances  and singlemode fiber at  \n μ (long) and  \n μ (extended) is used for long distances\n  GBase-ER can run for distances of   km  making it suitable for wide area applications\n All of these versions send a serial stream of information that is produced by scrambling the data bits  then encoding them with a  B/  B code\n This encoding has less overhead than an  B/  B code\n Name Cable Max\n segment Advantages  GBase-SR Fiber optics Up to m Multimode fiber ( \n  μ)  GBase-LR Fiber optics   km Single-mode fiber ( \n μ)  GBase-ER Fiber optics   km Single-mode fiber ( \n μ)  GBase-CX   Pairs of twinax   m Twinaxial copper  GBase-T  Pairs of UTP m Category  a UTP Figure  -  \n  -Gigabit Ethernet cabling\n The first copper version defined   GBase-CX  uses a cable with four pairs of twinaxial copper wiring\n Each pair uses  B/  B coding and runs at  \n   Gsymbols/ond to reach   Gbps\n This version is cheaper than fiber and was early to market  but it remains to be seen whether it will be beat out in the long run by  -gigabit Ethernet over more garden variety twisted pair wiring\n  GBase-T is the version that uses UTP cables\n While it calls for Category  a wiring  for shorter runs  it can use lower categories (including Category  ) to allow some reuse of installed cabling\n Not surprisingly  the physical layer is quite involved to reach   Gbps over twisted pair\n We will only sketch some of the high-level details\n Each of the four twisted pairs is used to send  Mbps in both directions\n This speed is reached using a signaling rate of Msymbols/ with symbols that use   voltage levels\n The symbols are produced by scrambling the data  protecting it with a LDPC (Low Density Parity Check) code  and further coding for error correction\n  -gigabit Ethernet is still shaking out in the market  but the   \n  committee has already moved on\n At the end of  IEEE created a group to standardize Ethernet operating at   Gbps and Gbps\n This upgrade will let Ethernet compete in very high-performance settings  including long-distance connections in backbone networks and short connections over the equipment backplanes\n The standard is not yet complete  but proprietary products are already available\n THE MEDIUM ACCESS CONTROL SUBLAYER  \n     Retrospective on Ethernet Ethernet has been around for over   years and has no serious competitors in sight  so it is likely to be around for many years to come\n Few CPU architectures  operating systems  or programming languages have been king of the mountain for three decades going on strong\n Clearly  Ethernet did something right\n What? Probably the main reason for its longevity is that Ethernet is simple and flexible\n In practice  simple translates into reliable  cheap  and easy to maintain\n Once the hub and switch architecture was adopted  failures became extremely rare\n People hesitate to replace something that works perfectly all the time  especially when they know that an awful lot of things in the computer industry work very poorly  so that many so-called ‘‘upgrades’’ are worse than what they replaced\n Simple also translates into cheap\n Twisted-pair wiring is relatively inexpensive as are the hardware components\n They may start out expensive when there is a transition  for example  new gigabit Ethernet NICs or switches  but they are merely additions to a well established network (not a replacement of it) and the prices fall quickly as the sales volume picks up\n Ethernet is easy to maintain\n There is no software to install (other than the drivers) and not much in the way of configuration tables to manage (and get wrong)\n Also  adding new hosts is as simple as just plugging them in\n Another point is that Ethernet interworks easily with TCP/IP  which has become dominant\n IP is a connectionless protocol  so it fits perfectly with Ethernet  which is also connectionless\n IP fits much less well with connection-oriented alternatives such as ATM\n This mismatch definitely hurt ATM’s chances\n Lastly  and perhaps most importantly  Ethernet has been able to evolve in certain crucial ways\n Speeds have gone up by several orders of magnitude and hubs and switches have been introduced  but these changes have not required changing the software and have often allowed the existing cabling to be reused for a time\n When a network salesman shows up at a large installation and says ‘‘I have this fantastic new network for you\n All you have to do is throw out all your hardware and rewrite all your software ’’ he has a problem\n Many alternative technologies that you have probably not even heard of were faster than Ethernet when they were introduced\n As well as ATM  this list includes FDDI (Fiber Distributed Data Interface) and Fibre Channel † two ringbased optical LANs\n Both were incompatible with Ethernet\n Neither one made it\n They were too complicated  which led to complex chips and high prices\n The lesson that should have been learned here was KISS (Keep It Simple  Stupid)\n Eventually  Ethernet caught up with them in terms of speed  often by borrowing some of their technology  for example  the  B/ B coding from FDDI and the  B/  B coding from Fibre Channel\n Then they had no advantages left and quietly died off or fell into specialized roles\n † It is called ‘‘Fibre Channel’’ and not ‘‘Fiber Channel’’ because the document editor was British\n   ETHERNET It looks like Ethernet will continue to expand in its applications for some time\n  -gigabit Ethernet has freed it from the distance constraints of CSMA/CD\n Much effort is being put into carrier-grade Ethernet to let network providers offer Ethernet-based services to their customers for metropolitan and wide area networks (Fouli and Maler  )\n This application carries Ethernet frames long distances over fiber and calls for better management features to help operators offer reliable  high-quality services\n Very high speed networks are also finding uses in backplanes connecting components in large routers or servers\n Both of these uses are in addition to that of sending frames between computers in offices  WIRELESS LANS Wireless LANs are increasingly popular  and homes  offices  cafes  libraries  airports  zoos  and other public places are being outfitted with them to connect computers  PDAs  and smart phones to the Internet\n Wireless LANs can also be used to let two or more nearby computers communicate without using the Internet\n The main wireless LAN standard is    We gave some background information on it in \n   \n Now it is time to take a closer look at the technology\n In the following tions  we will look at the protocol stack  physical-layer radio transmission techniques  the MAC sublayer protocol  the frame structure  and the services provided\n For more information about   \n   see Gast (   )\n To get the truth from the mouth of the horse  consult the published standard  IEEE   \n  - itself\n    The   \n  Architecture and Protocol Stack   \n  networks can be used in two modes\n The most popular mode is to connect clients  such as laptops and smart phones  to another network  such as a company intranet or the Internet\n This mode is shown in Fig\n  -  (a)\n In infrastructure mode  each client is associated with an AP (Access Point) that is in turn connected to the other network\n The client sends and receives its packets via the AP\n Several access points may be connected together  typically by a wired network called a distribution system  to form an extended   \n  network\n In this case  clients can send frames to other clients via their APs\n The other mode  shown in Fig\n  -  (b)  is an ad hoc network\n This mode is a collection of computers that are associated so that they can directly send frames to each other\n There is no access point\n Since Internet access is the killer application for wireless  ad hoc networks are not very popular\n Now we will look at the protocols\n All the protocols  including   \n  and Ethernet  have a certain commonality of structure\n A partial view of the   \n  protocol stack is given in Fig\n  -  \n The stack is the same for clients and THE MEDIUM ACCESS CONTROL SUBLAYER  \n  (a) (b) Access To network point Client Figure  -  \n   \n  architecture\n (a) Infrastructure mode\n (b) Ad-hoc mode\n APs\n The physical layer corresponds fairly well to the OSI physical layer  but the data link layer in all the protocols is split into two or more sublayers\n In   \n   the MAC (Medium Access Control) sublayer determines how the channel is allocated  that is  who gets to transmit next\n Above it is the LLC (Logical Link Control) sublayer  whose job it is to hide the differences between the different variants and make them indistinguishable as far as the network layer is concerned\n This could have been a significant responsibility  but these days the LLC is a glue layer that identifies the protocol ( \n  IP) that is carried within an   \n  frame\n   \n  (legacy) Frequency hopping and infrared   \n  a OFDM   \n  b Spread spectrum   \n  g OFDM   \n  n MIMO OFDM Logical link layer Release date: –    Upper layers Data link layer Physical layer MAC sublayer Figure  -  \n Part of the   \n  protocol stack\n Several transmission techniques have been added to the physical layer as   \n  has evolved since it first appeared in \n Two of the initial techniques  infrared in the manner of television remote controls and frequency hopping in the  \n -GHz band  are now defunct\n The third initial technique  direct sequence spread spectrum at  or  Mbps in the  \n -GHz band  was extended to run at rates up to   Mbps and quickly became a hit\n It is now known as   \n  b\n   WIRELESS LANS To give wireless junkies a much-wanted speed boost  new transmission techniques based on the OFDM (Orthogonal Frequency Division Multiplexing) scheme we described in \n    were introduced in  and \n The first is called   \n  a and uses a different frequency band   GHz\n The ond stuck with  \n  GHz and compatibility\n It is called   \n  g\n Both give rates up to   Mbps\n Most recently  transmission techniques that simultaneously use multiple antennas at the transmitter and receiver for a speed boost were finalized as   \n  n in Oct With four antennas and wider channels  the   \n  standard now defines rates up to a startling Mbps\n We will now examine each of these transmission techniques briefly\n We will only cover those that are in use  however  skipping the legacy   \n  transmission methods\n Technically  these belong to the physical layer and should have been examined in  \n   but since they are so closely tied to LANs in general and the   \n  LAN in particular  we treat them here instead\n    The   \n  Physical Layer Each of the transmission techniques makes it possible to send a MAC frame over the air from one station to another\n They differ  however  in the technology used and speeds achievable\n A detailed discussion of these technologies is far beyond the scope of this book  but a few words on each one will relate the techniques to the material we covered in   and will provide interested readers with the key terms to search for elsewhere for more information\n All of the   \n  techniques use short-range radios to transmit signals in either the  \n -GHz or the  -GHz ISM frequency bands  both described in \n   \n These bands have the advantage of being unlicensed and hence freely available to any transmitter willing to meet some restrictions  such as radiated power of at most  W (though   mW is more typical for wireless LAN radios)\n Unfortunately  this fact is also known to the manufacturers of garage door openers  cordless phones  microwave ovens  and countless other devices  all of which compete with laptops for the same spectrum\n The  \n -GHz band tends to be more crowded than the  -GHz band  so  GHz can be better for some applications even though it has shorter range due to the higher frequency\n All of the transmission methods also define multiple rates\n The idea is that different rates can be used depending on the current conditions\n If the wireless signal is weak  a low rate can be used\n If the signal is clear  the highest rate can be used\n This adjustment is called rate adaptation\n Since the rates vary by a factor of   or more  good rate adaptation is important for good performance\n Of course  since it is not needed for interoperability  the standards do not say how rate adaptation should be done\n The first transmission method we shall look at is   \n  b\n It is a spread-spectrum method that supports rates of   \n  and   Mbps  though in practice the operating rate is nearly always   Mbps\n It is similar to the CDMA system we THE MEDIUM ACCESS CONTROL SUBLAYER  \n  examined in   except that there is only one spreading code that is shared by all users\n Spreading is used to satisfy the FCC requirement that power be spread over the ISM band\n The spreading sequence used by   \n  b is a Barker sequence\n It has the property that its autocorrelation is low except when the sequences are aligned\n This property allows a receiver to lock onto the start of a transmission\n To send at a rate of  Mbps  the Barker sequence is used with BPSK modulation to send  bit per   chips\n The chips are transmitted at a rate of   Mchips/\n To send at  Mbps  it is used with QPSK modulation to send  bits per   chips\n The higher rates are different\n These rates use a technique called CCK (Complementary Code Keying) to construct codes instead of the Barker sequence\n The  \n -Mbps rate sends  bits in every  -chip code  and the  -Mbps rate sends  bits in every  -chip code\n Next we come to   \n  a  which supports rates up to   Mbps in the  -GHz ISM band\n You might have expected that   \n  a to come before   \n  b  but that was not the case\n Although the   \n  a group was set up first  the   \n  b standard was approved first and its product got to market well ahead of the   \n  a products  partly because of the difficulty of operating in the higher  -GHz band\n The   \n  a method is based on OFDM (Orthogonal Frequency Division Multiplexing) because OFDM uses the spectrum efficiently and resists wireless signal degradations such as multipath\n Bits are sent over   subcarriers in parallel carrying data and  used for synchronization\n Each symbol lasts  μs and sends  or  bits\n The bits are coded for error correction with a binary convolutional code first  so only  /   /  or  /  of the bits are not redundant\n With different combinations \n  a can run at eight different rates  ranging from  to   Mbps\n These rates are significantly faster than   \n  b rates  and there is less interference in the  -GHz band\n However \n  b has a range that is about seven times greater than that of   \n  a  which is more important in many situations\n Even with the greater range  the   \n  b people had no intention of letting this upstart win the speed championship\n Fortunately  in May  the FCC dropped its long-standing rule requiring all wireless communications equipment operating in the ISM bands in the  \n to use spread spectrum  so it got to work on   \n  g  which was approved by IEEE in \n It copies the OFDM modulation methods of   \n  a but operates in the narrow  \n -GHz ISM band along with   \n  b\n It offers the same rates as   \n  a (  to   Mbps) plus of course compatibility with any   \n  b devices that happen to be nearby\n All of these different choices can be confusing for customers  so it is common for products to support   \n  a/b/g in a single NIC\n Not content to stop there  the IEEE committee began work on a high-throughput physical layer called   \n  n\n It was ratified in \n The goal for   \n  n was throughput of at least Mbps after all the wireless overheads were removed\n This goal called for a raw speed increase of at least a factor of four\n To make it happen  the committee doubled the channels from   MHz to   MHz and   WIRELESS LANS reduced framing overheads by allowing a group of frames to be sent together\n More significantly  however \n  n uses up to four antennas to transmit up to four streams of information at the same time\n The signals of the streams interfere at the receiver  but they can be separated using MIMO (Multiple Input Multiple Output) communications techniques\n The use of multiple antennas gives a large speed boost  or better range and reliability instead\n MIMO  like OFDM  is one of those clever communications ideas that is changing wireless designs and which we are all likely to hear a lot about in the future\n For a brief introduction to multiple antennas in   \n  see Halperin et al\n (   )\n    The   \n  MAC Sublayer Protocol Let us now return from the land of electrical engineering to the land of computer science\n The   \n  MAC sublayer protocol is quite different from that of Ethernet  due to two factors that are fundamental to wireless communication\n First  radios are nearly always half duplex  meaning that they cannot transmit and listen for noise bursts at the same time on a single frequency\n The received signal can easily be a million times weaker than the transmitted signal  so it cannot be heard at the same time\n With Ethernet  a station just waits until the ether goes silent and then starts transmitting\n If it does not receive a noise burst back while transmitting the first   bytes  the frame has almost assuredly been delivered correctly\n With wireless  this collision detection mechanism does not work\n Instead \n  tries to avoid collisions with a protocol called CSMA/CA (CSMA with Collision Avoidance)\n This protocol is conceptually similar to Ethernet’s CSMA/CD  with channel sensing before sending and exponential back off after collisions\n However  a station that has a frame to send starts with a random backoff (except in the case that it has not used the channel recently and the channel is idle)\n It does not wait for a collision\n The number of slots to backoff is chosen in the range  to  say in the case of the OFDM physical layer\n The station waits until the channel is idle  by sensing that there is no signal for a short period of time (called the DIFS  as we explain below)  and counts down idle slots  pausing when frames are sent\n It sends its frame when the counter reaches  \n If the frame gets through  the destination immediately sends a short acknowledgement\n Lack of an acknowledgement is inferred to indicate an error  whether a collision or otherwise\n In this case  the sender doubles the backoff period and tries again  continuing with exponential backoff as in Ethernet until the frame has been successfully transmitted or the maximum number of retransmissions has been reached\n An example timeline is shown in Fig\n  -  \n Station A is the first to send a frame\n While A is sending  stations B and C become ready to send\n They see that the channel is busy and wait for it to become idle\n Shortly after A receives an acknowledgement  the channel goes idle\n However  rather than sending a frame right away and colliding  B and C both perform a backoff\n C picks a short backoff  THE MEDIUM ACCESS CONTROL SUBLAYER  \n  and thus sends first\n B pauses its countdown while it senses that C is using the channel  and resumes after C has received an acknowledgement\n B soon completes its backoff and sends its frame\n Station A B C Time Data Wait for idle Backoff Rest of backoff Ack A sends to D B ready to send D acks A C sends to D D acks C B sends to D D acks B Data Ack Data Ack Wait for idle Wait for idle Backoff C ready to send Figure  -  \n Sending a frame with CSMA/CA\n Compared to Ethernet  there are two main differences\n First  starting backoffs early helps to avoid collisions\n This avoidance is worthwhile because collisions are expensive  as the entire frame is transmitted even if one occurs\n ond  acknowledgements are used to infer collisions because collisions cannot be detected\n This mode of operation is called DCF (Distributed Coordination Function) because each station acts independently  without any kind of central control\n The standard also includes an optional mode of operation called PCF (Point Coordination Function) in which the access point controls all activity in its cell  just like a cellular base station\n However  PCF is not used in practice because there is normally no way to prevent stations in another nearby network from transmitting competing traffic\n The ond problem is that the transmission ranges of different stations may be different\n With a wire  the system is engineered so that all stations can hear each other\n With the complexities of RF propagation this situation does not hold for wireless stations\n Consequently  situations such as the hidden terminal problem mentioned earlier and illustrated again in Fig\n  -  (a) can arise\n Since not all stations are within radio range of each other  transmissions going on in one part of a cell may not be received elsewhere in the same cell\n In this example  station C is transmitting to station B\n If A senses the channel  it will not hear anything and will falsely conclude that it may now start transmitting to B\n This decision leads to a collision\n The inverse situation is the exposed terminal problem  illustrated in Fig\n  -  (b)\n Here  B wants to send to C  so it listens to the channel\n When it hears a   WIRELESS LANS Range of C's radio A B C (a) A C Range of A's radio B (b) A wants to send to B but cannot hear that B is busy B wants to send to C but mistakenly thinks the transmission will fail C is transmitting A is transmitting Figure  -  \n (a) The hidden terminal problem\n (b) The exposed terminal problem\n transmission  it falsely concludes that it may not send to C  even though A may in fact be transmitting to D (not shown)\n This decision wastes a transmission opportunity\n To reduce ambiguities about which station is sending \n  defines channel sensing to consist of both physical sensing and virtual sensing\n Physical sensing simply checks the medium to see if there is a valid signal\n With virtual sensing  each station keeps a logical record of when the channel is in use by tracking the NAV (Network Allocation Vector)\n Each frame carries a NAV field that says how long the sequence of which this frame is part will take to complete\n Stations that overhear this frame know that the channel will be busy for the period indicated by the NAV  regardless of whether they can sense a physical signal\n For example  the NAV of a data frame includes the time needed to send an acknowledgement\n All stations that hear the data frame will defer during the acknowledgement period  whether or not they can hear the acknowledgement\n An optional RTS/CTS mechanism uses the NAV to prevent terminals from sending frames at the same time as hidden terminals\n It is shown in Fig\n  -  \n In this example  A wants to send to B\n C is a station within range of A (and possibly within range of B  but that does not matter)\n D is a station within range of B but not within range of A\n The protocol starts when A decides it wants to send data to B\n A begins by sending an RTS frame to B to request permission to send it a frame\n If B receives this request  it answers with a CTS frame to indicate that the channel is clear to send\n Upon receipt of the CTS  A sends its frame and starts an ACK timer\n Upon correct receipt of the data frame  B responds with an ACK frame  completing the exchange\n If A’s ACK timer expires before the ACK gets back to it  it is treated as a collision and the whole protocol is run again after a backoff\n THE MEDIUM ACCESS CONTROL SUBLAYER  \n  A RTS Data B CTS ACK C D NAV NAV Time Figure  -  \n Virtual channel sensing using CSMA/CA\n Now let us consider this exchange from the viewpoints of C and D\n C is within range of A  so it may receive the RTS frame\n If it does  it realizes that someone is going to send data soon\n From the information provided in the RTS request  it can estimate how long the sequence will take  including the final ACK\n So  for the good of all  it desists from transmitting anything until the exchange is completed\n It does so by updating its record of the NAV to indicate that the channel is busy  as shown in Fig\n  -  \n D does not hear the RTS  but it does hear the CTS  so it also updates its NAV\n Note that the NAV signals are not transmitted; they are just internal reminders to keep quiet for a certain period of time\n However  while RTS/CTS sounds good in theory  it is one of those designs that has proved to be of little value in practice\n Several reasons why it is seldom used are known\n It does not help for short frames (which are sent in place of the RTS) or for the AP (which everyone can hear  by definition)\n For other situations  it only slows down operation\n RTS/CTS in   \n  is a little different than in the MACA protocol we saw in   \n  because everyone hearing the RTS or CTS remains quiet for the duration to allow the ACK to get through without collision\n Because of this  it does not help with exposed terminals as MACA did  only with hidden terminals\n Most often there are few hidden terminals  and CSMA/CA already helps them by slowing down stations that transmit unsuccessfully  whatever the cause  to make it more likely that transmissions will succeed\n CSMA/CA with physical and virtual sensing is the core of the   \n  protocol\n However  there are several other mechanisms that have been developed to go with it\n Each of these mechanisms was driven by the needs of real operation  so we will look at them briefly\n The first need we will look at is reliability\n In contrast to wired networks  wireless networks are noisy and unreliable  in no small part due to interference from other kinds of devices  such as microwave ovens  which also use the unlicensed ISM bands\n The use of acknowledgements and retransmissions is of little help if the probability of getting a frame through is small in the first place\n   WIRELESS LANS The main strategy that is used to increase successful transmissions is to lower the transmission rate\n Slower rates use more robust modulations that are more likely to be received correctly for a given signal-to-noise ratio\n If too many frames are lost  a station can lower the rate\n If frames are delivered with little loss  a station can occasionally test a higher rate to see if it should be used\n Another strategy to improve the chance of the frame getting through undamaged is to send shorter frames\n If the probability of any bit being in error is p  the probability of an n-bit frame being received entirely correctly is (  − p)n\n For example  for p =  −  the probability of receiving a full Ethernet frame (  bits) correctly is less than  %\n Most frames will be lost\n But if the frames are only a third as long ( bits) two thirds of them will be received correctly\n Now most frames will get through and fewer retransmissions will be needed\n Shorter frames can be implemented by reducing the maximum size of the message that is accepted from the network layer\n Alternatively \n  allows frames to be split into smaller pieces  called fragments  each with its own checksum\n The fragment size is not fixed by the standard  but is a parameter that can be adjusted by the AP\n The fragments are individually numbered and acknowledged using a stop-and-wait protocol ( \n  the sender may not transmit fragment k +  until it has received the acknowledgement for fragment k)\n Once the channel has been acquired  multiple fragments are sent as a burst\n They go one after the other with an acknowledgement (and possibly retransmissions) in between  until either the whole frame has been successfully sent or the transmission time reaches the maximum allowed\n The NAV mechanism keeps other stations quiet only until the next acknowledgement  but another mechanism (see below) is used to allow a burst of fragments to be sent without other stations sending a frame in the middle\n The ond need we will discuss is saving power\n Battery life is always an issue with mobile wireless devices\n The   \n  standard pays attention to the issue of power management so that clients need not waste power when they have neither information to send nor to receive\n The basic mechanism for saving power builds on beacon frames\n Beacons are periodic broadcasts by the AP ( \n  every m)\n The frames advertise the presence of the AP to clients and carry system parameters  such as the identifier of the AP  the time  how long until the next beacon  and urity settings\n Clients can set a power-management bit in frames that they send to the AP to tell it that they are entering power-save mode\n In this mode  the client can doze and the AP will buffer traffic intended for it\n To check for incoming traffic  the client wakes up for every beacon  and checks a traffic map that is sent as part of the beacon\n This map tells the client if there is buffered traffic\n If so  the client sends a poll message to the AP  which then sends the buffered traffic\n The client can then go back to sleep until the next beacon is sent\n Another power-saving mechanism  called APSD (Automatic Power Save Delivery)  was also added to   \n  in \n With this new mechanism  the AP buffers frames and sends them to a client just after the client sends frames to the THE MEDIUM ACCESS CONTROL SUBLAYER  \n  AP\n The client can then go to sleep until it has more traffic to send (and receive)\n This mechanism works well for applications such as VoIP that have frequent traffic in both directions\n For example  a VoIP wireless phone might use it to send and receive frames every   m  much more frequently than the beacon interval of m  while dozing in between\n The third and last need we will examine is quality of service\n When the VoIP traffic in the preceding example competes with peer-to-peer traffic  the VoIP traffic will suffer\n It will be delayed due to contention with the high-bandwidth peer-to-peer traffic  even though the VoIP bandwidth is low\n These delays are likely to degrade the voice calls\n To prevent this degradation  we would like to let the VoIP traffic go ahead of the peer-to-peer traffic  as it is of higher priority\n IEEE   \n  has a clever mechanism to provide this kind of quality of service that was introduced as set of extensions under the name   \n  e in \n It works by extending CSMA/CA with carefully defined intervals between frames\n After a frame has been sent  a certain amount of idle time is required before any station may send a frame to check that the channel is no longer in use\n The trick is to define different time intervals for different kinds of frames\n Five intervals are depicted in Fig\n  -  \n The interval between regular data frames is called the DIFS (DCF InterFrame Spacing)\n Any station may attempt to acquire the channel to send a new frame after the medium has been idle for DIFS\n The usual contention rules apply  and binary exponential backoff may be needed if a collision occurs\n The shortest interval is SIFS (Short InterFrame Spacing)\n It is used to allow the parties in a single dialog the chance to go first\n Examples include letting the receiver send an ACK  other control frame sequences like RTS and CTS  or letting a sender transmit a burst of fragments\n Sending the next fragment after waiting only SIFS is what prevents another station from jumping in with a frame in the middle of the exchange\n ACK SIFS AIFS  DIFS EIFS AIFS  Control frame or next fragment may be sent here High-priority frame here Regular DCF frame here Low-priority frame here Bad frame recovery done Time Figure  -  \n Interframe spacing in    The two AIFS (Arbitration InterFrame Space) intervals show examples of two different priority levels\n The short interval  AIFS  is smaller than DIFS but longer than SIFS\n It can be used by the AP to move voice or other high-priority   WIRELESS LANS traffic to the head of the line\n The AP will wait for a shorter interval before it sends the voice traffic  and thus send it before regular traffic\n The long interval  AIFS  is larger than DIFS\n It is used for background traffic that can be deferred until after regular traffic\n The AP will wait for a longer interval before it sends this traffic  giving regular traffic the opportunity to transmit first\n The complete quality of service mechanism defines four different priority levels that have different backoff parameters as well as different idle parameters\n The last time interval  EIFS (Extended InterFrame Spacing)  is used only by a station that has just received a bad or unknown frame  to report the problem\n The idea is that since the receiver may have no idea of what is going on  it should wait a while to avoid interfering with an ongoing dialog between two stations\n A further part of the quality of service extensions is the notion of a TXOP or transmission opportunity\n The original CSMA/CA mechanism let stations send one frame at a time\n This design was fine until the range of rates increased\n With   \n  a/g  one station might be sending at  Mbps and another station be sending at   Mbps\n They each get to send one frame  but the  -Mbps station takes nine times as long (ignoring fixed overheads) as the  -Mbps station to send its frame\n This disparity has the unfortunate side effect of slowing down a fast sender who is competing with a slow sender to roughly the rate of the slow sender\n For example  again ignoring fixed overheads  when sending alone the  -Mbps and  -Mbps senders will get their own rates  but when sending together they will both get  \n  Mbps on average\n It is a stiff penalty for the fast sender\n This issue is known as the rate anomaly (Heusse et al\n  )\n With transmission opportunities  each station gets an equal amount of airtime  not an equal number of frames\n Stations that send at a higher rate for their airtime will get higher throughput\n In our example  when sending together the  -Mbps and  -Mbps senders will now get  Mbps and   Mbps  respectively\n    The   \n  Frame Structure The   \n  standard defines three different classes of frames in the air: data  control  and management\n Each of these has a header with a variety of fields used within the MAC sublayer\n In addition  there are some headers used by the physical layer  but these mostly deal with the modulation techniques used  so we will not discuss them here\n We will look at the format of the data frame as an example\n It is shown in Fig\n  -  \n First comes the Frame control field  which is made up of   subfields\n The first of these is the Protocol version  set to  \n It is there to allow future versions of   \n  to operate at the same time in the same cell\n Then come the Type (data  control  or management) and Subtype fields ( \n  RTS or CTS)\n For a regular data frame (without quality of service)  they are set to   and  in binary\n The To DS and From DS bits are set to indicate whether the frame is going to or coming from the network connected to the APs  which is called the distribution THE MEDIUM ACCESS CONTROL SUBLAYER  \n  system\n The More fragments bit means that more fragments will follow\n The Retry bit marks a retransmission of a frame sent earlier\n The Power management bit indicates that the sender is going into power-save mode\n The More data bit indicates that the sender has additional frames for the receiver\n The Protected Frame bit indicates that the frame body has been encrypted for urity\n We will discuss urity briefly in the next tion\n Finally  the Order bit tells the receiver that the higher layer expects the sequence of frames to arrive strictly in order\n Bytes   – Address  Sequence Duration (recipient) Data Frame control Check sequence    Address  (transmitter) Address  Subtype =  Type =   Version =   To DS From DS More frag\n Retry Pwr\n mgt\n More data Protected Order Bits  Figure  -  \n Format of the   \n  data frame\n The ond field of the data frame  the Duration field  tells how long the frame and its acknowledgement will occupy the channel  measured in microonds\n It is present in all types of frames  including control frames  and is what stations use to manage the NAV mechanism\n Next come addresses\n Data frames sent to or from an AP have three addresses  all in standard IEEE format\n The first address is the receiver  and the ond address is the transmitter\n They are obviously needed  but what is the third address for? Remember that the AP is simply a relay point for frames as they travel between a client and another point on the network  perhaps a distant client or a portal to the Internet\n The third address gives this distant endpoint\n The Sequence field numbers frames so that duplicates can be detected\n Of the   bits available   identify the fragment and   carry a number that is advanced with each new transmission\n The Data field contains the payload  up to  bytes\n The first bytes of this payload are in a format known as LLC (Logical Link Control)\n This layer is the glue that identifies the higher-layer protocol ( \n  IP) to which the payloads should be passed\n Last comes the Frame check sequence  which is the same  -bit CRC we saw in \n    and elsewhere\n Management frames have the same format as data frames  plus a format for the data portion that varies with the subtype ( \n  parameters in beacon frames)\n Control frames are short\n Like all frames  they have the Frame control  Duration  and Frame check sequence fields\n However  they may have only one address and no data portion\n Most of the key information is conveyed with the Subtype field ( \n  ACK  RTS and CTS)\n   WIRELESS LANS    Services The   \n  standard defines the services that the clients  the access points  and the network connecting them must be a conformant wireless LAN\n These services cluster into several groups\n The association service is used by mobile stations to connect themselves to APs\n Typically  it is used just after a station moves within radio range of the AP\n Upon arrival  the station learns the identity and capabilities of the AP  either from beacon frames or by directly asking the AP\n The capabilities include the data rates supported  urity arrangements  power-saving capabilities  quality of service support  and more\n The station sends a request to associate with the AP\n The AP may accept or reject the request\n Reassociation lets a station change its preferred AP\n This facility is useful for mobile stations moving from one AP to another AP in the same extended   \n  LAN  like a handover in the cellular network\n If it is used correctly  no data will be lost as a consequence of the handover\n (But   \n   like Ethernet  is just a best-effort service\n) Either the station or the AP may also disassociate  breaking their relationship\n A station should use this service before shutting down or leaving the network\n The AP may use it before going down for maintenance\n Stations must also authenticate before they can send frames via the AP  but authentication is handled in different ways depending on the choice of urity scheme\n If the   \n  network is ‘‘open ’’ anyone is allowed to use it\n Otherwise  credentials are needed to authenticate\n The recommended scheme  called WPA  (WiFi Protected Access  )  implements urity as defined in the   \n  i standard\n (Plain WPA is an interim scheme that implements a subset of   \n  i\n We will skip it and go straight to the complete scheme\n) With WPA  the AP can talk to an authentication server that has a username and password database to determine if the station is allowed to access the network\n Alternatively a pre-shared key  which is a fancy name for a network password  may be configured\n Several frames are exchanged between the station and the AP with a challenge and response that lets the station prove it has the right credentials\n This exchange happens after association\n The scheme that was used before WPA is called WEP (Wired Equivalent Privacy)\n For this scheme  authentication with a preshared key happens before association\n However  its use is discouraged because of design flaws that make WEP easy to compromise\n The first practical demonstration that WEP was broken came when Adam Stubblefield was a summer intern at AT&T (Stubblefield et al\n  )\n He was able to code up and test an attack in one week  much of which was spent getting permission from management to buy the WiFi cards needed for experiments\n Software to crack WEP passwords is now freely available\n Once frames reach the AP  the distribution service determines how to route them\n If the destination is local to the AP  the frames can be sent out directly over the air\n Otherwise  they will have to be forwarded over the wired network\n The THE MEDIUM ACCESS CONTROL SUBLAYER  \n  integration service handles any translation that is needed for a frame to be sent outside the   \n  LAN  or to arrive from outside the   \n  LAN\n The common case here is connecting the wireless LAN to the Internet\n Data transmission is what it is all about  so   \n  naturally provides a data delivery service\n This service lets stations transmit and receive data using the protocols we described earlier in this  ter\n Since   \n  is modeled on Ethernet and transmission over Ethernet is not guaranteed to be   % reliable  transmission over   \n  is not guaranteed to be reliable either\n Higher layers must deal with detecting and correcting errors\n Wireless is a broadcast signal\n For information sent over a wireless LAN to be kept confidential  it must be encrypted\n This goal is accomplished with a privacy service that manages the details of encryption and decryption\n The encryption algorithm for WPA  is based on AES (Advanced Encryption Standard)  a  \n government standard approved in \n The keys that are used for encryption are determined during the authentication procedure\n To handle traffic with different priorities  there is a QOS traffic scheduling service\n It uses the protocols we described to give voice and video traffic preferential treatment compared to best-effort and background traffic\n A companion service also provides higher-layer timer synchronization\n This lets stations coordinate their actions  which may be useful for media processing\n Finally  there are two services that help stations manage their use of the spectrum\n The transmit power control service gives stations the information they need to meet regulatory limits on transmit power that vary from region to region\n The dynamic frequency selection service give stations the information they need to avoid transmitting on frequencies in the  -GHz band that are being used for radar in the proximity\n With these services \n  provides a rich set of functionality for connecting nearby mobile clients to the Internet\n It has been a huge success  and the standard has repeatedly been amended to add more functionality\n For a perspective on where the standard has been and where it is heading  see Hiertz et al\n (   )  BROADBAND WIRELESS We have been indoors too long\n Let us go outdoors  where there is quite a bit of interesting networking over the so-called ‘‘last mile\n’’ With the deregulation of the telephone systems in many countries  competitors to the entrenched telephone companies are now often allowed to offer local voice and high-speed Internet service\n There is certainly plenty of demand\n The problem is that running fiber or coax to millions of homes and businesses is prohibitively expensive\n What is a competitor to do? The answer is broadband wireless\n Erecting a big antenna on a hill just outside of town is much easier and cheaper than digging many trenches and stringing   BROADBAND WIRELESS cables\n Thus  companies have begun to experiment with providing multimegabit wireless communication services for voice  Internet  movies on demand  etc\n To stimulate the market  IEEE formed a group to standardize a broadband wireless metropolitan area network\n The next number available in the numbering space was   \n   so the standard got this number\n Informally the technology is called WiMAX (Worldwide Interoperability for Microwave Access)\n We will use the terms   \n  and WiMAX interchangeably\n The first   \n  standard was approved in December \n Early versions provided a wireless local loop between fixed points with a line of sight to each other\n This design soon changed to make WiMAX a more competitive alternative to cable and DSL for Internet access\n By January  \n  had been revised to support non-line-of-sight links by using OFDM technology at frequencies between  GHz and   GHz\n This change made deployment much easier  though stations were still fixed locations\n The rise of  G cellular networks posed a threat by promising high data rates and mobility\n In response \n  was enhanced again to allow mobility at vehicular speeds by December \n Mobile broadband Internet access is the target of the current standard  IEEE   \n  -   \n Like the other standards \n  was heavily influenced by the OSI model  including the (sub)layers  terminology  service primitives  and more\n Unfortunately  also like OSI  it is fairly complicated\n In fact  the WiMAX Forum was created to define interoperable subsets of the standard for commercial offerings\n In the following tions  we will give a brief description of some of the highlights of the common forms of   \n  air interface  but this treatment is far from complete and leaves out many details\n For additional information about WiMAX and broadband wireless in general  see Andrews et al\n (   )\n    Comparison of   \n  with   \n  and  G At this point you may be thinking: why devise a new standard? Why not just use   \n  or  G? In fact  WiMAX combines aspects of both   \n  and  G  making it more like a  G technology\n Like   \n   WiMAX is all about wirelessly connecting devices to the Internet at megabit/ speeds  instead of using cable or DSL\n The devices may be mobile  or at least portable\n WiMAX did not start by adding low-rate data on the side of voice-like cellular networks;   \n  was designed to carry IP packets over the air and to connect to an IP-based wired network with a minimum of fuss\n The packets may carry peer-to-peer traffic  VoIP calls  or streaming media to support a range of applications\n Also like   \n   it is based on OFDM technology to ensure good performance in spite of wireless signal degradations such as multipath fading  and on MIMO technology to achieve high levels of throughput\n However  WiMAX is more like  G (and thus unlike   \n  ) in several key respects\n The key technical problem is to achieve high capacity by the efficient use of spectrum  so that a large number of subscribers in a coverage area can all get THE MEDIUM ACCESS CONTROL SUBLAYER  \n  high throughput\n The typical distances are at least   times larger than for an   \n  network\n Consequently  WiMAX base stations are more powerful than   \n  Access Points (APs)\n To handle weaker signals over larger distances  the base station uses more power and better antennas  and it performs more processing to handle errors\n To maximize throughput  transmissions are carefully scheduled by the base station for each particular subscriber; spectrum use is not left to chance with CSMA/CA  which may waste capacity with collisions\n Licensed spectrum is the expected case for WiMAX  typically around  \n  GHz in the  \n The whole system is substantially more optimized than    This complexity is worth it  considering the large amount of money involved for licensed spectrum\n Unlike   \n   the result is a managed and reliable service with good support for quality of service\n With all of these features \n  most closely resembles the  G cellular networks that are now being standardized under the name LTE (Long Term Evolution)\n While  G cellular networks are based on CDMA and support voice and data  G cellular networks will be based on OFDM with MIMO  and they will target data  with voice as just one application\n It looks like WiMAX and  G are on a collision course in terms of technology and applications\n Perhaps this convergence is unsurprising  given that the Internet is the killer application and OFDM and MIMO are the best-known technologies for efficiently using the spectrum\n    The   \n  Architecture and Protocol Stack The   \n  architecture is shown in Fig\n  -  \n Base stations connect directly to the provider’s backbone network  which is in turn connected to the Internet\n The base stations communicate with stations over the wireless air interface\n Two kinds of stations exist\n Subscriber stations remain in a fixed location  for example  broadband Internet access for homes\n Mobile stations can receive service while they are moving  for example  a car equipped with WiMAX\n The   \n  protocol stack that is used across the air interface is shown in Fig\n  -  \n The general structure is similar to that of the other networks  but with more sublayers\n The bottom layer deals with transmission  and here we have shown only the popular offerings of   \n   fixed and mobile WiMAX\n There is a different physical layer for each offering\n Both layers operate in licensed spectrum below   GHz and use OFDM  but in different ways\n Above the physical layer  the data link layer consists of three sublayers\n The bottom one deals with privacy and urity  which is far more crucial for public outdoor networks than for private indoor networks\n It manages encryption  decryption  and key management\n Next comes the MAC common sublayer part\n This part is where the main protocols  such as channel management  are located\n The model here is that the base station completely controls the system\n It can schedule the downlink ( \n  base to subscriber) channels very efficiently and plays a major role in managing   BROADBAND WIRELESS Base station Mobile stations Subscriber stations Backbone network (to Internet) Air interface Figure  -  \n The   \n  architecture\n “Fixed WiMAX” OFDM (  \n  a) “Mobile WiMAX” Scalable OFDMA (  \n  e) Service specific convergence sublayer Release date:  Upper layers Data link layer Physical layer MAC common sublayer urity sublayer IP  for example Figure  -  \n The   \n  protocol stack\n the uplink ( \n  subscriber to base) channels as well\n An unusual feature of this MAC sublayer is that  unlike those of the other protocols  it is completely connection oriented  in order to provide quality of service guarantees for telephony and multimedia communication\n The service-specific convergence sublayer takes the place of the logical link sublayer in the other protocols\n Its function is to provide an interface to the network layer\n Different convergence layers are defined to integrate seamlessly with different upper layers\n The important choice is IP  though the standard defines mappings for protocols such as Ethernet and ATM too\n Since IP is connectionless and the   \n  MAC sublayer is connection-oriented  this layer must map between addresses and connections\n THE MEDIUM ACCESS CONTROL SUBLAYER  \n     The   \n  Physical Layer Most WiMAX deployments use licensed spectrum around either  \n  GHz or  \n  GHz\n As with  G  finding available spectrum is a key problem\n To help  the   \n  standard is designed for flexibility\n It allows operation from  GHz to   GHz\n Channels of different sizes are supported  for example  \n  MHz for fixed WiMAX and from  \n  MHz to   MHz for mobile WiMAX\n Transmissions are sent over these channels with OFDM  the technique we described in \n   \n Compared to   \n   the   \n  OFDM design is optimized to make the most out of licensed spectrum and wide area transmissions\n The channel is divided into more subcarriers with a longer symbol duration to tolerate larger wireless signal degradations; WiMAX parameters are around   times larger than comparable   \n  parameters\n For example  in mobile WiMAX there are subcarriers for a  -MHz channel and the time to send a symbol on each subcarrier is roughly μ\n Symbols on each subcarrier are sent with QPSK  QAM-   or QAM-   modulation schemes we described in \n   \n When the mobile or subscriber station is near the base station and the received signal has a high signal-to-noise ratio (SNR)  QAM-  can be used to send  bits per symbol\n To reach distant stations with a low SNR  QPSK can be used to deliver  bits per symbol\n The data is first coded for error correction with the convolutional coding (or better schemes) that we described in \n   \n This coding is common on noisy channels to tolerate some bit errors without needing to send retransmissions\n In fact  the modulation and coding methods should sound familiar by now as they are used for many networks we have studied  including   \n  cable  and DSL\n The net result is that a base station can support up to  \n  Mbps of downlink traffic and  \n  Mbps of uplink traffic per  -MHz channel and pair of antennas\n One thing the designers of   \n  did not like was a certain aspect of the way GSM and DAMPS work\n Both of those systems use equal frequency bands for upstream and downstream traffic\n That is  they implicitly assume there is as much upstream traffic as downstream traffic\n For voice  traffic is symmetric for the most part  but for Internet access (and certainly Web surfing) there is often more downstream traffic than upstream traffic\n The ratio is often  :   :  or more: \n So  the designers chose a flexible scheme for dividing the channel between stations  called OFDMA (Orthogonal Frequency Division Multiple Access)\n With OFDMA  different sets of subcarriers can be assigned to different stations  so that more than one station can send or receive at once\n If this were   \n   all subcarriers would be used by one station to send at any given moment\n The added flexibility in how bandwidth is assigned can increase performance because a given subcarrier might be faded at one receiver due to multipath effects but clear at another\n Subcarriers can be assigned to the stations that can use them best\n As well as having asymmetric traffic  stations usually alternate between sending and receiving\n This method is called TDD (Time Division Duplex)\n The   BROADBAND WIRELESS alternative method  in which a station sends and receives at the same time (on different subcarrier frequencies)  is called FDD (Frequency Division Duplex)\n WiMAX allows both methods  but TDD is preferred because it is easier to implement and more flexible\n Guard Ranging Burst Burst Burst Burst Burst Burst Burst Burst Downlink map Uplink map Preamble Time Subcarrier Downlink Uplink Next frame Last frame Figure  -  \n Frame structure for OFDMA with time division duplexing\n Fig\n  -  shows an example of the frame structure that is repeated over time\n It starts with a preamble to synchronize all stations  followed by downlink transmissions from the base station\n First  the base station sends maps that tell all stations how the downlink and uplink subcarriers are assigned over the frame\n The base station controls the maps  so it can allocate different amounts of bandwidth to stations from frame to frame depending on the needs of each station\n Next  the base station sends bursts of traffic to different subscriber and mobile stations on the subcarriers at the times given in the map\n The downlink transmissions end with a guard time for stations to switch from receiving to transmitting\n Finally  the subscriber and mobile stations send their bursts of traffic to the base station in the uplink positions that were reserved for them in the map\n One of these uplink bursts is reserved for ranging  which is the process by which new stations adjust their timing and request initial bandwidth to connect to the base station\n Since no connection is set up at this stage  new stations just transmit and hope there is no collision\n    The   \n  MAC Sublayer Protocol The data link layer is divided into three sublayers  as we saw in Fig\n  -  \n Since we will not study cryptography until  \n   it is difficult to explain now how the urity sublayer works\n Suffice it to say that encryption is used to keep ret all data transmitted\n Only the frame payloads are encrypted; the headers THE MEDIUM ACCESS CONTROL SUBLAYER  \n  are not\n This property means that a snooper can see who is talking to whom but cannot tell what they are saying to each other\n If you already know something about cryptography  what follows is a oneparagraph explanation of the urity sublayer\n If you know nothing about cryptography  you are not likely to find the next paragraph terribly enlightening (but you might consider rereading it after finishing  \n  )\n When a subscriber connects to a base station  they perform mutual authentication with RSA public-key cryptography using X\n   certificates\n The payloads themselves are encrypted using a symmetric-key system  either AES (Rijndael) or DES with cipher block chaining\n Integrity checking uses SHA- \n Now that was not so bad  was it? Let us now look at the MAC common sublayer part\n The MAC sublayer is connection-oriented and point-to-multipoint  which means that one base station communicates with multiple subscriber stations\n Much of this design is borrowed from cable modems  in which one cable headend controls the transmissions of multiple cable modems at the customer premises\n The downlink direction is fairly straightforward\n The base station controls the physical-layer bursts that are used to send information to the different subscriber stations\n The MAC sublayer simply packs its frames into this structure\n To reduce overhead  there are several different options\n For example  MAC frames may be sent individually  or packed back-to-back into a group\n The uplink channel is more complicated since there are competing subscribers that need access to it\n Its allocation is tied closely to the quality of service issue\n Four classes of service are defined  as follows:  \n Constant bit rate service Real-time variable bit rate service Non-real-time variable bit rate service Best-effort service\n All service in   \n  is connection-oriented\n Each connection gets one of these service classes  determined when the connection is set up\n This design is different from that of   \n  or Ethernet  which are connectionless in the MAC sublayer\n Constant bit rate service is intended for transmitting uncompressed voice\n This service needs to send a predetermined amount of data at predetermined time intervals\n It is accommodated by dedicating certain bursts to each connection of this type\n Once the bandwidth has been allocated  the bursts are available automatically  without the need to ask for each one\n Real-time variable bit rate service is for compressed multimedia and other soft real-time applications in which the amount of bandwidth needed at each instant may vary\n It is accommodated by the base station polling the subscriber at a fixed interval to ask how much bandwidth is needed this time\n   BROADBAND WIRELESS Non-real-time variable bit rate service is for heavy transmissions that are not real time  such as large file transfers\n For this service  the base station polls the subscriber often  but not at rigidly prescribed time intervals\n Connections with this service can also use best-effort service  described next  to request bandwidth\n Best-effort service is for everything else\n No polling is done and the subscriber must contend for bandwidth with other best-effort subscribers\n Requests for bandwidth are sent in bursts marked in the uplink map as available for contention\n If a request is successful  its success will be noted in the next downlink map\n If it is not successful  the unsuccessful subscriber have to try again later\n To minimize collisions  the Ethernet binary exponential backoff algorithm is used\n    The   \n  Frame Structure All MAC frames begin with a generic header\n The header is followed by an optional payload and an optional checksum (CRC)  as illustrated in Fig\n  -  \n The payload is not needed in control frames  for example  those requesting channel slots\n The checksum is (surprisingly) also optional  due to the error correction in the physical layer and the fact that no attempt is ever made to retransmit realtime frames\n If no retransmissions will be attempted  why even bother with a checksum? But if there is a checksum  it is the standard IEEE CRC  and acknowledgements and retransmissions are used for reliability\n Bits (a) (b)  Type Length Type Bytes needed E EK C C I Connection ID Header Data CRC CRC Connection ID Header CRC        Bits Figure  -  \n (a) A generic frame\n (b) A bandwidth request frame\n A quick rundown of the header fields of Fig\n  -  (a) follows\n The EC bit tells whether the payload is encrypted\n The Type field identifies the frame type  mostly telling whether packing and fragmentation are present\n The CI field indicates the presence or absence of the final checksum\n The EK field tells which of the encryption keys is being used (if any)\n The Length field gives the complete length of the frame  including the header\n The Connection identifier tells which connection this frame belongs to\n Finally  the Header CRC field is a checksum over the header only  using the polynomial x  + x  + x +  \n The   \n  protocol has many kinds of frames\n An example of a different type of frame  one that is used to request bandwidth  is shown in Fig\n  -  (b)\n It THE MEDIUM ACCESS CONTROL SUBLAYER  \n  starts with a  bit instead of a  bit and is otherwise similar to the generic header except that the ond and third bytes form a  -bit number telling how much bandwidth is needed to carry the specified number of bytes\n Bandwidth request frames do not carry a payload or full-frame CRC\n A great deal more could be said about   \n   but this is not the place to say it\n For more information  please consult the IEEE   \n  - standard itself  BLUETOOTH In  the L\n M\n Ericsson company became interested in connecting its mobile phones to other devices ( \n  laptops) without cables\n Together with four other companies (IBM  Intel  Nokia  and Toshiba)  it formed a SIG (Special Interest Group   \n  consortium) in  to develop a wireless standard for interconnecting computing and communication devices and accessories using short-range  low-power  inexpensive wireless radios\n The project was named Bluetooth  after Harald Blaatand (Bluetooth) II (  –  )  a Viking king who unified ( \n  conquered) Denmark and Norway  also without cables\n Bluetooth  \n  was released in July  and since then the SIG has never looked back\n All manner of consumer electronic devices now use Bluetooth  from mobile phones and laptops to headsets  printers  keyboards  mice  gameboxes  watches  music players  navigation units  and more\n The Bluetooth protocols let these devices find and connect to each other  an act called pairing  and urely transfer data\n The protocols have evolved over the past decade  too\n After the initial protocols stabilized  higher data rates were added to Bluetooth  \n  in \n With the  \n  release in  Bluetooth can be used for device pairing in combination with   \n  for high-throughput data transfer\n The  \n  release in December  specified low-power operation\n That will be handy for people who do not want to change the batteries regularly in all of those devices around the house\n We will cover the main aspects of Bluetooth below\n    Bluetooth Architecture Let us start our study of the Bluetooth system with a quick overview of what it contains and what it is intended to do\n The basic unit of a Bluetooth system is a piconet  which consists of a master node and up to seven active slave nodes within a distance of   meters\n Multiple piconets can exist in the same (large) room and can even be connected via a bridge node that takes part in multiple piconets  as in Fig\n  -  \n An interconnected collection of piconets is called a scatternet\n In addition to the seven active slave nodes in a piconet  there can be up to parked nodes in the net\n These are devices that the master has switched to a lowpower state to reduce the drain on their batteries\n In parked state  a device cannot   BLUETOOTH S S S S S S S S S S S M M Bridge slave Parked slave Piconet  Piconet  Active slave Figure  -  \n Two piconets can be connected to form a scatternet\n do anything except respond to an activation or beacon signal from the master\n Two intermediate power states  hold and sniff  also exist  but these will not concern us here\n The reason for the master/slave design is that the designers intended to facilitate the implementation of complete Bluetooth chips for under $ \n The consequence of this decision is that the slaves are fairly dumb  basically just doing whatever the master tells them to do\n At its heart  a piconet is a centralized TDM system  with the master controlling the clock and determining which device gets to communicate in which time slot\n All communication is between the master and a slave; direct slave-slave communication is not possible\n    Bluetooth Applications Most network protocols just provide channels between communicating entities and let application designers figure out what they want to use them for\n For example \n  does not specify whether users should use their notebook computers for reading email  surfing the Web  or something else\n In contrast  the Bluetooth SIG specifies particular applications to be supported and provides different protocol stacks for each one\n At the time of writing  there are   applications  which are called profiles\n Unfortunately  this approach leads to a very large amount of complexity\n We will omit the complexity here but will briefly look at the profiles to see more clearly what the Bluetooth SIG is trying to accomplish\n Six of the profiles are for different uses of audio and video\n For example  the intercom profile allows two telephones to connect as walkie-talkies\n The headset and hands-free profiles both provide voice communication between a headset and its base station  as might be used for hands-free telephony while driving a car\n THE MEDIUM ACCESS CONTROL SUBLAYER  \n  Other profiles are for streaming stereo-quality audio and video  say  from a portable music player to headphones  or from a digital camera to a TV\n The human interface device profile is for connecting keyboards and mice to computers\n Other profiles let a mobile phone or other computer receive images from a camera or send images to a printer\n Perhaps of more interest is a profile to use a mobile phone as a remote control for a (Bluetooth-enabled) TV\n Still other profiles enable networking\n The personal area network profile lets Bluetooth devices form an ad hoc network or remotely access another network  such as an   \n  LAN  via an access point\n The dial-up networking profile was actually the original motivation for the whole project\n It allows a notebook computer to connect to a mobile phone containing a built-in modem without using wires\n Profiles for higher-layer information exchange have also been defined\n The synchronization profile is intended for loading data into a mobile phone when it leaves home and collecting data from it when it returns\n We will skip the rest of the profiles  except to mention that some profiles serve as building blocks on which the above profiles are built\n The generic access profile  on which all of the other profiles are built  provides a way to establish and maintain ure links (channels) between the master and the slaves\n The other generic profiles define the basics of object exchange and audio and video transport\n Utility profiles are used widely for functions such as emulating a serial line  which is especially useful for many legacy applications\n Was it really necessary to spell out all these applications in detail and provide different protocol stacks for each one? Probably not  but there were a number of different working groups that devised different parts of the standard  and each one just focused on its specific problem and generated its own profile\n Think of this as Conway’s Law in action\n (In the April  issue of Datamation magazine  Melvin Conway observed that if you assign n people to write a compiler  you will get an n-pass compiler  or more generally  the software structure mirrors the structure of the group that produced it\n) It would probably have been possible to get away with two protocol stacks instead of one for file transfer and one for streaming real-time communication\n    The Bluetooth Protocol Stack The Bluetooth standard has many protocols grouped loosely into the layers shown in Fig\n  -  \n The first observation to make is that the structure does not follow the OSI model  the TCP/IP model  the model  or any other model\n The bottom layer is the physical radio layer  which corresponds fairly well to the physical layer in the OSI and models\n It deals with radio transmission and modulation\n Many of the concerns here have to do with the goal of making the system inexpensive so that it can become a mass-market item\n   BLUETOOTH Host-controller interface Upper layers Datalink layer Physical Radio layer Link control (Baseband) Link manager L CAP Service RFcomm discovery Applications  \n Profile Profile Profile Figure  -  \n The Bluetooth protocol architecture\n The link control (or baseband) layer is somewhat analogous to the MAC sublayer but also includes elements of the physical layer\n It deals with how the master controls time slots and how these slots are grouped into frames\n Next come two protocols that use the link control protocol\n The link manager handles the establishment of logical channels between devices  including power management  pairing and encryption  and quality of service\n It lies below the host controller interface line\n This interface is a convenience for implementation: typically  the protocols below the line will be implemented on a Bluetooth chip  and the protocols above the line will be implemented on the Bluetooth device that hosts the chip\n The link protocol above the line is L CAP (Logical Link Control Adaptation Protocol)\n It frames variable-length messages and provides reliability if needed\n Many protocols use L CAP  such as the two utility protocols that are shown\n The service discovery protocol is used to locate services within the network\n The RFcomm (Radio Frequency communication) protocol emulates the standard serial port found on PCs for connecting the keyboard  mouse  and modem  among other devices\n The top layer is where the applications are located\n The profiles are represented by vertical boxes because they each define a slice of the protocol stack for a particular purpose\n Specific profiles  such as the headset profile  usually contain only those protocols needed by that application and no others\n For example  profiles may include L CAP if they have packets to send but skip L CAP if they have only a steady flow of audio samples\n In the following tions  we will examine the Bluetooth radio layer and various link protocols  since these roughly correspond to the physical and MAC sublayers in the other procotol stacks we have studied\n THE MEDIUM ACCESS CONTROL SUBLAYER  \n     The Bluetooth Radio Layer The radio layer moves the bits from master to slave  or vice versa\n It is a low-power system with a range of   meters operating in the same  \n -GHz ISM band as    The band is divided into   channels of  MHz each\n To coexist with other networks using the ISM band  frequency hopping spread spectrum is used\n There can be up to  hops/ over slots with a dwell time of μ\n All the nodes in a piconet hop frequencies simultaneously  following the slot timing and pseudorandom hop sequence dictated by the master\n Unfortunately  it turned out that early versions of Bluetooth and   \n  interfered enough to ruin each other’s transmissions\n Some companies responded by banning Bluetooth altogether  but eventually a technical solution was devised\n The solution is for Bluetooth to adapt its hop sequence to exclude channels on which there are other RF signals\n This process reduces the harmful interference\n It is called adaptive frequency hopping\n Three forms of modulation are used to send bits on a channel\n The basic scheme is to use frequency shift keying to send a  -bit symbol every microond  giving a gross data rate of  Mbps\n Enhanced rates were introduced with the  \n  version of Bluetooth\n These rates use phase shift keying to send either  or  bits per symbol  for gross data rates of  or  Mbps\n The enhanced rates are only used in the data portion of frames\n    The Bluetooth Link Layers The link control (or baseband) layer is the closest thing Bluetooth has to a MAC sublayer\n It turns the raw bit stream into frames and defines some key formats\n In the simplest form  the master in each piconet defines a series of   - μ time slots  with the master’s transmissions starting in the even slots and the slaves’ transmissions starting in the odd ones\n This scheme is traditional time division multiplexing  with the master getting half the slots and the slaves sharing the other half\n Frames can be  or  slots long\n Each frame has an overhead of bits for an access code and header  plus a settling time of   –   μ per hop to allow the inexpensive radio circuits to become stable\n The payload of the frame can be encrypted for confidentiality with a key that is chosen when the master and slave connect\n Hops only happen between frames  not during a frame\n The result is that a  -slot frame is much more efficient than a  -slot frame because the overhead is constant but more data is sent\n The link manager protocol sets up logical channels  called links  to carry frames between the master and a slave device that have discovered each other\n A pairing procedure is followed to make sure that the two devices are allowed to communicate before the link is used\n The old pairing method is that both devices must be configured with the same four-digit PIN (Personal Identification Number)\n The matching PIN is how each device would know that it was connecting to   BLUETOOTH the right remote device\n However  unimaginative users and devices default to PINs such as ‘‘   ’’ and ‘‘   ’’ meant that this method provided very little urity in practice\n The new ure simple pairing method enables users to confirm that both devices are displaying the same passkey  or to observe the passkey on one device and enter it into the ond device\n This method is more ure because users do not have to choose or set a PIN\n They merely confirm a longer  device-generated passkey\n Of course  it cannot be used on some devices with limited input/output  such as a hands-free headset\n Once pairing is complete  the link manager protocol sets up the links\n Two main kinds of links exist to carry user data\n The first is the SCO (Synchronous Connection Oriented) link\n It is used for real-time data  such as telephone connections\n This type of link is allocated a fixed slot in each direction\n A slave may have up to three SCO links with its master\n Each SCO link can transmit one  -bps PCM audio channel\n Due to the time-critical nature of SCO links  frames sent over them are never retransmitted\n Instead  forward error correction can be used to increase reliability\n The other kind is the ACL (Asynchronous ConnectionLess) link\n This type of link is used for packet-switched data that is available at irregular intervals\n ACL traffic is delivered on a best-effort basis\n No guarantees are given\n Frames can be lost and may have to be retransmitted\n A slave may have only one ACL link to its master\n The data sent over ACL links come from the L CAP layer\n This layer has four major functions\n First  it accepts packets of up to   KB from the upper layers and breaks them into frames for transmission\n At the far end  the frames are reassembled into packets\n ond  it handles the multiplexing and demultiplexing of multiple packet sources\n When a packet has been reassembled  the L CAP layer determines which upper-layer protocol to hand it to  for example  RFcomm or service discovery\n Third  L CAP handles error control and retransmission\n It detects errors and resends packets that were not acknowledged\n Finally  L CAP enforces quality of service requirements between multiple links\n    The Bluetooth Frame Structure Bluetooth defines several frame formats  the most important of which is shown in two forms in Fig\n  -  \n It begins with an access code that usually identifies the master so that slaves within radio range of two masters can tell which traffic is for them\n Next comes a  -bit header containing typical MAC sublayer fields\n If the frame is sent at the basic rate  the data field comes next\n It has up to  bits for a five-slot transmission\n For a single time slot  the format is the same except that the data field is bits\n If the frame is sent at the enhanced rate  the data portion may have up to two or three times as many bits because each symbol carries  or  bits instead of  THE MEDIUM ACCESS CONTROL SUBLAYER  \n  Repeated  times Bits – Access code Data (at  X rate)   Header (a) Basic rate data frame  top Access code Header Guard/Sync Data (at  X or  X rate) Trailer Bits  –  (b) Enhanced rate data frame  bottom  x micro slots Addr Type F A S CRC  Figure  -  \n Typical Bluetooth data frame at (a) basic and (b) enhanced  data rates\n bit\n These data are preceded by a guard field and a synchronization pattern that is used to switch to the faster data rate\n That is  the access code and header are carried at the basic rate and only the data portion is carried at the faster rate\n Enhanced-rate frames end with a short trailer\n Let us take a quick look at the common header\n The Address field identifies which of the eight active devices the frame is intended for\n The Type field identifies the frame type (ACL  SCO  poll  or null)  the type of error correction used in the data field  and how many slots long the frame is\n The Flow bit is asserted by a slave when its buffer is full and cannot receive any more data\n This bit enables a primitive form of flow control\n The Acknowledgement bit is used to piggyback an ACK onto a frame\n The Sequence bit is used to number the frames to detect retransmissions\n The protocol is stop-and-wait  so  bit is enough\n Then comes the  -bit header Checksum\n The entire  -bit header is repeated three times to form the  -bit header shown in Fig\n  -  \n On the receiving side  a simple circuit examines all three copies of each bit\n If all three are the same  the bit is accepted\n If not  the majority opinion wins\n Thus bits of transmission capacity are used to send   bits of header\n The reason is that to reliably send data in a noisy environment using cheap  low-powered ( \n  mW) devices with little computing capacity  a great deal of redundancy is needed\n Various formats are used for the data field for ACL and SCO frames\n The basic-rate SCO frames are a simple example to study: the data field is always bits\n Three variants are defined  permitting  or bits of actual payload  with the rest being used for error correction\n In the most reliable version (  -bit payload)  the contents are just repeated three times  the same as the header\n We can work out the capacity with this frame as follows\n Since the slave may use only the odd slots  it gets slots/  just as the master does\n With an  -bit   BLUETOOTH payload  the channel capacity from the slave is   bps as is the channel capacity from the master\n This capacity is exactly enough for a single full-duplex PCM voice channel (which is why a hop rate of  hops/ was chosen)\n That is  despite a raw bandwidth of  Mbps  a single full-duplex uncompressed voice channel can completely saturate the piconet\n The efficiency of  % is the result of spending  % of the capacity on settling time   % on headers  and  % on repetition coding\n This shortcoming highlights the value of the enhanced rates and frames of more than a single slot\n There is much more to be said about Bluetooth  but no more space to say it here\n For the curious  the Bluetooth  \n  specification contains all the details  RFID We have looked at MAC designs from LANs up to MANs and down to PANs\n As a last example  we will study a category of low-end wireless devices that people may not recognize as forming a computer network: the RFID (Radio Frequency IDentification) tags and readers that we described in \n   \n RFID technology takes many forms  used in smartcards  implants for pets  passports  library books  and more\n The form that we will look at was developed in the quest for an EPC (Electronic Product Code) that started with the Auto-ID Center at the Massachusetts Institute of Technology in \n An EPC is a replacement for a barcode that can carry a larger amount of information and is electronically readable over distances up to   m  even when it is not visible\n It is different technology than  for example  the RFID used in passports which must be placed quite close to a reader to perform a transaction\n The ability to communicate over a distance makes EPCs more relevant to our studies\n EPCglobal was formed in  to commercialize the RFID technology developed by the Auto-ID Center\n The effort got a boost in  when Walmart required its top suppliers to label all shipments with RFID tags\n Widespread deployment has been hampered by the difficulty of competing with cheap printed barcodes  but new uses  such as in drivers licenses  are now growing\n We will describe the ond generation of this technology  which is informally called EPC Gen  (EPCglobal  )\n    EPC Gen  Architecture The architecture of an EPC Gen  RFID network is shown in Fig\n  -  \n It has two key components: tags and readers\n RFID tags are small  inexpensive devices that have a unique  -bit EPC identifier and a small amount of memory that can be read and written by the RFID reader\n The memory might be used to record the location history of an item  for example  as it moves through the supply chain\n THE MEDIUM ACCESS CONTROL SUBLAYER  \n  Often  the tags look like stickers that can be placed on  for example  pairs of jeans on the shelves in a store\n Most of the sticker is taken up by an antenna that is printed onto it\n A tiny dot in the middle is the RFID integrated circuit\n Alternatively  the RFID tags can be integrated into an object  such as a driver’s license\n In both cases  the tags have no battery and they must gather power from the radio transmissions of a nearby RFID reader to run\n This kind of tag is called a ‘‘Class  ’’ tag to distinguish it from more capable tags that have batteries\n RFID reader RFID tag Backscatter signal Reader signal Figure  -  \n RFID architecture\n The readers are the intelligence in the system  analogous to base stations and access points in cellular and WiFi networks\n Readers are much more powerful than tags\n They have their own power sources  often have multiple antennas  and are in charge of when tags send and receive messages\n As there will commonly be multiple tags within the reading range  the readers must solve the multiple access problem\n There may be multiple readers that can contend with each other in the same area  too\n The main job of the reader is to inventory the tags in the neighborhood  that is  to discover the identifiers of the nearby tags\n The inventory is accomplished with the physical layer protocol and the tag-identification protocol that are outlined in the following tions\n    EPC Gen  Physical Layer The physical layer defines how bits are sent between the RFID reader and tags\n Much of it uses methods for sending wireless signals that we have seen previously\n In the  \n  transmissions are sent in the unlicensed   –   MHz ISM band\n This band falls in the UHF (Ultra High Frequency) range  so the tags are referred to as UHF RFID tags\n The reader performs frequency hopping at least every m to spread its signal across the channel  to limit interference and satisfy regulatory requirements\n The reader and tags use forms of ASK (Amplitude Shift Keying) modulation that we described in \n    to encode bits\n They take turns to send bits  so the link is half duplex\n   RFID There are two main differences from other physical layers that we have studied\n The first is that the reader is always transmitting a signal  regardless of whether it is the reader or tag that is communicating\n Naturally  the reader transmits a signal to send bits to tags\n For the tags to send bits to the reader  the reader transmits a fixed carrier signal that carries no bits\n The tags harvest this signal to get the power they need to run; otherwise  a tag would not be able to transmit in the first place\n To send data  a tag changes whether it is reflecting the signal from the reader  like a radar signal bouncing off a target  or absorbing it\n This method is called backscatter\n It differs from all the other wireless situations we have seen so far  in which the sender and receiver never both transmit at the same time\n Backscatter is a low-energy way for the tag to create a weak signal of its own that shows up at the reader\n For the reader to decode the incoming signal  it must filter out the outgoing signal that it is transmitting\n Because the tag signal is weak  tags can only send bits to the reader at a low rate  and tags cannot receive or even sense transmissions from other tags\n The ond difference is that very simple forms of modulation are used so that they can be implemented on a tag that runs on very little power and costs only a few cents to make\n To send data to the tags  the reader uses two amplitude levels\n Bits are determined to be either a  or a   depending on how long the reader waits before a low-power period\n The tag measures the time between low-power periods and compares this time to a reference measured during a preamble\n As shown in Fig\n  - s are longer than  s\n Tag responses consist of the tag alternating its backscatter state at fixed intervals to create a series of pulses in the signal\n Anywhere from one to eight pulse periods can be used to encode each  or   depending on the need for reliability\n  s have fewer transitions than  s  as is shown with an example of two-pulse period coding in Fig\n  -  \n Time Power Reader “ ” Reader “ ” Tag “ ” Tag “ ” Backscatter Figure  -  \n Reader and tag backscatter signals\n    EPC Gen  Tag Identification Layer To inventory the nearby tags  the reader needs to receive a message from each tag that gives the identifier for the tag\n This situation is a multiple access problem for which the number of tags is unknown in the general case\n The reader might THE MEDIUM ACCESS CONTROL SUBLAYER  \n  broadcast a query to ask all tags to send their identifiers\n However  tags that replied right away would then collide in much the same way as stations on a classic Ethernet\n We have seen many ways of tackling the multiple access problem in this  ter\n The closest protocol for the current situation  in which the tags cannot hear each others’ transmissions  is slotted ALOHA  one of the earliest protocols we studied\n This protocol is adapted for use in Gen  RFID\n The sequence of messages used to identify a tag is shown in Fig\n  -  \n In the first slot (slot  )  the reader sends a Query message to start the process\n Each QRepeat message advances to the next slot\n The reader also tells the tags the range of slots over which to randomize transmissions\n Using a range is necessary because the reader synchronizes tags when it starts the process; unlike stations on an Ethernet  tags do not wake up with a message at a time of their choosing\n Time RFID tag Query (slot  ) RN  (slot  ) EPC identifier \n\n QRepeat (slot ) Ack QRepeat (slot  ) QRepeat (slot N) QRepeat (slot  ) RFID reader Figure  -  \n Example message exchange to identify a tag\n Tags pick a random slot in which to reply\n In Fig\n  -   the tag replies in slot  \n However  tags do not send their identifiers when they first reply\n Instead  a tag sends a short  -bit random number in an RN  message\n If there is no collision  the reader receives this message and sends an ACK message of its own\n At this stage  the tag has acquired the slot and sends its EPC identifier\n The reason for this exchange is that EPC identifiers are long  so collisions on these messages would be expensive\n Instead  a short exchange is used to test whether the tag can safely use the slot to send its identifier\n Once its identifier has been successfully transmitted  the tag temporarily stops responding to new Query messages so that all the remaining tags can be identified\n   RFID A key problem is for the reader to adjust the number of slots to avoid collisions  but without using so many slots that performance suffers\n This adjustment is analogous to binary exponential backoff in Ethernet\n If the reader sees too many slots with no responses or too many slots with collisions  it can send a QAdjust message to decrease or increase the range of slots over which the tags are responding\n The RFID reader can perform other operations on the tags\n For example  it can select a subset of tags before running an inventory  allowing it to collect responses from  say  tagged jeans but not tagged shirts\n The reader can also write data to tags as they are identified\n This feature could be used to record the point of sale or other relevant information\n    Tag Identification Message Formats The format of the Query message is shown in Fig\n  -  as an example of a reader-to-tag message\n The message is compact because the downlink rates are limited  from   kbps up to kbps\n The Command field carries the code  to identify the message as a Query\n Physical parameters Bits  Command  DR M TR Sel Session Target Q CRC Tag selection Figure  -  \n Format of the Query message\n The next flags  DR  M  and TR  determine the physical layer parameters for reader transmissions and tag responses\n For example  the response rate may be set to between  kbps and kbps\n We will skip over the details of these flags\n Then come three fields  Sel  Session  and Target  that select the tags to respond\n As well as the readers being able to select a subset of identifiers  the tags keep track of up to four concurrent sessions and whether they have been identified in those sessions\n In this way  multiple readers can operate in overlapping coverage areas by using different sessions\n Next is the most important parameter for this command  Q\n This field defines the range of slots over which tags will respond  from  to  Q− \n Finally  there is a CRC to protect the message fields\n At  bits  it is shorter than most CRCs we have seen  but the Query message is much shorter than most packets too\n Tag-to-reader messages are simpler\n Since the reader is in control  it knows what message to expect in response to each of its transmissions\n The tag responses simply carry data  such as the EPC identifier\n THE MEDIUM ACCESS CONTROL SUBLAYER  \n  Originally the tags were just for identification purposes\n However  they have grown over time to resemble very small computers\n Some research tags have sensors and are able to run small programs to gather and process data (Sample et al\n  )\n One vision for this technology is the ‘‘Internet of things’’ that connects objects in the physical world to the Internet (Welbourne et al\n  ; and Gershenfeld et al\n  )  DATA LINK LAYER SWITCHING Many organizations have multiple LANs and wish to connect them\n Would it not be convenient if we could just join the LANs together to make a larger LAN? In fact  we can do this when the connections are made with devices called bridges\n The Ethernet switches we described in \n    are a modern name for bridges; they provide functionality that goes beyond classic Ethernet and Ethernet hubs to make it easy to join multiple LANs into a larger and faster network\n We shall use the terms ‘‘bridge’’ and ‘‘switch’’ interchangeably\n Bridges operate in the data link layer  so they examine the data link layer addresses to forward frames\n Since they are not supposed to examine the payload field of the frames they forward  they can handle IP packets as well as other kinds of packets  such as AppleTalk packets\n In contrast  routers examine the addresses in packets and route based on them  so they only work with the protocols that they were designed to handle\n In this tion  we will look at how bridges work and are used to join multiple physical LANs into a single logical LAN\n We will also look at how to do the reverse and treat one physical LAN as multiple logical LANs  called VLANs (Virtual LANs)\n Both technologies provide useful flexibility for managing networks\n For a comprehensive treatment of bridges  switches  and related topics  see Seifert and Edwards (   ) and Perlman (   )\n    Uses of Bridges Before getting into the technology of bridges  let us take a look at some common situations in which bridges are used\n We will mention three reasons why a single organization may end up with multiple LANs\n First  many university and corporate departments have their own LANs to connect their own personal computers  servers  and devices such as printers\n Since the goals of the various departments differ  different departments may set up different LANs  without regard to what other departments are doing\n Sooner or later  though  there is a need for interaction  so bridges are needed\n In this example  multiple LANs come into existence due to the autonomy of their owners\n   DATA LINK LAYER SWITCHING ond  the organization may be geographically spread over several buildings separated by considerable distances\n It may be cheaper to have separate LANs in each building and connect them with bridges and a few long-distance fiber optic links than to run all the cables to a single central switch\n Even if laying the cables is easy to do  there are limits on their lengths ( \n  m for twisted-pair gigabit Ethernet)\n The network would not work for longer cables due to the excessive signal attenuation or round-trip delay\n The only solution is to partition the LAN and install bridges to join the pieces to increase the total physical distance that can be covered\n Third  it may be necessary to split what is logically a single LAN into separate LANs (connected by bridges) to accommodate the load\n At many large universities  for example  thousands of workstations are available for student and faculty computing\n Companies may also have thousands of employees\n The scale of this system precludes putting all the workstations on a single LAN—there are more computers than ports on any Ethernet hub and more stations than allowed on a single classic Ethernet\n Even if it were possible to wire all the workstations together  putting more stations on an Ethernet hub or classic Ethernet would not add capacity\n All of the stations share the same  fixed amount of bandwidth\n The more stations there are  the less average bandwidth per station\n However  two separate LANs have twice the capacity of a single LAN\n Bridges let the LANs be joined together while keeping this capacity\n The key is not to send traffic onto ports where it is not needed  so that each LAN can run at full speed\n This behavior also increases reliability  since on a single LAN a defective node that keeps outputting a continuous stream of garbage can clog up the entire LAN\n By deciding what to forward and what not to forward  bridges act like fire doors in a building  preventing a single node that has gone berserk from bringing down the entire system\n To make these benefits easily available  ideally bridges should be completely transparent\n It should be possible to go out and buy bridges  plug the LAN cables into the bridges  and have everything work perfectly  instantly\n There should be no hardware changes required  no software changes required  no setting of address switches  no downloading of routing tables or parameters  nothing at all\n Just plug in the cables and walk away\n Furthermore  the operation of the existing LANs should not be affected by the bridges at all\n As far as the stations are concerned  there should be no observable difference whether or not they are part of a bridged LAN\n It should be as easy to move stations around the bridged LAN as it is to move them around a single LAN\n Surprisingly enough  it is actually possible to create bridges that are transparent\n Two algorithms are used: a backward learning algorithm to stop traffic being sent where it is not needed; and a spanning tree algorithm to break loops that may be formed when switches are cabled together willy-nilly\n Let us now take a look at these algorithms in turn to learn how this magic is accomplished\n THE MEDIUM ACCESS CONTROL SUBLAYER  \n     Learning Bridges The topology of two LANs bridged together is shown in Fig\n  -  for two cases\n On the left-hand side  two multidrop LANs  such as classic Ethernets  are joined by a special station—the bridge—that sits on both LANs\n On the right-hand side  LANs with point-to-point cables  including one hub  are joined together\n The bridges are the devices to which the stations and hub are attached\n If the LAN technology is Ethernet  the bridges are better known as Ethernet switches\n (a) (b) A D Bridge B  Port B C E G F C Bridge B  B  A B G D H  Port    F E Hub Figure  -  \n (a) Bridge connecting two multidrop LANs\n (b) Bridges (and a hub) connecting seven point-to-point stations\n Bridges were developed when classic Ethernets were in use  so they are often shown in topologies with multidrop cables  as in Fig\n  -  (a)\n However  all the topologies that are encountered today are comprised of point-to-point cables and switches\n The bridges work the same way in both settings\n All of the stations attached to the same port on a bridge belong to the same collision domain  and this is different than the collision domain for other ports\n If there is more than one station  as in a classic Ethernet  a hub  or a half-duplex link  the CSMA/CD protocol is used to send frames\n There is a difference  however  in how the bridged LANs are built\n To bridge multidrop LANs  a bridge is added as a new station on each of the multidrop LANs  as in Fig\n  -  (a)\n To bridge point-to-point LANs  the hubs are either connected to a bridge or  preferably  replaced with a bridge to increase performance\n In Fig\n  -  (b)  bridges have replaced all but one hub\n Different kinds of cables can also be attached to one bridge\n For example  the cable connecting bridge B  to bridge B  in Fig\n  -  (b) might be a long-distance fiber optic link  while the cable connecting the bridges to stations might be a short-haul twisted-pair line\n This arrangement is useful for bridging LANs in different buildings\n Now let us consider what happens inside the bridges\n Each bridge operates in promiscuous mode  that is  it accepts every frame transmitted by the stations   DATA LINK LAYER SWITCHING attached to each of its ports\n The bridge must decide whether to forward or discard each frame  and  if the former  on which port to output the frame\n This decision is made by using the destination address\n As an example  consider the topology of Fig\n  -  (a)\n If station A sends a frame to station B  bridge B  will receive the frame on port  \n This frame can be immediately discarded without further ado because it is already on the correct port\n However  in the topology of Fig\n  -  (b) suppose that A sends a frame to D\n Bridge B  will receive the frame on port  and output it on port  \n Bridge B  will then receive the frame on its port  and output it on its port  \n A simple way to implement this scheme is to have a big (hash) table inside the bridge\n The table can list each possible destination and which output port it belongs on\n For example  in Fig\n  -  (b)  the table at B  would list D as belonging to port   since all B  has to know is which port to put frames on to reach D\n That  in fact  more forwarding will happen later when the frame hits B  is not of interest to B \n When the bridges are first plugged in  all the hash tables are empty\n None of the bridges know where any of the destinations are  so they use a flooding algorithm: every incoming frame for an unknown destination is output on all the ports to which the bridge is connected except the one it arrived on\n As time goes on  the bridges learn where destinations are\n Once a destination is known  frames destined for it are put only on the proper port; they are not flooded\n The algorithm used by the bridges is backward learning\n As mentioned above  the bridges operate in promiscuous mode  so they see every frame sent on any of their ports\n By looking at the source addresses  they can tell which machines are accessible on which ports\n For example  if bridge B  in Fig\n  -  (b) sees a frame on port  coming from C  it knows that C must be reachable via port   so it makes an entry in its hash table\n Any subsequent frame addressed to C coming in to B  on any other port will be forwarded to port  \n The topology can change as machines and bridges are powered up and down and moved around\n To handle dynamic topologies  whenever a hash table entry is made  the arrival time of the frame is noted in the entry\n Whenever a frame whose source is already in the table arrives  its entry is updated with the current time\n Thus  the time associated with every entry tells the last time a frame from that machine was seen\n Periodically  a process in the bridge scans the hash table and purges all entries more than a few minutes old\n In this way  if a computer is unplugged from its LAN  moved around the building  and plugged in again somewhere else  within a few minutes it will be back in normal operation  without any manual intervention\n This algorithm also means that if a machine is quiet for a few minutes  any traffic sent to it will have to be flooded until it next sends a frame itself\n The routing procedure for an incoming frame depends on the port it arrives on (the source port) and the address to which it is destined (the destination address)\n The procedure is as follows\n THE MEDIUM ACCESS CONTROL SUBLAYER  \n   \n If the port for the destination address is the same as the source port  discard the frame If the port for the destination address and the source port are different  forward the frame on to the destination port If the destination port is unknown  use flooding and send the frame on all ports except the source port\n You might wonder whether the first case can occur with point-to-point links\n The answer is that it can occur if hubs are used to connect a group of computers to a bridge\n An example is shown in Fig\n  -  (b) where stations E and F are connected to hub H  which is in turn connected to bridge B \n If E sends a frame to F  the hub will relay it to B  as well as to F\n That is what hubs do—they wire all ports together so that a frame input on one port is simply output on all other ports\n The frame will arrive at B  on port   which is already the right output port to reach the destination\n Bridge B  need only discard the frame\n As each frame arrives  this algorithm must be applied  so it is usually implemented with special-purpose VLSI chips\n The chips do the lookup and update the table entry  all in a few microonds\n Because bridges only look at the MAC addresses to decide how to forward frames  it is possible to start forwarding as soon as the destination header field has come in  before the rest of the frame has arrived (provided the output line is available  of course)\n This design reduces the latency of passing through the bridge  as well as the number of frames that the bridge must be able to buffer\n It is referred to as cut-through switching or wormhole routing and is usually handled in hardware\n We can look at the operation of a bridge in terms of protocol stacks to understand what it means to be a link layer device\n Consider a frame sent from station A to station D in the configuration of Fig\n  -  (a)  in which the LANs are Ethernet\n The frame will pass through one bridge\n The protocol stack view of processing is shown in Fig\n  -  \n The packet comes from a higher layer and descends into the Ethernet MAC layer\n It acquires an Ethernet header (and also a trailer  not shown in the figure)\n This unit is passed to the physical layer  goes out over the cable  and is picked up by the bridge\n In the bridge  the frame is passed up from the physical layer to the Ethernet MAC layer\n This layer has extended processing compared to the Ethernet MAC layer at a station\n It passes the frame to a relay  still within the MAC layer\n The bridge relay function uses only the Ethernet MAC header to determine how to handle the frame\n In this case  it passes the frame to the Ethernet MAC layer of the port used to reach station D  and the frame continues on its way\n In the general case  relays at a given layer can rewrite the headers for that layer\n VLANs will provide an example shortly\n In no case should the bridge look inside the frame and learn that it is carrying an IP packet; that is irrelevant to the   DATA LINK LAYER SWITCHING Eth Eth Packet Packet Packet Relay Network Ethernet MAC Physical Bridge Station A Station D Wire Wire Eth Eth Packet Packet Packet Eth Packet Eth Packet Eth Packet Eth Packet Figure  -  \n Protocol processing at a bridge\n bridge processing and would violate protocol layering\n Also note that a bridge with k ports will have k instances of MAC and physical layers\n The value of k is  for our simple example\n    Spanning Tree Bridges To increase reliability  redundant links can be used between bridges\n In the example of Fig\n  -   there are two links in parallel between a pair of bridges\n This design ensures that if one link is cut  the network will not be partitioned into two sets of computers that cannot talk to each other\n Frame F  Bridge B  A B  Redundant links F  F  F  F  Figure  -  \n Bridges with two parallel links\n However  this redundancy introduces some additional problems because it creates loops in the topology\n An example of these problems can be seen by looking at how a frame sent by A to a previously unobserved destination is handled in Fig\n  -  \n Each bridge follows the normal rule for handling unknown destinations  which is to flood the frame\n Call the frame from A that reaches bridge B  frame F \n The bridge sends copies of this frame out all of its other ports\n We THE MEDIUM ACCESS CONTROL SUBLAYER  \n  will only consider the bridge ports that connect B  to B  (though the frame will be sent out the other ports  too)\n Since there are two links from B  to B  two copies of the frame will reach B \n They are shown in Fig\n  -  as F  and F \n Shortly thereafter  bridge B  receives these frames\n However  it does not (and cannot) know that they are copies of the same frame  rather than two different frames sent one after the other\n So bridge B  takes F  and sends copies of it out all the other ports  and it also takes F  and sends copies of it out all the other ports\n This produces frames F  and F  that are sent along the two links back to B \n Bridge B  then sees two new frames with unknown destinations and copies them again\n This cycle goes on forever\n The solution to this difficulty is for the bridges to communicate with each other and overlay the actual topology with a spanning tree that reaches every bridge\n In effect  some potential connections between bridges are ignored in the interest of constructing a fictitious loop-free topology that is a subset of the actual topology\n For example  in Fig\n  -  we see five bridges that are interconnected and also have stations connected to them\n Each station connects to only one bridge\n There are some redundant connections between the bridges so that frames will be forwarded in loops if all of the links are used\n This topology can be thought of as a graph in which the bridges are the nodes and the point-to-point links are the edges\n The graph can be reduced to a spanning tree  which has no cycles by definition  by dropping the links shown as dashed lines in Fig\n  -  \n Using this spanning tree  there is exactly one path from every station to every other station\n Once the bridges have agreed on the spanning tree  all forwarding between stations follows the spanning tree\n Since there is a unique path from each source to each destination  loops are impossible\n Bridge Station B  B  B  B  B  Link that is not part of the spanning tree Root bridge Figure  -  \n A spanning tree connecting five bridges\n The dashed lines are links that are not part of the spanning tree\n To build the spanning tree  the bridges run a distributed algorithm\n Each bridge periodically broadcasts a configuration message out all of its ports to its   DATA LINK LAYER SWITCHING neighbors and processes the messages it receives from other bridges  as described next\n These messages are not forwarded  since their purpose is to build the tree  which can then be used for forwarding\n The bridges must first choose one bridge to be the root of the spanning tree\n To make this choice  they each include an identifier based on their MAC address in the configuration message  as well as the identifier of the bridge they believe to be the root\n MAC addresses are installed by the manufacturer and guaranteed to be unique worldwide  which makes these identifiers convenient and unique\n The bridges choose the bridge with the lowest identifier to be the root\n After enough messages have been exchanged to spread the news  all bridges will agree on which bridge is the root\n In Fig\n  -   bridge B  has the lowest identifier and becomes the root\n Next  a tree of shortest paths from the root to every bridge is constructed\n In Fig\n  -   bridges B  and B  can each be reached from bridge B  directly  in one hop that is a shortest path\n Bridge B  can be reached in two hops  via either B  or B \n To break this tie  the path via the bridge with the lowest identifier is chosen  so B  is reached via B \n Bridge B  can be reached in two hops via B \n To find these shortest paths  bridges include the distance from the root in their configuration messages\n Each bridge remembers the shortest path it finds to the root\n The bridges then turn off ports that are not part of the shortest path\n Although the tree spans all the bridges  not all the links (or even bridges) are necessarily present in the tree\n This happens because turning off the ports prunes some links from the network to prevent loops\n Even after the spanning tree has been established  the algorithm continues to run during normal operation to automatically detect topology changes and update the tree\n The algorithm for constructing the spanning tree was invented by Radia Perlman\n Her job was to solve the problem of joining LANs without loops\n She was given a week to do it  but she came up with the idea for the spanning tree algorithm in a day\n Fortunately  this left her enough time to write it as a poem (Perlman  ): I think that I shall never see A graph more lovely than a tree\n A tree whose crucial property Is loop-free connectivity\n A tree which must be sure to span\n So packets can reach every LAN\n First the Root must be selected By ID it is elected\n Least cost paths from Root are traced In the tree these paths are placed\n A mesh is made by folks like me Then bridges find a spanning tree\n THE MEDIUM ACCESS CONTROL SUBLAYER  \n  The spanning tree algorithm was then standardized as IEEE   \n D and used for many years\n In  it was revised to more rapidly find a new spanning tree after a topology change\n For a detailed treatment of bridges  see Perlman (   )\n    Repeaters  Hubs  Bridges  Switches  Routers  and Gateways So far in this book  we have looked at a variety of ways to get frames and packets from one computer to another\n We have mentioned repeaters  hubs  bridges  switches  routers  and gateways\n All of these devices are in common use  but they all differ in subtle and not-so-subtle ways\n Since there are so many of them  it is probably worth taking a look at them together to see what the similarities and differences are\n The key to understanding these devices is to realize that they operate in different layers  as illustrated in Fig\n  -  (a)\n The layer matters because different devices use different pieces of information to decide how to switch\n In a typical scenario  the user generates some data to be sent to a remote machine\n Those data are passed to the transport layer  which then adds a header (for example  a TCP header) and passes the resulting unit down to the network layer\n The network layer adds its own header to form a network layer packet ( \n  an IP packet)\n In Fig\n  -  (b)  we see the IP packet shaded in gray\n Then the packet goes to the data link layer  which adds its own header and checksum (CRC) and gives the resulting frame to the physical layer for transmission  for example  over a LAN\n Application layer Application gateway Transport layer Transport gateway Network layer Router Frame header Packet header TCP header Packet (supplied by network layer) Frame (built by data link layer) (a) (b) User data CRC Data link layer Bridge  switch Physical layer Repeater  hub Figure  -  \n (a) Which device is in which layer\n (b) Frames  packets  and headers\n Now let us look at the switching devices and see how they relate to the packets and frames\n At the bottom  in the physical layer  we find the repeaters\n These are analog devices that work with signals on the cables to which they are connected\n A signal appearing on one cable is cleaned up  amplified  and put out on another cable\n Repeaters do not understand frames  packets  or headers\n They understand the symbols that encode bits as volts\n Classic Ethernet  for example  was   DATA LINK LAYER SWITCHING designed to allow four repeaters that would boost the signal to extend the maximum cable length from meters to  meters\n Next we come to the hubs\n A hub has a number of input lines that it joins electrically\n Frames arriving on any of the lines are sent out on all the others\n If two frames arrive at the same time  they will collide  just as on a coaxial cable\n All the lines coming into a hub must operate at the same speed\n Hubs differ from repeaters in that they do not (usually) amplify the incoming signals and are designed for multiple input lines  but the differences are slight\n Like repeaters  hubs are physical layer devices that do not examine the link layer addresses or use them in any way\n Now let us move up to the data link layer  where we find bridges and switches\n We just studied bridges at some length\n A bridge connects two or more LANs\n Like a hub  a modern bridge has multiple ports  usually enough for  to   input lines of a certain type\n Unlike in a hub  each port is isolated to be its own collision domain; if the port has a full-duplex point-to-point line  the CSMA/CD algorithm is not needed\n When a frame arrives  the bridge extracts the destination address from the frame header and looks it up in a table to see where to send the frame\n For Ethernet  this address is the  -bit destination address shown in Fig\n  -  \n The bridge only outputs the frame on the port where it is needed and can forward multiple frames at the same time\n Bridges offer much better performance than hubs  and the isolation between bridge ports also means that the input lines may run at different speeds  possibly even with different network types\n A common example is a bridge with ports that connect to  - -  and -Mbps Ethernet\n Buffering within the bridge is needed to accept a frame on one port and transmit the frame out on a different port\n If frames come in faster than they can be retransmitted  the bridge may run out of buffer space and have to start discarding frames\n For example  if a gigabit Ethernet is pouring bits into a  -Mbps Ethernet at top speed  the bridge will have to buffer them  hoping not to run out of memory\n This problem still exists even if all the ports run at the same speed because more than one port may be sending frames to a given destination port\n Bridges were originally intended to be able to join different kinds of LANs  for example  an Ethernet and a Token Ring LAN\n However  this never worked well because of differences between the LANs\n Different frame formats require copying and reformatting  which takes CPU time  requires a new checksum calculation  and introduces the possibility of undetected errors due to bad bits in the bridge’s memory\n Different maximum frame lengths are also a serious problem with no good solution\n Basically  frames that are too large to be forwarded must be discarded\n So much for transparency\n Two other areas where LANs can differ are urity and quality of service\n Some LANs have link-layer encryption  for example   \n   and some do not  for example Ethernet\n Some LANs have quality of service features such as priorities  for example   \n   and some do not  for example Ethernet\n Consequently  when THE MEDIUM ACCESS CONTROL SUBLAYER  \n  a frame must travel between these LANs  the urity or quality of service expected by the sender may not be able to be provided\n For all of these reasons  modern bridges usually work for one network type  and routers  which we will come to soon  are used instead to join networks of different types\n Switches are modern bridges by another name\n The differences are more to do with marketing than technical issues  but there are a few points worth knowing\n Bridges were developed when classic Ethernet was in use  so they tend to join relatively few LANs and thus have relatively few ports\n The term ‘‘switch’’ is more popular nowadays\n Also  modern installations all use point-to-point links  such as twisted-pair cables  so individual computers plug directly into a switch and thus the switch will tend to have many ports\n Finally  ‘‘switch’’ is also used as a general term\n With a bridge  the functionality is clear\n On the other hand  a switch may refer to an Ethernet switch or a completely different kind of device that makes forwarding decisions  such as a telephone switch\n So far  we have seen repeaters and hubs  which are actually quite similar  as well as bridges and switches  which are even more similar to each other\n Now we move up to routers  which are different from all of the above\n When a packet comes into a router  the frame header and trailer are stripped off and the packet located in the frame’s payload field (shaded in Fig\n  -  ) is passed to the routing software\n This software uses the packet header to choose an output line\n For an IP packet  the packet header will contain a  -bit (IPv ) or   -bit (IPv ) address  but not a  -bit IEEE address\n The routing software does not see the frame addresses and does not even know whether the packet came in on a LAN or a point-to-point line\n We will study routers and routing in   Up another layer  we find transport gateways\n These connect two computers that use different connection-oriented transport protocols\n For example  suppose a computer using the connection-oriented TCP/IP protocol needs to talk to a computer using a different connection-oriented transport protocol called SCTP\n The transport gateway can copy the packets from one connection to the other  reformatting them as need be\n Finally  application gateways understand the format and contents of the data and can translate messages from one format to another\n An email gateway could translate Internet messages into SMS messages for mobile phones  for example\n Like ‘‘switch ’’ ‘‘gateway’’ is somewhat of a general term\n It refers to a forwarding process that runs at a high layer\n    Virtual LANs In the early days of local area networking  thick yellow cables snaked through the cable ducts of many office buildings\n Every computer they passed was plugged in\n No thought was given to which computer belonged on which LAN\n All the people in adjacent offices were put on the same LAN  whether they belonged together or not\n Geography trumped corporate organization charts\n   DATA LINK LAYER SWITCHING With the advent of twisted pair and hubs in the s  all that changed\n Buildings were rewired (at considerable expense) to rip out all the yellow garden hoses and install twisted pairs from every office to central wiring closets at the end of each corridor or in a central machine room  as illustrated in Fig\n  -  \n If the Vice President in Charge of Wiring was a visionary  Category  twisted pairs were installed; if he was a bean counter  the existing (Category  ) telephone wiring was used (only to be replaced a few years later  when fast Ethernet emerged)\n Twisted pair to a hub Office Switch Hub Hub Corridor Cable duct Figure  -  \n A building with centralized wiring using hubs and a switch\n Today  the cables have changed and hubs have become switches  but the wiring pattern is still the same\n This pattern makes it possible to configure LANs logically rather than physically\n For example  if a company wants k LANs  it could buy k switches\n By carefully choosing which connectors to plug into which switches  the occupants of a LAN can be chosen in a way that makes organizational sense  without too much regard to geography\n Does it matter who is on which LAN? After all  in nearly all organizations  all the LANs are interconnected\n In short  yes  it often matters\n Network administrators like to group users on LANs to reflect the organizational structure rather than the physical layout of the building  for a variety of reasons\n One issue is urity\n One LAN might host Web servers and other computers intended for public use\n Another LAN might host computers containing the records of the Human Resources department that are not to be passed outside of the department\n In such a situation  putting all the computers on a single LAN and not letting any of the servers be accessed from off the LAN makes sense\n Management tends to frown when hearing that such an arrangement is impossible\n THE MEDIUM ACCESS CONTROL SUBLAYER  \n  A ond issue is load\n Some LANs are more heavily used than others and it may be desirable to separate them\n For example  if the folks in research are running all kinds of nifty experiments that sometimes get out of hand and saturate their LAN  the folks in management may not be enthusiastic about donating some of the capacity they were using for videoconferencing to help out\n Then again  this might impress on management the need to install a faster network\n A third issue is broadcast traffic\n Bridges broadcast traffic when the location of the destination is unknown  and upper-layer protocols use broadcasting as well\n For example  when a user wants to send a packet to an IP address x  how does it know which MAC address to put in the frame? We will study this question in  \n   but briefly summarized  the answer is that it broadcasts a frame containing the question ‘‘who owns IP address x?’’ Then it waits for an answer\n As the number of computers in a LAN grows  so does the number of broadcasts\n Each broadcast consumes more of the LAN capacity than a regular frame because it is delivered to every computer on the LAN\n By keeping LANs no larger than they need to be  the impact of broadcast traffic is reduced\n Related to broadcasts is the problem that once in a while a network interface will break down or be misconfigured and begin generating an endless stream of broadcast frames\n If the network is really unlucky  some of these frames will elicit responses that lead to ever more traffic\n The result of this broadcast storm is that ( ) the entire LAN capacity is occupied by these frames  and ( ) all the machines on all the interconnected LANs are crippled just processing and discarding all the frames being broadcast\n At first it might appear that broadcast storms could be limited in scope by separating the LANs with bridges or switches  but if the goal is to achieve transparency ( \n  a machine can be moved to a different LAN across the bridge without anyone noticing it)  then bridges have to forward broadcast frames\n Having seen why companies might want multiple LANs with restricted scopes  let us get back to the problem of decoupling the logical topology from the physical topology\n Building a physical topology to reflect the organizational structure can add work and cost  even with centralized wiring and switches\n For example  if two people in the same department work in different buildings  it may be easier to wire them to different switches that are part of different LANs\n Even if this is not the case  a user might be shifted within the company from one department to another without changing offices  or might change offices without changing departments\n This might result in the user being on the wrong LAN until an administrator changes the user’s connector from one switch to another\n Furthermore  the number of computers that belong to different departments may not be a good match for the number of ports on switches; some departments may be too small and others so big that they require multiple switches\n This results in wasted switch ports that are not used\n In many companies  organizational changes occur all the time  meaning that system administrators spend a lot of time pulling out plugs and pushing them back   DATA LINK LAYER SWITCHING in somewhere else\n Also  in some cases  the change cannot be made at all because the twisted pair from the user’s machine is too far from the correct switch ( \n  in the wrong building)  or the available switch ports are on the wrong LAN\n In response to customer requests for more flexibility  network vendors began working on a way to rewire buildings entirely in software\n The resulting concept is called a VLAN (Virtual LAN)\n It has been standardized by the IEEE committee and is now widely deployed in many organizations\n Let us now take a look at it\n For additional information about VLANs  see Seifert and Edwards (   )\n VLANs are based on VLAN-aware switches\n To set up a VLAN-based network  the network administrator decides how many VLANs there will be  which computers will be on which VLAN  and what the VLANs will be called\n Often the VLANs are (informally) named by colors  since it is then possible to print color diagrams showing the physical layout of the machines  with the members of the red LAN in red  members of the green LAN in green  and so on\n In this way  both the physical and logical layouts are visible in a single view\n As an example  consider the bridged LAN of Fig\n  -   in which nine of the machines belong to the G (gray) VLAN and five belong to the W (white) VLAN\n Machines from the gray VLAN are spread across two switches  including two machines that connect to a switch via a hub\n Gray station B  B  Hub G W W GW G G G GW G G G G W W White station Gray port White port Gray and White port Bridge Figure  -  \n Two VLANs  gray and white  on a bridged LAN\n To make the VLANs function correctly  configuration tables have to be set up in the bridges\n These tables tell which VLANs are accessible via which ports\n When a frame comes in from  say  the gray VLAN  it must be forwarded on all the ports marked with a G\n This holds for ordinary ( \n  unicast) traffic for which the bridges have not learned the location of the destination  as well as for multicast and broadcast traffic\n Note that a port may be labeled with multiple VLAN colors\n As an example  suppose that one of the gray stations plugged into bridge B  in Fig\n  -  sends a frame to a destination that has not been observed beforehand\n Bridge B  will receive the frame and see that it came from a machine on the gray THE MEDIUM ACCESS CONTROL SUBLAYER  \n  VLAN  so it will flood the frame on all ports labeled G (except the incoming port)\n The frame will be sent to the five other gray stations attached to B  as well as over the link from B  to bridge B \n At bridge B  the frame is similarly forwarded on all ports labeled G\n This sends the frame to one further station and the hub (which will transmit the frame to all of its stations)\n The hub has both labels because it connects to machines from both VLANs\n The frame is not sent on other ports without G in the label because the bridge knows that there are no machines on the gray VLAN that can be reached via these ports\n In our example  the frame is only sent from bridge B  to bridge B  because there are machines on the gray VLAN that are connected to B \n Looking at the white VLAN  we can see that the bridge B  port that connects to bridge B  is not labeled W\n This means that a frame on the white VLAN will not be forwarded from bridge B  to bridge B \n This behavior is correct because no stations on the white VLAN are connected to B \n The IEEE   \n Q Standard To implement this scheme  bridges need to know to which VLAN an incoming frame belongs\n Without this information  for example  when bridge B  gets a frame from bridge B  in Fig\n  -   it cannot know whether to forward the frame on the gray or white VLAN\n If we were designing a new type of LAN  it would be easy enough to just add a VLAN field in the header\n But what to do about Ethernet  which is the dominant LAN  and did not have any spare fields lying around for the VLAN identifier? The IEEE committee had this problem thrown into its lap in \n After much discussion  it did the unthinkable and changed the Ethernet header\n The new format was published in IEEE standard   \n Q  issued in \n The new format contains a VLAN tag; we will examine it shortly\n Not surprisingly  changing something as well established as the Ethernet header was not entirely trivial\n A few questions that come to mind are:  \n Need we throw out several hundred million existing Ethernet cards?  \n If not  who generates the new fields?  \n What happens to frames that are already the maximum size? Of course  the committee was (only too painfully) aware of these problems and had to come up with solutions  which it did\n The key to the solution is to realize that the VLAN fields are only actually used by the bridges and switches and not by the user machines\n Thus  in Fig\n  - it is not really essential that they are present on the lines going out to the end stations as long as they are on the line between the bridges\n Also  to use VLANs  the bridges have to be VLAN aware\n This fact makes the design feasible\n   DATA LINK LAYER SWITCHING As to throwing out all existing Ethernet cards  the answer is no\n Remember that the   \n  committee could not even get people to change the Type field into a Length field\n You can imagine the reaction to an announcement that all existing Ethernet cards had to be thrown out\n However  new Ethernet cards are   \n Q compliant and can correctly fill in the VLAN fields\n Because there can be computers (and switches) that are not VLAN aware  the first VLAN-aware bridge to touch a frame adds VLAN fields and the last one down the road removes them\n An example of a mixed topology is shown in Fig\n  -  \n In this figure  VLAN-aware computers generate tagged (  Q) frames directly  and further switching uses these tags\n The shaded symbols are VLAN-aware and the empty ones are not\n Legacy bridge and host B  B  B  Tagged frame B  B  B  VLAN-aware host and bridge Legacy frame Figure  -  \n Bridged LAN that is only partly VLAN aware\n The shaded symbols are VLAN aware\n The empty ones are not\n With   \n Q  frames are colored depending on the port on which they are received\n For this method to work  all machines on a port must belong to the same VLAN  which reduces flexibility\n For example  in Fig\n  -   this property holds for all ports where an individual computer connects to a bridge  but not for the port where the hub connects to bridge B \n Additionally  the bridge can use the higher-layer protocol to select the color\n In this way  frames arriving on a port might be placed in different VLANs depending on whether they carry IP packets or PPP frames\n Other methods are possible  but they are not supported by   \n Q\n As one example  the MAC address can be used to select the VLAN color\n This might be useful for frames coming in from a nearby   \n  LAN in which laptops send frames via different ports as they move\n One MAC address would then be mapped to a fixed VLAN regardless of which port it entered the LAN on\n As to the problem of frames longer than  bytes \n Q just raised the limit to  bytes\n Luckily  only VLAN-aware computers and switches must support these longer frames\n Now let us take a look at the   \n Q frame format\n It is shown in Fig\n  -  \n The only change is the addition of a pair of  -byte fields\n The first one is the THE MEDIUM ACCESS CONTROL SUBLAYER  \n  VLAN protocol ID\n It always has the value  x   \n Since this number is greater than  all Ethernet cards interpret it as a type rather than a length\n What a legacy card does with such a frame is moot since such frames are not supposed to be sent to legacy cards\n   \n  Length Data Pad Checksum Destination address Source address   \n Q Tag Length Data Pad VLAN protocol VLAN Identifier ID ( x   ) Pri CFI Checksum Destination address Source address Figure  -  \n The   \n  (legacy) and   \n Q Ethernet frame formats\n The ond  -byte field contains three subfields\n The main one is the VLAN identifier  occupying the low-order   bits\n This is what the whole thing is about—the color of the VLAN to which the frame belongs\n The  -bit Priority field has nothing to do with VLANs at all  but since changing the Ethernet header is a once-in-a-decade event taking three years and featuring a hundred people  why not put in some other good things while you are at it? This field makes it possible to distinguish hard real-time traffic from soft real-time traffic from timeinsensitive traffic in order to provide better quality of service over Ethernet\n It is needed for voice over Ethernet (although in all fairness  IP has had a similar field for a quarter of a century and nobody ever used it)\n The last field  CFI (Canonical format indicator)  should have been called the CEI (Corporate ego indicator)\n It was originally intended to indicate the order of the bits in the MAC addresses (little-endian versus big-endian)  but that use got lost in other controversies\n Its presence now indicates that the payload contains a freeze-dried   \n  frame that is hoping to find another   \n  LAN at the destination while being carried by Ethernet in between\n This whole arrangement  of course  has nothing whatsoever to do with VLANs\n But standards’ committee politics are not unlike regular politics: if you vote for my bit  I will vote for your bit\n As we mentioned above  when a tagged frame arrives at a VLAN-aware switch  the switch uses the VLAN identifier as an index into a table to find out which ports to send it on\n But where does the table come from? If it is manually constructed  we are back to square zero: manual configuration of bridges\n The beauty of the transparent bridge is that it is plug-and-play and does not require any manual configuration\n It would be a terrible shame to lose that property\n Fortunately  VLAN-aware bridges can also autoconfigure themselves based on observing the tags that come by\n If a frame tagged as VLAN  comes in on port   DATA LINK LAYER SWITCHING   apparently some machine on port  is on VLAN  \n The   \n Q standard explains how to build the tables dynamically  mostly by referencing appropriate portions of the   \n D standard\n Before leaving the subject of VLAN routing  it is worth making one last observation\n Many people in the Internet and Ethernet worlds are fanatically in favor of connectionless networking and violently opposed to anything smacking of connections in the data link or network layers\n Yet VLANs introduce something that is surprisingly similar to a connection\n To use VLANs properly  each frame carries a new special identifier that is used as an index into a table inside the switch to look up where the frame is supposed to be sent\n That is precisely what happens in connection-oriented networks\n In connectionless networks  it is the destination address that is used for routing  not some kind of connection identifier\n We will see more of this creeping connectionism in    \n  SUMMARY Some networks have a single channel that is used for all communication\n In these networks  the key design issue is the allocation of this channel among the competing stations wishing to use it\n FDM and TDM are simple  efficient allocation schemes when the number of stations is small and fixed and the traffic is continuous\n Both are widely used under these circumstances  for example  for dividing up the bandwidth on telephone trunks\n However  when the number of stations is large and variable or the traffic is fairly bursty—the common case in computer networks—FDM and TDM are poor choices\n Numerous dynamic channel allocation algorithms have been devised\n The ALOHA protocol  with and without slotting  is used in many derivatives in real systems  for example  cable modems and RFID\n As an improvement when the state of the channel can be sensed  stations can avoid starting a transmission while another station is transmitting\n This technique  carrier sensing  has led to a variety of CSMA protocols for LANs and MANs\n It is the basis for classic Ethernet and   \n  networks\n A class of protocols that eliminates contention altogether  or at least reduces it considerably  is well known\n The bitmap protocol  topologies such as rings  and the binary countdown protocol completely eliminate contention\n The tree walk protocol reduces it by dynamically dividing the stations into two disjoint groups of different sizes and allowing contention only within one group; ideally that group is chosen so that only one station is ready to send when it is permitted to do so\n Wireless LANs have the added problems that it is difficult to sense colliding transmissions  and that the coverage regions of stations may differ\n In the dominant wireless LAN  IEEE   \n   stations use CSMA/CA to mitigate the first problem by leaving small gaps to avoid collisions\n The stations can also use the RTS/CTS protocol to combat hidden terminals that arise because of the ond THE MEDIUM ACCESS CONTROL SUBLAYER  \n  problem\n IEEE   \n  is commonly used to connect laptops and other devices to wireless access points  but it can also be used between devices\n Any of several physical layers can be used  including multichannel FDM with and without multiple antennas  and spread spectrum\n Like   \n   RFID readers and tags use a random access protocol to communicate identifiers\n Other wireless PANs and MANs have different designs\n The Bluetooth system connects headsets and many kinds of peripherals to computers without wires\n IEEE   \n  provides a wide area wireless Internet data service for stationary and mobile computers\n Both of these networks use a centralized  connection-oriented design in which the Bluetooth master and the WiMAX base station decide when each station may send or receive data\n For   \n   this design supports different quality of service for real-time traffic like telephone calls and interactive traffic like Web browsing\n For Bluetooth  placing the complexity in the master leads to inexpensive slave devices\n Ethernet is the dominant form of wired LAN\n Classic Ethernet used CSMA/CD for channel allocation on a yellow cable the size of a garden hose that snaked from machine to machine\n The architecture has changed as speeds have risen from   Mbps to   Gbps and continue to climb\n Now  point-to-point links such as twisted pair are attached to hubs and switches\n With modern switches and full-duplex links  there is no contention on the links and the switch can forward frames between different ports in parallel\n With buildings full of LANs  a way is needed to interconnect them all\n Plugand- play bridges are used for this purpose\n The bridges are built with a backward learning algorithm and a spanning tree algorithm\n Since this functionality is built into modern switches  the terms ‘‘bridge’’ and ‘‘switch’’ are used interchangeably\n To help with the management of bridged LANs  VLANs let the physical topology be divided into different logical topologies\n The VLAN standard  IEEE   \n Q  introduces a new format for Ethernet frames\n PROBLEMS  \n For this problem  use a formula from this  ter  but first state the formula\n Frames arrive randomly at a   -Mbps channel for transmission\n If the channel is busy when a frame arrives  it waits its turn in a queue\n Frame length is exponentially distributed with a mean of   bits/frame\n For each of the following frame arrival rates  give the delay experienced by the average frame  including both queueing time and transmission time\n (a)   frames/\n (b) frames/\n (c)  frames/  PROBLEMS  \n A group of N stations share a  -kbps pure ALOHA channel\n Each station outputs a -bit frame on average once every   even if the previous one has not yet been sent ( \n  the stations can buffer outgoing frames)\n What is the maximum value of N?  \n Consider the delay of pure ALOHA versus slotted ALOHA at low load\n Which one is less? Explain your answer A large population of ALOHA users manages to generate   requests/  including both originals and retransmissions\n Time is slotted in units of   m\n (a) What is the chance of success on the first attempt? (b) What is the probability of exactly k collisions and then a success? (c) What is the expected number of transmission attempts needed?  \n In an infinite-population slotted ALOHA system  the mean number of slots a station waits between a collision and a retransmission is  \n Plot the delay versus throughput curve for this system What is the length of a contention slot in CSMA/CD for (a) a  -km twin-lead cable (signal propagation speed is  % of the signal propagation speed in vacuum)?  and (b) a  -km multimode fiber optic cable (signal propagation speed is  % of the signal propagation speed in vacuum)?  \n How long does a station  s  have to wait in the worst case before it can start transmitting its frame over a LAN that uses the basic bit-map protocol?  \n In the binary countdown protocol  explain how a lower-numbered station may be starved from sending a packet Sixteen stations  numbered  through are contending for the use of a shared channel by using the adaptive tree walk protocol\n If all the stations whose addresses are prime numbers suddenly become ready at once  how many bit slots are needed to resolve the contention?  \n Consider five wireless stations  A  B  C  D  and E\n Station A can communicate with all other stations\n B can communicate with A  C and E\n C can communicate with A  B and D\n D can communicate with A  C and E\n E can communicate A  D and B\n (a) When A is sending to B  what other communications are possible? (b) When B is sending to A  what other communications are possible? (c) When B is sending to C  what other communications are possible?  \n Six stations  A through F  communicate using the MACA protocol\n Is it possible for two transmissions to take place simultaneously? Explain your answer A seven-story office building has   adjacent offices per floor\n Each office contains a wall socket for a terminal in the front wall  so the sockets form a rectangular grid in the vertical plane  with a separation of  m between sockets  both horizontally and vertically\n Assuming that it is feasible to run a straight cable between any pair of sockets  horizontally  vertically  or diagonally  how many meters of cable are needed to connect all sockets using (a) A star configuration with a single router in the middle? (b) A classic   \n  LAN? THE MEDIUM ACCESS CONTROL SUBLAYER   What is the baud rate of classic  -Mbps Ethernet?  \n Sketch the Manchester encoding on a classic Ethernet for the bit stream   A  -km-long   -Mbps CSMA/CD LAN (not   \n ) has a propagation speed of m/μ\n Repeaters are not allowed in this system\n Data frames are bits long  including   bits of header  checksum  and other overhead\n The first bit slot after a successful transmission is reserved for the receiver to capture the channel in order to send a  -bit acknowledgement frame\n What is the effective data rate  excluding overhead  assuming that there are no collisions?  \n Two CSMA/CD stations are each trying to transmit long (multiframe) files\n After each frame is sent  they contend for the channel  using the binary exponential backoff algorithm\n What is the probability that the contention ends on round k  and what is the mean number of rounds per contention period?  \n An IP packet to be transmitted by Ethernet is   bytes long  including all its headers\n If LLC is not in use  is padding needed in the Ethernet frame  and if so  how many bytes?  \n Ethernet frames must be at least   bytes long to ensure that the transmitter is still going in the event of a collision at the far end of the cable\n Fast Ethernet has the same  -byte minimum frame size but can get the bits out ten times faster\n How is it possible to maintain the same minimum frame size?  \n Some books quote the maximum size of an Ethernet frame as  bytes instead of  bytes\n Are they wrong? Explain your answer How many frames per ond can gigabit Ethernet handle? Think carefully and take into account all the relevant cases\n Hint: the fact that it is gigabit Ethernet matters Name two networks that allow frames to be packed back-to-back\n Why is this feature worth having?  \n In Fig\n  -   four stations  A  B  C  and D  are shown\n Which of the last two stations do you think is closest to A and why?  \n Give an example to show that the RTS/CTS in the   \n  protocol is a little different than in the MACA protocol A wireless LAN with one AP has   client stations\n Four stations have data rates of  Mbps  four stations have data rates of   Mbps  and the last two stations have data rates of   Mbps\n What is the data rate experienced by each station when all ten stations are sending data together  and (a) TXOP is not used? (b) TXOP is used?  \n Suppose that an  -Mbps   \n  b LAN is transmitting  -byte frames back-to-back over a radio channel with a bit error rate of  − \n How many frames per ond will be damaged on average?  \n An   \n  network has a channel width of   MHz\n How many bits/ can be sent to a subscriber station?  \n  PROBLEMS  \n Give two reasons why networks might use an error-correcting code instead of error detection and retransmission List two ways in which WiMAX is similar to   \n   and two ways in which it is different from     \n From Fig\n  -   we see that a Bluetooth device can be in two piconets at the same time\n Is there any reason why one device cannot be the master in both of them at the same time?  \n What is the maximum size of the data field for a  -slot Bluetooth frame at basic rate? Explain your answer Figure  -  shows several physical layer protocols\n Which of these is closest to the Bluetooth physical layer protocol? What is the biggest difference between the two?  \n It is mentioned in tion    that the efficiency of a  -slot frame with repetition encoding is about  % at basic data rate\n What will the efficiency be if a  -slot frame with repetition encoding is used at basic data rate instead?  \n Beacon frames in the frequency hopping spread spectrum variant of   \n  contain the dwell time\n Do you think the analogous beacon frames in Bluetooth also contain the dwell time? Discuss your answer Suppose that there are   RFID tags around an RFID reader\n What is the best value of Q? How likely is it that one tag responds with no collision in a given slot?  \n List some of the urity concerns of an RFID system A switch designed for use with fast Ethernet has a backplane that can move   Gbps\n How many frames/ can it handle in the worst case?  \n Briefly describe the difference between store-and-forward and cut-through switches Consider the extended LAN connected using bridges B  and B  in Fig\n  -  (b)\n Suppose the hash tables in the two bridges are empty\n List all ports on which a packet will be forwarded for the following sequence of data transmissions: (a) A sends a packet to C\n (b) E sends a packet to F\n (c) F sends a packet to E\n (d) G sends a packet to E\n (e) D sends a packet to A\n (f) B sends a packet to F Store-and-forward switches have an advantage over cut-through switches with respect to damaged frames\n Explain what it is It is mentioned in tion    that some bridges may not even be present in the spanning tree\n Outline a scenario where a bridge may not be present in the spanning tree To make VLANs work  configuration tables are needed in the bridges\n What if the VLANs of Fig\n  -  used hubs rather than switches? Do the hubs need configuration tables  too? Why or why not? THE MEDIUM ACCESS CONTROL SUBLAYER   In Fig\n  -   the switch in the legacy end domain on the right is a VLAN-aware switch\n Would it be possible to use a legacy switch there? If so  how would that work? If not  why not?  \n Write a program to simulate the behavior of the CSMA/CD protocol over Ethernet when there are N stations ready to transmit while a frame is being transmitted\n Your program should report the times when each station successfully starts sending its frame\n Assume that a clock tick occurs once every slot time (  \n  μ) and a collision detection and sending of a jamming sequence takes one slot time\n All frames are the maximum length allowed\n  THE NETWORK LAYER The network layer is concerned with getting packets from the source all the way to the destination\n Getting to the destination may require making many hops at intermediate routers along the way\n This function clearly contrasts with that of the data link layer  which has the more modest goal of just moving frames from one end of a wire to the other\n Thus  the network layer is the lowest layer that deals with end-to-end transmission\n To achieve its goals  the network layer must know about the topology of the network ( \n  the set of all routers and links) and choose appropriate paths through it  even for large networks\n It must also take care when choosing routes to avoid overloading some of the communication lines and routers while leaving others idle\n Finally  when the source and destination are in different networks  new problems occur\n It is up to the network layer to deal with them\n In this  ter we will study all these issues and illustrate them  primarily using the Internet and its network layer protocol  IP  NETWORK LAYER DESIGN ISSUES In the following tions  we will give an introduction to some of the issues that the designers of the network layer must grapple with\n These issues include the service provided to the transport layer and the internal design of the network\n    THE NETWORK LAYER  \n     Store-and-Forward Packet Switching Before starting to explain the details of the network layer  it is worth restating the context in which the network layer protocols operate\n This context can be seen in Fig\n  - \n The major components of the network are the ISP’s equipment (routers connected by transmission lines)  shown inside the shaded oval  and the customers’ equipment  shown outside the oval\n Host H  is directly connected to one of the ISP’s routers  A  perhaps as a home computer that is plugged into a DSL modem\n In contrast  H  is on a LAN  which might be an office Ethernet  with a router  F  owned and operated by the customer\n This router has a leased line to the ISP’s equipment\n We have shown F as being outside the oval because it does not belong to the ISP\n For the purposes of this  ter  however  routers on customer premises are considered part of the ISP network because they run the same algorithms as the ISP’s routers (and our main concern here is algorithms)\n D C B A E F Packet Process P  Host H  Router ISP’s equipment LAN H  P  Figure  - \n The environment of the network layer protocols\n This equipment is used as follows\n A host with a packet to send transmits it to the nearest router  either on its own LAN or over a point-to-point link to the ISP\n The packet is stored there until it has fully arrived and the link has finished its processing by verifying the checksum\n Then it is forwarded to the next router along the path until it reaches the destination host  where it is delivered\n This mechanism is store-and-forward packet switching  as we have seen in previous  ters\n    Services Provided to the Transport Layer The network layer provides services to the transport layer at the network layer/transport layer interface\n An important question is precisely what kind of services the network layer provides to the transport layer\n The services need to be carefully designed with the following goals in mind:   NETWORK LAYER DESIGN ISSUES  \n The services should be independent of the router technology The transport layer should be shielded from the number  type  and topology of the routers present The network addresses made available to the transport layer should use a uniform numbering plan  even across LANs and WANs\n Given these goals  the designers of the network layer have a lot of freedom in writing detailed specifications of the services to be offered to the transport layer\n This freedom often degenerates into a raging battle between two warring factions\n The discussion centers on whether the network layer should provide connectionoriented service or connectionless service\n One camp (represented by the Internet community) argues that the routers’ job is moving packets around and nothing else\n In this view (based on   years of experience with a real computer network)  the network is inherently unreliable  no matter how it is designed\n Therefore  the hosts should accept this fact and do error control ( \n  error detection and correction) and flow control themselves\n This viewpoint leads to the conclusion that the network service should be connectionless  with primitives SEND PACKET and RECEIVE PACKET and little else\n In particular  no packet ordering and flow control should be done  because the hosts are going to do that anyway and there is usually little to be gained by doing it twice\n This reasoning is an example of the end-to-end argument  a design principle that has been very influential in shaping the Internet (Saltzer et al\n  )\n Furthermore  each packet must carry the full destination address  because each packet sent is carried independently of its predecessors  if any\n The other camp (represented by the telephone companies) argues that the network should provide a reliable  connection-oriented service\n They claim that years of successful experience with the worldwide telephone system is an excellent guide\n In this view  quality of service is the dominant factor  and without connections in the network  quality of service is very difficult to achieve  especially for real-time traffic such as voice and video\n Even after several decades  this controversy is still very much alive\n Early  widely used data networks  such as X\n  in the s and its successor Frame Relay in the s  were connection-oriented\n However  since the days of the ARPANET and the early Internet  connectionless network layers have grown tremendously in popularity\n The IP protocol is now an ever-present symbol of success\n It was undeterred by a connection-oriented technology called ATM that was developed to overthrow it in the s; instead  it is ATM that is now found in niche uses and IP that is taking over telephone networks\n Under the covers  however  the Internet is evolving connection-oriented features as quality of service becomes more important\n Two examples of connection-oriented technologies are MPLS (MultiProtocol Label Switching)  which we will describe in this  ter  and VLANs  which we saw in   Both technologies are widely used\n THE NETWORK LAYER  \n     Implementation of Connectionless Service Having looked at the two classes of service the network layer can provide to its users  it is time to see how this layer works inside\n Two different organizations are possible  depending on the type of service offered\n If connectionless service is offered  packets are injected into the network individually and routed independently of each other\n No advance setup is needed\n In this context  the packets are frequently called datagrams (in analogy with telegrams) and the network is called a datagram network\n If connection-oriented service is used  a path from the source router all the way to the destination router must be established before any data packets can be sent\n This connection is called a VC (virtual circuit)  in analogy with the physical circuits set up by the telephone system  and the network is called a virtual-circuit network\n In this tion  we will examine datagram networks; in the next one  we will examine virtual-circuit networks\n Let us now see how a datagram network works\n Suppose that the process P  in Fig\n  -  has a long message for P \n It hands the message to the transport layer  with instructions to deliver it to process P  on host H \n The transport layer code runs on H  typically within the operating system\n It prepends a transport header to the front of the message and hands the result to the network layer  probably just another procedure within the operating system\n A’s table (initially) A’s table (later) C’s table E’s table Dest\n Line D C B A E F Packet Process P  Host H  Router ISP’s equipment LAN H  P  A B B – C C D B E C F C A B B – C C D B E B F B A B A A C – D E E E F E A B D C C C D D E – F F Figure  - \n Routing within a datagram network\n Let us assume for this example that the message is four times longer than the maximum packet size  so the network layer has to break it into four packets     NETWORK LAYER DESIGN ISSUES   and   and send each of them in turn to router A using some point-to-point protocol  for example  PPP\n At this point the ISP takes over\n Every router has an internal table telling it where to send packets for each of the possible destinations\n Each table entry is a pair consisting of a destination and the outgoing line to use for that destination\n Only directly connected lines can be used\n For example  in Fig\n  -  A has only two outgoing lines—to B and to C—so every incoming packet must be sent to one of these routers  even if the ultimate destination is to some other router\n A’s initial routing table is shown in the figure under the label ‘‘initially\n’’ At A  packets  and  are stored briefly  having arrived on the incoming link and had their checksums verified\n Then each packet is forwarded according to A’s table  onto the outgoing link to C within a new frame\n Packet  is then forwarded to E and then to F\n When it gets to F  it is sent within a frame over the LAN to H \n Packets  and  follow the same route\n However  something different happens to packet  \n When it gets to A it is sent to router B  even though it is also destined for F\n For some reason  A decided to send packet  via a different route than that of the first three packets\n Perhaps it has learned of a traffic jam somewhere along the ACE path and updated its routing table  as shown under the label ‘‘later\n’’ The algorithm that manages the tables and makes the routing decisions is called the routing algorithm\n Routing algorithms are one of the main topics we will study in this  ter\n There are several different kinds of them  as we will see\n IP (Internet Protocol)  which is the basis for the entire Internet  is the dominant example of a connectionless network service\n Each packet carries a destination IP address that routers use to individually forward each packet\n The addresses are   bits in IPv  packets and bits in IPv  packets\n We will describe IP in much detail later in this  ter\n    Implementation of Connection-Oriented Service For connection-oriented service  we need a virtual-circuit network\n Let us see how that works\n The idea behind virtual circuits is to avoid having to choose a new route for every packet sent  as in Fig\n  - \n Instead  when a connection is established  a route from the source machine to the destination machine is chosen as part of the connection setup and stored in tables inside the routers\n That route is used for all traffic flowing over the connection  exactly the same way that the telephone system works\n When the connection is released  the virtual circuit is also terminated\n With connection-oriented service  each packet carries an identifier telling which virtual circuit it belongs to\n As an example  consider the situation shown in Fig\n  - \n Here  host H  has established connection  with host H \n This connection is remembered as the first entry in each of the routing tables\n The first line of A’s table says that if a packet THE NETWORK LAYER  \n  bearing connection identifier  comes in from H  it is to be sent to router C and given connection identifier  \n Similarly  the first entry at C routes the packet to E  also with connection identifier  \n A’s table In Out D C B E F Packet Router ISP’s equipment LAN H  P  H  H  Process P  A Host H  P  H  C C C’s table A A E E E’s table C C F F Figure  - \n Routing within a virtual-circuit network\n Now let us consider what happens if H  also wants to establish a connection to H \n It chooses connection identifier  (because it is initiating the connection and this is its only connection) and tells the network to establish the virtual circuit\n This leads to the ond row in the tables\n Note that we have a conflict here because although A can easily distinguish connection  packets from H  from connection  packets from H  C cannot do this\n For this reason  A assigns a different connection identifier to the outgoing traffic for the ond connection\n Avoiding conflicts of this kind is why routers need the ability to replace connection identifiers in outgoing packets\n In some contexts  this process is called label switching\n An example of a connection-oriented network service is MPLS (MultiProtocol Label Switching)\n It is used within ISP networks in the Internet  with IP packets wrapped in an MPLS header having a  -bit connection identifier or label\n MPLS is often hidden from customers  with the ISP establishing long-term connections for large amounts of traffic  but it is increasingly being used to help when quality of service is important but also with other ISP traffic management tasks\n We will have more to say about MPLS later in this  ter\n   NETWORK LAYER DESIGN ISSUES    Comparison of Virtual-Circuit and Datagram Networks Both virtual circuits and datagrams have their supporters and their detractors\n We will now attempt to summarize both sets of arguments\n The major issues are listed in Fig\n  -  although purists could probably find a counterexample for everything in the figure\n Issue Datagram network Virtual-circuit network Circuit setup Not needed Required Addressing Each packet contains the full source and destination address Each packet contains a short VC number State information Routers do not hold state information about connections Each VC requires router table space per connection Routing Each packet is routed independently Route chosen when VC is set up; all packets follow it Effect of router failures None  except for packets lost during the crash All VCs that passed through the failed router are terminated Quality of service Difficult Easy if enough resources can be allocated in advance for each VC Congestion control Difficult Easy if enough resources can be allocated in advance for each VC Figure  - \n Comparison of datagram and virtual-circuit networks\n Inside the network  several trade-offs exist between virtual circuits and datagrams\n One trade-off is setup time versus address parsing time\n Using virtual circuits requires a setup phase  which takes time and consumes resources\n However  once this price is paid  figuring out what to do with a data packet in a virtual-circuit network is easy: the router just uses the circuit number to index into a table to find out where the packet goes\n In a datagram network  no setup is needed but a more complicated lookup procedure is required to locate the entry for the destination\n A related issue is that the destination addresses used in datagram networks are longer than circuit numbers used in virtual-circuit networks because they have a global meaning\n If the packets tend to be fairly short  including a full destination address in every packet may represent a significant amount of overhead  and hence a waste of bandwidth\n Yet another issue is the amount of table space required in router memory\n A datagram network needs to have an entry for every possible destination  whereas a virtual-circuit network just needs an entry for each virtual circuit\n However  this THE NETWORK LAYER  \n  advantage is somewhat illusory since connection setup packets have to be routed too  and they use destination addresses  the same as datagrams do\n Virtual circuits have some advantages in guaranteeing quality of service and avoiding congestion within the network because resources ( \n  buffers  bandwidth  and CPU cycles) can be reserved in advance  when the connection is established\n Once the packets start arriving  the necessary bandwidth and router capacity will be there\n With a datagram network  congestion avoidance is more difficult\n For transaction processing systems ( \n  stores calling up to verify credit card purchases)  the overhead required to set up and clear a virtual circuit may easily dwarf the use of the circuit\n If the majority of the traffic is expected to be of this kind  the use of virtual circuits inside the network makes little sense\n On the other hand  for long-running uses such as VPN traffic between two corporate offices  permanent virtual circuits (that are set up manually and last for months or years) may be useful\n Virtual circuits also have a vulnerability problem\n If a router crashes and loses its memory  even if it comes back up a ond later  all the virtual circuits passing through it will have to be aborted\n In contrast  if a datagram router goes down  only those users whose packets were queued in the router at the time need suffer (and probably not even then since the sender is likely to retransmit them shortly)\n The loss of a communication line is fatal to virtual circuits using it  but can easily be compensated for if datagrams are used\n Datagrams also allow the routers to balance the traffic throughout the network  since routes can be changed partway through a long sequence of packet transmissions  ROUTING ALGORITHMS The main function of the network layer is routing packets from the source machine to the destination machine\n In most networks  packets will require multiple hops to make the journey\n The only notable exception is for broadcast networks  but even here routing is an issue if the source and destination are not on the same network segment\n The algorithms that choose the routes and the data structures that they use are a major area of network layer design\n The routing algorithm is that part of the network layer software responsible for deciding which output line an incoming packet should be transmitted on\n If the network uses datagrams internally  this decision must be made anew for every arriving data packet since the best route may have changed since last time\n If the network uses virtual circuits internally  routing decisions are made only when a new virtual circuit is being set up\n Thereafter  data packets just follow the already established route\n The latter case is sometimes called session routing because a route remains in force for an entire session ( \n  while logged in over a VPN)\n   ROUTING ALGORITHMS It is sometimes useful to make a distinction between routing  which is making the decision which routes to use  and forwarding  which is what happens when a packet arrives\n One can think of a router as having two processes inside it\n One of them handles each packet as it arrives  looking up the outgoing line to use for it in the routing tables\n This process is forwarding\n The other process is responsible for filling in and updating the routing tables\n That is where the routing algorithm comes into play\n Regardless of whether routes are chosen independently for each packet sent or only when new connections are established  certain properties are desirable in a routing algorithm: correctness  simplicity  robustness  stability  fairness  and efficiency\n Correctness and simplicity hardly require comment  but the need for robustness may be less obvious at first\n Once a major network comes on the air  it may be expected to run continuously for years without system-wide failures\n During that period there will be hardware and software failures of all kinds\n Hosts  routers  and lines will fail repeatedly  and the topology will change many times\n The routing algorithm should be able to cope with changes in the topology and traffic without requiring all jobs in all hosts to be aborted\n Imagine the havoc if the network needed to be rebooted every time some router crashed! Stability is also an important goal for the routing algorithm\n There exist routing algorithms that never converge to a fixed set of paths  no matter how long they run\n A stable algorithm reaches equilibrium and stays there\n It should converge quickly too  since communication may be disrupted until the routing algorithm has reached equilibrium\n Fairness and efficiency may sound obvious—surely no reasonable person would oppose them—but as it turns out  they are often contradictory goals\n As a simple example of this conflict  look at Fig\n  - \n Suppose that there is enough traffic between A and A′  between B and B′  and between C and C′ to saturate the horizontal links\n To maximize the total flow  the X to X′ traffic should be shut off altogether\n Unfortunately  X and X′ may not see it that way\n Evidently  some compromise between global efficiency and fairness to individual connections is needed\n Before we can even attempt to find trade-offs between fairness and efficiency  we must decide what it is we seek to optimize\n Minimizing the mean packet delay is an obvious candidate to send traffic through the network effectively  but so is maximizing total network throughput\n Furthermore  these two goals are also in conflict  since operating any queueing system near capacity implies a long queueing delay\n As a compromise  many networks attempt to minimize the distance a packet must travel  or simply reduce the number of hops a packet must make\n Either choice tends to improve the delay and also reduce the amount of bandwidth consumed per packet  which tends to improve the overall network throughput as well\n Routing algorithms can be grouped into two major classes: nonadaptive and adaptive\n Nonadaptive algorithms do not base their routing decisions on any THE NETWORK LAYER  \n  X X′ A B C A' B' C' Figure  - \n Network with a conflict between fairness and efficiency\n measurements or estimates of the current topology and traffic\n Instead  the choice of the route to use to get from I to J (for all I and J) is computed in advance  offline  and downloaded to the routers when the network is booted\n This procedure is sometimes called static routing\n Because it does not respond to failures  static routing is mostly useful for situations in which the routing choice is clear\n For example  router F in Fig\n  -  should send packets headed into the network to router E regardless of the ultimate destination\n Adaptive algorithms  in contrast  change their routing decisions to reflect changes in the topology  and sometimes changes in the traffic as well\n These dynamic routing algorithms differ in where they get their information ( \n  locally  from adjacent routers  or from all routers)  when they change the routes ( \n  when the topology changes  or every ΔT onds as the load changes)  and what metric is used for optimization ( \n  distance  number of hops  or estimated transit time)\n In the following tions  we will discuss a variety of routing algorithms\n The algorithms cover delivery models besides sending a packet from a source to a destination\n Sometimes the goal is to send the packet to multiple  all  or one of a set of destinations\n All of the routing algorithms we describe here make decisions based on the topology; we defer the possibility of decisions based on the traffic levels to       The Optimality Principle Before we get into specific algorithms  it may be helpful to note that one can make a general statement about optimal routes without regard to network topology or traffic\n This statement is known as the optimality principle (Bellman  )\n It states that if router J is on the optimal path from router I to router K    ROUTING ALGORITHMS then the optimal path from J to K also falls along the same route\n To see this  call the part of the route from I to J r  and the rest of the route r  \n If a route better than r  existed from J to K  it could be concatenated with r  to improve the route from I to K  contradicting our statement that r  r  is optimal\n As a direct consequence of the optimality principle  we can see that the set of optimal routes from all sources to a given destination form a tree rooted at the destination\n Such a tree is called a sink tree and is illustrated in Fig\n  - (b)  where the distance metric is the number of hops\n The goal of all routing algorithms is to discover and use the sink trees for all routers\n B A F D E C J N O I H G L M K (a) B A F D E C J N O I H G L M K (b) Figure  - \n (a) A network\n (b) A sink tree for router B\n Note that a sink tree is not necessarily unique; other trees with the same path lengths may exist\n If we allow all of the possible paths to be chosen  the tree becomes a more general structure called a DAG (Directed Acyclic Graph)\n DAGs have no loops\n We will use sink trees as a convenient shorthand for both cases\n Both cases also depend on the technical assumption that the paths do not interfere with each other so  for example  a traffic jam on one path will not cause another path to divert\n Since a sink tree is indeed a tree  it does not contain any loops  so each packet will be delivered within a finite and bounded number of hops\n In practice  life is not quite this easy\n Links and routers can go down and come back up during operation  so different routers may have different ideas about the current topology\n Also  we have quietly finessed the issue of whether each router has to individually acquire the information on which to base its sink tree computation or whether this information is collected by some other means\n We will come back to these issues shortly\n Nevertheless  the optimality principle and the sink tree provide a benchmark against which other routing algorithms can be measured\n THE NETWORK LAYER  \n     Shortest Path Algorithm Let us begin our study of routing algorithms with a simple technique for computing optimal paths given a complete picture of the network\n These paths are the ones that we want a distributed routing algorithm to find  even though not all routers may know all of the details of the network\n The idea is to build a graph of the network  with each node of the graph representing a router and each edge of the graph representing a communication line  or link\n To choose a route between a given pair of routers  the algorithm just finds the shortest path between them on the graph\n The concept of a shortest path deserves some explanation\n One way of measuring path length is the number of hops\n Using this metric  the paths ABC and ABE in Fig\n  -  are equally long\n Another metric is the geographic distance in kilometers  in which case ABC is clearly much longer than ABE (assuming the figure is drawn to scale)\n A  D G  (a) F (∞  −) D(∞ −) B  C  H  E  F  A (c) B (  A) C (  B) H (∞  −) E (  B) G (  A) A F (  E) D (∞ −) (e) B (  A) C (  B) H (  G) E (  B) G (  E) A F (  E) D (∞ −) (f) B (  A) C (  B) H (  F) E (  B) G (  E) A F (  E) D (∞  ) (d) B (  A) C (  B) H (∞  −) E (  B) G (  E) A F (∞  −) D (∞  −) (b) B (  A) C (∞  −) H (∞  −) E (∞  −) G (  A) Figure  - \n The first six steps used in computing the shortest path from A to D\n The arrows indicate the working node\n   ROUTING ALGORITHMS However  many other metrics besides hops and physical distance are also possible\n For example  each edge could be labeled with the mean delay of a standard test packet  as measured by hourly runs\n With this graph labeling  the shortest path is the fastest path rather than the path with the fewest edges or kilometers\n In the general case  the labels on the edges could be computed as a function of the distance  bandwidth  average traffic  communication cost  measured delay  and other factors\n By changing the weighting function  the algorithm would then compute the ‘‘shortest’’ path measured according to any one of a number of criteria or to a combination of criteria\n Several algorithms for computing the shortest path between two nodes of a graph are known\n This one is due to Dijkstra (   ) and finds the shortest paths between a source and all destinations in the network\n Each node is labeled (in parentheses) with its distance from the source node along the best known path\n The distances must be non-negative  as they will be if they are based on real quantities like bandwidth and delay\n Initially  no paths are known  so all nodes are labeled with infinity\n As the algorithm proceeds and paths are found  the labels may change  reflecting better paths\n A label may be either tentative or permanent\n Initially  all labels are tentative\n When it is discovered that a label represents the shortest possible path from the source to that node  it is made permanent and never changed thereafter\n To illustrate how the labeling algorithm works  look at the weighted  undirected graph of Fig\n  - (a)  where the weights represent  for example  distance\n We want to find the shortest path from A to D\n We start out by marking node A as permanent  indicated by a filled-in circle\n Then we examine  in turn  each of the nodes adjacent to A (the working node)  relabeling each one with the distance to A\n Whenever a node is relabeled  we also label it with the node from which the probe was made so that we can reconstruct the final path later\n If the network had more than one shortest path from A to D and we wanted to find all of them  we would need to remember all of the probe nodes that could reach a node with the same distance\n Having examined each of the nodes adjacent to A  we examine all the tentatively labeled nodes in the whole graph and make the one with the smallest label permanent  as shown in Fig\n  - (b)\n This one becomes the new working node\n We now start at B and examine all nodes adjacent to it\n If the sum of the label on B and the distance from B to the node being considered is less than the label on that node  we have a shorter path  so the node is relabeled\n After all the nodes adjacent to the working node have been inspected and the tentative labels changed if possible  the entire graph is searched for the tentatively labeled node with the smallest value\n This node is made permanent and becomes the working node for the next round\n Figure  -  shows the first six steps of the algorithm\n To see why the algorithm works  look at Fig\n  - (c)\n At this point we have just made E permanent\n Suppose that there were a shorter path than ABE  say THE NETWORK LAYER  \n  AXYZE (for some X and Y)\n There are two possibilities: either node Z has already been made permanent  or it has not been\n If it has  then E has already been probed (on the round following the one when Z was made permanent)  so the AXYZE path has not escaped our attention and thus cannot be a shorter path\n Now consider the case where Z is still tentatively labeled\n If the label at Z is greater than or equal to that at E  then AXYZE cannot be a shorter path than ABE\n If the label is less than that of E  then Z and not E will become permanent first  allowing E to be probed from Z\n This algorithm is given in Fig\n  - \n The global variables n and dist describe the graph and are initialized before shortest path is called\n The only difference between the program and the algorithm described above is that in Fig\n  -  we compute the shortest path starting at the terminal node  t  rather than at the source node  s\n Since the shortest paths from t to s in an undirected graph are the same as the shortest paths from s to t  it does not matter at which end we begin\n The reason for searching backward is that each node is labeled with its predecessor rather than its successor\n When the final path is copied into the output variable  path  the path is thus reversed\n The two reversal effects cancel  and the answer is produced in the correct order\n    Flooding When a routing algorithm is implemented  each router must make decisions based on local knowledge  not the complete picture of the network\n A simple local technique is flooding  in which every incoming packet is sent out on every outgoing line except the one it arrived on\n Flooding obviously generates vast numbers of duplicate packets  in fact  an infinite number unless some measures are taken to damp the process\n One such measure is to have a hop counter contained in the header of each packet that is decremented at each hop  with the packet being discarded when the counter reaches zero\n Ideally  the hop counter should be initialized to the length of the path from source to destination\n If the sender does not know how long the path is  it can initialize the counter to the worst case  namely  the full diameter of the network\n Flooding with a hop count can produce an exponential number of duplicate packets as the hop count grows and routers duplicate packets they have seen before\n A better technique for damming the flood is to have routers keep track of which packets have been flooded  to avoid sending them out a ond time\n One way to achieve this goal is to have the source router put a sequence number in each packet it receives from its hosts\n Each router then needs a list per source router telling which sequence numbers originating at that source have already been seen\n If an incoming packet is on the list  it is not flooded\n   ROUTING ALGORITHMS #define MAX NODES  /* maximum number of nodes */ #define INFINITY   /* a number larger than every maximum path */ int n  dist[MAX NODES][MAX NODES]; /* dist[i][j] is the distance from i to j */ void shortest path(int s  int t  int path[]) { struct state { /* the path being worked on */ int predecessor; /* previous node */ int length; /* length from source to this node */ enum {permanent  tentative} label; /* label state */ } state[MAX NODES]; int i  k  min; struct state *p; for (p = &state[ ]; p < &state[n]; p++) { /* initialize state */ p->predecessor = − ; p->length = INFINITY; p->label = tentative; } state[t] =  ; state[t] = permanent; k = t; /* k is the initial working node */ do { /* Is there a better path from k? */ for (i =  ; i < n; i++) /* this graph has n nodes */ if (dist[k][i] !=  && state[i] == tentative) { if (state[k] + dist[k][i] < state[i]) { state[i] = k; state[i] = state[k] + dist[k][i]; } } /* Find the tentatively labeled node with the smallest label\n */ k =  ; min = INFINITY; for (i =  ; i < n; i++) if (state[i] == tentative && state[i] < min) { min = state[i]; k = i; } state[k] = permanent; } while (k != s); /* Copy the path into the output array\n */ i =  ; k = s; do {path[i++] = k; k = state[k]; } while (k >=  ); } Figure  - \n Dijkstra’s algorithm to compute the shortest path through a graph\n To prevent the list from growing without bound  each list should be augmented by a counter  k  meaning that all sequence numbers through k have been seen\n When a packet comes in  it is easy to check if the packet has already been THE NETWORK LAYER  \n  flooded (by comparing its sequence number to k; if so  it is discarded\n Furthermore  the full list below k is not needed  since k effectively summarizes it\n Flooding is not practical for sending most packets  but it does have some important uses\n First  it ensures that a packet is delivered to every node in the network\n This may be wasteful if there is a single destination that needs the packet  but it is effective for broadcasting information\n In wireless networks  all messages transmitted by a station can be received by all other stations within its radio range  which is  in fact  flooding  and some algorithms utilize this property\n ond  flooding is tremendously robust\n Even if large numbers of routers are blown to bits ( \n  in a military network located in a war zone)  flooding will find a path if one exists  to get a packet to its destination\n Flooding also requires little in the way of setup\n The routers only need to know their neighbors\n This means that flooding can be used as a building block for other routing algorithms that are more efficient but need more in the way of setup\n Flooding can also be used as a metric against which other routing algorithms can be compared\n Flooding always chooses the shortest path because it chooses every possible path in parallel\n Consequently  no other algorithm can produce a shorter delay (if we ignore the overhead generated by the flooding process itself)\n    Distance Vector Routing Computer networks generally use dynamic routing algorithms that are more complex than flooding  but more efficient because they find shortest paths for the current topology\n Two dynamic algorithms in particular  distance vector routing and link state routing  are the most popular\n In this tion  we will look at the former algorithm\n In the following tion  we will study the latter algorithm\n A distance vector routing algorithm operates by having each router maintain a table ( \n  a vector) giving the best known distance to each destination and which link to use to get there\n These tables are updated by exchanging information with the neighbors\n Eventually  every router knows the best link to reach each destination\n The distance vector routing algorithm is sometimes called by other names  most commonly the distributed Bellman-Ford routing algorithm  after the researchers who developed it (Bellman  ; and Ford and Fulkerson  )\n It was the original ARPANET routing algorithm and was also used in the Internet under the name RIP\n In distance vector routing  each router maintains a routing table indexed by  and containing one entry for each router in the network\n This entry has two parts: the preferred outgoing line to use for that destination and an estimate of the distance to that destination\n The distance might be measured as the number of hops or using another metric  as we discussed for computing shortest paths\n The router is assumed to know the ‘‘distance’’ to each of its neighbors\n If the metric is hops  the distance is just one hop\n If the metric is propagation delay  the   ROUTING ALGORITHMS router can measure it directly with special ECHO packets that the receiver just timestamps and sends back as fast as it can\n As an example  assume that delay is used as a metric and that the router knows the delay to each of its neighbors\n Once every T m  each router sends to each neighbor a list of its estimated delays to each destination\n It also receives a similar list from each neighbor\n Imagine that one of these tables has just come in from neighbor X  with Xi being X’s estimate of how long it takes to get to router i\n If the router knows that the delay to X is m m  it also knows that it can reach router i via X in Xi + m m\n By performing this calculation for each neighbor  a router can find out which estimate seems the best and use that estimate and the corresponding link in its new routing table\n Note that the old routing table is not used in the calculation\n This updating process is illustrated in Fig\n  - \n Part (a) shows a network\n The first four columns of part (b) show the delay vectors received from the neighbors of router J\n A claims to have a  -m delay to B  a  -m delay to C  a  - m delay to D  etc\n Suppose that J has measured or estimated its delay to its neighbors  A  I  H  and K  as   and  m  respectively\n (a) A B C D E I J K L F G H Router                        A A I H I I H H I − K K To A I H K Line New estimated delay from J A B C DE F G H I J K L JA JI JH JK delay delay delay delay is is is is  New routing table for J Vectors received from J's four neighbors (b) Figure  - \n (a) A network\n (b) Input from A  I  H  K  and the new routing table for J\n Consider how J computes its new route to router G\n It knows that it can get to A in  m  and furthermore A claims to be able to get to G in   m  so J knows it can count on a delay of   m to G if it forwards packets bound for G THE NETWORK LAYER  \n  to A\n Similarly  it computes the delay to G via I  H  and K as   (  +  ) (  +  )  and   (  +  ) m  respectively\n The best of these values is so it makes an entry in its routing table that the delay to G is   m and that the route to use is via H\n The same calculation is performed for all the other destinations  with the new routing table shown in the last column of the figure\n The Count-to-Infinity Problem The settling of routes to best paths across the network is called convergence\n Distance vector routing is useful as a simple technique by which routers can collectively compute shortest paths  but it has a serious drawback in practice: although it converges to the correct answer  it may do so slowly\n In particular  it reacts rapidly to good news  but leisurely to bad news\n Consider a router whose best route to destination X is long\n If  on the next exchange  neighbor A suddenly reports a short delay to X  the router just switches over to using the line to A to send traffic to X\n In one vector exchange  the good news is processed\n To see how fast good news propagates  consider the five-node (linear) network of Fig\n  -   where the delay metric is the number of hops\n Suppose A is down initially and all the other routers know this\n In other words  they have all recorded the delay to A as infinity\n A B C D E • • • • • • • • • •    Initially After  exchange After  exchanges After  exchanges After  exchanges A B C D E    • • • •         Initially After  exchange After  exchanges After  exchanges After  exchanges After  exchanges After  exchanges \n\n (a) (b) Figure  -  \n The count-to-infinity problem\n When A comes up  the other routers learn about it via the vector exchanges\n For simplicity  we will assume that there is a gigantic gong somewhere that is struck periodically to initiate a vector exchange at all routers simultaneously\n At the time of the first exchange  B learns that its left-hand neighbor has zero delay to A\n B now makes an entry in its routing table indicating that A is one hop away to the left\n All the other routers still think that A is down\n At this point  the routing table entries for A are as shown in the ond row of Fig\n  -  (a)\n On the next   ROUTING ALGORITHMS exchange  C learns that B has a path of length  to A  so it updates its routing table to indicate a path of length   but D and E do not hear the good news until later\n Clearly  the good news is spreading at the rate of one hop per exchange\n In a network whose longest path is of length N hops  within N exchanges everyone will know about newly revived links and routers\n Now let us consider the situation of Fig\n  -  (b)  in which all the links and routers are initially up\n Routers B  C  D  and E have distances to A of  and  hops  respectively\n Suddenly  either A goes down or the link between A and B is cut (which is effectively the same thing from B’s point of view)\n At the first packet exchange  B does not hear anything from A\n Fortunately  C says ‘‘Do not worry; I have a path to A of length  \n’’ Little does B suspect that C’s path runs through B itself\n For all B knows  C might have ten links all with separate paths to A of length  \n As a result  B thinks it can reach A via C  with a path length of  \n D and E do not update their entries for A on the first exchange\n On the ond exchange  C notices that each of its neighbors claims to have a path to A of length  \n It picks one of them at random and makes its new distance to A   as shown in the third row of Fig\n  -  (b)\n Subsequent exchanges produce the history shown in the rest of Fig\n  -  (b)\n From this figure  it should be clear why bad news travels slowly: no router ever has a value more than one higher than the minimum of all its neighbors\n Gradually  all routers work their way up to infinity  but the number of exchanges required depends on the numerical value used for infinity\n For this reason  it is wise to set infinity to the longest path plus  \n Not entirely surprisingly  this problem is known as the count-to-infinity problem\n There have been many attempts to solve it  for example  preventing routers from advertising their best paths back to the neighbors from which they heard them with the split horizon with poisoned reverse rule discussed in RFC \n However  none of these heuristics work well in practice despite the colorful names\n The core of the problem is that when X tells Y that it has a path somewhere  Y has no way of knowing whether it itself is on the path\n    Link State Routing Distance vector routing was used in the ARPANET until  when it was replaced by link state routing\n The primary problem that caused its demise was that the algorithm often took too long to converge after the network topology changed (due to the count-to-infinity problem)\n Consequently  it was replaced by an entirely new algorithm  now called link state routing\n Variants of link state routing called IS-IS and OSPF are the routing algorithms that are most widely used inside large networks and the Internet today\n The idea behind link state routing is fairly simple and can be stated as five parts\n Each router must do the following things to make it work: THE NETWORK LAYER  \n   \n Discover its neighbors and learn their network addresses Set the distance or cost metric to each of its neighbors Construct a packet telling all it has just learned Send this packet to and receive packets from all other routers Compute the shortest path to every other router\n In effect  the complete topology is distributed to every router\n Then Dijkstra’s algorithm can be run at each router to find the shortest path to every other router\n Below we will consider each of these five steps in more detail\n Learning about the Neighbors When a router is booted  its first task is to learn who its neighbors are\n It accomplishes this goal by sending a special HELLO packet on each point-to-point line\n The router on the other end is expected to send back a reply giving its name\n These names must be globally unique because when a distant router later hears that three routers are all connected to F  it is essential that it can determine whether all three mean the same F\n When two or more routers are connected by a broadcast link ( \n  a switch  ring  or classic Ethernet)  the situation is slightly more complicated\n Fig\n  -  (a) illustrates a broadcast LAN to which three routers  A  C  and F  are directly connected\n Each of these routers is connected to one or more additional routers  as shown\n Router A B C D E C D E H I F G G H F I N A B LAN (a) (b) Figure  -  \n (a) Nine routers and a broadcast LAN\n (b) A graph model of (a)\n The broadcast LAN provides connectivity between each pair of attached routers\n However  modeling the LAN as many point-to-point links increases the size   ROUTING ALGORITHMS of the topology and leads to wasteful messages\n A better way to model the LAN is to consider it as a node itself  as shown in Fig\n  -  (b)\n Here  we have introduced a new  artificial node  N  to which A  C  and F are connected\n One designated router on the LAN is selected to play the role of N in the routing protocol\n The fact that it is possible to go from A to C on the LAN is represented by the path ANC here\n Setting Link Costs The link state routing algorithm requires each link to have a distance or cost metric for finding shortest paths\n The cost to reach neighbors can be set automatically  or configured by the network operator\n A common choice is to make the cost inversely proportional to the bandwidth of the link\n For example  -Gbps Ethernet may have a cost of  and   -Mbps Ethernet a cost of  \n This makes higher-capacity paths better choices\n If the network is geographically spread out  the delay of the links may be factored into the cost so that paths over shorter links are better choices\n The most direct way to determine this delay is to send over the line a special ECHO packet that the other side is required to send back immediately\n By measuring the round-trip time and dividing it by two  the sending router can get a reasonable estimate of the delay\n Building Link State Packets Once the information needed for the exchange has been collected  the next step is for each router to build a packet containing all the data\n The packet starts with the identity of the sender  followed by a sequence number and age (to be described later) and a list of neighbors\n The cost to each neighbor is also given\n An example network is presented in Fig\n  -  (a) with costs shown as labels on the lines\n The corresponding link state packets for all six routers are shown in Fig\n  -  (b)\n B C E F A D    (a) A Seq\n Age B C D E F B  E  Seq\n Age A  C  Seq\n Age B  D  Seq\n Age C  F  Seq\n Age A  C  Seq\n Age B  D  F  E  F  E  Link State Packets (b) Figure  -  \n (a) A network\n (b) The link state packets for this network\n THE NETWORK LAYER  \n  Building the link state packets is easy\n The hard part is determining when to build them\n One possibility is to build them periodically  that is  at regular intervals\n Another possibility is to build them when some significant event occurs  such as a line or neighbor going down or coming back up again or changing its properties appreciably\n Distributing the Link State Packets The trickiest part of the algorithm is distributing the link state packets\n All of the routers must get all of the link state packets quickly and reliably\n If different routers are using different versions of the topology  the routes they compute can have inconsistencies such as loops  unreachable machines  and other problems\n First  we will describe the basic distribution algorithm\n After that we will give some refinements\n The fundamental idea is to use flooding to distribute the link state packets to all routers\n To keep the flood in check  each packet contains a sequence number that is incremented for each new packet sent\n Routers keep track of all the (source router  sequence) pairs they see\n When a new link state packet comes in  it is checked against the list of packets already seen\n If it is new  it is forwarded on all lines except the one it arrived on\n If it is a duplicate  it is discarded\n If a packet with a sequence number lower than the highest one seen so far ever arrives  it is rejected as being obsolete as the router has more recent data\n This algorithm has a few problems  but they are manageable\n First  if the sequence numbers wrap around  confusion will reign\n The solution here is to use a  -bit sequence number\n With one link state packet per ond  it would take years to wrap around  so this possibility can be ignored\n ond  if a router ever crashes  it will lose track of its sequence number\n If it starts again at   the next packet it sends will be rejected as a duplicate\n Third  if a sequence number is ever corrupted and   is received instead of  (a  -bit error)  packets  through   will be rejected as obsolete  since the current sequence number will be thought to be  \n The solution to all these problems is to include the age of each packet after the sequence number and decrement it once per ond\n When the age hits zero  the information from that router is discarded\n Normally  a new packet comes in  say  every     so router information only times out when a router is down (or six conutive packets have been lost  an unlikely event)\n The Age field is also decremented by each router during the initial flooding process  to make sure no packet can get lost and live for an indefinite period of time (a packet whose age is zero is discarded)\n Some refinements to this algorithm make it more robust\n When a link state packet comes in to a router for flooding  it is not queued for transmission immediately\n Instead  it is put in a holding area to wait a short while in case more links are coming up or going down\n If another link state packet from the same source comes in before the first packet is transmitted  their sequence numbers are   ROUTING ALGORITHMS compared\n If they are equal  the duplicate is discarded\n If they are different  the older one is thrown out\n To guard against errors on the links  all link state packets are acknowledged\n The data structure used by router B for the network shown in Fig\n  -  (a) is depicted in Fig\n  -  \n Each row here corresponds to a recently arrived  but as yet not fully processed  link state packet\n The table records where the packet originated  its sequence number and age  and the data\n In addition  there are send and acknowledgement flags for each of B’s three links (to A  C  and F  respectively)\n The send flags mean that the packet must be sent on the indicated link\n The acknowledgement flags mean that it must be acknowledged there\n D     C     E     F     A     Source Seq\n Age A C F A C F Data Send flags ACK flags Figure  -  \n The packet buffer for router B in Fig\n  -  (a)\n In Fig\n  -   the link state packet from A arrives directly  so it must be sent to C and F and acknowledged to A  as indicated by the flag bits\n Similarly  the packet from F has to be forwarded to A and C and acknowledged to F\n However  the situation with the third packet  from E  is different\n It arrives twice  once via EAB and once via EFB\n Consequently  it has to be sent only to C but must be acknowledged to both A and F  as indicated by the bits\n If a duplicate arrives while the original is still in the buffer  bits have to be changed\n For example  if a copy of C’s state arrives from F before the fourth entry in the table has been forwarded  the six bits will be changed to   to indicate that the packet must be acknowledged to F but not sent there\n Computing the New Routes Once a router has accumulated a full set of link state packets  it can construct the entire network graph because every link is represented\n Every link is  in fact  represented twice  once for each direction\n The different directions may even have different costs\n The shortest-path computations may then find different paths from router A to B than from router B to A\n Now Dijkstra’s algorithm can be run locally to construct the shortest paths to all possible destinations\n The results of this algorithm tell the router which link to THE NETWORK LAYER  \n  use to reach each destination\n This information is installed in the routing tables  and normal operation is resumed\n Compared to distance vector routing  link state routing requires more memory and computation\n For a network with n routers  each of which has k neighbors  the memory required to store the input data is proportional to kn  which is at least as large as a routing table listing all the destinations\n Also  the computation time grows faster than kn  even with the most efficient data structures  an issue in large networks\n Nevertheless  in many practical situations  link state routing works well because it does not suffer from slow convergence problems\n Link state routing is widely used in actual networks  so a few words about some example protocols are in order\n Many ISPs use the IS-IS (Intermediate System-Intermediate System) link state protocol (Oran  )\n It was designed for an early network called DECnet  later adopted by ISO for use with the OSI protocols and then modified to handle other protocols as well  most notably  IP\n OSPF (Open Shortest Path First) is the other main link state protocol\n It was designed by IETF several years after IS-IS and adopted many of the innovations designed for IS-IS\n These innovations include a self-stabilizing method of flooding link state updates  the concept of a designated router on a LAN  and the method of computing and supporting path splitting and multiple metrics\n As a consequence  there is very little difference between IS-IS and OSPF\n The most important difference is that IS-IS can carry information about multiple network layer protocols at the same time ( \n  IP  IPX  and AppleTalk)\n OSPF does not have this feature  and it is an advantage in large multiprotocol environments\n We will go over OSPF in \n   \n A general comment on routing algorithms is also in order\n Link state  distance vector  and other algorithms rely on processing at all the routers to compute routes\n Problems with the hardware or software at even a small number of routers can wreak havoc across the network\n For example  if a router claims to have a link it does not have or forgets a link it does have  the network graph will be incorrect\n If a router fails to forward packets or corrupts them while forwarding them  the route will not work as expected\n Finally  if it runs out of memory or does the routing calculation wrong  bad things will happen\n As the network grows into the range of tens or hundreds of thousands of nodes  the probability of some router failing occasionally becomes nonnegligible\n The trick is to try to arrange to limit the damage when the inevitable happens\n Perlman (   ) discusses these problems and their possible solutions in detail\n    Hierarchical Routing As networks grow in size  the router routing tables grow proportionally\n Not only is router memory consumed by ever-increasing tables  but more CPU time is needed to scan them and more bandwidth is needed to send status reports about them\n At a certain point  the network may grow to the point where it is no longer   ROUTING ALGORITHMS feasible for every router to have an entry for every other router  so the routing will have to be done hierarchically  as it is in the telephone network\n When hierarchical routing is used  the routers are divided into what we will call regions\n Each router knows all the details about how to route packets to destinations within its own region but knows nothing about the internal structure of other regions\n When different networks are interconnected  it is natural to regard each one as a separate region to free the routers in one network from having to know the topological structure of the other ones\n For huge networks  a two-level hierarchy may be insufficient; it may be necessary to group the regions into clusters  the clusters into zones  the zones into groups  and so on  until we run out of names for aggregations\n As an example of a multilevel hierarchy  consider how a packet might be routed from Berkeley  California  to Malindi  Kenya\n The Berkeley router would know the detailed topology within California but would send all out-of-state traffic to the Los Angeles router\n The Los Angeles router would be able to route traffic directly to other domestic routers but would send all foreign traffic to New York\n The New York router would be programmed to direct all traffic to the router in the destination country responsible for handling foreign traffic  say  in Nairobi\n Finally  the packet would work its way down the tree in Kenya until it got to Malindi\n Figure  -  gives a quantitative example of routing in a two-level hierarchy with five regions\n The full routing table for router  A has   entries  as shown in Fig\n  -  (b)\n When routing is done hierarchically  as in Fig\n  -  (c)  there are entries for all the local routers  as before  but all other regions are condensed into a single router  so all traffic for region  goes via the  B- A line  but the rest of the remote traffic goes via the  C- B line\n Hierarchical routing has reduced the table from   to  entries\n As the ratio of the number of regions to the number of routers per region grows  the savings in table space increase\n Unfortunately  these gains in space are not free\n There is a penalty to be paid: increased path length\n For example  the best route from  A to  C is via region   but with hierarchical routing all traffic to region  goes via region   because that is better for most destinations in region  \n When a single network becomes very large  an interesting question is ‘‘how many levels should the hierarchy have?’’ For example  consider a network with routers\n If there is no hierarchy  each router needs routing table entries\n If the network is partitioned into   regions of   routers each  each router needs   local entries plus   remote entries for a total of   entries\n If a three-level hierarchy is chosen  with  clusters each containing  regions of   routers  each router needs   entries for local routers   entries for routing to other regions within its own cluster  and  entries for distant clusters  for a total of   entries\n Kamoun and Kleinrock (   ) discovered that the optimal number of levels for an N router network is ln N  requiring a total of e ln N entries per router\n They have also shown that the increase in effective mean path length caused by hierarchical routing is sufficiently small that it is usually acceptable\n THE NETWORK LAYER  \n  Region  Region  Region  Region  Region   B  A  C  A  B  C  B  C  A  E  D  D  A  B  C  A  B  B   C   B   B   B   B   C   C   C   C   C   C   C   B   C   C   A – –  C  A  B  C  D  A  B  A  B  C  A  B  C  D  E  B Dest\n Line Hops Full table for  A  A  C  B Dest\n Line Hops Hierarchical table for  A  B   C   B   C   C   C  – – (a) (b) (c) Figure  -  \n Hierarchical routing\n    Broadcast Routing In some applications  hosts need to send messages to many or all other hosts\n For example  a service distributing weather reports  stock market updates  or live radio programs might work best by sending to all machines and letting those that are interested read the data\n Sending a packet to all destinations simultaneously is called broadcasting\n Various methods have been proposed for doing it\n One broadcasting method that requires no special features from the network is for the source to simply send a distinct packet to each destination\n Not only is the method wasteful of bandwidth and slow  but it also requires the source to have a complete list of all destinations\n This method is not desirable in practice  even though it is widely applicable\n An improvement is multidestination routing  in which each packet contains either a list of destinations or a bit map indicating the desired destinations\n When a packet arrives at a router  the router checks all the destinations to determine the set of output lines that will be needed\n (An output line is needed if it is the best route to at least one of the destinations\n) The router generates a new copy of the packet for each output line to be used and includes in each packet only those destinations that are to use the line\n In effect  the destination set is partitioned among   ROUTING ALGORITHMS the output lines\n After a sufficient number of hops  each packet will carry only one destination like a normal packet\n Multidestination routing is like using separately addressed packets  except that when several packets must follow the same route  one of them pays full fare and the rest ride free\n The network bandwidth is therefore used more efficiently\n However  this scheme still requires the source to know all the destinations  plus it is as much work for a router to determine where to send one multidestination packet as it is for multiple distinct packets\n We have already seen a better broadcast routing technique: flooding\n When implemented with a sequence number per source  flooding uses links efficiently with a decision rule at routers that is relatively simple\n Although flooding is illsuited for ordinary point-to-point communication  it rates serious consideration for broadcasting\n However  it turns out that we can do better still once the shortest path routes for regular packets have been computed\n The idea for reverse path forwarding is elegant and remarkably simple once it has been pointed out (Dalal and Metcalfe  )\n When a broadcast packet arrives at a router  the router checks to see if the packet arrived on the link that is normally used for sending packets toward the source of the broadcast\n If so  there is an excellent chance that the broadcast packet itself followed the best route from the router and is therefore the first copy to arrive at the router\n This being the case  the router forwards copies of it onto all links except the one it arrived on\n If  however  the broadcast packet arrived on a link other than the preferred one for reaching the source  the packet is discarded as a likely duplicate\n I F H J N A D E K G O M O C G D N H B L L B A E H B C D F J G O M K L N I (a) A B C D G J O F I E H K L M N (b) (c) E K H Figure  -  \n Reverse path forwarding\n (a) A network\n (b) A sink tree\n (c) The tree built by reverse path forwarding\n An example of reverse path forwarding is shown in Fig\n  -  \n Part (a) shows a network  part (b) shows a sink tree for router I of that network  and part (c) shows how the reverse path algorithm works\n On the first hop  I sends packets to F  H  J  and N  as indicated by the ond row of the tree\n Each of these packets arrives on the preferred path to I (assuming that the preferred path falls along the sink tree) and is so indicated by a circle around the letter\n On the ond hop  THE NETWORK LAYER  \n  eight packets are generated  two by each of the routers that received a packet on the first hop\n As it turns out  all eight of these arrive at previously unvisited routers  and five of these arrive along the preferred line\n Of the six packets generated on the third hop  only three arrive on the preferred path (at C  E  and K); the others are duplicates\n After five hops and   packets  the broadcasting terminates  compared with four hops and   packets had the sink tree been followed exactly\n The principal advantage of reverse path forwarding is that it is efficient while being easy to implement\n It sends the broadcast packet over each link only once in each direction  just as in flooding  yet it requires only that routers know how to reach all destinations  without needing to remember sequence numbers (or use other mechanisms to stop the flood) or list all destinations in the packet\n Our last broadcast algorithm improves on the behavior of reverse path forwarding\n It makes explicit use of the sink tree—or any other convenient spanning tree—for the router initiating the broadcast\n A spanning tree is a subset of the network that includes all the routers but contains no loops\n Sink trees are spanning trees\n If each router knows which of its lines belong to the spanning tree  it can copy an incoming broadcast packet onto all the spanning tree lines except the one it arrived on\n This method makes excellent use of bandwidth  generating the absolute minimum number of packets necessary to do the job\n In Fig\n  -   for example  when the sink tree of part (b) is used as the spanning tree  the broadcast packet is sent with the minimum   packets\n The only problem is that each router must have knowledge of some spanning tree for the method to be applicable\n Sometimes this information is available ( \n  with link state routing  all routers know the complete topology  so they can compute a spanning tree) but sometimes it is not ( \n  with distance vector routing)\n    Multicast Routing Some applications  such as a multiplayer game or live video of a sports event streamed to many viewing locations  send packets to multiple receivers\n Unless the group is very small  sending a distinct packet to each receiver is expensive\n On the other hand  broadcasting a packet is wasteful if the group consists of  say  machines on a million-node network  so that most receivers are not interested in the message (or worse yet  they are definitely interested but are not supposed to see it)\n Thus  we need a way to send messages to well-defined groups that are numerically large in size but small compared to the network as a whole\n Sending a message to such a group is called multicasting  and the routing algorithm used is called multicast routing\n All multicasting schemes require some way to create and destroy groups and to identify which routers are members of a group\n How these tasks are accomplished is not of concern to the routing algorithm\n For now  we will assume that each group is identified by a multicast address and that routers know the groups to which they belong\n We will revisit group membership when we describe the network layer of the Internet in \n     ROUTING ALGORITHMS Multicast routing schemes build on the broadcast routing schemes we have already studied  sending packets along spanning trees to deliver the packets to the members of the group while making efficient use of bandwidth\n However  the best spanning tree to use depends on whether the group is dense  with receivers scattered over most of the network  or sparse  with much of the network not belonging to the group\n In this tion we will consider both cases\n If the group is dense  broadcast is a good start because it efficiently gets the packet to all parts of the network\n But broadcast will reach some routers that are not members of the group  which is wasteful\n The solution explored by Deering and Cheriton (   ) is to prune the broadcast spanning tree by removing links that do not lead to members\n The result is an efficient multicast spanning tree\n As an example  consider the two groups   and   in the network shown in Fig\n  -  (a)\n Some routers are attached to hosts that belong to one or both of these groups  as indicated in the figure\n A spanning tree for the leftmost router is shown in Fig\n  -  (b)\n This tree can be used for broadcast but is overkill for multicast  as can be seen from the two pruned versions that are shown next\n In Fig\n  -  (c)  all the links that do not lead to hosts that are members of group  have been removed\n The result is the multicast spanning tree for the leftmost router to send to group  \n Packets are forwarded only along this spanning tree  which is more efficient than the broadcast tree because there are  links instead of  \n Fig\n  -  (d) shows the multicast spanning tree after pruning for group  \n It is efficient too  with only five links this time\n It also shows that different multicast groups have different spanning trees\n Various ways of pruning the spanning tree are possible\n The simplest one can be used if link state routing is used and each router is aware of the complete topology  including which hosts belong to which groups\n Each router can then construct its own pruned spanning tree for each sender to the group in question by constructing a sink tree for the sender as usual and then removing all links that do not connect group members to the sink node\n MOSPF (Multicast OSPF) is an example of a link state protocol that works in this way (Moy  )\n With distance vector routing  a different pruning strategy can be followed\n The basic algorithm is reverse path forwarding\n However  whenever a router with no hosts interested in a particular group and no connections to other routers receives a multicast message for that group  it responds with a PRUNE message  telling the neighbor that sent the message not to send it any more multicasts from the sender for that group\n When a router with no group members among its own hosts has received such messages on all the lines to which it sends the multicast  it  too  can respond with a PRUNE message\n In this way  the spanning tree is recursively pruned\n DVMRP (Distance Vector Multicast Routing Protocol) is an example of a multicast routing protocol that works this way (Waitzman et al\n  )\n Pruning results in efficient spanning trees that use only the links that are actually needed to reach members of the group\n One potential disadvantage is that it is lots of work for routers  especially for large networks\n Suppose that a network THE NETWORK LAYER  \n          (a) (b) (c) (d) Figure  -  \n (a) A network\n (b) A spanning tree for the leftmost router\n (c) A multicast tree for group  \n (d) A multicast tree for group  \n has n groups  each with an average of m nodes\n At each router and for each group  m pruned spanning trees must be stored  for a total of mn trees\n For example  Fig\n  -  (c) gives the spanning tree for the leftmost router to send to group  \n The spanning tree for the rightmost router to send to group  (not shown) will look quite different  as packets will head directly for group members rather than via the left side of the graph\n This in turn means that routers must forward packets destined to group  in different directions depending on which node is sending to the group\n When many large groups with many senders exist  considerable storage is needed to store all the trees\n An alternative design uses core-based trees to compute a single spanning tree for the group (Ballardie et al\n  )\n All of the routers agree on a root (called the core or rendezvous point) and build the tree by sending a packet from each member to the root\n The tree is the union of the paths traced by these packets\n Fig\n  -  (a) shows a core-based tree for group  \n To send to this group  a sender sends a packet to the core\n When the packet reaches the core  it is forwarded down the tree\n This is shown in Fig\n  -  (b) for the sender on the righthand side of the network\n As a performance optimization  packets destined for the group do not need to reach the core before they are multicast\n As soon as a packet reaches the   ROUTING ALGORITHMS tree  it can be forwarded up toward the root  as well as down all the other branches\n This is the case for the sender at the top of Fig\n  -  (b)\n    Core Core Sender Sender (a) (b) Figure  -  \n (a) Core-based tree for group  \n (b) Sending to group  \n Having a shared tree is not optimal for all sources\n For example  in Fig\n  -  (b)  the packet from the sender on the righthand side reaches the top-right group member via the core in three hops  instead of directly\n The inefficiency depends on where the core and senders are located  but often it is reasonable when the core is in the middle of the senders\n When there is only a single sender  as in a video that is streamed to a group  using the sender as the core is optimal\n Also of note is that shared trees can be a major savings in storage costs  messages sent  and computation\n Each router has to keep only one tree per group  instead of m trees\n Further  routers that are not part of the tree do no work at all to support the group\n For this reason  shared tree approaches like core-based trees are used for multicasting to sparse groups in the Internet as part of popular protocols such as PIM (Protocol Independent Multicast) (Fenner et al\n  )\n    Anycast Routing So far  we have covered delivery models in which a source sends to a single destination (called unicast)  to all destinations (called broadcast)  and to a group of destinations (called multicast)\n Another delivery model  called anycast is sometimes also useful\n In anycast  a packet is delivered to the nearest member of a group (Partridge et al\n  )\n Schemes that find these paths are called anycast routing\n Why would we want anycast? Sometimes nodes provide a service  such as time of day or content distribution for which it is getting the right information all that matters  not the node that is contacted; any node will do\n For example  anycast is used in the Internet as part of DNS  as we will see in   Luckily  we will not have to devise new routing schemes for anycast because regular distance vector and link state routing can produce anycast routes\n Suppose THE NETWORK LAYER  \n  we want to anycast to the members of group  \n They will all be given the address ‘‘  ’’ instead of different addresses\n Distance vector routing will distribute vectors as usual  and nodes will choose the shortest path to destination  \n This will result in nodes sending to the nearest instance of destination  \n The routes are shown in Fig\n  -  (a)\n This procedure works because the routing protocol does not realize that there are multiple instances of destination  \n That is  it believes that all the instances of node  are the same node  as in the topology shown in Fig\n  -  (b)\n    (a) (b) Figure  -  \n (a) Anycast routes to group  \n (b) Topology seen by the routing protocol\n This procedure works for link state routing as well  although there is the added consideration that the routing protocol must not find seemingly short paths that pass through node  \n This would result in jumps through hyperspace  since the instances of node  are really nodes located in different parts of the network\n However  link state protocols already make this distinction between routers and hosts\n We glossed over this fact earlier because it was not needed for our discussion\n    Routing for Mobile Hosts Millions of people use computers while on the go  from truly mobile situations with wireless devices in moving cars  to nomadic situations in which laptop computers are used in a series of different locations\n We will use the term mobile hosts to mean either category  as distinct from stationary hosts that never move\n Increasingly  people want to stay connected wherever in the world they may be  as easily as if they were at home\n These mobile hosts introduce a new complication: to route a packet to a mobile host  the network first has to find it\n The model of the world that we will consider is one in which all hosts are assumed to have a permanent home location that never changes\n Each hosts also has a permanent home address that can be used to determine its home location  analogous to the way the telephone number  -  -   indicates the United States (country code  ) and Manhattan (  )\n The routing goal in systems with   ROUTING ALGORITHMS mobile hosts is to make it possible to send packets to mobile hosts using their fixed home addresses and have the packets efficiently reach them wherever they may be\n The trick  of course  is to find them\n Some discussion of this model is in order\n A different model would be to recompute routes as the mobile host moves and the topology changes\n We could then simply use the routing schemes described earlier in this tion\n However  with a growing number of mobile hosts  this model would soon lead to the entire network endlessly computing new routes\n Using the home addresses greatly reduces this burden\n Another alternative would be to provide mobility above the network layer  which is what typically happens with laptops today\n When they are moved to new Internet locations  laptops acquire new network addresses\n There is no association between the old and new addresses; the network does not know that they belonged to the same laptop\n In this model  a laptop can be used to browse the Web  but other hosts cannot send packets to it (for example  for an incoming call)  without building a higher layer location service  for example  signing into Skype again after moving\n Moreover  connections cannot be maintained while the host is moving; new connections must be started up instead\n Network-layer mobility is useful to fix these problems\n The basic idea used for mobile routing in the Internet and cellular networks is for the mobile host to tell a host at the home location where it is now\n This host  which acts on behalf of the mobile host  is called the home agent\n Once it knows where the mobile host is currently located  it can forward packets so that they are delivered\n Fig\n  -  shows mobile routing in action\n A sender in the northwest city of Seattle wants to send a packet to a host normally located across the United States in New York\n The case of interest to us is when the mobile host is not at home\n Instead  it is temporarily in San Diego\n The mobile host in San Diego must acquire a local network address before it can use the network\n This happens in the normal way that hosts obtain network addresses; we will cover how this works for the Internet later in this  ter\n The local address is called a care of address\n Once the mobile host has this address  it can tell its home agent where it is now\n It does this by sending a registration message to the home agent (step  ) with the care of address\n The message is shown with a dashed line in Fig\n  -  to indicate that it is a control message  not a data message\n Next  the sender sends a data packet to the mobile host using its permanent address (step  )\n This packet is routed by the network to the host’s home location because that is where the home address belongs\n In New York  the home agent intercepts this packet because the mobile host is away from home\n It then wraps or encapsulates the packet with a new header and sends this bundle to the care of address (step  )\n This mechanism is called tunneling\n It is very important in the Internet so we will look at it in more detail later\n THE NETWORK LAYER  \n  Mobile host at care of address  : Tunnel to care of address  : Register care of address  : Send to home address Home agent at home address Sender  : Reply  : Tunnel to sender to care of address Figure  -  \n Packet routing for mobile hosts\n When the encapsulated packet arrives at the care of address  the mobile host unwraps it and retrieves the packet from the sender\n The mobile host then sends its reply packet directly to the sender (step  )\n The overall route is called triangle routing because it may be circuitous if the remote location is far from the home location\n As part of step   the sender may learn the current care of address\n Subsequent packets can be routed directly to the mobile host by tunneling them to the care of address (step  )  bypassing the home location entirely\n If connectivity is lost for any reason as the mobile moves  the home address can always be used to reach the mobile\n An important aspect that we have omitted from this description is urity\n In general  when a host or router gets a message of the form ‘‘Starting right now  please send all of Stephany’s mail to me ’’ it might have a couple of questions about whom it is talking to and whether this is a good idea\n urity information is included in the messages so that their validity can be checked with cryptographic protocols that we will study in   There are many variations on mobile routing\n The scheme above is modeled on IPv  mobility  the form of mobility used in the Internet (Johnson et al\n  ) and as part of IP-based cellular networks such as UMTS\n We showed the sender to be a stationary node for simplicity  but the designs let both nodes be mobile hosts\n Alternatively  the host may be part of a mobile network  for example a computer in a plane\n Extensions of the basic scheme support mobile networks with no work on the part of the hosts (Devarapalli et al\n  )\n Some schemes make use of a foreign ( \n  remote) agent  similar to the home agent but at the foreign location  or analogous to the VLR (Visitor Location Register) in cellular networks\n However  in more recent schemes  the foreign agent is not needed; mobile hosts act as their own foreign agents\n In either case  knowledge of the temporary location of the mobile host is limited to a small number of   ROUTING ALGORITHMS hosts ( \n  the mobile  home agent  and senders) so that the many routers in a large network do not need to recompute routes\n For more information about mobile routing  see also Perkins (  ) and Snoeren and Balakrishnan (   )\n    Routing in Ad Hoc Networks We have now seen how to do routing when the hosts are mobile but the routers are fixed\n An even more extreme case is one in which the routers themselves are mobile\n Among the possibilities are emergency workers at an earthquake site  military vehicles on a battlefield  a fleet of ships at sea  or a gathering of people with laptop computers in an area lacking    In all these cases  and others  each node communicates wirelessly and acts as both a host and a router\n Networks of nodes that just happen to be near each other are called ad hoc networks or MANETs (Mobile Ad hoc NETworks)\n Let us now examine them briefly\n More information can be found in Perkins (   )\n What makes ad hoc networks different from wired networks is that the topology is suddenly tossed out the window\n Nodes can come and go or appear in new places at the drop of a bit\n With a wired network  if a router has a valid path to some destination  that path continues to be valid barring failures  which are hopefully rare\n With an ad hoc network  the topology may be changing all the time  so the desirability and even the validity of paths can change spontaneously without warning\n Needless to say  these circumstances make routing in ad hoc networks more challenging than routing in their fixed counterparts\n Many  many routing algorithms for ad hoc networks have been proposed\n However  since ad hoc networks have been little used in practice compared to mobile networks  it is unclear which of these protocols are most useful\n As an example  we will look at one of the most popular routing algorithms  AODV (Ad hoc On-demand Distance Vector) (Perkins and Royer  )\n It is a relative of the distance vector algorithm that has been adapted to work in a mobile environment  in which nodes often have limited bandwidth and battery lifetimes\n Let us now see how it discovers and maintains routes\n Route Discovery In AODV  routes to a destination are discovered on demand  that is  only when a somebody wants to send a packet to that destination\n This saves much work that would otherwise be wasted when the topology changes before the route is used\n At any instant  the topology of an ad hoc network can be described by a graph of connected nodes\n Two nodes are connected ( \n  have an arc between them in the graph) if they can communicate directly using their radios\n A basic but adequate model that is sufficient for our purposes is that each node can communicate with all other nodes that lie within its coverage circle\n Real networks are THE NETWORK LAYER  \n  more complicated  with buildings  hills  and other obstacles that block communication  and nodes for which A is connected to B but B is not connected to A because A has a more powerful transmitter than B\n However  for simplicity  we will assume all connections are symmetric\n To describe the algorithm  consider the newly formed ad hoc network of Fig\n  -  \n Suppose that a process at node A wants to send a packet to node I\n The AODV algorithm maintains a distance vector table at each node  keyed by destination  giving information about that destination  including the neighbor to which to send packets to reach the destination\n First  A looks in its table and does not find an entry for I\n It now has to discover a route to I\n This property of discovering routes only when they are needed is what makes this algorithm ‘‘on demand\n’’ A B C Range of A’s broadcast A D B C E F F H I H I G G E E D D B C B C A A G H I F D E G H I (a) (b) (c) (d) F Figure  -  \n (a) Range of A’s broadcast\n (b) After B and D receive it\n (c) After C  F  and G receive it\n (d) After E  H  and I receive it\n The shaded nodes are new recipients\n The dashed lines show possible reverse routes\n The solid lines show the discovered route\n To locate I  A constructs a ROUTE REQUEST packet and broadcasts it using flooding  as described in \n   \n The transmission from A reaches B and D  as illustrated in Fig\n  -  (a)\n Each node rebroadcasts the request  which continues to reach nodes F  G  and C in Fig\n  -  (c) and nodes H  E  and I in Fig\n  -  (d)\n A sequence number set at the source is used to weed out duplicates during the flood\n For example  D discards the transmission from B in Fig\n  -  (c) because it has already forwarded the request\n Eventually  the request reaches node I  which constructs a ROUTE REPLY packet\n This packet is unicast to the sender along the reverse of the path followed by the request\n For this to work  each intermediate node must remember the node that sent it the request\n The arrows in Fig\n  -  (b)–(d) show the reverse route information that is stored\n Each intermediate node also increments a hop count as it forwards the reply\n This tells the nodes how far they are from the destination\n The replies tell each intermediate node which neighbor to use to reach the destination: it is the node that sent them the reply\n Intermediate nodes G and D put the   ROUTING ALGORITHMS best route they hear into their routing tables as they process the reply\n When the reply reaches A  a new route  ADGI  has been created\n In a large network  the algorithm generates many broadcasts  even for destinations that are close by\n To reduce overhead  the scope of the broadcasts is limited using the IP packet’s Time to live field\n This field is initialized by the sender and decremented on each hop\n If it hits   the packet is discarded instead of being broadcast\n The route discovery process is then modified as follows\n To locate a destination  the sender broadcasts a ROUTE REQUEST packet with Time to live set to  \n If no response comes back within a reasonable time  another one is sent  this time with Time to live set to  \n Subsequent attempts use  etc\n In this way  the search is first attempted locally  then in increasingly wider rings\n Route Maintenance Because nodes can move or be switched off  the topology can change spontaneously\n For example  in Fig\n  -   if G is switched off  A will not realize that the route it was using to I (ADGI) is no longer valid\n The algorithm needs to be able to deal with this\n Periodically  each node broadcasts a Hello message\n Each of its neighbors is expected to respond to it\n If no response is forthcoming  the broadcaster knows that that neighbor has moved out of range or failed and is no longer connected to it\n Similarly  if it tries to send a packet to a neighbor that does not respond  it learns that the neighbor is no longer available\n This information is used to purge routes that no longer work\n For each possible destination  each node  N  keeps track of its active neighbors that have fed it a packet for that destination during the last ΔT onds\n When any of N’s neighbors becomes unreachable  it checks its routing table to see which destinations have routes using the now-gone neighbor\n For each of these routes  the active neighbors are informed that their route via N is now invalid and must be purged from their routing tables\n In our example  D purges its entries for G and I from its routing table and notifies A  which purges its entry for I\n In the general case  the active neighbors tell their active neighbors  and so on  recursively  until all routes depending on the now-gone node are purged from all routing tables\n At this stage  the invalid routes have been purged from the network  and senders can find new  valid routes by using the discovery mechanism that we described\n However  there is a complication\n Recall that distance vector protocols can suffer from slow convergence or count-to-infinity problems after a topology change in which they confuse old  invalid routes with new  valid routes\n To ensure rapid convergence  routes include a sequence number that is controlled by the destination\n The destination sequence number is like a logical clock\n The destination increments it every time that it sends a fresh ROUTE REPLY\n Senders ask for a fresh route by including in the ROUTE REQUEST the destination sequence number of the last route they used  which will either be the sequence number of the route that was just purged  or  as an initial value\n The THE NETWORK LAYER  \n  request will be broadcast until a route with a higher sequence number is found\n Intermediate nodes store the routes that have a higher sequence number  or the fewest hops for the current sequence number\n In the spirit of an on demand protocol  intermediate nodes only store the routes that are in use\n Other route information learned during broadcasts is timed out after a short delay\n Discovering and storing only the routes that are used helps to save bandwidth and battery life compared to a standard distance vector protocol that periodically broadcasts updates\n So far  we have considered only a single route  from A to I\n To further save resources  route discovery and maintenance are shared when routes overlap\n For instance  if B also wants to send packets to I  it will perform route discovery\n However  in this case the request will first reach D  which already has a route to I\n Node D can then generate a reply to tell B the route without any additional work being required\n There are many other ad hoc routing schemes\n Another well-known on demand scheme is DSR (Dynamic Source Routing) (Johnson et al\n  )\n A different strategy based on geography is explored by GPSR (Greedy Perimeter Stateless Routing) (Karp and Kung  )\n If all nodes know their geographic positions  forwarding to a destination can proceed without route computation by simply heading in the right direction and circling back to escape any dead ends\n Which protocols win out will depend on the kinds of ad hoc networks that prove useful in practice  CONGESTION CONTROL ALGORITHMS Too many packets present in (a part of) the network causes packet delay and loss that degrades performance\n This situation is called congestion\n The network and transport layers share the responsibility for handling congestion\n Since congestion occurs within the network  it is the network layer that directly experiences it and must ultimately determine what to do with the excess packets\n However  the most effective way to control congestion is to reduce the load that the transport layer is placing on the network\n This requires the network and transport layers to work together\n In this  ter we will look at the network aspects of congestion\n In  \n   we will complete the topic by covering the transport aspects of congestion\n Figure  -  depicts the onset of congestion\n When the number of packets hosts send into the network is well within its carrying capacity  the number delivered is proportional to the number sent\n If twice as many are sent  twice as many are delivered\n However  as the offered load approaches the carrying capacity  bursts of traffic occasionally fill up the buffers inside routers and some packets are lost\n These lost packets consume some of the capacity  so the number of delivered packets falls below the ideal curve\n The network is now congested\n   CONGESTION CONTROL ALGORITHMS Ideal Goodput (packets/) Desirable response Capacity of the network Congestion collapse Offered load (packet/) Onset of congestion Figure  -  \n With too much traffic  performance drops sharply\n Unless the network is well designed  it may experience a congestion collapse  in which performance plummets as the offered load increases beyond the capacity\n This can happen because packets can be sufficiently delayed inside the network that they are no longer useful when they leave the network\n For example  in the early Internet  the time a packet spent waiting for a backlog of packets ahead of it to be sent over a slow  -kbps link could reach the maximum time it was allowed to remain in the network\n It then had to be thrown away\n A different failure mode occurs when senders retransmit packets that are greatly delayed  thinking that they have been lost\n In this case  copies of the same packet will be delivered by the network  again wasting its capacity\n To capture these factors  the y-axis of Fig\n  -  is given as goodput  which is the rate at which useful packets are delivered by the network\n We would like to design networks that avoid congestion where possible and do not suffer from congestion collapse if they do become congested\n Unfortunately  congestion cannot wholly be avoided\n If all of a sudden  streams of packets begin arriving on three or four input lines and all need the same output line  a queue will build up\n If there is insufficient memory to hold all of them  packets will be lost\n Adding more memory may help up to a point  but Nagle (   ) realized that if routers have an infinite amount of memory  congestion gets worse  not better\n This is because by the time packets get to the front of the queue  they have already timed out (repeatedly) and duplicates have been sent\n This makes matters worse  not better—it leads to congestion collapse\n Low-bandwidth links or routers that process packets more slowly than the line rate can also become congested\n In this case  the situation can be improved by directing some of the traffic away from the bottleneck to other parts of the network\n Eventually  however  all regions of the network will be congested\n In this situation  there is no alternative but to shed load or build a faster network\n It is worth pointing out the difference between congestion control and flow control  as the relationship is a very subtle one\n Congestion control has to do with THE NETWORK LAYER  \n  making sure the network is able to carry the offered traffic\n It is a global issue  involving the behavior of all the hosts and routers\n Flow control  in contrast  relates to the traffic between a particular sender and a particular receiver\n Its job is to make sure that a fast sender cannot continually transmit data faster than the receiver is able to absorb it\n To see the difference between these two concepts  consider a network made up of   -Gbps fiber optic links on which a supercomputer is trying to force feed a large file to a personal computer that is capable of handling only  Gbps\n Although there is no congestion (the network itself is not in trouble)  flow control is needed to force the supercomputer to stop frequently to give the personal computer a chance to breathe\n At the other extreme  consider a network with  -Mbps lines and  large computers  half of which are trying to transfer files at kbps to the other half\n Here  the problem is not that of fast senders overpowering slow receivers  but that the total offered traffic exceeds what the network can handle\n The reason congestion control and flow control are often confused is that the best way to handle both problems is to get the host to slow down\n Thus  a host can get a ‘‘slow down’’ message either because the receiver cannot handle the load or because the network cannot handle it\n We will come back to this point in   We will start our study of congestion control by looking at the approaches that can be used at different time scales\n Then we will look at approaches to preventing congestion from occurring in the first place  followed by approaches for coping with it once it has set in\n    Approaches to Congestion Control The presence of congestion means that the load is (temporarily) greater than the resources (in a part of the network) can handle\n Two solutions come to mind: increase the resources or decrease the load\n As shown in Fig\n  -   these solutions are usually applied on different time scales to either prevent congestion or react to it once it has occurred\n Traffic-aware routing Network provisioning Traffic throttling Admission control Load shedding Slower (Preventative) Faster (Reactive) Figure  -  \n Timescales of approaches to congestion control\n The most basic way to avoid congestion is to build a network that is well matched to the traffic that it carries\n If there is a low-bandwidth link on the path along which most traffic is directed  congestion is likely\n Sometimes resources   CONGESTION CONTROL ALGORITHMS can be added dynamically when there is serious congestion  for example  turning on spare routers or enabling lines that are normally used only as backups (to make the system fault tolerant) or purchasing bandwidth on the open market\n More often  links and routers that are regularly heavily utilized are upgraded at the earliest opportunity\n This is called provisioning and happens on a time scale of months  driven by long-term traffic trends\n To make the most of the existing network capacity  routes can be tailored to traffic patterns that change during the day as network users wake and sleep in different time zones\n For example  routes may be changed to shift traffic away from heavily used paths by changing the shortest path weights\n Some local radio stations have helicopters flying around their cities to report on road congestion to make it possible for their mobile listeners to route their packets (cars) around hotspots\n This is called traffic-aware routing\n Splitting traffic across multiple paths is also helpful\n However  sometimes it is not possible to increase capacity\n The only way then to beat back the congestion is to decrease the load\n In a virtual-circuit network  new connections can be refused if they would cause the network to become congested\n This is called admission control\n At a finer granularity  when congestion is imminent the network can deliver feedback to the sources whose traffic flows are responsible for the problem\n The network can request these sources to throttle their traffic  or it can slow down the traffic itself\n Two difficulties with this approach are how to identify the onset of congestion  and how to inform the source that needs to slow down\n To tackle the first issue  routers can monitor the average load  queueing delay  or packet loss\n In all cases  rising numbers indicate growing congestion\n To tackle the ond issue  routers must participate in a feedback loop with the sources\n For a scheme to work correctly  the time scale must be adjusted carefully\n If every time two packets arrive in a row  a router yells STOP and every time a router is idle for   μ  it yells GO  the system will oscillate wildly and never converge\n On the other hand  if it waits   minutes to make sure before saying anything  the congestion-control mechanism will react too sluggishly to be of any use\n Delivering timely feedback is a nontrivial matter\n An added concern is having routers send more messages when the network is already congested\n Finally  when all else fails  the network is forced to discard packets that it cannot deliver\n The general name for this is load shedding\n A good policy for choosing which packets to discard can help to prevent congestion collapse\n    Traffic-Aware Routing The first approach we will examine is traffic-aware routing\n The routing schemes we looked at in   \n  used fixed link weights\n These schemes adapted to changes in topology  but not to changes in load\n The goal in taking load into THE NETWORK LAYER  \n  account when computing routes is to shift traffic away from hotspots that will be the first places in the network to experience congestion\n The most direct way to do this is to set the link weight to be a function of the (fixed) link bandwidth and propagation delay plus the (variable) measured load or average queuing delay\n Least-weight paths will then favor paths that are more lightly loaded  all else being equal\n Traffic-aware routing was used in the early Internet according to this model (Khanna and Zinky  )\n However  there is a peril\n Consider the network of Fig\n  -   which is divided into two parts  East and West  connected by two links  CF and EI\n Suppose that most of the traffic between East and West is using link CF  and  as a result  this link is heavily loaded with long delays\n Including queueing delay in the weight used for the shortest path calculation will make EI more attractive\n After the new routing tables have been installed  most of the East-West traffic will now go over EI  loading this link\n Consequently  in the next update  CF will appear to be the shortest path\n As a result  the routing tables may oscillate wildly  leading to erratic routing and many potential problems\n West East B A D E C F G H J I Figure  -  \n A network in which the East and West parts are connected by two links\n If load is ignored and only bandwidth and propagation delay are considered  this problem does not occur\n Attempts to include load but change weights within a narrow range only slow down routing oscillations\n Two techniques can contribute to a successful solution\n The first is multipath routing  in which there can be multiple paths from a source to a destination\n In our example this means that the traffic can be spread across both of the East to West links\n The ond one is for the routing scheme to shift traffic across routes slowly enough that it is able to converge  as in the scheme of Gallagher (   )\n Given these difficulties  in the Internet routing protocols do not generally adjust their routes depending on the load\n Instead  adjustments are made outside the routing protocol by slowly changing its inputs\n This is called traffic engineering\n   CONGESTION CONTROL ALGORITHMS    Admission Control One technique that is widely used in virtual-circuit networks to keep congestion at bay is admission control\n The idea is simple: do not set up a new virtual circuit unless the network can carry the added traffic without becoming congested\n Thus  attempts to set up a virtual circuit may fail\n This is better than the alternative  as letting more people in when the network is busy just makes matters worse\n By analogy  in the telephone system  when a switch gets overloaded it practices admission control by not giving dial tones\n The trick with this approach is working out when a new virtual circuit will lead to congestion\n The task is straightforward in the telephone network because of the fixed bandwidth of calls (  kbps for uncompressed audio)\n However  virtual circuits in computer networks come in all shapes and sizes\n Thus  the circuit must come with some characterization of its traffic if we are to apply admission control\n Traffic is often described in terms of its rate and shape\n The problem of how to describe it in a simple yet meaningful way is difficult because traffic is typically bursty—the average rate is only half the story\n For example  traffic that varies while browsing the Web is more difficult to handle than a streaming movie with the same long-term throughput because the bursts of Web traffic are more likely to congest routers in the network\n A commonly used descriptor that captures this effect is the leaky bucket or token bucket\n A leaky bucket has two parameters that bound the average rate and the instantaneous burst size of traffic\n Since leaky buckets are widely used for quality of service  we will go over them in detail in \n   Armed with traffic descriptions  the network can decide whether to admit the new virtual circuit\n One possibility is for the network to reserve enough capacity along the paths of each of its virtual circuits that congestion will not occur\n In this case  the traffic description is a service agreement for what the network will guarantee its users\n We have prevented congestion but veered into the related topic of quality of service a little too early; we will return to it in the next tion\n Even without making guarantees  the network can use traffic descriptions for admission control\n The task is then to estimate how many circuits will fit within the carrying capacity of the network without congestion\n Suppose that virtual circuits that may blast traffic at rates up to   Mbps all pass through the same   - Mbps physical link\n How many circuits should be admitted? Clearly circuits can be admitted without risking congestion  but this is wasteful in the normal case since it may rarely happen that all   are transmitting full blast at the same time\n In real networks  measurements of past behavior that capture the statistics of transmissions can be used to estimate the number of circuits to admit  to trade better performance for acceptable risk\n Admission control can also be combined with traffic-aware routing by considering routes around traffic hotspots as part of the setup procedure\n For example  THE NETWORK LAYER  \n  consider the network illustrated in Fig\n  -  (a)  in which two routers are congested  as indicated\n A Congestion Virtual circuit Congestion B A B (a) (b) Figure  -  \n (a) A congested network\n (b) The portion of the network that is not congested\n A virtual circuit from A to B is also shown\n Suppose that a host attached to router A wants to set up a connection to a host attached to router B\n Normally  this connection would pass through one of the congested routers\n To avoid this situation  we can redraw the network as shown in Fig\n  -  (b)  omitting the congested routers and all of their lines\n The dashed line shows a possible route for the virtual circuit that avoids the congested routers\n Shaikh et al\n (   ) give a design for this kind of load-sensitive routing\n    Traffic Throttling In the Internet and many other computer networks  senders adjust their transmissions to send as much traffic as the network can readily deliver\n In this setting  the network aims to operate just before the onset of congestion\n When congestion is imminent  it must tell the senders to throttle back their transmissions and slow down\n This feedback is business as usual rather than an exceptional situation\n The term congestion avoidance is sometimes used to contrast this operating point with the one in which the network has become (overly) congested\n Let us now look at some approaches to throttling traffic that can be used in both datagram networks and virtual-circuit networks\n Each approach must solve two problems\n First  routers must determine when congestion is approaching  ideally before it has arrived\n To do so  each router can continuously monitor the resources it is using\n Three possibilities are the utilization of the output links  the buffering of queued packets inside the router  and the number of packets that are lost due to insufficient buffering\n Of these possibilities  the ond one is the most useful\n Averages of utilization do not directly account for the burstiness of   CONGESTION CONTROL ALGORITHMS most traffic—a utilization of  % may be low for smooth traffic and too high for highly variable traffic\n Counts of packet losses come too late\n Congestion has already set in by the time that packets are lost\n The queueing delay inside routers directly captures any congestion experienced by packets\n It should be low most of time  but will jump when there is a burst of traffic that generates a backlog\n To maintain a good estimate of the queueing delay  d  a sample of the instantaneous queue length  s  can be made periodically and d updated according to dnew = αdold + (  − α)s where the constant α determines how fast the router forgets recent history\n This is called an EWMA (Exponentially Weighted Moving Average)\n It smoothes out fluctuations and is equivalent to a low-pass filter\n Whenever d moves above the threshold  the router notes the onset of congestion\n The ond problem is that routers must deliver timely feedback to the senders that are causing the congestion\n Congestion is experienced in the network  but relieving congestion requires action on behalf of the senders that are using the network\n To deliver feedback  the router must identify the appropriate senders\n It must then warn them carefully  without sending many more packets into the already congested network\n Different schemes use different feedback mechanisms  as we will now describe\n Choke Packets The most direct way to notify a sender of congestion is to tell it directly\n In this approach  the router selects a congested packet and sends a choke packet back to the source host  giving it the destination found in the packet\n The original packet may be tagged (a header bit is turned on) so that it will not generate any more choke packets farther along the path and then forwarded in the usual way\n To avoid increasing load on the network during a time of congestion  the router may only send choke packets at a low rate\n When the source host gets the choke packet  it is required to reduce the traffic sent to the specified destination  for example  by  %\n In a datagram network  simply picking packets at random when there is congestion is likely to cause choke packets to be sent to fast senders  because they will have the most packets in the queue\n The feedback implicit in this protocol can help prevent congestion yet not throttle any sender unless it causes trouble\n For the same reason  it is likely that multiple choke packets will be sent to a given host and destination\n The host should ignore these additional chokes for the fixed time interval until its reduction in traffic takes effect\n After that period  further choke packets indicate that the network is still congested\n An example of a choke packet used in the early Internet is the SOURCEQUENCH message (Postel  )\n It never caught on  though  partly because the THE NETWORK LAYER  \n  circumstances in which it was generated and the effect it had were not clearly specified\n The modern Internet uses an alternative notification design that we will describe next\n Explicit Congestion Notification Instead of generating additional packets to warn of congestion  a router can tag any packet it forwards (by setting a bit in the packet’s header) to signal that it is experiencing congestion\n When the network delivers the packet  the destination can note that there is congestion and inform the sender when it sends a reply packet\n The sender can then throttle its transmissions as before\n This design is called ECN (Explicit Congestion Notification) and is used in the Internet (Ramakrishnan et al\n  )\n It is a refinement of early congestion signaling protocols  notably the binary feedback scheme of Ramakrishnan and Jain (   ) that was used in the DECNET architecture\n Two bits in the IP packet header are used to record whether the packet has experienced congestion\n Packets are unmarked when they are sent  as illustrated in Fig\n  -  \n If any of the routers they pass through is congested  that router will then mark the packet as having experienced congestion as it is forwarded\n The destination will then echo any marks back to the sender as an explicit congestion signal in its next reply packet\n This is shown with a dashed line in the figure to indicate that it happens above the IP level ( \n  in TCP)\n The sender must then throttle its transmissions  as in the case of choke packets\n Congestion signal Host Marked packet Host Packet Congested router Figure  -  \n Explicit congestion notification Hop-by-Hop Backpressure At high speeds or over long distances  many new packets may be transmitted after congestion has been signaled because of the delay before the signal takes effect\n Consider  for example  a host in San Francisco (router A in Fig\n  -  ) that is sending traffic to a host in New York (router D in Fig\n  -  ) at the OC-  speed of Mbps\n If the New York host begins to run out of buffers  it will take about   m for a choke packet to get back to San Francisco to tell it to slow down\n An ECN indication will take even longer because it is delivered via the destination\n Choke packet propagation is illustrated as the ond  third  and fourth steps in   CONGESTION CONTROL ALGORITHMS Fig\n  -  (a)\n In those   m  another  \n  megabits will have been sent\n Even if the host in San Francisco completely shuts down immediately  the  \n  megabits in the pipe will continue to pour in and have to be dealt with\n Only in the seventh diagram in Fig\n  -  (a) will the New York router notice a slower flow\n An alternative approach is to have the choke packet take effect at every hop it passes through  as shown in the sequence of Fig\n  -  (b)\n Here  as soon as the choke packet reaches F  F is required to reduce the flow to D\n Doing so will require F to devote more buffers to the connection  since the source is still sending away at full blast  but it gives D immediate relief  like a headache remedy in a television commercial\n In the next step  the choke packet reaches E  which tells E to reduce the flow to F\n This action puts a greater demand on E’s buffers but gives F immediate relief\n Finally  the choke packet reaches A and the flow genuinely slows down\n The net effect of this hop-by-hop scheme is to provide quick relief at the point of congestion  at the price of using up more buffers upstream\n In this way  congestion can be nipped in the bud without losing any packets\n The idea is discussed in detail by Mishra et al\n (   )\n    Load Shedding When none of the above methods make the congestion disappear  routers can bring out the heavy artillery: load shedding\n Load shedding is a fancy way of saying that when routers are being inundated by packets that they cannot handle  they just throw them away\n The term comes from the world of electrical power generation  where it refers to the practice of utilities intentionally blacking out certain areas to save the entire grid from collapsing on hot summer days when the demand for electricity greatly exceeds the supply\n The key question for a router drowning in packets is which packets to drop\n The preferred choice may depend on the type of applications that use the network\n For a file transfer  an old packet is worth more than a new one\n This is because dropping packet  and keeping packets  through for example  will only force the receiver to do more work to buffer data that it cannot yet use\n In contrast  for real-time media  a new packet is worth more than an old one\n This is because packets become useless if they are delayed and miss the time at which they must be played out to the user\n The former policy (old is better than new) is often called wine and the latter (new is better than old) is often called milk because most people would rather drink new milk and old wine than the alternative\n More intelligent load shedding requires cooperation from the senders\n An example is packets that carry routing information\n These packets are more important than regular data packets because they establish routes; if they are lost  the network may lose connectivity\n Another example is that algorithms for compressing video  like MPEG  periodically transmit an entire frame and then send subsequent THE NETWORK LAYER  \n  (a) (b) Choke Choke B C A D E F Choke Reduced flow Flow is still at maximum rate Flow is reduced B C A D E F Heavy flow Choke Choke Choke Reduced flow Figure  -  \n (a) A choke packet that affects only the source\n (b) A choke packet that affects each hop it passes through\n   CONGESTION CONTROL ALGORITHMS frames as differences from the last full frame\n In this case  dropping a packet that is part of a difference is preferable to dropping one that is part of a full frame because future packets depend on the full frame\n To implement an intelligent discard policy  applications must mark their packets to indicate to the network how important they are\n Then  when packets have to be discarded  routers can first drop packets from the least important class  then the next most important class  and so on\n Of course  unless there is some significant incentive to avoid marking every packet as VERY IMPORTANT—NEVER  EVER DISCARD  nobody will do it\n Often accounting and money are used to discourage frivolous marking\n For example  the network might let senders send faster than the service they purchased allows if they mark excess packets as low priority\n Such a strategy is actually not a bad idea because it makes more efficient use of idle resources  allowing hosts to use them as long as nobody else is interested  but without establishing a right to them when times get tough\n Random Early Detection Dealing with congestion when it first starts is more effective than letting it gum up the works and then trying to deal with it\n This observation leads to an interesting twist on load shedding  which is to discard packets before all the buffer space is really exhausted\n The motivation for this idea is that most Internet hosts do not yet get congestion signals from routers in the form of ECN\n Instead  the only reliable indication of congestion that hosts get from the network is packet loss\n After all  it is difficult to build a router that does not drop packets when it is overloaded\n Transport protocols such as TCP are thus hardwired to react to loss as congestion  slowing down the source in response\n The reasoning behind this logic is that TCP was designed for wired networks and wired networks are very reliable  so lost packets are mostly due to buffer overruns rather than transmission errors\n Wireless links must recover transmission errors at the link layer (so they are not seen at the network layer) to work well with TCP\n This situation can be exploited to help reduce congestion\n By having routers drop packets early  before the situation has become hopeless  there is time for the source to take action before it is too late\n A popular algorithm for doing this is called RED (Random Early Detection) (Floyd and Jacobson  )\n To determine when to start discarding  routers maintain a running average of their queue lengths\n When the average queue length on some link exceeds a threshold  the link is said to be congested and a small fraction of the packets are dropped at random\n Picking packets at random makes it more likely that the fastest senders will see a packet drop; this is the best option since the router cannot tell which source is causing the most trouble in a datagram network\n The affected sender will notice the loss when there is no acknowledgement  and then the transport protocol THE NETWORK LAYER  \n  will slow down\n The lost packet is thus delivering the same message as a choke packet  but implicitly  without the router sending any explicit signal\n RED routers improve performance compared to routers that drop packets only when their buffers are full  though they may require tuning to work well\n For example  the ideal number of packets to drop depends on how many senders need to be notified of congestion\n However  ECN is the preferred option if it is available\n It works in exactly the same manner  but delivers a congestion signal explicitly rather than as a loss; RED is used when hosts cannot receive explicit signals  QUALITY OF SERVICE The techniques we looked at in the previous tions are designed to reduce congestion and improve network performance\n However  there are applications (and customers) that demand stronger performance guarantees from the network than ‘‘the best that could be done under the circumstances\n’’ Multimedia applications in particular  often need a minimum throughput and maximum latency to work\n In this tion  we will continue our study of network performance  but now with a sharper focus on ways to provide quality of service that is matched to application needs\n This is an area in which the Internet is undergoing a long-term upgrade\n An easy solution to provide good quality of service is to build a network with enough capacity for whatever traffic will be thrown at it\n The name for this solution is overprovisioning\n The resulting network will carry application traffic without significant loss and  assuming a decent routing scheme  will deliver packets with low latency\n Performance doesn’t get any better than this\n To some extent  the telephone system is overprovisioned because it is rare to pick up a telephone and not get a dial tone instantly\n There is simply so much capacity available that demand can almost always be met\n The trouble with this solution is that it is expensive\n It is basically solving a problem by throwing money at it\n Quality of service mechanisms let a network with less capacity meet application requirements just as well at a lower cost\n Moreover  overprovisioning is based on expected traffic\n All bets are off if the traffic pattern changes too much\n With quality of service mechanisms  the network can honor the performance guarantees that it makes even when traffic spikes  at the cost of turning down some requests\n Four issues must be addressed to ensure quality of service:  \n What applications need from the network How to regulate the traffic that enters the network How to reserve resources at routers to guarantee performance Whether the network can safely accept more traffic\n   QUALITY OF SERVICE No single technique deals efficiently with all these issues\n Instead  a variety of techniques have been developed for use at the network (and transport) layer\n Practical quality-of-service solutions combine multiple techniques\n To this end  we will describe two versions of quality of service for the Internet called Integrated Services and Differentiated Services\n    Application Requirements A stream of packets from a source to a destination is called a flow (Clark  )\n A flow might be all the packets of a connection in a connection-oriented network  or all the packets sent from one process to another process in a connectionless network\n The needs of each flow can be characterized by four primary parameters: bandwidth  delay  jitter  and loss\n Together  these determine the QoS (Quality of Service) the flow requires\n Several common applications and the stringency of their network requirements are listed in Fig\n  -  \n Note that network requirements are less demanding than application requirements in those cases that the application can improve on the service provided by the network\n In particular  networks do not need to be lossless for reliable file transfer  and they do not need to deliver packets with identical delays for audio and video playout\n Some amount of loss can be repaired with retransmissions  and some amount of jitter can be smoothed by buffering packets at the receiver\n However  there is nothing applications can do to remedy the situation if the network provides too little bandwidth or too much delay\n Application Bandwidth Delay Jitter Loss Email Low Low Low Medium File sharing High Low Low Medium Web access Medium Medium Low Medium Remote login Low Medium Medium Medium Audio on demand Low Low High Low Video on demand High Low High Low Telephony Low High High Low Videoconferencing High High High Low Figure  -  \n Stringency of applications’ quality-of-service requirements\n The applications differ in their bandwidth needs  with email  audio in all forms  and remote login not needing much  but file sharing and video in all forms needing a great deal\n More interesting are the delay requirements\n File transfer applications  including email and video  are not delay sensitive\n If all packets are delayed uniformly by a few onds  no harm is done\n Interactive applications  such as Web THE NETWORK LAYER  \n  surfing and remote login  are more delay sensitive\n Real-time applications  such as telephony and videoconferencing  have strict delay requirements\n If all the words in a telephone call are each delayed by too long  the users will find the connection unacceptable\n On the other hand  playing audio or video files from a server does not require low delay\n The variation ( \n  standard deviation) in the delay or packet arrival times is called jitter\n The first three applications in Fig\n  -  are not sensitive to the packets arriving with irregular time intervals between them\n Remote login is somewhat sensitive to that  since updates on the screen will appear in little bursts if the connection suffers much jitter\n Video and especially audio are extremely sensitive to jitter\n If a user is watching a video over the network and the frames are all delayed by exactly  \n   onds  no harm is done\n But if the transmission time varies randomly between  and  onds  the result will be terrible unless the application hides the jitter\n For audio  a jitter of even a few millionds is clearly audible\n The first four applications have more stringent requirements on loss than audio and video because all bits must be delivered correctly\n This goal is usually achieved with retransmissions of packets that are lost in the network by the transport layer\n This is wasted work; it would be better if the network refused packets it was likely to lose in the first place\n Audio and video applications can tolerate some lost packets without retransmission because people do not notice short pauses or occasional skipped frames\n To accommodate a variety of applications  networks may support different categories of QoS\n An influential example comes from ATM networks  which were once part of a grand vision for networking but have since become a niche technology\n They support:  \n Constant bit rate ( \n  telephony) Real-time variable bit rate ( \n  compressed videoconferencing) Non-real-time variable bit rate ( \n  watching a movie on demand) Available bit rate ( \n  file transfer)\n These categories are also useful for other purposes and other networks\n Constant bit rate is an attempt to simulate a wire by providing a uniform bandwidth and a uniform delay\n Variable bit rate occurs when video is compressed  with some frames compressing more than others\n Sending a frame with a lot of detail in it may require sending many bits  whereas a shot of a white wall may compress extremely well\n Movies on demand are not actually real time because a few onds of video can easily be buffered at the receiver before playback starts  so jitter on the network merely causes the amount of stored-but-not-played video to vary\n Available bit rate is for applications such as email that are not sensitive to delay or jitter and will take what bandwidth they can get\n   QUALITY OF SERVICE    Traffic Shaping Before the network can make QoS guarantees  it must know what traffic is being guaranteed\n In the telephone network  this characterization is simple\n For example  a voice call (in uncompressed format) needs   kbps and consists of one  -bit sample every μ\n However  traffic in data networks is bursty\n It typically arrives at nonuniform rates as the traffic rate varies ( \n  videoconferencing with compression)  users interact with applications ( \n  browsing a new Web page)  and computers switch between tasks\n Bursts of traffic are more difficult to handle than constant-rate traffic because they can fill buffers and cause packets to be lost\n Traffic shaping is a technique for regulating the average rate and burstiness of a flow of data that enters the network\n The goal is to allow applications to transmit a wide variety of traffic that suits their needs  including some bursts  yet have a simple and useful way to describe the possible traffic patterns to the network\n When a flow is set up  the user and the network ( \n  the customer and the provider) agree on a certain traffic pattern ( \n  shape) for that flow\n In effect  the customer says to the provider ‘‘My transmission pattern will look like this; can you handle it?’’ Sometimes this agreement is called an SLA (Service Level Agreement)  especially when it is made over aggregate flows and long periods of time  such as all of the traffic for a given customer\n As long as the customer fulfills her part of the bargain and only sends packets according to the agreed-on contract  the provider promises to deliver them all in a timely fashion\n Traffic shaping reduces congestion and thus helps the network live up to its promise\n However  to make it work  there is also the issue of how the provider can tell if the customer is following the agreement and what to do if the customer is not\n Packets in excess of the agreed pattern might be dropped by the network  or they might be marked as having lower priority\n Monitoring a traffic flow is called traffic policing\n Shaping and policing are not so important for peer-to-peer and other transfers that will consume any and all available bandwidth  but they are of great importance for real-time data  such as audio and video connections  which have stringent quality-of-service requirements\n Leaky and Token Buckets We have already seen one way to limit the amount of data an application sends: the sliding window  which uses one parameter to limit how much data is in transit at any given time  which indirectly limits the rate\n Now we will look at a more general way to characterize traffic  with the leaky bucket and token bucket algorithms\n The formulations are slightly different but give an equivalent result\n THE NETWORK LAYER  \n  Try to imagine a bucket with a small hole in the bottom  as illustrated in Fig\n  -  (b)\n No matter the rate at which water enters the bucket  the outflow is at a constant rate  R  when there is any water in the bucket and zero when the bucket is empty\n Also  once the bucket is full to capacity B  any additional water entering it spills over the sides and is lost\n Check bucket here Host Packets Rate R B B Rate R Take out water/tokens Put in water Network (a) (b) (c) Figure  -  \n (a) Shaping packets\n (b) A leaky bucket\n (c) A token bucket\n This bucket can be used to shape or police packets entering the network  as shown in Fig\n  -  (a)\n Conceptually  each host is connected to the network by an interface containing a leaky bucket\n To send a packet into the network  it must be possible to put more water into the bucket\n If a packet arrives when the bucket is full  the packet must either be queued until enough water leaks out to hold it or be discarded\n The former might happen at a host shaping its traffic for the network as part of the operating system\n The latter might happen in hardware at a provider network interface that is policing traffic entering the network\n This technique was proposed by Turner (   ) and is called the leaky bucket algorithm\n A different but equivalent formulation is to imagine the network interface as a bucket that is being filled  as shown in Fig\n  -  (c)\n The tap is running at rate R and the bucket has a capacity of B  as before\n Now  to send a packet we must be able to take water  or tokens  as the contents are commonly called  out of the bucket (rather than putting water into the bucket)\n No more than a fixed number of tokens  B  can accumulate in the bucket  and if the bucket is empty  we must wait until more tokens arrive before we can send another packet\n This algorithm is called the token bucket algorithm\n Leaky and token buckets limit the long-term rate of a flow but allow shortterm bursts up to a maximum regulated length to pass through unaltered and without suffering any artificial delays\n Large bursts will be smoothed by a leaky bucket traffic shaper to reduce congestion in the network\n As an example  imagine that a computer can produce data at up to  Mbps (   million bytes/) and that the first link of the network also runs at this speed\n The pattern of traffic the host generates is shown in Fig\n  -  (a)\n This pattern is bursty\n The average   QUALITY OF SERVICE rate over one ond is Mbps  even though the host sends a burst of   KB at the top speed of  Mbps (for  /  of the ond)\n   MB/s for m MB/s for m Time (m)   Rate (Mbps) (a) (d) (b) (e) (c) (f)  Bucket (KB) With R =   MB/s  B =  With R =   MB/s  B =  KB Bucket always empty Bucket empties  traffic delayed Time (m)    Figure  -  \n (a) Traffic from a host\n Output shaped by a token bucket of rate Mbps and capacity (b)  KB and (c)  KB\n Token bucket level for shaping with rate Mbps and capacity (d)   KB  (e)  KB  and (f)  KB\n Now suppose that the routers can accept data at the top speed only for short intervals  until their buffers fill up\n The buffer size is  KB  smaller than the traffic burst\n For long intervals  the routers work best at rates not exceeding Mbps (say  because this is all the bandwidth given to the customer)\n The implication is that if traffic is sent in this pattern  some of it will be dropped in the network because it does not fit into the buffers at routers\n To avoid this packet loss  we can shape the traffic at the host with a token bucket\n If we use a rate  R  of Mbps and a capacity  B  of  KB  the traffic will fall within what the network can handle\n The output of this token bucket is shown in Fig\n  -  (b)\n The host can send full throttle at  Mbps for a short while until it has drained the bucket\n Then it has to cut back to Mbps until the burst has been sent\n The effect is to spread out the burst over time because it was too large to handle all at once\n The level of the token bucket is shown in Fig\n  -  (e)\n It starts off full and is depleted by the initial burst\n When it reaches zero  new packets can be sent only at the rate at which the buffer is filling; there can be no more bursts until the bucket has recovered\n The bucket fills when no traffic is being sent and stays flat when traffic is being sent at the fill rate\n We can also shape the traffic to be less bursty\n Fig\n  -  (c) shows the output of a token bucket with R = Mbps and a capacity of  \n This is the extreme case THE NETWORK LAYER  \n  in which the traffic has been completely smoothed\n No bursts are allowed  and the traffic enters the network at a steady rate\n The corresponding bucket level  shown in Fig\n  -  (f)  is always empty\n Traffic is being queued on the host for release into the network and there is always a packet waiting to be sent when it is allowed\n Finally  Fig\n  -  (d) shows the bucket level for a token bucket with R = Mbps and a capacity of B =   KB\n This is the smallest token bucket through which the traffic passes unaltered\n It might be used at a router in the network to police the traffic that the host sends\n If the host is sending traffic that conforms to the token bucket on which it has agreed with the network  the traffic will fit through that same token bucket run at the router at the edge of the network\n If the host sends at a faster or burstier rate  the token bucket will run out of water\n If this happens  a traffic policer will know that the traffic is not as described\n It will then either drop the excess packets or lower their priority  depending on the design of the network\n In our example  the bucket empties only momentarily  at the end of the initial burst  then recovers enough for the next burst\n Leaky and token buckets are easy to implement\n We will now describe the operation of a token bucket\n Even though we have described water flowing continuously into and out of the bucket  real implementations must work with discrete quantities\n A token bucket is implemented with a counter for the level of the bucket\n The counter is advanced by R /ΔT units at every clock tick of ΔT onds\n This would be Kbit every  m in our example above\n Every time a unit of traffic is sent into the network  the counter is decremented  and traffic may be sent until the counter reaches zero\n When the packets are all the same size  the bucket level can just be counted in packets ( \n  Mbit is   packets of  bytes)\n However  often variablesized packets are being used\n In this case  the bucket level is counted in bytes\n If the residual byte count is too low to send a large packet  the packet must wait until the next tick (or even longer  if the fill rate is small)\n Calculating the length of the maximum burst (until the bucket empties) is slightly tricky\n It is longer than just  KB divided by MB/ because while the burst is being output  more tokens arrive\n If we call the burst length S \n  the maximum output rate M bytes/  the token bucket capacity B bytes  and the token arrival rate R bytes/  we can see that an output burst contains a maximum of B + RS bytes\n We also know that the number of bytes in a maximumspeed burst of length S onds is MS\n Hence  we have B + RS = MS We can solve this equation to get S = B /(M − R)\n For our parameters of B =  KB  M = MB/  and R =   MB/  we get a burst time of about   m\n A potential problem with the token bucket algorithm is that it reduces large bursts down to the long-term rate R\n It is frequently desirable to reduce the peak rate  but without going down to the long-term rate (and also without raising the   QUALITY OF SERVICE long-term rate to allow more traffic into the network)\n One way to get smoother traffic is to insert a ond token bucket after the first one\n The rate of the ond bucket should be much higher than the first one\n Basically  the first bucket characterizes the traffic  fixing its average rate but allowing some bursts\n The ond bucket reduces the peak rate at which the bursts are sent into the network\n For example  if the rate of the ond token bucket is set to be Mbps and the capacity is set to   the initial burst will enter the network at a peak rate of Mbps  which is lower than the  Mbps rate we had previously\n Using all of these buckets can be a bit tricky\n When token buckets are used for traffic shaping at hosts  packets are queued and delayed until the buckets permit them to be sent\n When token buckets are used for traffic policing at routers in the network  the algorithm is simulated to make sure that no more packets are sent than permitted\n Nevertheless  these tools provide ways to shape the network traffic into more manageable forms to assist in meeting quality-of-service requirements\n    Packet Scheduling Being able to regulate the shape of the offered traffic is a good start\n However  to provide a performance guarantee  we must reserve sufficient resources along the route that the packets take through the network\n To do this  we are assuming that the packets of a flow follow the same route\n Spraying them over routers at random makes it hard to guarantee anything\n As a consequence  something similar to a virtual circuit has to be set up from the source to the destination  and all the packets that belong to the flow must follow this route\n Algorithms that allocate router resources among the packets of a flow and between competing flows are called packet scheduling algorithms\n Three different kinds of resources can potentially be reserved for different flows:  \n Bandwidth Buffer space CPU cycles\n The first one  bandwidth  is the most obvious\n If a flow requires  Mbps and the outgoing line has a capacity of  Mbps  trying to direct three flows through that line is not going to work\n Thus  reserving bandwidth means not oversubscribing any output line\n A ond resource that is often in short supply is buffer space\n When a packet arrives  it is buffered inside the router until it can be transmitted on the chosen outgoing line\n The purpose of the buffer is to absorb small bursts of traffic as the flows contend with each other\n If no buffer is available  the packet has to be discarded since there is no place to put it\n For good quality of service  some buffers might be reserved for a specific flow so that flow does not have to compete for THE NETWORK LAYER  \n  buffers with other flows\n Up to some maximum value  there will always be a buffer available when the flow needs one\n Finally  CPU cycles may also be a scarce resource\n It takes router CPU time to process a packet  so a router can process only a certain number of packets per ond\n While modern routers are able to process most packets quickly  some kinds of packets require greater CPU processing  such as the ICMP packets we will describe in \n   Making sure that the CPU is not overloaded is needed to ensure timely processing of these packets\n Packet scheduling algorithms allocate bandwidth and other router resources by determining which of the buffered packets to send on the output line next\n We already described the most straightforward scheduler when explaining how routers work\n Each router buffers packets in a queue for each output line until they can be sent  and they are sent in the same order that they arrived\n This algorithm is known as FIFO (First-In First-Out)  or equivalently FCFS (First-Come First-Serve)\n FIFO routers usually drop newly arriving packets when the queue is full\n Since the newly arrived packet would have been placed at the end of the queue  this behavior is called tail drop\n It is intuitive  and you may be wondering what alternatives exist\n In fact  the RED algorithm we described in \n    chose a newly arriving packet to drop at random when the average queue length grew large\n The other scheduling algorithms that we will describe also create other opportunities for deciding which packet to drop when the buffers are full\n FIFO scheduling is simple to implement  but it is not suited to providing good quality of service because when there are multiple flows  one flow can easily affect the performance of the other flows\n If the first flow is aggressive and sends large bursts of packets  they will lodge in the queue\n Processing packets in the order of their arrival means that the aggressive sender can hog most of the capacity of the routers its packets traverse  starving the other flows and reducing their quality of service\n To add insult to injury  the packets of the other flows that do get through are likely to be delayed because they had to sit in the queue behind many packets from the aggressive sender\n Many packet scheduling algorithms have been devised that provide stronger isolation between flows and thwart attempts at interference (Bhatti and Crowcroft  )\n One of the first ones was the fair queueing algorithm devised by Nagle (   )\n The essence of this algorithm is that routers have separate queues  one for each flow for a given output line\n When the line becomes idle  the router scans the queues round-robin  as shown in Fig\n  -  \n It then takes the first packet on the next queue\n In this way  with n hosts competing for the output line  each host gets to send one out of every n packets\n It is fair in the sense that all flows get to send packets at the same rate\n Sending more packets will not improve this rate\n Although a start  the algorithm has a flaw: it gives more bandwidth to hosts that use large packets than to hosts that use small packets\n Demers et al\n (   ) suggested an improvement in which the round-robin is done in such a way as to   QUALITY OF SERVICE Input queues Round-robin service     Output line Figure  -  \n Round-robin fair queueing\n simulate a byte-by-byte round-robin  instead of a packet-by-packet round-robin\n The trick is to compute a virtual time that is the number of the round at which each packet would finish being sent\n Each round drains a byte from all of the queues that have data to send\n The packets are then sorted in order of their finishing times and sent in that order\n This algorithm and an example of finish times for packets arriving in three flows are illustrated in Fig\n  -  \n If a packet has length L  the round at which it will finish is simply L rounds after the start time\n The start time is either the finish time of the previous packet  or the arrival time of the packet  if the queue is empty when it arrives\n Input queues Fair queueing Packet Arrival time Length Finish time Output order A    B  C  D  E  F  G   H  A B G E C D F H Arrives late (a) (b) Arrives after D but goes first Weight is   X Figure  -  \n (a) Weighted Fair Queueing\n (b) Finishing times for the packets\n From the table in Fig\n  -  (b)  and looking only at the first two packets in the top two queues  packets arrive in the order A  B  D  and F\n Packet A arrives at round  and is  bytes long  so its finish time is round  \n Similarly the finish time for packet B is  \n Packet D arrives while B is being sent\n Its finish time is  byte-rounds after it starts when B finishes  or  \n Similarly  the finish time for F is  \n In the absence of new arrivals  the relative sending order is A  B  F  D  even though F arrived after D\n It is possible that another small packet will arrive on the top flow and obtain a finish time before D\n It will only jump ahead of D if the THE NETWORK LAYER  \n  transmission of that packet has not started\n Fair queueing does not preempt packets that are currently being transmitted\n Because packets are sent in their entirety  fair queueing is only an approximation of the ideal byte-by-byte scheme\n But it is a very good approximation  staying within one packet transmission of the ideal scheme at all times\n One shortcoming of this algorithm in practice is that it gives all hosts the same priority\n In many situations  it is desirable to give  for example  video servers more bandwidth than  say  file servers\n This is easily possible by giving the video server two or more bytes per round\n This modified algorithm is called WFQ (Weighted Fair Queueing)\n Letting the number of bytes per round be the weight of a flow  W  we can now give the formula for computing the finish time: Fi = max(Ai  Fi − )+Li /W where Ai is the arrival time  Fi is the finish time  and Li is the length of packet i\n The bottom queue of Fig\n  -  (a) has a weight of   so its packets are sent more quickly as you can see in the finish times given in Fig\n  -  (b)\n Another practical consideration is implementation complexity\n WFQ requires that packets be inserted by their finish time into a sorted queue\n With N flows  this is at best an O(logN) operation per packet  which is difficult to achieve for many flows in high-speed routers\n Shreedhar and Varghese (   ) describe an approximation called deficit round robin that can be implemented very efficiently  with only O( ) operations per packet\n WFQ is widely used given this approximation\n Other kinds of scheduling algorithms exist  too\n A simple example is priority scheduling  in which each packet is marked with a priority\n High-priority packets are always sent before any low-priority packets that are buffered\n Within a priority  packets are sent in FIFO order\n However  priority scheduling has the disadvantage that a burst of high-priority packets can starve low-priority packets  which may have to wait indefinitely\n WFQ often provides a better alternative\n By giving the high-priority queue a large weight  say   high-priority packets will often go through a short line (as relatively few packets should be high priority) yet some fraction of low priority packets will continue to be sent even when there is high priority traffic\n A high and low priority system is essentially a two-queue WFQ system in which the high priority has infinite weight\n As a final example of a scheduler  packets might carry timestamps and be sent in timestamp order\n Clark et al\n (   ) describe a design in which the timestamp records how far the packet is behind or ahead of schedule as it is sent through a sequence of routers on the path\n Packets that have been queued behind other packets at a router will tend to be behind schedule  and the packets that have been serviced first will tend to be ahead of schedule\n Sending packets in order of their timestamps has the beneficial effect of speeding up slow packets while at the same time slowing down fast packets\n The result is that all packets are delivered by the network with a more consistent delay\n   QUALITY OF SERVICE    Admission Control We have now seen all the necessary elements for QoS and it is time to put them together to actually provide it\n QoS guarantees are established through the process of admission control\n We first saw admission control used to control congestion  which is a performance guarantee  albeit a weak one\n The guarantees we are considering now are stronger  but the model is the same\n The user offers a flow with an accompanying QoS requirement to the network\n The network then decides whether to accept or reject the flow based on its capacity and the commitments it has made to other flows\n If it accepts  the network reserves capacity in advance at routers to guarantee QoS when traffic is sent on the new flow\n The reservations must be made at all of the routers along the route that the packets take through the network\n Any routers on the path without reservations might become congested  and a single congested router can break the QoS guarantee\n Many routing algorithms find the single best path between each source and each destination and send all traffic over the best path\n This may cause some flows to be rejected if there is not enough spare capacity along the best path\n QoS guarantees for new flows may still be accommodated by choosing a different route for the flow that has excess capacity\n This is called QoS routing\n Chen and Nahrstedt (   ) give an overview of these techniques\n It is also possible to split the traffic for each destination over multiple paths to more easily find excess capacity\n A simple method is for routers to choose equal-cost paths and to divide the traffic equally or in proportion to the capacity of the outgoing links\n However  more sophisticated algorithms are also available (Nelakuditi and Zhang  )\n Given a path  the decision to accept or reject a flow is not a simple matter of comparing the resources (bandwidth  buffers  cycles) requested by the flow with the router’s excess capacity in those three dimensions\n It is a little more complicated than that\n To start with  although some applications may know about their bandwidth requirements  few know about buffers or CPU cycles  so at the minimum  a different way is needed to describe flows and translate this description to router resources\n We will get to this shortly\n Next  some applications are far more tolerant of an occasional missed deadline than others\n The applications must choose from the type of guarantees that the network can make  whether hard guarantees or behavior that will hold most of the time\n All else being equal  everyone would like hard guarantees  but the difficulty is that they are expensive because they constrain worst case behavior\n Guarantees for most of the packets are often sufficient for applications  and more flows with this guarantee can be supported for a fixed capacity\n Finally  some applications may be willing to haggle about the flow parameters and others may not\n For example  a movie viewer that normally runs at   frames/ may be willing to drop back to   frames/ if there is not enough free bandwidth to support   frames/\n Similarly  the number of pixels per frame  audio bandwidth  and other properties may be adjustable\n THE NETWORK LAYER  \n  Because many parties may be involved in the flow negotiation (the sender  the receiver  and all the routers along the path between them)  flows must be described accurately in terms of specific parameters that can be negotiated\n A set of such parameters is called a flow specification\n Typically  the sender ( \n  the video server) produces a flow specification proposing the parameters it would like to use\n As the specification propagates along the route  each router examines it and modifies the parameters as need be\n The modifications can only reduce the flow  not increase it ( \n  a lower data rate  not a higher one)\n When it gets to the other end  the parameters can be established\n As an example of what can be in a flow specification  consider the example of Fig\n  -  \n This is based on RFCs  and  for Integrated Services  a QoS design we will cover in the next tion\n It has five parameters\n The first two parameters  the token bucket rate and token bucket size  use a token bucket to give the maximum sustained rate the sender may transmit  averaged over a long time interval  and the largest burst it can send over a short time interval\n Parameter Unit Token bucket rate Bytes/ Token bucket size Bytes Peak data rate Bytes/ Minimum packet size Bytes Maximum packet size Bytes Figure  -  \n An example flow specification\n The third parameter  the peak data rate  is the maximum transmission rate tolerated  even for brief time intervals\n The sender must never exceed this rate even for short bursts\n The last two parameters specify the minimum and maximum packet sizes  including the transport and network layer headers ( \n  TCP and IP)\n The minimum size is useful because processing each packet takes some fixed time  no matter how short\n A router may be prepared to handle   packets/ of  KB each  but not be prepared to handle    packets/ of   bytes each  even though this represents a lower data rate\n The maximum packet size is important due to internal network limitations that may not be exceeded\n For example  if part of the path goes over an Ethernet  the maximum packet size will be restricted to no more than  bytes no matter what the rest of the network can handle\n An interesting question is how a router turns a flow specification into a set of specific resource reservations\n At first glance  it might appear that if a router has a link that runs at  say   Gbps and the average packet is  bits  it can process  million packets/\n This observation is not the case  though  because there will always be idle periods on the link due to statistical fluctuations in the load\n If the   QUALITY OF SERVICE link needs every bit of capacity to get its work done  idling for even a few bits creates a backlog it can never get rid of\n Even with a load slightly below the theoretical capacity  queues can build up and delays can occur\n Consider a situation in which packets arrive at random with a mean arrival rate of λ packets/\n The packets have random lengths and can be sent on the link with a mean service rate of μ packets/\n Under the assumption that both the arrival and service distributions are Poisson distributions (what is called an M/M/  queueing system  where ‘‘M’’ stands for Markov   \n  Poisson)  it can be proven using queueing theory that the mean delay experienced by a packet  T  is T = μ  ×  − λ/μ  = μ  ×  − ρ  where ρ = λ/μ is the CPU utilization\n The first factor  /μ  is what the service time would be in the absence of competition\n The ond factor is the slowdown due to competition with other flows\n For example  if λ =    packets/ and μ =  packets/  then ρ =  \n  and the mean delay experienced by each packet will be   μ instead of  μ\n This time accounts for both the queueing time and the service time  as can be seen when the load is very low (λ/μ∼∼  )\n If there are  say routers along the flow’s route  queueing delay alone will account for μ of delay\n One method of relating flow specifications to router resources that correspond to bandwidth and delay performance guarantees is given by Parekh and Gallagher (  )\n It is based on traffic sources shaped by (R  B) token buckets and WFQ at routers\n Each flow is given a WFQ weight W large enough to drain its token bucket rate R as shown in Fig\n  -  \n For example  if the flow has a rate of  Mbps and the router and output link have a capacity of  Gbps  the weight for the flow must be greater than  /   th of the total of the weights for all of the flows at that router for the output link\n This guarantees the flow a minimum bandwidth\n If it cannot be given a large enough rate  the flow cannot be admitted\n Weighted fair queue (R  B) Traffic source Router Capacity C W wi wi R < W x C weights Figure  -  \n Bandwidth and delay guarantees with token buckets and WFQ\n The largest queueing delay the flow will see is a function of the burst size of the token bucket\n Consider the two extreme cases\n If the traffic is smooth  without THE NETWORK LAYER  \n  any bursts  packets will be drained from the router just as quickly as they arrive\n There will be no queueing delay (ignoring packetization effects)\n On the other hand  if the traffic is saved up in bursts  then a maximum-size burst  B  may arrive at the router all at once\n In this case the maximum queueing delay  D  will be the time taken to drain this burst at the guaranteed bandwidth  or B/R (again  ignoring packetization effects)\n If this delay is too large  the flow must request more bandwidth from the network\n These guarantees are hard\n The token buckets bound the burstiness of the source  and fair queueing isolates the bandwidth given to different flows\n This means that the flow will meet its bandwidth and delay guarantees regardless of how the other competing flows behave at the router\n Those other flows cannot break the guarantee even by saving up traffic and all sending at once\n Moreover  the result holds for a path through multiple routers in any network topology\n Each flow gets a minimum bandwidth because that bandwidth is guaranteed at each router\n The reason each flow gets a maximum delay is more subtle\n In the worst case that a burst of traffic hits the first router and competes with the traffic of other flows  it will be delayed up to the maximum delay of D\n However  this delay will also smooth the burst\n In turn  this means that the burst will incur no further queueing delays at later routers\n The overall queueing delay will be at most D\n    Integrated Services Between  and  IETF put a lot of effort into devising an architecture for streaming multimedia\n This work resulted in over two dozen RFCs  starting with RFCs –   \n The generic name for this work is integrated services\n It was aimed at both unicast and multicast applications\n An example of the former is a single user streaming a video clip from a news site\n An example of the latter is a collection of digital television stations broadcasting their programs as streams of IP packets to many receivers at various locations\n Below we will concentrate on multicast  since unicast is a special case of multicast\n In many multicast applications  groups can change membership dynamically  for example  as people enter a video conference and then get bored and switch to a soap opera or the croquet channel\n Under these conditions  the approach of having the senders reserve bandwidth in advance does not work well  since it would require each sender to track all entries and exits of its audience\n For a system designed to transmit television with millions of subscribers  it would not work at all\n RSVP—The Resource reSerVation Protocol The main part of the integrated services architecture that is visible to the users of the network is RSVP\n It is described in RFCs –   \n This protocol is used for making the reservations; other protocols are used for sending the data\n   QUALITY OF SERVICE RSVP allows multiple senders to transmit to multiple groups of receivers  permits individual receivers to switch channels freely  and optimizes bandwidth use while at the same time eliminating congestion\n In its simplest form  the protocol uses multicast routing using spanning trees  as discussed earlier\n Each group is assigned a group address\n To send to a group  a sender puts the group’s address in its packets\n The standard multicast routing algorithm then builds a spanning tree covering all group members\n The routing algorithm is not part of RSVP\n The only difference from normal multicasting is a little extra information that is multicast to the group periodically to tell the routers along the tree to maintain certain data structures in their memories\n As an example  consider the network of Fig\n  -  (a)\n Hosts  and  are multicast senders  and hosts  and  are multicast receivers\n In this example  the senders and receivers are disjoint  but in general  the two sets may overlap\n The multicast trees for hosts  and  are shown in Fig\n  -  (b) and Fig\n  -  (c)  respectively\n A D G J C F I L B K H E  Receivers Senders A D G J C F I L B K H E    A D G J C F I L B K H E (a) (b) (c) Figure  -  \n (a) A network\n (b) The multicast spanning tree for host  \n (c) The multicast spanning tree for host  \n To get better reception and eliminate congestion  any of the receivers in a group can send a reservation message up the tree to the sender\n The message is propagated using the reverse path forwarding algorithm discussed earlier\n At each THE NETWORK LAYER  \n  hop  the router notes the reservation and reserves the necessary bandwidth\n We saw in the previous tion how a weighted fair queueing scheduler can be used to make this reservation\n If insufficient bandwidth is available  it reports back failure\n By the time the message gets back to the source  bandwidth has been reserved all the way from the sender to the receiver making the reservation request along the spanning tree\n An example of such a reservation is shown in Fig\n  -  (a)\n Here host  has requested a channel to host  \n Once it has been established  packets can flow from  to  without congestion\n Now consider what happens if host  next reserves a channel to the other sender  host   so the user can watch two television programs at once\n A ond path is reserved  as illustrated in Fig\n  -  (b)\n Note that two separate channels are needed from host  to router E because two independent streams are being transmitted\n A D G J C F Bandwidth reserved for source  Bandwidth reserved for source  I L B K H E  A D G J C F I L B K H E    A D G J C F I L B K H E (a) (b) (c)    Figure  -  \n (a) Host  requests a channel to host  \n (b) Host  then requests a ond channel  to host  \n (c) Host  requests a channel to host  \n Finally  in Fig\n  -  (c)  host  decides to watch the program being transmitted by host  and also makes a reservation\n First  dedicated bandwidth is reserved as far as router H\n However  this router sees that it already has a feed from host   so if the necessary bandwidth has already been reserved  it does not have to reserve any more\n Note that hosts  and  might have asked for different amounts of bandwidth ( \n  if host  is playing on a small screen and only wants the lowresolution information)  so the capacity reserved must be large enough to satisfy the greediest receiver\n When making a reservation  a receiver can (optionally) specify one or more sources that it wants to receive from\n It can also specify whether these choices   QUALITY OF SERVICE are fixed for the duration of the reservation or whether the receiver wants to keep open the option of changing sources later\n The routers use this information to optimize bandwidth planning\n In particular  two receivers are only set up to share a path if they both agree not to change sources later on\n The reason for this strategy in the fully dynamic case is that reserved bandwidth is decoupled from the choice of source\n Once a receiver has reserved bandwidth  it can switch to another source and keep that portion of the existing path that is valid for the new source\n If host  is transmitting several video streams in real time  for example a TV broadcaster with multiple channels  host  may switch between them at will without changing its reservation: the routers do not care what program the receiver is watching\n    Differentiated Services Flow-based algorithms have the potential to offer good quality of service to one or more flows because they reserve whatever resources are needed along the route\n However  they also have a downside\n They require an advance setup to establish each flow  something that does not scale well when there are thousands or millions of flows\n Also  they maintain internal per-flow state in the routers  making them vulnerable to router crashes\n Finally  the changes required to the router code are substantial and involve complex router-to-router exchanges for setting up the flows\n As a consequence  while work continues to advance integrated services  few deployments of it or anything like it exist yet\n For these reasons  IETF has also devised a simpler approach to quality of service  one that can be largely implemented locally in each router without advance setup and without having the whole path involved\n This approach is known as class-based (as opposed to flow-based) quality of service\n IETF has standardized an architecture for it  called differentiated services  which is described in RFCs    and numerous others\n We will now describe it\n Differentiated services can be offered by a set of routers forming an administrative domain ( \n  an ISP or a telco)\n The administration defines a set of service classes with corresponding forwarding rules\n If a customer subscribes to differentiated services  customer packets entering the domain are marked with the class to which they belong\n This information is carried in the Differentiated services field of IPv  and IPv  packets (described in  )\n The classes are defined as per hop behaviors because they correspond to the treatment the packet will receive at each router  not a guarantee across the network\n Better service is provided to packets with some per-hop behaviors ( \n  premium service) than to others ( \n  regular service)\n Traffic within a class may be required to conform to some specific shape  such as a leaky bucket with some specified drain rate\n An operator with a nose for business might charge extra for each premium packet transported or might allow up to N premium packets per month for a fixed additional monthly fee\n Note that this scheme requires no advance setup  no resource THE NETWORK LAYER  \n  reservation  and no time-consuming end-to-end negotiation for each flow  as with integrated services\n This makes differentiated services relatively easy to implement\n Class-based service also occurs in other industries\n For example  package delivery companies often offer overnight  two-day  and three-day service\n Airlines offer first class  business class  and cattle-class service\n Long-distance trains often have multiple service classes\n Even the Paris subway has two different service classes\n For packets  the classes may differ in terms of delay  jitter  and probability of being discarded in the event of congestion  among other possibilities (but probably not roomier Ethernet frames)\n To make the difference between flow-based quality of service and class-based quality of service clearer  consider an example: Internet telephony\n With a flowbased scheme  each telephone call gets its own resources and guarantees\n With a class-based scheme  all the telephone calls together get the resources reserved for the class telephony\n These resources cannot be taken away by packets from the Web browsing class or other classes  but no telephone call gets any private resources reserved for it alone\n Expedited Forwarding The choice of service classes is up to each operator  but since packets are often forwarded between networks run by different operators  IETF has defined some network-independent service classes\n The simplest class is expedited forwarding  so let us start with that one\n It is described in RFC \n The idea behind expedited forwarding is very simple\n Two classes of service are available: regular and expedited\n The vast majority of the traffic is expected to be regular  but a limited fraction of the packets are expedited\n The expedited packets should be able to transit the network as though no other packets were present\n In this way they will get low loss  low delay and low jitter service—just what is needed for VoIP\n A symbolic representation of this ‘‘two-tube’’ system is given in Fig\n  -  \n Note that there is still just one physical line\n The two logical pipes shown in the figure represent a way to reserve bandwidth for different classes of service  not a ond physical line\n One way to implement this strategy is as follows\n Packets are classified as expedited or regular and marked accordingly\n This step might be done on the sending host or in the ingress (first) router\n The advantage of doing classification on the sending host is that more information is available about which packets belong to which flows\n This task may be performed by networking software or even the operating system  to avoid having to change existing applications\n For example  it is becoming common for VoIP packets to be marked for expedited service by hosts\n If the packets pass through a corporate network or ISP that supports expedited service  they will receive preferential treatment\n If the network does not support expedited service  no harm is done\n   QUALITY OF SERVICE Regular packets Expedited packets Figure  -  \n Expedited packets experience a traffic-free network\n Of course  if the marking is done by the host  the ingress router is likely to police the traffic to make sure that customers are not sending more expedited traffic than they have paid for\n Within the network  the routers may have two output queues for each outgoing line  one for expedited packets and one for regular packets\n When a packet arrives  it is queued accordingly\n The expedited queue is given priority over the regular one  for example  by using a priority scheduler\n In this way  expedited packets see an unloaded network  even when there is  in fact  a heavy load of regular traffic\n Assured Forwarding A somewhat more elaborate scheme for managing the service classes is called assured forwarding\n It is described in RFC \n Assured forwarding specifies that there shall be four priority classes  each class having its own resources\n The top three classes might be called gold  silver  and bronze\n In addition  it defines three discard classes for packets that are experiencing congestion: low  medium  and high\n Taken together  these two factors define   service classes\n Figure  -  shows one way packets might be processed under assured forwarding\n The first step is to classify the packets into one of the four priority classes\n As before  this step might be done on the sending host (as shown in the figure) or in the ingress router  and the rate of higher-priority packets may be limited by the operator as part of the service offering\n The next step is to determine the discard class for each packet\n This is done by passing the packets of each priority class through a traffic policer such as a token bucket\n The policer lets all of the traffic through  but it identifies packets that fit within small bursts as low discard  packets that exceed small bursts as medium discard  and packets that exceed large bursts as high discard\n The combination of priority and discard class is then encoded in each packet\n Finally  the packets are processed by routers in the network with a packet scheduler that distinguishes the different classes\n A common choice is to use THE NETWORK LAYER  \n  Weighted fair queues Router Silver Gold Bronze Packet source Four priority classes Classifier Policer Twelve priority/drop classes Packets with DiffServ mark Figure  -  \n A possible implementation of assured forwarding\n weighted fair queueing for the four priority classes  with higher classes given higher weights\n In this way  the higher classes will get most of the bandwidth  but the lower classes will not be starved of bandwidth entirely\n For example  if the weights double from one class to the next higher class  the higher class will get twice the bandwidth\n Within a priority class  packets with a higher discard class can be preferentially dropped by running an algorithm such as RED (Random Early Detection)  which we saw in \n   \n RED will start to drop packets as congestion builds but before the router has run out of buffer space\n At this stage  there is still buffer space with which to accept low discard packets while dropping high discard packets  INTERNETWORKING Until now  we have implicitly assumed that there is a single homogeneous network  with each machine using the same protocol in each layer\n Unfortunately  this assumption is wildly optimistic\n Many different networks exist  including PANs  LANs  MANs  and WANs\n We have described Ethernet  Internet over cable  the fixed and mobile telephone networks    and more\n Numerous protocols are in widespread use across these networks in every layer\n In the following tions  we will take a careful look at the issues that arise when two or more networks are connected to form an internetwork  or more simply an internet\n It would be much simpler to join networks together if everyone used a single networking technology  and it is often the case that there is a dominant kind of network  such as Ethernet\n Some pundits speculate that the multiplicity of technologies will go away as soon as everyone realizes how wonderful [fill in your favorite network] is\n Do not count on it\n History shows this to be wishful thinking\n Different kinds of networks grapple with different problems  so  for example  Ethernet and satellite networks are always likely to differ\n Reusing existing systems  such as running data networks on top of cable  the telephone network  and power   INTERNETWORKING lines  adds constraints that cause the features of the networks to diverge\n Heterogeneity is here to stay\n If there will always be different networks  it would be simpler if we did not need to interconnect them\n This also is unlikely\n Bob Metcalfe postulated that the value of a network with N nodes is the number of connections that may be made between the nodes  or N  (Gilder  )\n This means that large networks are much more valuable than small networks because they allow many more connections  so there always will be an incentive to combine smaller networks\n The Internet is the prime example of this interconnection\n (We will write Internet with a capital ‘‘I’’ to distinguish it from other internets  or connected networks\n) The purpose of joining all these networks is to allow users on any of them to communicate with users on all the other ones\n When you pay an ISP for Internet service  you may be charged depending on the bandwidth of your line  but what you are really paying for is the ability to exchange packets with any other host that is also connected to the Internet\n After all  the Internet would not be very popular if you could only send packets to other hosts in the same city\n Since networks often differ in important ways  getting packets from one network to another is not always so easy\n We must address problems of heterogeneity  and also problems of scale as the resulting internet grows very large\n We will begin by looking at how networks can differ to see what we are up against\n Then we shall see the approach used so successfully by IP (Internet Protocol)  the network layer protocol of the Internet  including techniques for tunneling through networks  routing in internetworks  and packet fragmentation\n    How Networks Differ Networks can differ in many ways\n Some of the differences  such as different modulation techniques or frame formats  are internal to the physical and data link layers\n These differences will not concern us here\n Instead  in Fig\n  -  we list some of the differences that can be exposed to the network layer\n It is papering over these differences that makes internetworking more difficult than operating within a single network\n When packets sent by a source on one network must transit one or more foreign networks before reaching the destination network  many problems can occur at the interfaces between networks\n To start with  the source needs to be able to address the destination\n What do we do if the source is on an Ethernet network and the destination is on a WiMAX network? Assuming we can even specify a WiMAX destination from an Ethernet network  packets would cross from a connectionless network to a connection-oriented one\n This may require that a new connection be set up on short notice  which injects a delay  and much overhead if the connection is not used for many more packets\n Many specific differences may have to be accommodated as well\n How do we multicast a packet to a group with some members on a network that does not THE NETWORK LAYER  \n  Item Some Possibilities Service offered Connectionless versus connection oriented Addressing Different sizes  flat or hierarchical Broadcasting Present or absent (also multicast) Packet size Every network has its own maximum Ordering Ordered and unordered delivery Quality of service Present or absent; many different kinds Reliability Different levels of loss urity Privacy rules  encryption  etc\n Parameters Different timeouts  flow specifications  etc\n Accounting By connect time  packet  byte  or not at all Figure  -  \n Some of the many ways networks can differ\n support multicast? The differing max packet sizes used by different networks can be a major nuisance  too\n How do you pass an -byte packet through a network whose maximum size is  bytes? If packets on a connection-oriented network transit a connectionless network  they may arrive in a different order than they were sent\n That is something the sender likely did not expect  and it might come as an (unpleasant) surprise to the receiver as well\n These kinds of differences can be papered over  with some effort\n For example  a gateway joining two networks might generate separate packets for each destination in lieu of better network support for multicasting\n A large packet might be broken up  sent in pieces  and then joined back together\n Receivers might buffer packets and deliver them in order\n Networks also can differ in large respects that are more difficult to reconcile\n The clearest example is quality of service\n If one network has strong QoS and the other offers best effort service  it will be impossible to make bandwidth and delay guarantees for real-time traffic end to end\n In fact  they can likely only be made while the best-effort network is operated at a low utilization  or hardly used  which is unlikely to be the goal of most ISPs\n urity mechanisms are problematic  but at least encryption for confidentiality and data integrity can be layered on top of networks that do not already include it\n Finally  differences in accounting can lead to unwelcome bills when normal usage suddenly becomes expensive  as roaming mobile phone users with data plans have discovered\n    How Networks Can Be Connected There are two basic choices for connecting different networks: we can build devices that translate or convert packets from each kind of network into packets for each other network  or  like good computer scientists  we can try to solve the   INTERNETWORKING problem by adding a layer of indirection and building a common layer on top of the different networks\n In either case  the devices are placed at the boundaries between networks\n Early on  Cerf and Kahn (   ) argued for a common layer to hide the differences of existing networks\n This approach has been tremendously successful  and the layer they proposed was eventually separated into the TCP and IP protocols\n Almost four decades later  IP is the foundation of the modern Internet\n For this accomplishment  Cerf and Kahn were awarded the  Turing Award  informally known as the Nobel Prize of computer science\n IP provides a universal packet format that all routers recognize and that can be passed through almost every network\n IP has extended its reach from computer networks to take over the telephone network\n It also runs on sensor networks and other tiny devices that were once presumed too resource-constrained to support it\n We have discussed several different devices that connect networks  including repeaters  hubs  switches  bridges  routers  and gateways\n Repeaters and hubs just move bits from one wire to another\n They are mostly analog devices and do not understand anything about higher layer protocols\n Bridges and switches operate at the link layer\n They can be used to build networks  but only with minor protocol translation in the process  for example  between    and  Mbps Ethernet switches\n Our focus in this tion is interconnection devices that operate at the network layer  namely the routers\n We will leave gateways  which are higherlayer interconnection devices  until later\n Let us first explore at a high level how interconnection with a common network layer can be used to interconnect dissimilar networks\n An internet comprised of   \n   MPLS  and Ethernet networks is shown in Fig\n  -  (a)\n Suppose that the source machine on the   \n  network wants to send a packet to the destination machine on the Ethernet network\n Since these technologies are different  and they are further separated by another kind of network (MPLS)  some added processing is needed at the boundaries between the networks\n Because different networks may  in general  have different forms of addressing  the packet carries a network layer address that can identify any host across the three networks\n The first boundary the packet reaches is when it transitions from an   \n  network to an MPLS network\n   \n  provides a connectionless service  but MPLS provides a connection-oriented service\n This means that a virtual circuit must be set up to cross that network\n Once the packet has traveled along the virtual circuit  it will reach the Ethernet network\n At this boundary  the packet may be too large to be carried  since   \n  can work with larger frames than Ethernet\n To handle this problem  the packet is divided into fragments  and each fragment is sent separately\n When the fragments reach the destination  they are reassembled\n Then the packet has completed its journey\n The protocol processing for this journey is shown in Fig\n  -  (b)\n The source accepts data from the transport layer and generates a packet with the common network layer header  which is IP in this example\n The network header contains the THE NETWORK LAYER    MPLS Ethernet Source Destination Packet Virtual circuit   \n  IP IP Router Router   \n  IP IP MPLSIP Eth IP MPLS IP IP IP Eth IP Physical (a) (b) Data from transport layer Figure  -  \n (a) A packet crossing different networks\n (b) Network and link layer protocol processing\n ultimate destination address  which is used to determine that the packet should be sent via the first router\n So the packet is encapsulated in an   \n  frame whose destination is the first router and transmitted\n At the router  the packet is removed from the frame’s data field and the   \n  frame header is discarded\n The router now examines the IP address in the packet and looks up this address in its routing table\n Based on this address  it decides to send the packet to the ond router next\n For this part of the path  an MPLS virtual circuit must be established to the ond router and the packet must be encapsulated with MPLS headers that travel this circuit\n At the far end  the MPLS header is discarded and the network address is again consulted to find the next network layer hop\n It is the destination itself\n Since the packet is too long to be sent over Ethernet  it is split into two portions\n Each of these portions is put into the data field of an Ethernet frame and sent to the Ethernet address of the destination\n At the destination  the Ethernet header is stripped from each of the frames  and the contents are reassembled\n The packet has finally reached its destination\n Observe that there is an essential difference between the routed case and the switched (or bridged) case\n With a router  the packet is extracted from the frame and the network address in the packet is used for deciding where to send it\n With a switch (or bridge)  the entire frame is transported on the basis of its MAC address\n Switches do not have to understand the network layer protocol being used to switch packets\n Routers do\n Unfortunately  internetworking is not as easy as we have made it sound\n In fact  when bridges were introduced  it was intended that they would join different types of networks  or at least different types of LANs\n They were to do this by translating frames from one LAN into frames from another LAN\n However  this   INTERNETWORKING did not work well  for the same reason that internetworking is difficult: the differences in the features of LANs  such as different maximum packet sizes and LANs with and without priority classes  are hard to mask\n Today  bridges are predominantly used to connect the same kind of network at the link layer  and routers connect different networks at the network layer\n Internetworking has been very successful at building large networks  but it only works when there is a common network layer\n There have  in fact  been many network protocols over time\n Getting everybody to agree on a single format is difficult when companies perceive it to their commercial advantage to have a proprietary format that they control\n Examples besides IP  which is now the near-universal network protocol  were IPX  SNA  and AppleTalk\n None of these protocols are still in widespread use  but there will always be other protocols\n The most relevant example now is probably IPv  and IPv \n While these are both versions of IP  they are not compatible (or it would not have been necessary to create IPv )\n A router that can handle multiple network protocols is called a multiprotocol router\n It must either translate the protocols  or leave connection for a higher protocol layer\n Neither approach is entirely satisfactory\n Connection at a higher layer  say  by using TCP  requires that all the networks implement TCP (which may not be the case)\n Then  it limits usage across the networks to applications that use TCP (which does not include many real-time applications)\n The alternative is to translate packets between the networks\n However  unless the packet formats are close relatives with the same information fields  such conversions will always be incomplete and often doomed to failure\n For example  IPv  addresses are bits long\n They will not fit in a  -bit IPv  address field  no matter how hard the router tries\n Getting IPv  and IPv  to run in the same network has proven to be a major obstacle to the deployment of IPv \n (To be fair  so has getting customers to understand why they should want IPv  in the first place\n) Greater problems can be expected when translating between fundamentally different protocols  such as connectionless and connection-oriented network protocols\n Given these difficulties  conversion is only rarely attempted\n Arguably  even IP has only worked so well by serving as a kind of lowest common denominator\n It requires little of the networks on which it runs  but offers only best-effort service as a result\n    Tunneling Handling the general case of making two different networks interwork is exceedingly difficult\n However  there is a common special case that is manageable even for different network protocols\n This case is where the source and destination hosts are on the same type of network  but there is a different network in between\n As an example  think of an international bank with an IPv  network THE NETWORK LAYER  \n  in Paris  an IPv  network in London and connectivity between the offices via the IPv  Internet\n This situation is shown in Fig\n  -  \n IPv  IPv  IPv  Paris London Tunnel Router Router IPv  packet IPv  IPv  packet IPv  packet Figure  -  \n Tunneling a packet from Paris to London\n The solution to this problem is a technique called tunneling\n To send an IP packet to a host in the London office  a host in the Paris office constructs the packet containing an IPv  address in London  and sends it to the multiprotocol router that connects the Paris IPv  network to the IPv  Internet\n When this router gets the IPv  packet  it encapsulates the packet with an IPv  header addressed to the IPv  side of the multiprotocol router that connects to the London IPv  network\n That is  the router puts a (IPv ) packet inside a (IPv ) packet\n When this wrapped packet arrives  the London router removes the original IPv  packet and sends it onward to the destination host\n The path through the IPv  Internet can be seen as a big tunnel extending from one multiprotocol router to the other\n The IPv  packet just travels from one end of the tunnel to the other  snug in its nice box\n It does not have to worry about dealing with IPv  at all\n Neither do the hosts in Paris or London\n Only the multiprotocol routers have to understand both IPv  and IPv  packets\n In effect  the entire trip from one multiprotocol router to the other is like a hop over a single link\n An analogy may make tunneling clearer\n Consider a person driving her car from Paris to London\n Within France  the car moves under its own power  but when it hits the English Channel  it is loaded onto a high-speed train and transported to England through the Chunnel (cars are not permitted to drive through the Chunnel)\n Effectively  the car is being carried as freight  as depicted in Fig\n  -  \n At the far end  the car is let loose on the English roads and once again continues to move under its own power\n Tunneling of packets through a foreign network works the same way\n Tunneling is widely used to connect isolated hosts and networks using other networks\n The network that results is called an overlay since it has effectively been overlaid on the base network\n Deployment of a network protocol with a new feature is a common reason  as our ‘‘IPv  over IPv ’’ example shows\n The disadvantage of tunneling is that none of the hosts on the network that is tunneled over can be reached because the packets cannot escape in the middle of the tunnel\n   INTERNETWORKING Car English Channel Paris London Railroad track Railroad carriage Figure  -  \n Tunneling a car from France to England\n However  this limitation of tunnels is turned into an advantage with VPNs (Virtual Private Networks)\n A VPN is simply an overlay that is used to provide a measure of urity\n We will explore VPNs when we get to      Internetwork Routing Routing through an internet poses the same basic problem as routing within a single network  but with some added complications\n To start  the networks may internally use different routing algorithms\n For example  one network may use link state routing and another distance vector routing\n Since link state algorithms need to know the topology but distance vector algorithms do not  this difference alone would make it unclear how to find the shortest paths across the internet\n Networks run by different operators lead to bigger problems\n First  the operators may have different ideas about what is a good path through the network\n One operator may want the route with the least delay  while another may want the most inexpensive route\n This will lead the operators to use different quantities to set the shortest-path costs ( \n  millionds of delay vs\n monetary cost)\n The weights will not be comparable across networks  so shortest paths on the internet will not be well defined\n Worse yet  one operator may not want another operator to even know the details of the paths in its network  perhaps because the weights and paths may reflect sensitive information (such as the monetary cost) that represents a competitive business advantage\n Finally  the internet may be much larger than any of the networks that comprise it\n It may therefore require routing algorithms that scale well by using a hierarchy  even if none of the individual networks need to use a hierarchy\n All of these considerations lead to a two-level routing algorithm\n Within each network  an intradomain or interior gateway protocol is used for routing\n (‘‘Gateway’’ is an older term for ‘‘router\n’’) It might be a link state protocol of the kind we have already described\n Across the networks that make up the internet  an interdomain or exterior gateway protocol is used\n The networks may all use different intradomain protocols  but they must use the same interdomain protocol\n THE NETWORK LAYER  \n  In the Internet  the interdomain routing protocol is called BGP (Border Gateway Protocol)\n We will describe it in the next tion\n There is one more important term to introduce\n Since each network is operated independently of all the others  it is often referred to as an AS (Autonomous System)\n A good mental model for an AS is an ISP network\n In fact  an ISP network may be comprised of more than one AS  if it is managed  or  has been acquired  as multiple networks\n But the difference is usually not significant\n The two levels are usually not strictly hierarchical  as highly suboptimal paths might result if a large international network and a small regional network were both abstracted to be a single network\n However  relatively little information about routes within the networks is exposed to find routes across the internetwork\n This helps to address all of the complications\n It improves scaling and lets operators freely select routes within their own networks using a protocol of their choosing\n It also does not require weights to be compared across networks or expose sensitive information outside of networks\n However  we have said little so far about how the routes across the networks of the internet are determined\n In the Internet  a large determining factor is the business arrangements between ISPs\n Each ISP may charge or receive money from the other ISPs for carrying traffic\n Another factor is that if internetwork routing requires crossing international boundaries  various laws may suddenly come into play  such as Sweden’s strict privacy laws about exporting personal data about Swedish citizens from Sweden\n All of these nontechnical factors are wrapped up in the concept of a routing policy that governs the way autonomous networks select the routes that they use\n We will return to routing policies when we describe BGP\n    Packet Fragmentation Each network or link imposes some maximum size on its packets\n These limits have various causes  among them  \n Hardware ( \n  the size of an Ethernet frame) Operating system ( \n  all buffers are bytes) Protocols ( \n  the number of bits in the packet length field) Compliance with some (inter)national standard Desire to reduce error-induced retransmissions to some level Desire to prevent one packet from occupying the channel too long\n The result of all these factors is that the network designers are not free to choose any old maximum packet size they wish\n Maximum payloads for some common   INTERNETWORKING technologies are  bytes for Ethernet and  bytes for    IP is more generous  allows for packets as big as   bytes\n Hosts usually prefer to transmit large packets because this reduces packet overheads such as bandwidth wasted on header bytes\n An obvious internetworking problem appears when a large packet wants to travel through a network whose maximum packet size is too small\n This nuisance has been a persistent issue  and solutions to it have evolved along with much experience gained on the Internet\n One solution is to make sure the problem does not occur in the first place\n However  this is easier said than done\n A source does not usually know the path a packet will take through the network to a destination  so it certainly does not know how small packets must be to get there\n This packet size is called the Path MTU (Path Maximum Transmission Unit)\n Even if the source did know the path MTU  packets are routed independently in a connectionless network such as the Internet\n This routing means that paths may suddenly change  which can unexpectedly change the path MTU\n The alternative solution to the problem is to allow routers to break up packets into fragments  sending each fragment as a separate network layer packet\n However  as every parent of a small child knows  converting a large object into small fragments is considerably easier than the reverse process\n (Physicists have even given this effect a name: the ond law of thermodynamics\n) Packet-switching networks  too  have trouble putting the fragments back together again\n Two opposing strategies exist for recombining the fragments back into the original packet\n The first strategy is to make fragmentation caused by a ‘‘smallpacket’’ network transparent to any subsequent networks through which the packet must pass on its way to the ultimate destination\n This option is shown in Fig\n  -  (a)\n In this approach  when an oversized packet arrives at G  the router breaks it up into fragments\n Each fragment is addressed to the same exit router  G  where the pieces are recombined\n In this way  passage through the small-packet network is made transparent\n Subsequent networks are not even aware that fragmentation has occurred\n Transparent fragmentation is straightforward but has some problems\n For one thing  the exit router must know when it has received all the pieces  so either a count field or an ‘‘end of packet’’ bit must be provided\n Also  because all packets must exit via the same router so that they can be reassembled  the routes are constrained\n By not allowing some fragments to follow one route to the ultimate destination and other fragments a disjoint route  some performance may be lost\n More significant is the amount of work that the router may have to do\n It may need to buffer the fragments as they arrive  and decide when to throw them away if not all of the fragments arrive\n Some of this work may be wasteful  too  as the packet may pass through a series of small packet networks and need to be repeatedly fragmented and reassembled\n The other fragmentation strategy is to refrain from recombining fragments at any intermediate routers\n Once a packet has been fragmented  each fragment is THE NETWORK LAYER  \n  G  G  G  G  G  G  G  G  Packet Network  G  fragments a large packet G  reassembles the fragments G  fragments again G  reassembles again Network  (a) Packet G  fragments a large packet The fragments are not reassembled until the final destination (a host) is reached (b) Figure  -  \n (a) Transparent fragmentation\n (b) Nontransparent fragmentation\n treated as though it were an original packet\n The routers pass the fragments  as shown in Fig\n  -  (b)  and reassembly is performed only at the destination host\n The main advantage of nontransparent fragmentation is that it requires routers to do less work\n IP works this way\n A complete design requires that the fragments be numbered in such a way that the original data stream can be reconstructed\n The design used by IP is to give every fragment a packet number (carried on all packets)  an absolute byte offset within the packet  and a flag indicating whether it is the end of the packet\n An example is shown in Fig\n  -  \n While simple  this design has some attractive properties\n Fragments can be placed in a buffer at the destination in the right place for reassembly  even if they arrive out of order\n Fragments can also be fragmented if they pass over a network with a yet smaller MTU\n This is shown in Fig\n  -  (c)\n Retransmissions of the packet (if all fragments were not received) can be fragmented into different pieces\n Finally  fragments can be of arbitrary size  down to a single byte plus the packet header\n In all cases  the destination simply uses the packet number and fragment offset to place the data in the right position  and the end-of-packet flag to determine when it has the complete packet\n Unfortunately  this design still has problems\n The overhead can be higher than with transparent fragmentation because fragment headers are now carried over some links where they may not be needed\n But the real problem is the existence of fragments in the first place\n Kent and Mogul (   ) argued that fragmentation is detrimental to performance because  as well as the header overheads  a whole packet is lost if any of its fragments are lost  and because fragmentation is more of a burden for hosts than was originally realized\n   INTERNETWORKING Number of the first elementary fragment in this packet Packet number End of packet bit   A B C D E F G H I J   A B C D E F G H   I J   A B C D E   F G H   I J Header  byte Header Header Header Header Header (a) (b) (c) Figure  -  \n Fragmentation when the elementary data size is  byte\n (a) Original packet  containing   data bytes\n (b) Fragments after passing through a network with maximum packet size of  payload bytes plus header\n (c) Fragments after passing through a size  gateway\n This leads us back to the original solution of getting rid of fragmentation in the network  the strategy used in the modern Internet\n The process is called path MTU discovery (Mogul and Deering  )\n It works as follows\n Each IP packet is sent with its header bits set to indicate that no fragmentation is allowed to be performed\n If a router receives a packet that is too large  it generates an error packet  returns it to the source  and drops the packet\n This is shown in Fig\n  -  \n When the source receives the error packet  it uses the information inside to refragment the packet into pieces that are small enough for the router to handle\n If a router further down the path has an even smaller MTU  the process is repeated\n Source Destination Packet (with length) “Try ” “Try   ”  Figure  -  \n Path MTU discovery\n THE NETWORK LAYER  \n  The advantage of path MTU discovery is that the source now knows what length packet to send\n If the routes and path MTU change  new error packets will be triggered and the source will adapt to the new path\n However  fragmentation is still needed between the source and the destination unless the higher layers learn the path MTU and pass the right amount of data to IP\n TCP and IP are typically implemented together (as ‘‘TCP/IP’’) to be able to pass this sort of information\n Even if this is not done for other protocols  fragmentation has still been moved out of the network and into the hosts\n The disadvantage of path MTU discovery is that there may be added startup delays simply to send a packet\n More than one round-trip delay may be needed to probe the path and find the MTU before any data is delivered to the destination\n This begs the question of whether there are better designs\n The answer is probably ‘‘Yes\n’’ Consider the design in which each router simply truncates packets that exceed its MTU\n This would ensure that the destination learns the MTU as rapidly as possible (from the amount of data that was delivered) and receives some of the data  THE NETWORK LAYER IN THE INTERNET It is now time to discuss the network layer of the Internet in detail\n But before getting into specifics  it is worth taking a look at the principles that drove its design in the past and made it the success that it is today\n All too often  nowadays  people seem to have forgotten them\n These principles are enumerated and discussed in RFC  which is well worth reading (and should be mandatory for all protocol designers—with a final exam at the end)\n This RFC draws heavily on ideas put forth by Clark (   ) and Saltzer et al\n (   )\n We will now summarize what we consider to be the top   principles (from most important to least important) Make sure it works\n Do not finalize the design or standard until multiple prototypes have successfully communicated with each other\n All too often  designers first write a -page standard  get it approved  then discover it is deeply flawed and does not work\n Then they write version  \n  of the standard\n This is not the way to go Keep it simple\n When in doubt  use the simplest solution\n William of Occam stated this principle (Occam’s razor) in the  th century\n Put in modern terms: fight features\n If a feature is not absolutely essential  leave it out  especially if the same effect can be achieved by combining other features Make clear choices\n If there are several ways of doing the same thing  choose one\n Having two or more ways to do the same thing is looking for trouble\n Standards often have multiple options or modes   THE NETWORK LAYER IN THE INTERNET or parameters because several powerful parties insist that their way is best\n Designers should strongly resist this tendency\n Just say no Exploit modularity\n This principle leads directly to the idea of having protocol stacks  each of whose layers is independent of all the other ones\n In this way  if circumstances require one module or layer to be changed  the other ones will not be affected Expect heterogeneity\n Different types of hardware  transmission facilities  and applications will occur on any large network\n To handle them  the network design must be simple  general  and flexible Avoid static options and parameters\n If parameters are unavoidable ( \n  maximum packet size)  it is best to have the sender and receiver negotiate a value rather than defining fixed choices Look for a good design; it need not be perfect\n Often  the designers have a good design but it cannot handle some weird special case\n Rather than messing up the design  the designers should go with the good design and put the burden of working around it on the people with the strange requirements Be strict when sending and tolerant when receiving\n In other words  send only packets that rigorously comply with the standards  but expect incoming packets that may not be fully conformant and try to deal with them Think about scalability\n If the system is to handle millions of hosts and billions of users effectively  no centralized databases of any kind are tolerable and load must be spread as evenly as possible over the available resources Consider performance and cost\n If a network has poor performance or outrageous costs  nobody will use it\n Let us now leave the general principles and start looking at the details of the Internet’s network layer\n In the network layer  the Internet can be viewed as a collection of networks or ASes (Autonomous Systems) that are interconnected\n There is no real structure  but several major backbones exist\n These are constructed from high-bandwidth lines and fast routers\n The biggest of these backbones  to which everyone else connects to reach the rest of the Internet  are called Tier  networks\n Attached to the backbones are ISPs (Internet Service Providers) that provide Internet access to homes and businesses  data centers and colocation facilities full of server machines  and regional (mid-level) networks\n The data centers serve much of the content that is sent over the Internet\n Attached THE NETWORK LAYER  \n  to the regional networks are more ISPs  LANs at many universities and companies  and other edge networks\n A sketch of this quasihierarchical organization is given in Fig\n  -  \n Leased lines to Asia A  \n backbone Leased transatlantic lines A European backbone National network Company network Ethernet IP router Mobile network WiMAX Cable Home network Regional network Figure  -  \n The Internet is an interconnected collection of many networks\n The glue that holds the whole Internet together is the network layer protocol  IP (Internet Protocol)\n Unlike most older network layer protocols  IP was designed from the beginning with internetworking in mind\n A good way to think of the network layer is this: its job is to provide a best-effort ( \n  not guaranteed) way to transport packets from source to destination  without regard to whether these machines are on the same network or whether there are other networks in between them\n Communication in the Internet works as follows\n The transport layer takes data streams and breaks them up so that they may be sent as IP packets\n In theory  packets can be up to   KB each  but in practice they are usually not more than  bytes (so they fit in one Ethernet frame)\n IP routers forward each packet through the Internet  along a path from one router to the next  until the destination is reached\n At the destination  the network layer hands the data to the transport layer  which gives it to the receiving process\n When all the pieces finally get to the destination machine  they are reassembled by the network layer into the original datagram\n This datagram is then handed to the transport layer\n In the example of Fig\n  -   a packet originating at a host on the home network has to traverse four networks and a large number of IP routers before even getting to the company network on which the destination host is located\n This is   THE NETWORK LAYER IN THE INTERNET not unusual in practice  and there are many longer paths\n There is also much redundant connectivity in the Internet  with backbones and ISPs connecting to each other in multiple locations\n This means that there are many possible paths between two hosts\n It is the job of the IP routing protocols to decide which paths to use\n    The IP Version  Protocol An appropriate place to start our study of the network layer in the Internet is with the format of the IP datagrams themselves\n An IPv  datagram consists of a header part and a body or payload part\n The header has a  -byte fixed part and a variable-length optional part\n The header format is shown in Fig\n  -  \n The bits are transmitted from left to right and top to bottom  with the high-order bit of the Version field going first\n (This is a ‘‘big-endian’’ network byte order\n On littleendian machines  such as Intel x  computers  a software conversion is required on both transmission and reception\n) In retrospect  little endian would have been a better choice  but at the time IP was designed  no one knew it would come to dominate computing\n Version IHL Total length Time to live Protocol Differentiated services Identification Header checksum Fragment offset Source address Destination address Options (  or more words) DF MF   Bits Figure  -  \n The IPv  (Internet Protocol) header\n The Version field keeps track of which version of the protocol the datagram belongs to\n Version  dominates the Internet today  and that is where we have started our discussion\n By including the version at the start of each datagram  it becomes possible to have a transition between versions over a long period of time\n In fact  IPv  the next version of IP  was defined more than a decade ago  yet is only just beginning to be deployed\n We will describe it later in this tion\n Its use will eventually be forced when each of China’s almost people has a desktop PC  a laptop  and an IP phone\n As an aside on numbering  IPv  was an experimental real-time stream protocol that was never widely used\n THE NETWORK LAYER  \n  Since the header length is not constant  a field in the header  IHL  is provided to tell how long the header is  in  -bit words\n The minimum value is   which applies when no options are present\n The maximum value of this  -bit field is which limits the header to   bytes  and thus the Options field to   bytes\n For some options  such as one that records the route a packet has taken bytes is far too small  making those options useless\n The Differentiated services field is one of the few fields that has changed its meaning (slightly) over the years\n Originally  it was called the Type of service field\n It was and still is intended to distinguish between different classes of service\n Various combinations of reliability and speed are possible\n For digitized voice  fast delivery beats accurate delivery\n For file transfer  error-free transmission is more important than fast transmission\n The Type of service field provided  bits to signal priority and  bits to signal whether a host cared more about delay  throughput  or reliability\n However  no one really knew what to do with these bits at routers  so they were left unused for many years\n When differentiated services were designed  IETF threw in the towel and reused this field\n Now  the top  bits are used to mark the packet with its service class; we described the expedited and assured services earlier in this  ter\n The bottom  bits are used to carry explicit congestion notification information  such as whether the packet has experienced congestion; we described explicit congestion notification as part of congestion control earlier in this  ter\n The Total length includes everything in the datagram—both header and data\n The maximum length is   bytes\n At present  this upper limit is tolerable  but with future networks  larger datagrams may be needed\n The Identification field is needed to allow the destination host to determine which packet a newly arrived fragment belongs to\n All the fragments of a packet contain the same Identification value\n Next comes an unused bit  which is surprising  as available real estate in the IP header is extremely scarce\n As an April Fool’s joke  Bellovin (   ) proposed using this bit to detect malicious traffic\n This would greatly simplify urity  as packets with the ‘‘evil’’ bit set would be known to have been sent by attackers and could just be discarded\n Unfortunately  network urity is not this simple\n Then come two  -bit fields related to fragmentation\n DF stands for Don’t Fragment\n It is an order to the routers not to fragment the packet\n Originally  it was intended to support hosts incapable of putting the pieces back together again\n Now it is used as part of the process to discover the path MTU  which is the largest packet that can travel along a path without being fragmented\n By marking the datagram with the DF bit  the sender knows it will either arrive in one piece  or an error message will be returned to the sender\n MF stands for More Fragments\n All fragments except the last one have this bit set\n It is needed to know when all fragments of a datagram have arrived\n The Fragment offset tells where in the current packet this fragment belongs\n All fragments except the last one in a datagram must be a multiple of  bytes  the   THE NETWORK LAYER IN THE INTERNET elementary fragment unit\n Since   bits are provided  there is a maximum of  fragments per datagram  supporting a maximum packet length up to the limit of the Total length field\n Working together  the Identification  MF  and Fragment offset fields are used to implement fragmentation as described in \n   \n The TtL (Time to live) field is a counter used to limit packet lifetimes\n It was originally supposed to count time in onds  allowing a maximum lifetime of \n It must be decremented on each hop and is supposed to be decremented multiple times when a packet is queued for a long time in a router\n In practice  it just counts hops\n When it hits zero  the packet is discarded and a warning packet is sent back to the source host\n This feature prevents packets from wandering around forever  something that otherwise might happen if the routing tables ever become corrupted\n When the network layer has assembled a complete packet  it needs to know what to do with it\n The Protocol field tells it which transport process to give the packet to\n TCP is one possibility  but so are UDP and some others\n The numbering of protocols is global across the entire Internet\n Protocols and other assigned numbers were formerly listed in RFC  but nowadays they are contained in an online database located at  \n Since the header carries vital information such as addresses  it rates its own checksum for protection  the Header checksum\n The algorithm is to add up all the  -bit halfwords of the header as they arrive  using one’s complement arithmetic  and then take the one’s complement of the result\n For purposes of this algorithm  the Header checksum is assumed to be zero upon arrival\n Such a checksum is useful for detecting errors while the packet travels through the network\n Note that it must be recomputed at each hop because at least one field always changes (the Time to live field)  but tricks can be used to speed up the computation\n The Source address and Destination address indicate the IP address of the source and destination network interfaces\n We will discuss Internet addresses in the next tion\n The Options field was designed to provide an escape to allow subsequent versions of the protocol to include information not present in the original design  to permit experimenters to try out new ideas  and to avoid allocating header bits to information that is rarely needed\n The options are of variable length\n Each begins with a  -byte code identifying the option\n Some options are followed by a  -byte option length field  and then one or more data bytes\n The Options field is padded out to a multiple of  bytes\n Originally  the five options listed in Fig\n  -  were defined\n The urity option tells how ret the information is\n In theory  a military router might use this field to specify not to route packets through certain countries the military considers to be ‘‘bad guys\n’’ In practice  all routers ignore it  so its only practical function is to help spies find the good stuff more easily\n The Strict source routing option gives the complete path from source to destination as a sequence of IP addresses\n The datagram is required to follow that THE NETWORK LAYER  \n  Option Description urity Specifies how ret the datagram is Strict source routing Gives the complete path to be followed Loose source routing Gives a list of routers not to be missed Record route Makes each router append its IP address Timestamp Makes each router append its address and timestamp Figure  -  \n Some of the IP options\n exact route\n It is most useful for system managers who need to send emergency packets when the routing tables have been corrupted  or for making timing measurements\n The Loose source routing option requires the packet to traverse the list of routers specified  in the order specified  but it is allowed to pass through other routers on the way\n Normally  this option will provide only a few routers  to force a particular path\n For example  to force a packet from London to Sydney to go west instead of east  this option might specify routers in New York  Los Angeles  and Honolulu\n This option is most useful when political or economic considerations dictate passing through or avoiding certain countries\n The Record route option tells each router along the path to append its IP address to the Options field\n This allows system managers to track down bugs in the routing algorithms (‘‘Why are packets from Houston to Dallas visiting Tokyo first?’’)\n When the ARPANET was first set up  no packet ever passed through more than nine routers  so   bytes of options was plenty\n As mentioned above  now it is too small\n Finally  the Timestamp option is like the Record route option  except that in addition to recording its  -bit IP address  each router also records a  -bit timestamp\n This option  too  is mostly useful for network measurement\n Today  IP options have fallen out of favor\n Many routers ignore them or do not process them efficiently  shunting them to the side as an uncommon case\n That is  they are only partly supported and they are rarely used\n    IP Addresses A defining feature of IPv  is its  -bit addresses\n Every host and router on the Internet has an IP address that can be used in the Source address and Destination address fields of IP packets\n It is important to note that an IP address does not actually refer to a host\n It really refers to a network interface  so if a host is on two networks  it must have two IP addresses\n However  in practice  most hosts are on one network and thus have one IP address\n In contrast  routers have multiple interfaces and thus multiple IP addresses\n   THE NETWORK LAYER IN THE INTERNET Prefixes IP addresses are hierarchical  unlike Ethernet addresses\n Each  -bit address is comprised of a variable-length network portion in the top bits and a host portion in the bottom bits\n The network portion has the same value for all hosts on a single network  such as an Ethernet LAN\n This means that a network corresponds to a contiguous block of IP address space\n This block is called a prefix\n IP addresses are written in dotted decimal notation\n In this format  each of the  bytes is written in decimal  from  to   \n For example  the  -bit hexadecimal address  D  is written as   \n    \n Prefixes are written by giving the lowest IP address in the block and the size of the block\n The size is determined by the number of bits in the network portion; the remaining bits in the host portion can vary\n This means that the size must be a power of two\n By convention  it is written after the prefix IP address as a slash followed by the length in bits of the network portion\n In our example  if the prefix contains   addresses and so leaves   bits for the network portion  it is written as   \n   /  \n Since the prefix length cannot be inferred from the IP address alone  routing protocols must carry the prefixes to routers\n Sometimes prefixes are simply described by their length  as in a ‘‘/  ’’ which is pronounced ‘‘slash  \n’’ The length of the prefix corresponds to a binary mask of  s in the network portion\n When written out this way  it is called a subnet mask\n It can be ANDed with the IP address to extract only the network portion\n For our example  the subnet mask is      Fig\n  -  shows a prefix and a subnet mask\n   bits Network Prefix length = L bits Host Subnet mask           – L bits Figure  -  \n An IP prefix and a subnet mask\n Hierarchical addresses have significant advantages and disadvantages\n The key advantage of prefixes is that routers can forward packets based on only the network portion of the address  as long as each of the networks has a unique address block\n The host portion does not matter to the routers because all hosts on the same network will be sent in the same direction\n It is only when the packets reach the network for which they are destined that they are forwarded to the correct host\n This makes the routing tables much smaller than they would otherwise be\n Consider that the number of hosts on the Internet is approaching one billion\n That would be a very large table for every router to keep\n However  by using a hierarchy  routers need to keep routes for only around    prefixes\n THE NETWORK LAYER  \n  While using a hierarchy lets Internet routing scale  it has two disadvantages\n First  the IP address of a host depends on where it is located in the network\n An Ethernet address can be used anywhere in the world  but every IP address belongs to a specific network  and routers will only be able to deliver packets destined to that address to the network\n Designs such as mobile IP are needed to support hosts that move between networks but want to keep the same IP addresses\n The ond disadvantage is that the hierarchy is wasteful of addresses unless it is carefully managed\n If addresses are assigned to networks in (too) large blocks  there will be (many) addresses that are allocated but not in use\n This allocation would not matter much if there were plenty of addresses to go around\n However  it was realized more than two decades ago that the tremendous growth of the Internet was rapidly depleting the free address space\n IPv  is the solution to this shortage  but until it is widely deployed there will be great pressure to allocate IP addresses so that they are used very efficiently\n Subnets Network numbers are managed by a nonprofit corporation called ICANN (Internet Corporation for Assigned Names and Numbers)  to avoid conflicts\n In turn  ICANN has delegated parts of the address space to various regional authorities  which dole out IP addresses to ISPs and other companies\n This is the process by which a company is allocated a block of IP addresses\n However  this process is only the start of the story  as IP address assignment is ongoing as companies grow\n We have said that routing by prefix requires all the hosts in a network to have the same network number\n This property can cause problems as networks grow\n For example  consider a university that started out with our example /  prefix for use by the Computer Science Dept\n for the computers on its Ethernet\n A year later  the Electrical Engineering Dept\n wants to get on the Internet\n The Art Dept\n soon follows suit\n What IP addresses should these departments use? Getting further blocks requires going outside the university and may be expensive or inconvenient\n Moreover  the /  already allocated has enough addresses for over   hosts\n It might be intended to allow for significant growth  but until that happens  it is wasteful to allocate further blocks of IP addresses to the same university\n A different organization is required\n The solution is to allow the block of addresses to be split into several parts for internal use as multiple networks  while still acting like a single network to the outside world\n This is called subnetting and the networks (such as Ethernet LANs) that result from dividing up a larger network are called subnets\n As we mentioned in  \n   you should be aware that this new usage of the term conflicts with older usage of ‘‘subnet’’ to mean the set of all routers and communication lines in a network\n Fig\n  -  shows how subnets can help with our example\n The single /  has been split into pieces\n This split does not need to be even  but each piece must be   THE NETWORK LAYER IN THE INTERNET aligned so that any bits can be used in the lower host portion\n In this case  half of the block (a /  ) is allocated to the Computer Science Dept  a quarter is allocated to the Electrical Engineering Dept\n (a /  )  and one eighth (a /  ) to the Art Dept\n The remaining eighth is unallocated\n A different way to see how the block was divided is to look at the resulting prefixes when written in binary notation: Computer Science:   |xxxxxxx xxxxxxxx Electrical Eng\n:    |xxxxxx xxxxxxxx Art:    |xxxxx xxxxxxxx Here  the vertical bar (|) shows the boundary between the subnet number and the host portion\n Art   \n   /  (to Internet)     \n /  EE CS     \n /  \n   /  Figure  -  \n Splitting an IP prefix into separate networks with subnetting\n When a packet comes into the main router  how does the router know which subnet to give it to? This is where the details of our prefixes come in\n One way would be for each router to have a table with   entries telling it which outgoing line to use for each host on campus\n But this would undermine the main scaling benefit we get from using a hierarchy\n Instead  the routers simply need to know the subnet masks for the networks on campus\n When a packet arrives  the router looks at the destination address of the packet and checks which subnet it belongs to\n The router can do this by ANDing the destination address with the mask for each subnet and checking to see if the result is the corresponding prefix\n For example  consider a packet destined for IP address   \n    \n To see if it is for the Computer Science Dept\n  we AND with     \n  to take the first   bits (which is   \n   ) and see if they match the prefix address (which is     \n )\n They do not match\n Checking the first   bits for the Electrical Engineering Dept\n  we get   \n    when ANDing with the subnet mask\n This does match the prefix address  so the packet is forwarded onto the interface which leads to the Electrical Engineering network\n THE NETWORK LAYER  \n  The subnet divisions can be changed later if necessary  by updating all subnet masks at routers inside the university\n Outside the network  the subnetting is not visible  so allocating a new subnet does not require contacting ICANN or changing any external databases\n CIDR—Classless InterDomain Routing Even if blocks of IP addresses are allocated so that the addresses are used efficiently  there is still a problem that remains: routing table explosion\n Routers in organizations at the edge of a network  such as a university  need to have an entry for each of their subnets  telling the router which line to use to get to that network\n For routes to destinations outside of the organization  they can use the simple default rule of sending the packets on the line toward the ISP that connects the organization to the rest of the Internet\n The other destination addresses must all be out there somewhere\n Routers in ISPs and backbones in the middle of the Internet have no such luxury\n They must know which way to go to get to every network and no simple default will work\n These core routers are said to be in the default-free zone of the Internet\n No one really knows how many networks are connected to the Internet any more  but it is a large number  probably at least a million\n This can make for a very large table\n It may not sound large by computer standards  but realize that routers must perform a lookup in this table to forward every packet  and routers at large ISPs may forward up to millions of packets per ond\n Specialized hardware and fast memory are needed to process packets at these rates  not a generalpurpose computer\n In addition  routing algorithms require each router to exchange information about the addresses it can reach with other routers\n The larger the tables  the more information needs to be communicated and processed\n The processing grows at least linearly with the table size\n Greater communication increases the likelihood that some parts will get lost  at least temporarily  possibly leading to routing instabilities\n The routing table problem could have been solved by going to a deeper hierarchy  like the telephone network\n For example  having each IP address contain a country  state/province  city  network  and host field might work\n Then  each router would only need to know how to get to each country  the states or provinces in its own country  the cities in its state or province  and the networks in its city\n Unfortunately  this solution would require considerably more than   bits for IP addresses and would use addresses inefficiently (and Liechtenstein would have as many bits in its addresses as the United States)\n Fortunately  there is something we can do to reduce routing table sizes\n We can apply the same insight as subnetting: routers at different locations can know about a given IP address as belonging to prefixes of different sizes\n However  instead of splitting an address block into subnets  here we combine multiple small   THE NETWORK LAYER IN THE INTERNET prefixes into a single larger prefix\n This process is called route aggregation\n The resulting larger prefix is sometimes called a supernet  to contrast with subnets as the division of blocks of addresses\n With aggregation  IP addresses are contained in prefixes of varying sizes\n The same IP address that one router treats as part of a /  (a block containing addresses) may be treated by another router as part of a larger /  (which contains addresses)\n It is up to each router to have the corresponding prefix information\n This design works with subnetting and is called CIDR (Classless Inter- Domain Routing)  which is pronounced ‘‘cider ’’ as in the drink\n The most recent version of it is specified in RFC  (Fuller and Li  )\n The name highlights the contrast with addresses that encode hierarchy with classes  which we will describe shortly\n To make CIDR easier to understand  let us consider an example in which a block of  IP addresses is available starting at   \n   \n Suppose that Cambridge University needs  addresses and is assigned the addresses   \n    through   \n   along with mask      This is a /  prefix\n Next  Oxford University asks for  addresses\n Since a block of  addresses must lie on a -byte boundary  Oxford cannot be given addresses starting at   \n   \n Instead  it gets     \n  through     \n along with subnet mask      Finally  the University of Edinburgh asks for  addresses and is assigned addresses   \n    through     \n   and mask      These assignments are summarized in Fig\n  -  \n University First address Last address How many Prefix Cambridge   \n   \n     \n   /  Edinburgh   \n     \n   \n   /  (Available)            \n /  Oxford            \n /  Figure  -  \n A set of IP address assignments\n All of the routers in the default-free zone are now told about the IP addresses in the three networks\n Routers close to the universities may need to send on a different outgoing line for each of the prefixes  so they need an entry for each of the prefixes in their routing tables\n An example is the router in London in Fig\n  -  \n Now let us look at these three universities from the point of view of a distant router in New York\n All of the IP addresses in the three prefixes should be sent from New York (or the  \n in general) to London\n The routing process in London notices this and combines the three prefixes into a single aggregate entry for the prefix   \n   /  that it passes to the New York router\n This prefix contains  K addresses and covers the three universities and the otherwise unallocated  addresses\n By using aggregation  three prefixes have been reduced to one  reducing THE NETWORK LAYER  \n  Edinburgh   \n   /  (  aggregate prefix)   \n   /  Cambridge Oxford     \n /  \n   /  New York London (  prefixes) Figure  -  \n Aggregation of IP prefixes\n the prefixes that the New York router must be told about and the routing table entries in the New York router\n When aggregation is turned on  it is an automatic process\n It depends on which prefixes are located where in the Internet not on the actions of an administrator assigning addresses to networks\n Aggregation is heavily used throughout the Internet and can reduce the size of router tables to around    prefixes\n As a further twist  prefixes are allowed to overlap\n The rule is that packets are sent in the direction of the most specific route  or the longest matching prefix that has the fewest IP addresses\n Longest matching prefix routing provides a useful degree of flexibility  as seen in the behavior of the router at New York in Fig\n  -  \n This router still uses a single aggregate prefix to send traffic for the three universities to London\n However  the previously available block of addresses within this prefix has now been allocated to a network in San Francisco\n One possibility is for the New York router to keep four prefixes  sending packets for three of them to London and packets for the fourth to San Francisco\n Instead  longest matching prefix routing can handle this forwarding with the two prefixes that are shown\n One overall prefix is used to direct traffic for the entire block to London\n One more specific prefix is also used to direct a portion of the larger prefix to San Francisco\n With the longest matching prefix rule  IP addresses within the San Francisco network will be sent on the outgoing line to San Francisco  and all other IP addresses in the larger prefix will be sent to London\n Conceptually  CIDR works as follows\n When a packet comes in  the routing table is scanned to determine if the destination lies within the prefix\n It is possible that multiple entries with different prefix lengths will match  in which case the entry with the longest prefix is used\n Thus  if there is a match for a /  mask and a /  mask  the /  entry is used to look up the outgoing line for the packet\n However  this process would be tedious if the table were really scanned entry by entry\n   THE NETWORK LAYER IN THE INTERNET   \n   /  \n   /    \n /  \n   /  New York London     \n /  San Francisco     \n /  Figure  -  \n Longest matching prefix routing at the New York router\n Instead  complex algorithms have been devised to speed up the address matching process (Ruiz-Sanchez et al\n  )\n Commercial routers use custom VLSI chips with these algorithms embedded in hardware\n Classful and Special Addressing To help you better appreciate why CIDR is so useful  we will briefly relate the design that predated it\n Before  IP addresses were divided into the five categories listed in Fig\n  -  \n This allocation has come to be called classful addressing\n   Bits Range of host addresses   \n  to     \n   \n  to     \n   \n  to     \n   \n  to     \n   \n  to     \n   Class  Network Host   Network Host Network Host  Multicast address  Reserved for future use A B C D E Figure  -  \n IP address formats\n The class A  B  and C formats allow for up to networks with   million hosts each    networks with up to   hosts each  and  million networks ( \n  LANs) with up to hosts each (although a few of these are special)\n Also supported is multicast (the class D format)  in which a datagram is directed to multiple hosts\n Addresses beginning with  are reserved for use in the future\n They would be valuable to use now given the depletion of the IPv  address space\n THE NETWORK LAYER  \n  Unfortunately  many hosts will not accept these addresses as valid because they have been off-limits for so long and it is hard to teach old hosts new tricks\n This is a hierarchical design  but unlike CIDR the sizes of the address blocks are fixed\n Over  billion addresses exist  but organizing the address space by classes wastes millions of them\n In particular  the real villain is the class B network\n For most organizations  a class A network  with   million addresses  is too big  and a class C network  with addresses is too small\n A class B network  with    is just right\n In Internet folklore  this situation is known as the three bears problem [as in Goldilocks and the Three Bears (Southey  )]\n In reality  though  a class B address is far too large for most organizations\n Studies have shown that more than half of all class B networks have fewer than   hosts\n A class C network would have done the job  but no doubt every organization that asked for a class B address thought that one day it would outgrow the  - bit host field\n In retrospect  it might have been better to have had class C networks use   bits instead of  for the host number  allowing  hosts per network\n Had this been the case  most organizations would probably have settled for a class C network  and there would have been half a million of them (versus only   class B networks)\n It is hard to fault the Internet’s designers for not having provided more (and smaller) class B addresses\n At the time the decision was made to create the three classes  the Internet was a research network connecting the major research universities in the  \n (plus a very small number of companies and military sites doing networking research)\n No one then perceived the Internet becoming a massmarket communication system rivaling the telephone network\n At the time  someone no doubt said: ‘‘The  \n has about  colleges and universities\n Even if all of them connect to the Internet and many universities in other countries join  too  we are never going to hit    since there are not that many universities in the whole world\n Furthermore  having the host number be an integral number of bytes speeds up packet processing’’ (which was then done entirely in software)\n Perhaps some day people will look back and fault the folks who designed the telephone number scheme and say: ‘‘What idiots\n Why didn’t they include the planet number in the phone number?’’ But at the time  it did not seem necessary\n To handle these problems  subnets were introduced to flexibly assign blocks of addresses within an organization\n Later  CIDR was added to reduce the size of the global routing table\n Today  the bits that indicate whether an IP address belongs to class A  B  or C network are no longer used  though references to these classes in the literature are still common\n To see how dropping the classes made forwarding more complicated  consider how simple it was in the old classful system\n When a packet arrived at a router  a copy of the IP address was shifted right   bits to yield a  -bit class number\n A  -way branch then sorted packets into A  B  C (and D and E) classes  with eight of the cases for class A  four of the cases for class B  and two of the cases for class C\n The code for each class then masked off the  -   -  or  -bit network   THE NETWORK LAYER IN THE INTERNET number and right aligned it in a  -bit word\n The network number was then looked up in the A  B  or C table  usually by indexing for A and B networks and hashing for C networks\n Once the entry was found  the outgoing line could be looked up and the packet forwarded\n This is much simpler than the longest matching prefix operation  which can no longer use a simple table lookup because an IP address may have any length prefix\n Class D addresses continue to be used in the Internet for multicast\n Actually  it might be more accurate to say that they are starting to be used for multicast  since Internet multicast has not been widely deployed in the past\n There are also several other addresses that have special meanings  as shown in Fig\n  -  \n The IP address   \n  the lowest address  is used by hosts when they are being booted\n It means ‘‘this network’’ or ‘‘this host\n’’ IP addresses with  as the network number refer to the current network\n These addresses allow machines to refer to their own network without knowing its number (but they have to know the network mask to know how many  s to include)\n The address consisting of all  s  or     \n  —the highest address—is used to mean all hosts on the indicated network\n It allows broadcasting on the local network  typically a LAN\n The addresses with a proper network number and all  s in the host field allow machines to send broadcast packets to distant LANs anywhere in the Internet\n However  many network administrators disable this feature as it is mostly a urity hazard\n Finally  all addresses of the form   zz are reserved for loopback testing\n Packets sent to that address are not put out onto the wire; they are processed locally and treated as incoming packets\n This allows packets to be sent to the host without the sender knowing its number  which is useful for testing\n This host A host on this network Broadcast on the local network  Host Network (Anything) Broadcast on a distant network Loopback                   \n     \n    Figure  -  \n Special IP addresses\n NAT—Network Address Translation IP addresses are scarce\n An ISP might have a /  address  giving it   usable host numbers\n If it has more customers than that  it has a problem\n THE NETWORK LAYER  \n  This scarcity has led to techniques to use IP addresses sparingly\n One approach is to dynamically assign an IP address to a computer when it is on and using the network  and to take the IP address back when the host becomes inactive\n The IP address can then be assigned to another computer that becomes active\n In this way  a single /  address can handle up to   active users\n This strategy works well in some cases  for example  for dialup networking and mobile and other computers that may be temporarily absent or powered off\n However  it does not work very well for business customers\n Many PCs in businesses are expected to be on continuously\n Some are employee machines  backed up at night  and some are servers that may have to serve a remote request at a moment’s notice\n These businesses have an access line that always provides connectivity to the rest of the Internet\n Increasingly  this situation also applies to home users subscribing to ADSL or Internet over cable  since there is no connection charge (just a monthly flat rate charge)\n Many of these users have two or more computers at home  often one for each family member  and they all want to be online all the time\n The solution is to connect all the computers into a home network via a LAN and put a (wireless) router on it\n The router then connects to the ISP\n From the ISP’s point of view  the family is now the same as a small business with a handful of computers\n Welcome to Jones  Inc\n With the techniques we have seen so far  each computer must have its own IP address all day long\n For an ISP with many thousands of customers  particularly business customers and families that are just like small businesses  the demand for IP addresses can quickly exceed the block that is available\n The problem of running out of IP addresses is not a theoretical one that might occur at some point in the distant future\n It is happening right here and right now\n The long-term solution is for the whole Internet to migrate to IPv  which has   -bit addresses\n This transition is slowly occurring  but it will be years before the process is complete\n To get by in the meantime  a quick fix was needed\n The quick fix that is widely used today came in the form of NAT (Network Address Translation)  which is described in RFC  and which we will summarize below\n For additional information  see Dutcher (   )\n The basic idea behind NAT is for the ISP to assign each home or business a single IP address (or at most  a small number of them) for Internet traffic\n Within the customer network  every computer gets a unique IP address  which is used for routing intramural traffic\n However  just before a packet exits the customer network and goes to the ISP  an address translation from the unique internal IP address to the shared public IP address takes place\n This translation makes use of three ranges of IP addresses that have been declared as private\n Networks may use them internally as they wish\n The only rule is that no packets containing these addresses may appear on the Internet itself\n The three reserved ranges are:   \n  –    \n  /  (  hosts)   \n    –     \n  /  (  hosts)   \n    –     \n  /  (  hosts)   THE NETWORK LAYER IN THE INTERNET The first range provides for   addresses (except for all  s and all  s  as usual) and is the usual choice  even if the network is not large\n The operation of NAT is shown in Fig\n  -  \n Within the customer premises  every machine has a unique address of the form  z\n However  before a packet leaves the customer premises  it passes through a NAT box that converts the internal IP source address    \n  in the figure  to the customer’s true IP address   \n  in this example\n The NAT box is often combined in a single device with a firewall  which provides urity by carefully controlling what goes into the customer network and what comes out of it\n We will study firewalls in   It is also possible to integrate the NAT box into a router or ADSL modem\n Packet after translation Boundary of customer premises NAT box/firewall ISP router IP =     \n  port =  IP =   \n  port =  (to Internet) Packet before translation Customer router and LAN Figure  -  \n Placement and operation of a NAT box\n So far  we have glossed over one tiny but crucial detail: when the reply comes back ( \n  from a Web server)  it is naturally addressed to     \n   so how does the NAT box know which internal address to replace it with? Herein lies the problem with NAT\n If there were a spare field in the IP header  that field could be used to keep track of who the real sender was  but only  bit is still unused\n In principle  a new option could be created to hold the true source address  but doing so would require changing the IP code on all the machines on the entire Internet to handle the new option\n This is not a promising alternative for a quick fix\n What actually happens is as follows\n The NAT designers observed that most IP packets carry either TCP or UDP payloads\n When we study TCP and UDP in  \n   we will see that both of these have headers containing a source port and a destination port\n Below we will just discuss TCP ports  but exactly the same story holds for UDP ports\n The ports are  -bit integers that indicate where the TCP connection begins and ends\n These ports provide the field needed to make NAT work\n When a process wants to establish a TCP connection with a remote process  it attaches itself to an unused TCP port on its own machine\n This is called the source port and tells the TCP code where to send incoming packets belonging to this connection\n The process also supplies a destination port to tell who to give THE NETWORK LAYER  \n  the packets to on the remote side\n Ports  – are reserved for well-known services\n For example  port   is the port used by Web servers  so remote clients can locate them\n Each outgoing TCP message contains both a source port and a destination port\n Together  these ports serve to identify the processes using the connection on both ends\n An analogy may make the use of ports clearer\n Imagine a company with a single main telephone number\n When people call the main number  they reach an operator who asks which extension they want and then puts them through to that extension\n The main number is analogous to the customer’s IP address and the extensions on both ends are analogous to the ports\n Ports are effectively an extra   bits of addressing that identify which process gets which incoming packet\n Using the Source port field  we can solve our mapping problem\n Whenever an outgoing packet enters the NAT box  the  z source address is replaced by the customer’s true IP address\n In addition  the TCP Source port field is replaced by an index into the NAT box’s  -entry translation table\n This table entry contains the original IP address and the original source port\n Finally  both the IP and TCP header checksums are recomputed and inserted into the packet\n It is necessary to replace the Source port because connections from machines   \n  and   \n  may both happen to use port  for example  so the Source port alone is not enough to identify the sending process\n When a packet arrives at the NAT box from the ISP  the Source port in the TCP header is extracted and used as an index into the NAT box’s mapping table\n From the entry located  the internal IP address and original TCP Source port are extracted and inserted into the packet\n Then  both the IP and TCP checksums are recomputed and inserted into the packet\n The packet is then passed to the customer router for normal delivery using the  z address\n Although this scheme sort of solves the problem  networking purists in the IP community have a tendency to regard it as an abomination-on-the-face-of-theearth\n Briefly summarized  here are some of the objections\n First  NAT violates the architectural model of IP  which states that every IP address uniquely identifies a single machine worldwide\n The whole software structure of the Internet is built on this fact\n With NAT  thousands of machines may (and do) use address    ond  NAT breaks the end-to-end connectivity model of the Internet  which says that any host can send a packet to any other host at any time\n Since the mapping in the NAT box is set up by outgoing packets  incoming packets cannot be accepted until after outgoing ones\n In practice  this means that a home user with NAT can make TCP/IP connections to a remote Web server  but a remote user cannot make connections to a game server on the home network\n Special configuration or NAT traversal techniques are needed to support this kind of situation\n Third  NAT changes the Internet from a connectionless network to a peculiar kind of connection-oriented network\n The problem is that the NAT box must maintain information ( \n  the mapping) for each connection passing through it\n   THE NETWORK LAYER IN THE INTERNET Having the network maintain connection state is a property of connection-oriented networks  not connectionless ones\n If the NAT box crashes and its mapping table is lost  all its TCP connections are destroyed\n In the absence of NAT  a router can crash and restart with no long-term effect on TCP connections\n The sending process just times out within a few onds and retransmits all unacknowledged packets\n With NAT  the Internet becomes as vulnerable as a circuit-switched network\n Fourth  NAT violates the most fundamental rule of protocol layering: layer k may not make any assumptions about what layer k +  has put into the payload field\n This basic principle is there to keep the layers independent\n If TCP is later upgraded to TCP-  with a different header layout ( \n   -bit ports)  NAT will fail\n The whole idea of layered protocols is to ensure that changes in one layer do not require changes in other layers\n NAT destroys this independence\n Fifth  processes on the Internet are not required to use TCP or UDP\n If a user on machine A decides to use some new transport protocol to talk to a user on machine B (for example  for a multimedia application)  introduction of a NAT box will cause the application to fail because the NAT box will not be able to locate the TCP Source port correctly\n A sixth and related problem is that some applications use multiple TCP/IP connections or UDP ports in prescribed ways\n For example  FTP  the standard File Transfer Protocol  inserts IP addresses in the body of packet for the receiver to extract and use\n Since NAT knows nothing about these arrangements  it cannot rewrite the IP addresses or otherwise account for them\n This lack of understanding means that FTP and other applications such as the H\n   Internet telephony protocol (which we will study in  \n  ) will fail in the presence of NAT unless special precautions are taken\n It is often possible to patch NAT for these cases  but having to patch the code in the NAT box every time a new application comes along is not a good idea\n Finally  since the TCP Source port field is   bits  at most   machines can be mapped onto an IP address\n Actually  the number is slightly less because the first  ports are reserved for special uses\n However  if multiple IP addresses are available  each one can handle up to   machines\n A view of these and other problems with NAT is given in RFC \n Despite the issues  NAT is widely used in practice  especially for home and small business networks  as the only expedient technique to deal with the IP address shortage\n It has become wrapped up with firewalls and privacy because it blocks unsolicited incoming packets by default\n For this reason  it is unlikely to go away even when IPv  is widely deployed\n    IP Version  IP has been in heavy use for decades\n It has worked extremely well  as demonstrated by the exponential growth of the Internet\n Unfortunately  IP has become a victim of its own popularity: it is close to running out of addresses\n Even THE NETWORK LAYER  \n  with CIDR and NAT using addresses more sparingly  the last IPv  addresses are expected to be assigned by ICANN before the end of \n This looming disaster was recognized almost two decades ago  and it sparked a great deal of discussion and controversy within the Internet community about what to do about it\n In this tion  we will describe both the problem and several proposed solutions\n The only long-term solution is to move to larger addresses\n IPv  (IP version  ) is a replacement design that does just that\n It uses   -bit addresses; a shortage of these addresses is not likely any time in the foreseeable future\n However  IPv  has proved very difficult to deploy\n It is a different network layer protocol that does not really interwork with IPv  despite many similarities\n Also  companies and users are not really sure why they should want IPv  in any case\n The result is that IPv  is deployed and used on only a tiny fraction of the Internet (estimates are  %) despite having been an Internet Standard since \n The next several years will be an interesting time  as the few remaining IPv  addresses are allocated\n Will people start to auction off their IPv  addresses on eBay? Will a black market in them spring up? Who knows\n In addition to the address problems  other issues loom in the background\n In its early years  the Internet was largely used by universities  high-tech industries  and the  \n Government (especially the Dept\n of Defense)\n With the explosion of interest in the Internet starting in the mid-   s  it began to be used by a different group of people  often with different requirements\n For one thing  numerous people with smart phones use it to keep in contact with their home bases\n For another  with the impending convergence of the computer  communication  and entertainment industries  it may not be that long before every telephone and television set in the world is an Internet node  resulting in a billion machines being used for audio and video on demand\n Under these circumstances  it became apparent that IP had to evolve and become more flexible\n Seeing these problems on the horizon  in  IETF started work on a new version of IP  one that would never run out of addresses  would solve a variety of other problems  and be more flexible and efficient as well\n Its major goals were:  \n Support billions of hosts  even with inefficient address allocation Reduce the size of the routing tables Simplify the protocol  to allow routers to process packets faster Provide better urity (authentication and privacy) Pay more attention to the type of service  particularly for real-time data Aid multicasting by allowing scopes to be specified Make it possible for a host to roam without changing its address Allow the protocol to evolve in the future Permit the old and new protocols to coexist for years\n   THE NETWORK LAYER IN THE INTERNET The design of IPv  presented a major opportunity to improve all of the features in IPv  that fall short of what is now wanted\n To develop a protocol that met all these requirements  IETF issued a call for proposals and discussion in RFC \n Twenty-one responses were initially received\n By December  seven serious proposals were on the table\n They ranged from making minor patches to IP  to throwing it out altogether and replacing it with a completely different protocol\n One proposal was to run TCP over CLNP  the network layer protocol designed for OSI\n With its   -bit addresses  CLNP would have provided enough address space forever as it could give every molecule of water in the oceans enough addresses (roughly  ) to set up a small network\n This choice would also have unified two major network layer protocols\n However  many people felt that this would have been an admission that something in the OSI world was actually done right  a statement considered Politically Incorrect in Internet circles\n CLNP was patterned closely on IP  so the two are not really that different\n In fact  the protocol ultimately chosen differs from IP far more than CLNP does\n Another strike against CLNP was its poor support for service types  something required to transmit multimedia efficiently\n Three of the better proposals were published in IEEE Network (Deering  ; Francis  ; and Katz and Ford  )\n After much discussion  revision  and jockeying for position  a modified combined version of the Deering and Francis proposals  by now called SIPP (Simple Internet Protocol Plus) was selected and given the designation IPv \n IPv  meets IETF’s goals fairly well\n It maintains the good features of IP  discards or deemphasizes the bad ones  and adds new ones where needed\n In general  IPv  is not compatible with IPv  but it is compatible with the other auxiliary Internet protocols  including TCP  UDP  ICMP  IGMP  OSPF  BGP  and DNS  with small modifications being required to deal with longer addresses\n The main features of IPv  are discussed below\n More information about it can be found in RFCs  through \n First and foremost  IPv  has longer addresses than IPv \n They are bits long  which solves the problem that IPv  set out to solve: providing an effectively unlimited supply of Internet addresses\n We will have more to say about addresses shortly\n The ond major improvement of IPv  is the simplification of the header\n It contains only seven fields (versus   in IPv )\n This change allows routers to process packets faster and thus improves throughput and delay\n We will discuss the header shortly  too\n The third major improvement is better support for options\n This change was essential with the new header because fields that previously were required are now optional (because they are not used so often)\n In addition  the way options are represented is different  making it simple for routers to skip over options not intended for them\n This feature speeds up packet processing time\n THE NETWORK LAYER  \n  A fourth area in which IPv  represents a big advance is in urity\n IETF had its fill of newspaper stories about precocious  -year-olds using their personal computers to break into banks and military bases all over the Internet\n There was a strong feeling that something had to be done to improve urity\n Authentication and privacy are key features of the new IP\n These were later retrofitted to IPv  however  so in the area of urity the differences are not so great any more\n Finally  more attention has been paid to quality of service\n Various halfhearted efforts to improve QoS have been made in the past  but now  with the growth of multimedia on the Internet  the sense of urgency is greater\n The Main IPv  Header The IPv  header is shown in Fig\n  -  \n The Version field is always  for IPv  (and  for IPv )\n During the transition period from IPv  which has already taken more than a decade  routers will be able to examine this field to tell what kind of packet they have\n As an aside  making this test wastes a few instructions in the critical path  given that the data link header usually indicates the network protocol for demultiplexing  so some routers may skip the check\n For example  the Ethernet Type field has different values to indicate an IPv  or an IPv  payload\n The discussions between the ‘‘Do it right’’ and ‘‘Make it fast’’ camps will no doubt be lengthy and vigorous\n   Bits Version Diff\n services Flow label Payload length Next header Hop limit Source address (  bytes) Destination address (  bytes) Figure  -  \n The IPv  fixed header (required)\n The Differentiated services field (originally called Traffic class) is used to distinguish the class of service for packets with different real-time delivery   THE NETWORK LAYER IN THE INTERNET requirements\n It is used with the differentiated service architecture for quality of service in the same manner as the field of the same name in the IPv  packet\n Also  the low-order  bits are used to signal explicit congestion indications  again in the same way as with IPv \n The Flow label field provides a way for a source and destination to mark groups of packets that have the same requirements and should be treated in the same way by the network  forming a pseudoconnection\n For example  a stream of packets from one process on a certain source host to a process on a specific destination host might have stringent delay requirements and thus need reserved bandwidth\n The flow can be set up in advance and given an identifier\n When a packet with a nonzero Flow label shows up  all the routers can look it up in internal tables to see what kind of special treatment it requires\n In effect  flows are an attempt to have it both ways: the flexibility of a datagram network and the guarantees of a virtual-circuit network\n Each flow for quality of service purposes is designated by the source address  destination address  and flow number\n This design means that up to flows may be active at the same time between a given pair of IP addresses\n It also means that even if two flows coming from different hosts but with the same flow label pass through the same router  the router will be able to tell them apart using the source and destination addresses\n It is expected that flow labels will be chosen randomly  rather than assigned sequentially starting at   so routers are expected to hash them\n The Payload length field tells how many bytes follow the  -byte header of Fig\n  -  \n The name was changed from the IPv  Total length field because the meaning was changed slightly: the   header bytes are no longer counted as part of the length (as they used to be)\n This change means the payload can now be   bytes instead of a mere   bytes\n The Next header field lets the cat out of the bag\n The reason the header could be simplified is that there can be additional (optional) extension headers\n This field tells which of the (currently) six extension headers  if any  follow this one\n If this header is the last IP header  the Next header field tells which transport protocol handler ( \n  TCP  UDP) to pass the packet to\n The Hop limit field is used to keep packets from living forever\n It is  in practice  the same as the Time to live field in IPv  namely  a field that is decremented on each hop\n In theory  in IPv  it was a time in onds  but no router used it that way  so the name was changed to reflect the way it is actually used\n Next come the Source address and Destination address fields\n Deering’s original proposal  SIP  used  -byte addresses  but during the review process many people felt that with  -byte addresses IPv  would run out of addresses within a few decades  whereas with  -byte addresses it would never run out\n Other people argued that   bytes was overkill  whereas still others favored using  -byte addresses to be compatible with the OSI datagram protocol\n Still another faction wanted variable-sized addresses\n After much debate and more than a few words THE NETWORK LAYER  \n  unprintable in an academic textbook  it was decided that fixed-length  -byte addresses were the best compromise\n A new notation has been devised for writing  -byte addresses\n They are written as eight groups of four hexadecimal digits with colons between the groups  like this: :   :   :   :   :   :  AB:CDEF Since many addresses will have many zeros inside them  three optimizations have been authorized\n First  leading zeros within a group can be omitted  so  can be written as   \n ond  one or more groups of   zero bits can be replaced by a pair of colons\n Thus  the above address now becomes ::  :   :  AB:CDEF Finally  IPv  addresses can be written as a pair of colons and an old dotted decimal number  for example: ::    \n  Perhaps it is unnecessary to be so explicit about it  but there are a lot of  - byte addresses\n Specifically  there are  of them  which is approximately  × \n If the entire earth  land and water  were covered with computers  IPv  would allow  ×  IP addresses per square meter\n Students of chemistry will notice that this number is larger than Avogadro’s number\n While it was not the intention to give every molecule on the surface of the earth its own IP address  we are not that far off\n In practice  the address space will not be used efficiently  just as the telephone number address space is not (the area code for Manhattan  is nearly full  but that for Wyoming  is nearly empty)\n In RFC  Durand and Huitema calculated that  using the allocation of telephone numbers as a guide  even in the most pessimistic scenario there will still be well over  IP addresses per square meter of the entire earth’s surface (land and water)\n In any likely scenario  there will be trillions of them per square meter\n In short  it seems unlikely that we will run out in the foreseeable future\n It is instructive to compare the IPv  header (Fig\n  -  ) with the IPv  header (Fig\n  -  ) to see what has been left out in IPv \n The IHL field is gone because the IPv  header has a fixed length\n The Protocol field was taken out because the Next header field tells what follows the last IP header ( \n  a UDP or TCP segment)\n All the fields relating to fragmentation were removed because IPv  takes a different approach to fragmentation\n To start with  all IPv -conformant hosts are expected to dynamically determine the packet size to use\n They do this using the path MTU discovery procedure we described in \n   \n In brief  when a host sends an IPv  packet that is too large  instead of fragmenting it  the router that is unable to forward it drops the packet and sends an error message back to the   THE NETWORK LAYER IN THE INTERNET sending host\n This message tells the host to break up all future packets to that destination\n Having the host send packets that are the right size in the first place is ultimately much more efficient than having the routers fragment them on the fly\n Also  the minimum-size packet that routers must be able to forward has been raised from to  bytes to allow  bytes of data and many headers\n Finally  the Checksum field is gone because calculating it greatly reduces performance\n With the reliable networks now used  combined with the fact that the data link layer and transport layers normally have their own checksums  the value of yet another checksum was deemed not worth the performance price it extracted\n Removing all these features has resulted in a lean and mean network layer protocol\n Thus  the goal of IPv —a fast  yet flexible  protocol with plenty of address space—is met by this design\n Extension Headers Some of the missing IPv  fields are occasionally still needed  so IPv  introduces the concept of (optional) extension headers\n These headers can be supplied to provide extra information  but encoded in an efficient way\n Six kinds of extension headers are defined at present  as listed in Fig\n  -  \n Each one is optional  but if more than one is present they must appear directly after the fixed header  and preferably in the order listed\n Extension header Description Hop-by-hop options Miscellaneous information for routers Destination options Additional information for the destination Routing Loose list of routers to visit Fragmentation Management of datagram fragments Authentication Verification of the sender’s identity Encrypted urity payload Information about the encrypted contents Figure  -  \n IPv  extension headers\n Some of the headers have a fixed format; others contain a variable number of variable-length options\n For these  each item is encoded as a (Type  Length  Value) tuple\n The Type is a  -byte field telling which option this is\n The Type values have been chosen so that the first  bits tell routers that do not know how to process the option what to do\n The choices are: skip the option; discard the packet; discard the packet and send back an ICMP packet; and discard the packet but do not send ICMP packets for multicast addresses (to prevent one bad multicast packet from generating millions of ICMP reports)\n The Length is also a  -byte field\n It tells how long the value is (  to bytes)\n The Value is any information required  up to bytes\n THE NETWORK LAYER  \n  The hop-by-hop header is used for information that all routers along the path must examine\n So far  one option has been defined: support of datagrams exceeding   KB\n The format of this header is shown in Fig\n  -  \n When it is used  the Payload length field in the fixed header is set to  \n Next header Jumbo payload length    Figure  -  \n The hop-by-hop extension header for large datagrams (jumbograms)\n As with all extension headers  this one starts with a byte telling what kind of header comes next\n This byte is followed by one telling how long the hop-by-hop header is in bytes  excluding the first  bytes  which are mandatory\n All extensions begin this way\n The next  bytes indicate that this option defines the datagram size (code   ) and that the size is a  -byte number\n The last  bytes give the size of the datagram\n Sizes less than   bytes are not permitted and will result in the first router discarding the packet and sending back an ICMP error message\n Datagrams using this header extension are called jumbograms\n The use of jumbograms is important for supercomputer applications that must transfer gigabytes of data efficiently across the Internet\n The destination options header is intended for fields that need only be interpreted at the destination host\n In the initial version of IPv  the only options defined are null options for padding this header out to a multiple of  bytes  so initially it will not be used\n It was included to make sure that new routing and host software can handle it  in case someone thinks of a destination option some day\n The routing header lists one or more routers that must be visited on the way to the destination\n It is very similar to the IPv  loose source routing in that all addresses listed must be visited in order  but other routers not listed may be visited in between\n The format of the routing header is shown in Fig\n  -  \n Next header Header extension length Routing type Segments left Type-specific data Figure  -  \n The extension header for routing\n   THE NETWORK LAYER IN THE INTERNET The first  bytes of the routing extension header contain four  -byte integers\n The Next header and Header extension length fields were described above\n The Routing type field gives the format of the rest of the header\n Type  says that a reserved  -bit word follows the first word  followed by some number of IPv  addresses\n Other types may be invented in the future  as needed\n Finally  the Segments left field keeps track of how many of the addresses in the list have not yet been visited\n It is decremented every time one is visited\n When it hits   the packet is on its own with no more guidance about what route to follow\n Usually  at this point it is so close to the destination that the best route is obvious\n The fragment header deals with fragmentation similarly to the way IPv  does\n The header holds the datagram identifier  fragment number  and a bit telling whether more fragments will follow\n In IPv  unlike in IPv  only the source host can fragment a packet\n Routers along the way may not do this\n This change is a major philosophical break with the original IP  but in keeping with current practice for IPv \n Plus  it simplifies the routers’ work and makes routing go faster\n As mentioned above  if a router is confronted with a packet that is too big  it discards the packet and sends an ICMP error packet back to the source\n This information allows the source host to fragment the packet into smaller pieces using this header and try again\n The authentication header provides a mechanism by which the receiver of a packet can be sure of who sent it\n The encrypted urity payload makes it possible to encrypt the contents of a packet so that only the intended recipient can read it\n These headers use the cryptographic techniques that we will describe in  \n  to accomplish their missions\n Controversies Given the open design process and the strongly held opinions of many of the people involved  it should come as no surprise that many choices made for IPv  were highly controversial  to say the least\n We will summarize a few of these briefly below\n For all the gory details  see the RFCs\n We have already mentioned the argument about the address length\n The result was a compromise:  -byte fixed-length addresses\n Another fight developed over the length of the Hop limit field\n One camp felt strongly that limiting the maximum number of hops to (implicit in using an  -bit field) was a gross mistake\n After all  paths of   hops are common now  and   years from now much longer paths may be common\n These people argued that using a huge address size was farsighted but using a tiny hop count was shortsighted\n In their view  the greatest sin a computer scientist can commit is to provide too few bits somewhere\n The response was that arguments could be made to increase every field  leading to a bloated header\n Also  the function of the Hop limit field is to keep packets from wandering around for too long a time and   hops is far  far too long\n THE NETWORK LAYER  \n  Finally  as the Internet grows  more and more long-distance links will be built  making it possible to get from any country to any other country in half a dozen hops at most\n If it takes more than hops to get from the source and the destination to their respective international gateways  something is wrong with the national backbones\n The  -bitters won this one\n Another hot potato was the maximum packet size\n The supercomputer community wanted packets in excess of   KB\n When a supercomputer gets started transferring  it really means business and does not want to be interrupted every   KB\n The argument against large packets is that if a  -MB packet hits a  \n -Mbps T  line  that packet will tie the line up for over  onds  producing a very noticeable delay for interactive users sharing the line\n A compromise was reached here: normal packets are limited to   KB  but the hop-by-hop extension header can be used to permit jumbograms\n A third hot topic was removing the IPv  checksum\n Some people likened this move to removing the brakes from a car\n Doing so makes the car lighter so it can go faster  but if an unexpected event happens  you have a problem\n The argument against checksums was that any application that really cares about data integrity has to have a transport layer checksum anyway  so having another one in IP (in addition to the data link layer checksum) is overkill\n Furthermore  experience showed that computing the IP checksum was a major expense in IPv \n The antichecksum camp won this one  and IPv  does not have a checksum\n Mobile hosts were also a point of contention\n If a portable computer flies halfway around the world  can it continue operating there with the same IPv  address  or does it have to use a scheme with home agents? Some people wanted to build explicit support for mobile hosts into IPv \n That effort failed when no consensus could be found for any specific proposal\n Probably the biggest battle was about urity\n Everyone agreed it was essential\n The war was about where to put it and how\n First where\n The argument for putting it in the network layer is that it then becomes a standard service that all applications can use without any advance planning\n The argument against it is that really ure applications generally want nothing less than end-to-end encryption  where the source application does the encryption and the destination application undoes it\n With anything less  the user is at the mercy of potentially buggy network layer implementations over which he has no control\n The response to this argument is that these applications can just refrain from using the IP urity features and do the job themselves\n The rejoinder to that is that the people who do not trust the network to do it right do not want to pay the price of slow  bulky IP implementations that have this capability  even if it is disabled\n Another aspect of where to put urity relates to the fact that many (but not all) countries have very stringent export laws concerning cryptography\n Some  notably France and Iraq  also restrict its use domestically  so that people cannot have rets from the government\n As a result  any IP implementation that used a   THE NETWORK LAYER IN THE INTERNET cryptographic system strong enough to be of much value could not be exported from the United States (and many other countries) to customers worldwide\n Having to maintain two sets of software  one for domestic use and one for export  is something most computer vendors vigorously oppose\n One point on which there was no controversy is that no one expects the IPv  Internet to be turned off on a Sunday evening and come back up as an IPv  Internet Monday morning\n Instead  isolated ‘‘islands’’ of IPv  will be converted  initially communicating via tunnels  as we showed in \n   \n As the IPv  islands grow  they will merge into bigger islands\n Eventually  all the islands will merge  and the Internet will be fully converted\n At least  that was the plan\n Deployment has proved the Achilles heel of IPv \n It remains little used  even though all major operating systems fully support it\n Most deployments are new situations in which a network operator—for example  a mobile phone operator— needs a large number of IP addresses\n Many strategies have been defined to help ease the transition\n Among them are ways to automatically configure the tunnels that carry IPv  over the IPv  Internet  and ways for hosts to automatically find the tunnel endpoints\n Dual-stack hosts have an IPv  and an IPv  implementation so that they can select which protocol to use depending on the destination of the packet\n These strategies will streamline the substantial deployment that seems inevitable when IPv  addresses are exhausted\n For more information about IPv  see Davies (   )\n    Internet Control Protocols In addition to IP  which is used for data transfer  the Internet has several companion control protocols that are used in the network layer\n They include ICMP  ARP  and DHCP\n In this tion  we will look at each of these in turn  describing the versions that correspond to IPv  because they are the protocols that are in common use\n ICMP and DHCP have similar versions for IPv ; the equivalent of ARP is called NDP (Neighbor Discovery Protocol) for IPv \n IMCP—The Internet Control Message Protocol The operation of the Internet is monitored closely by the routers\n When something unexpected occurs during packet processing at a router  the event is reported to the sender by the ICMP (Internet Control Message Protocol)\n ICMP is also used to test the Internet\n About a dozen types of ICMP messages are defined\n Each ICMP message type is carried encapsulated in an IP packet\n The most important ones are listed in Fig\n  -  \n The DESTINATION UNREACHABLE message is used when the router cannot locate the destination or when a packet with the DF bit cannot be delivered because a ‘‘small-packet’’ network stands in the way\n THE NETWORK LAYER  \n  Message type Description Destination unreachable Packet could not be delivered Time exceeded Time to live field hit  Parameter problem Invalid header field Source quench Choke packet Redirect Teach a router about geography Echo and echo reply Check if a machine is alive Timestamp request/reply Same as Echo  but with timestamp Router advertisement/solicitation Find a nearby router Figure  -  \n The principal ICMP message types\n The TIME EXCEEDED message is sent when a packet is dropped because its TtL (Time to live) counter has reached zero\n This event is a symptom that packets are looping  or that the counter values are being set too low\n One clever use of this error message is the traceroute utility that was developed by Van Jacobson in \n Traceroute finds the routers along the path from the host to a destination IP address\n It finds this information without any kind of privileged network support\n The method is simply to send a sequence of packets to the destination  first with a TtL of   then a TtL of  and so on\n The counters on these packets will reach zero at successive routers along the path\n These routers will each obediently send a TIME EXCEEDED message back to the host\n From those messages  the host can determine the IP addresses of the routers along the path  as well as keep statistics and timings on parts of the path\n It is not what the TIME EXCEEDED message was intended for  but it is perhaps the most useful network debugging tool of all time\n The PARAMETER PROBLEM message indicates that an illegal value has been detected in a header field\n This problem indicates a bug in the sending host’s IP software or possibly in the software of a router transited\n The SOURCE QUENCH message was long ago used to throttle hosts that were sending too many packets\n When a host received this message  it was expected to slow down\n It is rarely used anymore because when congestion occurs  these packets tend to add more fuel to the fire and it is unclear how to respond to them\n Congestion control in the Internet is now done largely by taking action in the transport layer  using packet losses as a congestion signal; we will study it in detail in   The REDIRECT message is used when a router notices that a packet seems to be routed incorrectly\n It is used by the router to tell the sending host to update to a better route\n The ECHO and ECHO REPLY messages are sent by hosts to see if a given destination is reachable and currently alive\n Upon receiving the ECHO message    THE NETWORK LAYER IN THE INTERNET the destination is expected to send back an ECHO REPLY message\n These messages are used in the ping utility that checks if a host is up and on the Internet\n The TIMESTAMP REQUEST and TIMESTAMP REPLY messages are similar  except that the arrival time of the message and the departure time of the reply are recorded in the reply\n This facility can be used to measure network performance\n The ROUTER ADVERTISEMENT and ROUTER SOLICITATION messages are used to let hosts find nearby routers\n A host needs to learn the IP address of at least one router to be able to send packets off the local network\n In addition to these messages  others have been defined\n The online list is now kept at  /assignments/icmp-parameters\n ARP—The Address Resolution Protocol Although every machine on the Internet has one or more IP addresses  these addresses are not sufficient for sending packets\n Data link layer NICs (Network Interface Cards) such as Ethernet cards do not understand Internet addresses\n In the case of Ethernet  every NIC ever manufactured comes equipped with a unique  -bit Ethernet address\n Manufacturers of Ethernet NICs request a block of Ethernet addresses from IEEE to ensure that no two NICs have the same address (to avoid conflicts should the two NICs ever appear on the same LAN)\n The NICs send and receive frames based on  -bit Ethernet addresses\n They know nothing at all about  -bit IP addresses\n The question now arises  how do IP addresses get mapped onto data link layer addresses  such as Ethernet? To explain how this works  let us use the example of Fig\n  -   in which a small university with two /  networks is illustrated\n One network (CS) is a switched Ethernet in the Computer Science Dept\n It has the prefix     \n /  \n The other LAN (EE)  also switched Ethernet  is in Electrical Engineering and has the prefix     \n /  \n The two LANs are connected by an IP router\n Each machine on an Ethernet and each interface on the router has a unique Ethernet address  labeled E  through E  and a unique IP address on the CS or EE network\n Let us start out by seeing how a user on host  sends a packet to a user on host  on the CS network\n Let us assume the sender knows the name of the intended receiver  possibly something like   The first step is to find the IP address for host  \n This lookup is performed by DNS  which we will study in   For the moment  we will just assume that DNS returns the IP address for host  (    \n )\n The upper layer software on host  now builds a packet with     \n  in the Destination address field and gives it to the IP software to transmit\n The IP software can look at the address and see that the destination is on the CS network  ( \n  its own network)\n However  it still needs some way to find the destination’s Ethernet address to send the frame\n One solution is to have a configuration file somewhere in the system that maps IP addresses onto Ethernet addresses\n While THE NETWORK LAYER  \n  Ethernet switch E  CS Network     \n /  IP  =     \n  E  E  E  E  E   \n  IP  =         IP  =     \n  IP  =     \n  EE Network     \n /  Router Host  Host  Host  Host  Frame Source IP Source Eth\n Destination IP Destination Eth\n Host  to   on CS net IP  E  IP  E  Host  to   on CS net IP  E  IP  E  Host  to   on EE net IP  E  IP  E  Figure  -  \n Two switched Ethernet LANs joined by a router\n this solution is certainly possible  for organizations with thousands of machines keeping all these files up to date is an error-prone  time-consuming job\n A better solution is for host  to output a broadcast packet onto the Ethernet asking who owns IP address      The broadcast will arrive at every machine on the CS Ethernet  and each one will check its IP address\n Host  alone will respond with its Ethernet address (E )\n In this way host  learns that IP address     \n  is on the host with Ethernet address E \n The protocol used for asking this question and getting the reply is called ARP (Address Resolution Protocol)\n Almost every machine on the Internet runs it\n ARP is defined in RFC   \n The advantage of using ARP over configuration files is the simplicity\n The system manager does not have to do much except assign each machine an IP address and decide about subnet masks\n ARP does the rest\n At this point  the IP software on host  builds an Ethernet frame addressed to E  puts the IP packet (addressed to     \n ) in the payload field  and dumps it onto the Ethernet\n The IP and Ethernet addresses of this packet are given in Fig\n  -  \n The Ethernet NIC of host  detects this frame  recognizes it as a frame for itself  scoops it up  and causes an interrupt\n The Ethernet driver extracts the IP packet from the payload and passes it to the IP software  which sees that it is correctly addressed and processes it\n Various optimizations are possible to make ARP work more efficiently\n To start with  once a machine has run ARP  it caches the result in case it needs to contact the same machine shortly\n Next time it will find the mapping in its own cache  thus eliminating the need for a ond broadcast\n In many cases  host    THE NETWORK LAYER IN THE INTERNET will need to send back a reply  forcing it  too  to run ARP to determine the sender’s Ethernet address\n This ARP broadcast can be avoided by having host  include its IP-to-Ethernet mapping in the ARP packet\n When the ARP broadcast arrives at host   the pair (    \n  E ) is entered into host  ’s ARP cache\n In fact  all machines on the Ethernet can enter this mapping into their ARP caches\n To allow mappings to change  for example  when a host is configured to use a new IP address (but keeps its old Ethernet address)  entries in the ARP cache should time out after a few minutes\n A clever way to help keep the cached information current and to optimize performance is to have every machine broadcast its mapping when it is configured\n This broadcast is generally done in the form of an ARP looking for its own IP address\n There should not be a response  but a side effect of the broadcast is to make or update an entry in everyone’s ARP cache\n This is known as a gratuitous ARP\n If a response does (unexpectedly) arrive  two machines have been assigned the same IP address\n The error must be resolved by the network manager before both machines can use the network\n Now let us look at Fig\n  -  again  only this time assume that host  wants to send a packet to host  (    \n ) on the EE network\n Host  will see that the destination IP address is not on the CS network\n It knows to send all such off-network traffic to the router  which is also known as the default gateway\n By convention  the default gateway is the lowest address on the network (    \n )\n To send a frame to the router  host  must still know the Ethernet address of the router interface on the CS network\n It discovers this by sending an ARP broadcast for     \n  from which it learns E \n It then sends the frame\n The same lookup mechanisms are used to send a packet from one router to the next over a sequence of routers in an Internet path\n When the Ethernet NIC of the router gets this frame  it gives the packet to the IP software\n It knows from the network masks that the packet should be sent onto the EE network where it will reach host  \n If the router does not know the Ethernet address for host   then it will use ARP again\n The table in Fig\n  -  lists the source and destination Ethernet and IP addresses that are present in the frames as observed on the CS and EE networks\n Observe that the Ethernet addresses change with the frame on each network while the IP addresses remain constant (because they indicate the endpoints across all of the interconnected networks)\n It is also possible to send a packet from host  to host  without host  knowing that host  is on a different network\n The solution is to have the router answer ARPs on the CS network for host  and give its Ethernet address  E  as the response\n It is not possible to have host  reply directly because it will not see the ARP request (as routers do not forward Ethernet-level broadcasts)\n The router will then receive frames sent to     \n  and forward them onto the EE network\n This solution is called proxy ARP\n It is used in special cases in which a host wants to appear on a network even though it actually resides on another network\n A common situation  for example  is a mobile computer that wants some other node to pick up packets for it when it is not on its home network\n THE NETWORK LAYER  \n  DHCP—The Dynamic Host Configuration Protocol ARP (as well as other Internet protocols) makes the assumption that hosts are configured with some basic information  such as their own IP addresses\n How do hosts get this information? It is possible to manually configure each computer  but that is tedious and error-prone\n There is a better way  and it is called DHCP (Dynamic Host Configuration Protocol)\n With DHCP  every network must have a DHCP server that is responsible for configuration\n When a computer is started  it has a built-in Ethernet or other link layer address embedded in the NIC  but no IP address\n Much like ARP  the computer broadcasts a request for an IP address on its network\n It does this by using a DHCP DISCOVER packet\n This packet must reach the DHCP server\n If that server is not directly attached to the network  the router will be configured to receive DHCP broadcasts and relay them to the DHCP server  wherever it is located\n When the server receives the request  it allocates a free IP address and sends it to the host in a DHCP OFFER packet (which again may be relayed via the router)\n To be able to do this work even when hosts do not have IP addresses  the server identifies a host using its Ethernet address (which is carried in the DHCP DISCOVER packet) An issue that arises with automatic assignment of IP addresses from a pool is for how long an IP address should be allocated\n If a host leaves the network and does not return its IP address to the DHCP server  that address will be permanently lost\n After a period of time  many addresses may be lost\n To prevent that from happening  IP address assignment may be for a fixed period of time  a technique called leasing\n Just before the lease expires  the host must ask for a DHCP renewal\n If it fails to make a request or the request is denied  the host may no longer use the IP address it was given earlier\n DHCP is described in RFCs  and \n It is widely used in the Internet to configure all sorts of parameters in addition to providing hosts with IP addresses\n As well as in business and home networks  DHCP is used by ISPs to set the parameters of devices over the Internet access link  so that customers do not need to phone their ISPs to get this information\n Common examples of the information that is configured include the network mask  the IP address of the default gateway  and the IP addresses of DNS and time servers\n DHCP has largely replaced earlier protocols (called RARP and BOOTP) with more limited functionality\n    Label Switching and MPLS So far  on our tour of the network layer of the Internet  we have focused exclusively on packets as datagrams that are forwarded by IP routers\n There is also another kind of technology that is starting to be widely used  especially by ISPs  in order to move Internet traffic across their networks\n This technology is   THE NETWORK LAYER IN THE INTERNET called MPLS (MultiProtocol Label Switching) and it is perilously close to circuit switching\n Despite the fact that many people in the Internet community have an intense dislike for connection-oriented networking  the idea seems to keep coming back\n As Yogi Berra once put it  it is like deja vu all over again\n However  there are essential differences between the way the Internet handles route construction and the way connection-oriented networks do it  so the technique is certainly not traditional circuit switching\n MPLS adds a label in front of each packet  and forwarding is based on the label rather than on the destination address\n Making the label an index into an internal table makes finding the correct output line just a matter of table lookup\n Using this technique  forwarding can be done very quickly\n This advantage was the original motivation behind MPLS  which began as proprietary technology known by various names including tag switching\n Eventually  IETF began to standardize the idea\n It is described in RFC  and many other RFCs\n The main benefits over time have come to be routing that is flexible and forwarding that is suited to quality of service as well as fast\n The first question to ask is where does the label go? Since IP packets were not designed for virtual circuits  there is no field available for virtual-circuit numbers within the IP header\n For this reason  a new MPLS header had to be added in front of the IP header\n On a router-to-router line using PPP as the framing protocol  the frame format  including the PPP  MPLS  IP  and TCP headers  is as shown in Fig\n  -  \n PPP MPLS IP Label QoS S TtL Bits   Headers  TCP User data CRC Figure  -  \n Transmitting a TCP segment using IP  MPLS  and PPP\n The generic MPLS header is  bytes long and has four fields\n Most important is the Label field  which holds the index\n The QoS field indicates the class of service\n The S field relates to stacking multiple labels (which is discussed below)\n The TtL field indicates how many more times the packet may be forwarded\n It is decremented at each router  and if it hits   the packet is discarded\n This feature prevents infinite looping in the case of routing instability\n MPLS falls between the IP network layer protocol and the PPP link layer protocol\n It is not really a layer  protocol because it depends on IP or other network THE NETWORK LAYER  \n  layer addresses to set up label paths\n It is not really a layer  protocol either because it forwards packets across multiple hops  not a single link\n For this reason  MPLS is sometimes described as a layer  \n  protocol\n It is an illustration that real protocols do not always fit neatly into our ideal layered protocol model\n On the brighter side  because the MPLS headers are not part of the network layer packet or the data link layer frame  MPLS is to a large extent independent of both layers\n Among other things  this property means it is possible to build MPLS switches that can forward both IP packets and non-IP packets  depending on what shows up\n This feature is where the ‘‘multiprotocol’’ in the name MPLS came from\n MPLS can also carry IP packets over non-IP networks\n When an MPLS-enhanced packet arrives at a LSR (Label Switched Router)  the label is used as an index into a table to determine the outgoing line to use and also the new label to use\n This label swapping is used in all virtual-circuit networks\n Labels have only local significance and two different routers can feed unrelated packets with the same label into another router for transmission on the same outgoing line\n To be distinguishable at the other end  labels have to be remapped at every hop\n We saw this mechanism in action in Fig\n  - \n MPLS uses the same technique\n As an aside  some people distinguish between forwarding and switching\n Forwarding is the process of finding the best match for a destination address in a table to decide where to send packets\n An example is the longest matching prefix algorithm used for IP forwarding\n In contrast  switching uses a label taken from the packet as an index into a forwarding table\n It is simpler and faster\n These definitions are far from universal  however\n Since most hosts and routers do not understand MPLS  we should also ask when and how the labels are attached to packets\n This happens when an IP packet reaches the edge of an MPLS network\n The LER (Label Edge Router) inspects the destination IP address and other fields to see which MPLS path the packet should follow  and puts the right label on the front of the packet\n Within the MPLS network  this label is used to forward the packet\n At the other edge of the MPLS network  the label has served its purpose and is removed  revealing the IP packet again for the next network\n This process is shown in Fig\n  -  \n One difference from traditional virtual circuits is the level of aggregation\n It is certainly possible for each flow to have its own set of labels through the MPLS network\n However  it is more common for routers to group multiple flows that end at a particular router or LAN and use a single label for them\n The flows that are grouped together under a single label are said to belong to the same FEC (Forwarding Equivalence Class)\n This class covers not only where the packets are going  but also their service class (in the differentiated services sense) because all the packets are treated the same way for forwarding purposes\n With traditional virtual-circuit routing  it is not possible to group several distinct paths with different endpoints onto the same virtual-circuit identifier because there would be no way to distinguish them at the final destination\n With MPLS    THE NETWORK LAYER IN THE INTERNET Switching on label only Label switch router IP IP Label IP Label edge router Add label Remove label (to next network) Label Label Figure  -  \n Forwarding an IP packet through an MPLS network\n the packets still contain their final destination address  in addition to the label\n At the end of the labeled route  the label header can be removed and forwarding can continue the usual way  using the network layer destination address\n Actually  MPLS goes even further\n It can operate at multiple levels at once by adding more than one label to the front of a packet\n For example  suppose that there are many packets that already have different labels (because we want to treat the packets differently somewhere in the network) that should follow a common path to some destination\n Instead of setting up many label switching paths  one for each of the different labels  we can set up a single path\n When the already- labeled packets reach the start of this path  another label is added to the front\n This is called a stack of labels\n The outermost label guides the packets along the path\n It is removed at the end of the path  and the labels revealed  if any  are used to forward the packet further\n The S bit in Fig\n  -  allows a router removing a label to know if there are any additional labels left\n It is set to  for the bottom label and  for all the other labels\n The final question we will ask is how the label forwarding tables are set up so that packets follow them\n This is one area of major difference between MPLS and conventional virtual-circuit designs\n In traditional virtual-circuit networks  when a user wants to establish a connection  a setup packet is launched into the network to create the path and make the forwarding table entries\n MPLS does not involve users in the setup phase\n Requiring users to do anything other than send a datagram would break too much existing Internet software\n Instead  the forwarding information is set up by protocols that are a combination of routing protocols and connection setup protocols\n These control protocols are cleanly separated from label forwarding  which allows multiple  different control protocols to be used\n One of the variants works like this\n When a router is booted  it checks to see which routes it is the final destination for ( \n  which prefixes belong to its interfaces)\n It then creates one or more FECs for them  allocates a label for each one  and passes the labels to its neighbors\n They  in turn  enter the labels in their forwarding tables and send new labels to their neighbors  until all the routers have acquired the path\n Resources can also be reserved as the THE NETWORK LAYER  \n  path is constructed to guarantee an appropriate quality of service\n Other variants can set up different paths  such as traffic engineering paths that take unused capacity into account  and create paths on-demand to support service offerings such as quality of service\n Although the basic ideas behind MPLS are straightforward  the details are complicated  with many variations and use cases that are being actively developed\n For more information  see Davie and Farrel (   ) and Davie and Rekhter (   )\n    OSPF—An Interior Gateway Routing Protocol We have now finished our study of how packets are forwarded in the Internet\n It is time to move on to the next topic: routing in the Internet\n As we mentioned earlier  the Internet is made up of a large number of independent networks or ASes (Autonomous Systems) that are operated by different organizations  usually a company  university  or ISP\n Inside of its own network  an organization can use its own algorithm for internal routing  or intradomain routing  as it is more commonly known\n Nevertheless  there are only a handful of standard protocols that are popular\n In this tion  we will study the problem of intradomain routing and look at the OSPF protocol that is widely used in practice\n An intradomain routing protocol is also called an interior gateway protocol\n In the next tion  we will study the problem of routing between independently operated networks  or interdomain routing\n For that case  all networks must use the same interdomain routing protocol or exterior gateway protocol\n The protocol that is used in the Internet is BGP (Border Gateway Protocol)\n Early intradomain routing protocols used a distance vector design  based on the distributed Bellman-Ford algorithm inherited from the ARPANET\n RIP (Routing Information Protocol) is the main example that is used to this day\n It works well in small systems  but less well as networks get larger\n It also suffers from the count-to-infinity problem and generally slow convergence\n The ARPANET switched over to a link state protocol in May  because of these problems  and in  IETF began work on a link state protocol for intradomain routing\n That protocol  called OSPF (Open Shortest Path First)  became a standard in \n It drew on a protocol called IS-IS (Intermediate-System to Intermediate-System)  which became an ISO standard\n Because of their shared heritage  the two protocols are much more alike than different\n For the complete story  see RFC \n They are the dominant intradomain routing protocols  and most router vendors now support both of them\n OSPF is more widely used in company networks  and IS-IS is more widely used in ISP networks\n Of the two  we will give a sketch of how OSPF works\n Given the long experience with other routing protocols  the group designing OSPF had a long list of requirements that had to be met\n First  the algorithm had to be published in the open literature  hence the ‘‘O’’ in OSPF\n A proprietary   THE NETWORK LAYER IN THE INTERNET solution owned by one company would not do\n ond  the new protocol had to support a variety of distance metrics  including physical distance  delay  and so on\n Third  it had to be a dynamic algorithm  one that adapted to changes in the topology automatically and quickly\n Fourth  and new for OSPF  it had to support routing based on type of service\n The new protocol had to be able to route real-time traffic one way and other traffic a different way\n At the time  IP had a Type of service field  but no existing routing protocol used it\n This field was included in OSPF but still nobody used it  and it was eventually removed\n Perhaps this requirement was ahead of its time  as it preceded IETF’s work on differentiated services  which has rejuvenated classes of service\n Fifth  and related to the above  OSPF had to do load balancing  splitting the load over multiple lines\n Most previous protocols sent all packets over a single best route  even if there were two routes that were equally good\n The other route was not used at all\n In many cases  splitting the load over multiple routes gives better performance\n Sixth  support for hierarchical systems was needed\n By  some networks had grown so large that no router could be expected to know the entire topology\n OSPF had to be designed so that no router would have to\n Seventh  some modicum of urity was required to prevent fun-loving students from spoofing routers by sending them false routing information\n Finally  provision was needed for dealing with routers that were connected to the Internet via a tunnel\n Previous protocols did not handle this well\n OSPF supports both point-to-point links ( \n  SONET) and broadcast networks ( \n  most LANs)\n Actually  it is able to support networks with multiple routers  each of which can communicate directly with the others (called multiaccess networks) even if they do not have broadcast capability\n Earlier protocols did not handle this case well\n An example of an autonomous system network is given in Fig\n  -  (a)\n Hosts are omitted because they do not generally play a role in OSPF  while routers and networks (which may contain hosts) do\n Most of the routers in Fig\n  -  (a) are connected to other routers by point-to-point links  and to networks to reach the hosts on those networks\n However  routers R  R  and R  are connected by a broadcast LAN such as switched Ethernet\n OSPF operates by abstracting the collection of actual networks  routers  and links into a directed graph in which each arc is assigned a weight (distance  delay  etc\n)\n A point-to-point connection between two routers is represented by a pair of arcs  one in each direction\n Their weights may be different\n A broadcast network is represented by a node for the network itself  plus a node for each router\n The arcs from that network node to the routers have weight  \n They are important nonetheless  as without them there is no path through the network\n Other networks  which have only hosts  have only an arc reaching them and not one returning\n This structure gives routes to hosts  but not through them\n THE NETWORK LAYER  \n  LAN  LAN  LAN  LAN  R  R  R  R  R  R  R  R  R  R  LAN  LAN  LAN  LAN  (a) (b)     Figure  -  \n (a) An autonomous system\n (b) A graph representation of (a)\n Figure  -  (b) shows the graph representation of the network of Fig\n  -  (a)\n What OSPF fundamentally does is represent the actual network as a graph like this and then use the link state method to have every router compute the shortest path from itself to all other nodes\n Multiple paths may be found that are equally short\n In this case  OSPF remembers the set of shortest paths and during packet forwarding  traffic is split across them\n This helps to balance load\n It is called ECMP (Equal Cost MultiPath)\n Many of the ASes in the Internet are themselves large and nontrivial to manage\n To work at this scale  OSPF allows an AS to be divided into numbered areas  where an area is a network or a set of contiguous networks\n Areas do not overlap but need not be exhaustive  that is  some routers may belong to no area\n Routers that lie wholly within an area are called internal routers\n An area is a generalization of an individual network\n Outside an area  its destinations are visible but not its topology\n This characteristic helps routing to scale\n Every AS has a backbone area  called area  \n The routers in this area are called backbone routers\n All areas are connected to the backbone  possibly by tunnels  so it is possible to go from any area in the AS to any other area in the AS via the backbone\n A tunnel is represented in the graph as just another arc with a cost\n As with other areas  the topology of the backbone is not visible outside the backbone\n Each router that is connected to two or more areas is called an area border router\n It must also be part of the backbone\n The job of an area border router is to summarize the destinations in one area and to inject this summary into the other   THE NETWORK LAYER IN THE INTERNET areas to which it is connected\n This summary includes cost information but not all the details of the topology within an area\n Passing cost information allows hosts in other areas to find the best area border router to use to enter an area\n Not passing topology information reduces traffic and simplifies the shortest-path computations of routers in other areas\n However  if there is only one border router out of an area  even the summary does not need to be passed\n Routes to destinations out of the area always start with the instruction ‘‘Go to the border router\n’’ This kind of area is called a stub area\n The last kind of router is the AS boundary router\n It injects routes to external destinations on other ASes into the area\n The external routes then appear as destinations that can be reached via the AS boundary router with some cost\n An external route can be injected at one or more AS boundary routers\n The relationship between ASes  areas  and the various kinds of routers is shown in Fig\n  -  \n One router may play multiple roles  for example  a border router is also a backbone router\n Area  (stub) Area  (backbone) Area  Backbone router AS boundary router Internal router Area border router One autonomous system Figure  -  \n The relation between ASes  backbones  and areas in OSPF\n During normal operation  each router within an area has the same link state database and runs the same shortest path algorithm\n Its main job is to calculate the shortest path from itself to every other router and network in the entire AS\n An area border router needs the databases for all the areas to which it is connected and must run the shortest path algorithm for each area separately\n For a source and destination in the same area  the best intra-area route (that lies wholly within the area) is chosen\n For a source and destination in different areas  the inter-area route must go from the source to the backbone  across the backbone to the destination area  and then to the destination\n This algorithm forces a star configuration on OSPF  with the backbone being the hub and the other areas being spokes\n Because the route with the lowest cost is chosen  routers in different parts of the network may use different area border routers to enter the backbone and destination area\n Packets are routed from source to destination ‘‘as is\n’’ They are not encapsulated or tunneled (unless going to an area whose THE NETWORK LAYER  \n  only connection to the backbone is a tunnel)\n Also  routes to external destinations may include the external cost from the AS boundary router over the external path  if desired  or just the cost internal to the AS\n When a router boots  it sends HELLO messages on all of its point-to-point lines and multicasts them on LANs to the group consisting of all the other routers\n From the responses  each router learns who its neighbors are\n Routers on the same LAN are all neighbors\n OSPF works by exchanging information between adjacent routers  which is not the same as between neighboring routers\n In particular  it is inefficient to have every router on a LAN talk to every other router on the LAN\n To avoid this situation  one router is elected as the designated router\n It is said to be adjacent to all the other routers on its LAN  and exchanges information with them\n In effect  it is acting as the single node that represents the LAN\n Neighboring routers that are not adjacent do not exchange information with each other\n A backup designated router is always kept up to date to ease the transition should the primary designated router crash and need to be replaced immediately\n During normal operation  each router periodically floods LINK STATE UPDATE messages to each of its adjacent routers\n These messages gives its state and provide the costs used in the topological database\n The flooding messages are acknowledged  to make them reliable\n Each message has a sequence number  so a router can see whether an incoming LINK STATE UPDATE is older or newer than what it currently has\n Routers also send these messages when a link goes up or down or its cost changes\n DATABASE DESCRIPTION messages give the sequence numbers of all the link state entries currently held by the sender\n By comparing its own values with those of the sender  the receiver can determine who has the most recent values\n These messages are used when a link is brought up\n Either partner can request link state information from the other one by using LINK STATE REQUEST messages\n The result of this algorithm is that each pair of adjacent routers checks to see who has the most recent data  and new information is spread throughout the area this way\n All these messages are sent directly in IP packets\n The five kinds of messages are summarized in Fig\n  -  \n Message type Description Hello Used to discover who the neighbors are Link state update Provides the sender’s costs to its neighbors Link state ack Acknowledges link state update Database description Announces which updates the sender has Link state request Requests information from the partner Figure  -  \n The five types of OSPF messages\n   THE NETWORK LAYER IN THE INTERNET Finally  we can put all the pieces together\n Using flooding  each router informs all the other routers in its area of its links to other routers and networks and the cost of these links\n This information allows each router to construct the graph for its area(s) and compute the shortest paths\n The backbone area does this work  too\n In addition  the backbone routers accept information from the area border routers in order to compute the best route from each backbone router to every other router\n This information is propagated back to the area border routers  which advertise it within their areas\n Using this information  internal routers can select the best route to a destination outside their area  including the best exit router to the backbone\n    BGP—The Exterior Gateway Routing Protocol Within a single AS  OSPF and IS-IS are the protocols that are commonly used\n Between ASes  a different protocol  called BGP (Border Gateway Protocol)  is used\n A different protocol is needed because the goals of an intradomain protocol and an interdomain protocol are not the same\n All an intradomain protocol has to do is move packets as efficiently as possible from the source to the destination\n It does not have to worry about politics\n In contrast  interdomain routing protocols have to worry about politics a great deal (Metz  )\n For example  a corporate AS might want the ability to send packets to any Internet site and receive packets from any Internet site\n However  it might be unwilling to carry transit packets originating in a foreign AS and ending in a different foreign AS  even if its own AS is on the shortest path between the two foreign ASes (‘‘That’s their problem  not ours’’)\n On the other hand  it might be willing to carry transit traffic for its neighbors  or even for specific other ASes that paid it for this service\n Telephone companies  for example  might be happy to act as carriers for their customers  but not for others\n Exterior gateway protocols in general  and BGP in particular  have been designed to allow many kinds of routing policies to be enforced in the interAS traffic\n Typical policies involve political  urity  or economic considerations\n A few examples of possible routing constraints are:  \n Do not carry commercial traffic on the educational network Never send traffic from the Pentagon on a route through Iraq Use TeliaSonera instead of Verizon because it is cheaper Don’t use AT&T in Australia because performance is poor Traffic starting or ending at Apple should not transit Google\n As you might imagine from this list  routing policies can be highly individual\n They are often proprietary because they contain sensitive business information\n THE NETWORK LAYER  \n  However  we can describe some patterns that capture the reasoning of the company above and that are often used as a starting point\n A routing policy is implemented by deciding what traffic can flow over which of the links between ASes\n One common policy is that a customer ISP pays another provider ISP to deliver packets to any other destination on the Internet and receive packets sent from any other destination\n The customer ISP is said to buy transit service from the provider ISP\n This is just like a customer at home buying Internet access service from an ISP\n To make it work  the provider should advertise routes to all destinations on the Internet to the customer over the link that connects them\n In this way  the customer will have a route to use to send packets anywhere\n Conversely  the customer should advertise routes only to the destinations on its network to the provider\n This will let the provider send traffic to the customer only for those addresses; the customer does not want to handle traffic intended for other destinations\n We can see an example of transit service in Fig\n  -  \n There are four ASes that are connected\n The connection is often made with a link at IXPs (Internet eXchange Points)  facilities to which many ISPs have a link for the purpose of connecting with other ISPs\n AS  AS  and AS  are customers of AS \n They buy transit service from it\n Thus  when source A sends to destination C  the packets travel from AS  to AS  and finally to AS \n The routing advertisements travel in the opposite direction to the packets\n AS  advertises C as a destination to its transit provider  AS  to let sources reach C via AS \n Later  AS  advertises a route to C to its other customers  including AS  to let the customers know that they can send traffic to C via AS \n TR AS  AS  AS  AS  A PE CU PE CU CU TR TR Path of BGP routing advertisements (dash) Path of IP packets (solid) Routing policy: TR = Transit CU = Customer PE = Peer B C Figure  -  \n Routing policies between four autonomous systems\n In Fig\n  -   all of the other ASes buy transit service from AS \n This provides them with connectivity so they can interact with any host on the Internet\n However  they have to pay for this privilege\n Suppose that AS  and AS  exchange a lot of traffic\n Given that their networks are connected already  if they want to  they   THE NETWORK LAYER IN THE INTERNET can use a different policy—they can send traffic directly to each other for free\n This will reduce the amount of traffic they must have AS  deliver on their behalf  and hopefully it will reduce their bills\n This policy is called peering\n To implement peering  two ASes send routing advertisements to each other for the addresses that reside in their networks\n Doing so makes it possible for AS  to send AS  packets from A destined to B and vice versa\n However  note that peering is not transitive\n In Fig\n  -   AS  and AS  also peer with each other\n This peering allows traffic from C destined for B to be sent directly to AS \n What happens if C sends a packet to A? AS  is only advertising a route to B to AS \n It is not advertising a route to A\n The consequence is that traffic will not pass from AS  to AS  to AS  even though a physical path exists\n This restriction is exactly what AS  wants\n It peers with AS  to exchange traffic  but does not want to carry traffic from AS  to other parts of the Internet since it is not being paid to so do\n Instead  AS  gets transit service from AS \n Thus  it is AS  who will carry the packet from C to A\n Now that we know about transit and peering  we can also see that A  B  and C have transit arrangements\n For example  A must buy Internet access from AS \n A might be a single home computer or a company network with many LANs\n However  it does not need to run BGP because it is a stub network that is connected to the rest of the Internet by only one link\n So the only place for it to send packets destined outside of the network is over the link to AS \n There is nowhere else to go\n This path can be arranged simply by setting up a default route\n For this reason  we have not shown A  B  and C as ASes that participate in interdomain routing\n On the other hand  some company networks are connected to multiple ISPs\n This technique is used to improve reliability  since if the path through one ISP fails  the company can use the path via the other ISP\n This technique is called multihoming\n In this case  the company network is likely to run an interdomain routing protocol ( \n  BGP) to tell other ASes which addresses should be reached via which ISP links\n Many variations on these transit and peering policies are possible  but they already illustrate how business relationships and control over where route advertisements go can implement different kinds of policies\n Now we will consider in more detail how routers running BGP advertise routes to each other and select paths over which to forward packets\n BGP is a form of distance vector protocol  but it is quite unlike intradomain distance vector protocols such as RIP\n We have already seen that policy  instead of minimum distance  is used to pick which routes to use\n Another large difference is that instead of maintaining just the cost of the route to each destination  each BGP router keeps track of the path used\n This approach is called a path vector protocol\n The path consists of the next hop router (which may be on the other side of the ISP  not adjacent) and the sequence of ASes  or AS path  that the route has followed (given in reverse order)\n Finally  pairs of BGP routers communicate THE NETWORK LAYER  \n  with each other by establishing TCP connections\n Operating this way provides reliable communication and also hides all the details of the network being passed through\n An example of how BGP routes are advertised is shown in Fig\n  -  \n There are three ASes and the middle one is providing transit to the left and right ISPs\n A route advertisement to prefix C starts in AS \n When it is propagated across the link to R c at the top of the figure  it has the AS path of simply AS  and the next hop router of R a\n At the bottom  it has the same AS path but a different next hop because it came across a different link\n This advertisement continues to propagate and crosses the boundary into AS \n At router R a  at the top of the figure  the AS path is AS  AS  and the next hop is R a\n R a Prefix A B C AS  AS  AS  Path of packets R b R c R d R a R b R a R b C  AS  AS  R a C  AS  R a C  AS  AS  R b C  AS  AS  R a C  AS  AS  R b AS path Next hop C  AS  R b Figure  -  \n Propagation of BGP route advertisements\n Carrying the complete path with the route makes it easy for the receiving router to detect and break routing loops\n The rule is that each router that sends a route outside of the AS prepends its own AS number to the route\n (This is why the list is in reverse order\n) When a router receives a route  it checks to see if its own AS number is already in the AS path\n If it is  a loop has been detected and the advertisement is discarded\n However  and somewhat ironically  it was realized in the late s that despite this precaution BGP suffers from a version of the count-to-infinity problem (Labovitz et al\n  )\n There are no long-lived loops  but routes can sometimes be slow to converge and have transient loops\n Giving a list of ASes is a very coarse way to specify a path\n An AS might be a small company  or an international backbone network\n There is no way of telling from the route\n BGP does not even try because different ASes may use different intradomain protocols whose costs cannot be compared\n Even if they could be compared  an AS may not want to reveal its internal metrics\n This is one of the ways that interdomain routing protocols differ from intradomain protocols\n   THE NETWORK LAYER IN THE INTERNET So far we have seen how a route advertisement is sent across the link between two ISPs\n We still need some way to propagate BGP routes from one side of the ISP to the other  so they can be sent on to the next ISP\n This task could be handled by the intradomain protocol  but because BGP is very good at scaling to large networks  a variant of BGP is often used\n It is called iBGP (internal BGP) to distinguish it from the regular use of BGP as eBGP (external BGP)\n The rule for propagating routes inside an ISP is that every router at the boundary of the ISP learns of all the routes seen by all the other boundary routers  for consistency\n If one boundary router on the ISP learns of a prefix to IP   \n   /   all the other routers will learn of this prefix\n The prefix will then be reachable from all parts of the ISP  no matter how packets enter the ISP from other ASes\n We have not shown this propagation in Fig\n  -  to avoid clutter  but  for example  router R b will know that it can reach C via either router R c at top or router R d at bottom\n The next hop is updated as the route crosses within the ISP so that routers on the far side of the ISP know which router to use to exit the ISP on the other side\n This can be seen in the leftmost routes in which the next hop points to a router in the same ISP and not a router in the next ISP\n We can now describe the key missing piece  which is how BGP routers choose which route to use for each destination\n Each BGP router may learn a route for a given destination from the router it is connected to in the next ISP and from all of the other boundary routers (which have heard different routes from the routers they are connected to in other ISPs)\n Each router must decide which route in this set of routes is the best one to use\n Ultimately the answer is that it is up to the ISP to write some policy to pick the preferred route\n However  this explanation is very general and not at all satisfying  so we can at least describe some common strategies\n The first strategy is that routes via peered networks are chosen in preference to routes via transit providers\n The former are free; the latter cost money\n A similar strategy is that customer routes are given the highest preference\n It is only good business to send traffic directly to the paying customers\n A different kind of strategy is the default rule that shorter AS paths are better\n This is debatable given that an AS could be a network of any size  so a path through three small ASes could actually be shorter than a path through one big AS\n However  shorter tends to be better on average  and this rule is a common tiebreaker\n The final strategy is to prefer the route that has the lowest cost within the ISP\n This is the strategy implemented in Fig\n  -  \n Packets sent from A to C exit AS  at the top router  R a\n Packets sent from B exit via the bottom router  R b\n The reason is that both A and B are taking the lowest-cost path or quickest route out of AS \n Because they are located in different parts of the ISP  the quickest exit for each one is different\n The same thing happens as the packets pass through AS \n On the last leg  AS  has to carry the packet from B through its own network\n THE NETWORK LAYER  \n  This strategy is known as early exit or hot-potato routing\n It has the curious side effect of tending to make routes asymmetric\n For example  consider the path taken when C sends a packet back to B\n The packet will exit AS  quickly  at the top router  to avoid wasting its resources\n Similarly  it will stay at the top when AS  passes it to AS  as quickly as possible\n Then the packet will have a longer journey in AS \n This is a mirror image of the path taken from B to C\n The above discussion should make clear that each BGP router chooses its own best route from the known possibilities\n It is not the case  as might naively be expected  that BGP chooses a path to follow at the AS level and OSPF chooses paths within each of the ASes\n BGP and the interior gateway protocol are integrated much more deeply\n This means that  for example  BGP can find the best exit point from one ISP to the next and this point will vary across the ISP  as in the case of the hot-potato policy\n It also means that BGP routers in different parts of one AS may choose different AS paths to reach the same destination\n Care must be exercised by the ISP to configure all of the BGP routers to make compatible choices given all of this freedom  but this can be done in practice\n Amazingly  we have only scratched the surface of BGP\n For more information  see the BGP version  specification in RFC  and related RFCs\n However  realize that much of its complexity lies with policies  which are not described in the specification of the BGP protocol\n    Internet Multicasting Normal IP communication is between one sender and one receiver\n However  for some applications  it is useful for a process to be able to send to a large number of receivers simultaneously\n Examples are streaming a live sports event to many viewers  delivering program updates to a pool of replicated servers  and handling digital conference ( \n  multiparty) telephone calls\n IP supports one-to-many communication  or multicasting  using class D IP addresses\n Each class D address identifies a group of hosts\n Twenty-eight bits are available for identifying groups  so over million groups can exist at the same time\n When a process sends a packet to a class D address  a best-effort attempt is made to deliver it to all the members of the group addressed  but no guarantees are given\n Some members may not get the packet\n The range of IP addresses    \n /  is reserved for multicast on the local network\n In this case  no routing protocol is needed\n The packets are multicast by simply broadcasting them on the LAN with a multicast address\n All hosts on the LAN receive the broadcasts  and hosts that are members of the group process the packet\n Routers do not forward the packet off the LAN\n Some examples of local multicast addresses are:    \n  All systems on a LAN    \n  All routers on a LAN    \n  All OSPF routers on a LAN    \n   All DNS servers on a LAN   THE NETWORK LAYER IN THE INTERNET Other multicast addresses may have members on different networks\n In this case  a routing protocol is needed\n But first the multicast routers need to know which hosts are members of a group\n A process asks its host to join in a specific group\n It can also ask its host to leave the group\n Each host keeps track of which groups its processes currently belong to\n When the last process on a host leaves a group  the host is no longer a member of that group\n About once a minute  each multicast router sends a query packet to all the hosts on its LAN (using the local multicast address of    \n  of course) asking them to report back on the groups to which they currently belong\n The multicast routers may or may not be colocated with the standard routers\n Each host sends back responses for all the class D addresses it is interested in\n These query and response packets use a protocol called IGMP (Internet Group Management Protocol)\n It is described in RFC \n Any of several multicast routing protocols may be used to build multicast spanning trees that give paths from senders to all of the members of the group\n The algorithms that are used are the ones we described in \n   \n Within an AS  the main protocol used is PIM (Protocol Independent Multicast)\n PIM comes in several flavors\n In Dense Mode PIM  a pruned reverse path forwarding tree is created\n This is suited to situations in which members are everywhere in the network  such as distributing files to many servers within a data center network\n In Sparse Mode PIM  spanning trees that are built are similar to core-based trees\n This is suited to situations such as a content provider multicasting TV to subscribers on its IP network\n A variant of this design  called Source-Specific Multicast PIM  is optimized for the case that there is only one sender to the group\n Finally  multicast extensions to BGP or tunnels need to be used to create multicast routes when the group members are in more than one AS\n    Mobile IP Many users of the Internet have mobile computers and want to stay connected when they are away from home and even on the road in between\n Unfortunately  the IP addressing system makes working far from home easier said than done  as we will describe shortly\n When people began demanding the ability anyway  IETF set up a Working Group to find a solution\n The Working Group quickly formulated a number of goals considered desirable in any solution\n The major ones were:  \n Each mobile host must be able to use its home IP address anywhere Software changes to the fixed hosts were not permitted Changes to the router software and tables were not permitted Most packets for mobile hosts should not make detours on the way No overhead should be incurred when a mobile host is at home\n THE NETWORK LAYER  \n  The solution chosen was the one described in \n    \n In brief  every site that wants to allow its users to roam has to create a helper at the site called a home agent\n When a mobile host shows up at a foreign site  it obtains a new IP address (called a care-of address) at the foreign site\n The mobile then tells the home agent where it is now by giving it the care-of address\n When a packet for the mobile arrives at the home site and the mobile is elsewhere  the home agent grabs the packet and tunnels it to the mobile at the current care-of address\n The mobile can send reply packets directly to whoever it is communicating with  but still using its home address as the source address\n This solution meets all the requirements stated above except that packets for mobile hosts do make detours\n Now that we have covered the network layer of the Internet  we can go into the solution in more detail\n The need for mobility support in the first place comes from the IP addressing scheme itself\n Every IP address contains a network number and a host number\n For example  consider the machine with IP address     \n  /  \n The   \n  gives the network number; the  \n  is the host number\n Routers all over the world have routing tables telling which link to use to get to network    Whenever a packet comes in with a destination IP address of the form      it goes out on that line\n If all of a sudden  the machine with that address is carted off to some distant site  the packets for it will continue to be routed to its home LAN (or router)\n At this stage  there are two options—both unattractive\n The first is that we could create a route to a more specific prefix\n That is  if the distant site advertises a route to     \n  /   packets sent to the destination will start arriving in the right place again\n This option depends on the longest matching prefix algorithm that is used at routers\n However  we have added a route to an IP prefix with a single IP address in it\n All ISPs in the world will learn about this prefix\n If everyone changes global IP routes in this way when they move their computer  each router would have millions of table entries  at astronomical cost to the Internet\n This option is not workable\n The ond option is to change the IP address of the mobile\n True  packets sent to the home IP address will no longer be delivered until all the relevant people  programs  and databases are informed of the change\n But the mobile can still use the Internet at the new location to browse the Web and run other applications\n This option handles mobility at a higher layer\n It is what typically happens when a user takes a laptop to a coffee store and uses the Internet via the local wireless network\n The disadvantage is that it breaks some applications  and it does not keep connectivity as the mobile moves around\n As an aside  mobility can also be handled at a lower layer  the link layer\n This is what happens when using a laptop on a single   \n  wireless network\n The IP address of the mobile does not change and the network path remains the same\n It is the wireless link that is providing mobility\n However  the degree of mobility is limited\n If the laptop moves too far  it will have to connect to the Internet via another network with a different IP address\n   THE NETWORK LAYER IN THE INTERNET The mobile IP solution for IPv  is given in RFC \n It works with the existing Internet routing and allows hosts to stay connected with their own IP addresses as they move about\n For it to work  the mobile must be able to discover when it has moved\n This is accomplished with ICMP router advertisement and solicitation messages\n Mobiles listen for periodic router advertisements or send a solicitation to discover the nearest router\n If this router is not the usual address of the router when the mobile is at home  it must be on a foreign network\n If this router has changed since last time  the mobile has moved to another foreign network\n This same mechanism lets mobile hosts find their home agents\n To get a care-of IP address on the foreign network  a mobile can simply use DHCP\n Alternatively  if IPv  addresses are in short supply  the mobile can send and receive packets via a foreign agent that already has an IP address on the network\n The mobile host finds a foreign agent using the same ICMP mechanism used to find the home agent\n After the mobile obtains an IP address or finds a foreign agent  it is able to use the network to send a message to its home agent  informing the home agent of its current location\n The home agent needs a way to intercept packets sent to the mobile only when the mobile is not at home\n ARP provides a convenient mechanism\n To send a packet over an Ethernet to an IP host  the router needs to know the Ethernet address of the host\n The usual mechanism is for the router to send an ARP query to ask  for example  what is the Ethernet address of      When the mobile is at home  it answers ARP queries for its IP address with its own Ethernet address\n When the mobile is away  the home agent responds to this query by giving its Ethernet address\n The router then sends packets for     \n  to the home agent\n Recall that this is called a proxy ARP\n To quickly update ARP mappings back and forth when the mobile leaves home or arrives back home  another ARP technique called a gratuitous ARP can be used\n Basically  the mobile or home agent send themselves an ARP query for the mobile IP address that supplies the right answer so that the router notices and updates its mapping\n Tunneling to send a packet between the home agent and the mobile host at the care-of address is done by encapsulating the packet with another IP header destined for the care-of address\n When the encapsulated packet arrives at the care-of address  the outer IP header is removed to reveal the packet\n As with many Internet protocols  the devil is in the details  and most often the details of compatibility with other protocols that are deployed\n There are two complications\n First  NAT boxes depend on peeking past the IP header to look at the TCP or UDP header\n The original form of tunneling for mobile IP did not use these headers  so it did not work with NAT boxes\n The solution was to change the encapsulation to include a UDP header\n The ond complication is that some ISPs check the source IP addresses of packets to see that they match where the routing protocol believes the source should be located\n This technique is called ingress filtering  and it is a urity THE NETWORK LAYER  \n  measure intended to discard traffic with seemingly incorrect addresses that may be malicious\n However  packets sent from the mobile to other Internet hosts when it is on a foreign network will have a source IP address that is out of place  so they will be discarded\n To get around this problem  the mobile can use the care-of address as a source to tunnel the packets back to the home agent\n From here  they are sent into the Internet from what appears to be the right location\n The cost is that the route is more roundabout\n Another issue we have not discussed is urity\n When a home agent gets a message asking it to please forward all of Roberta’s packets to some IP address  it had better not comply unless it is convinced that Roberta is the source of this request  and not somebody trying to impersonate her\n Cryptographic authentication protocols are used for this purpose\n We will study such protocols in   Mobility protocols for IPv  build on the IPv  foundation\n The scheme above suffers from the triangle routing problem in which packets sent to the mobile take a dogleg through a distant home agent\n In IPv  route optimization is used to follow a direct path between the mobile and other IP addresses after the initial packets have followed the long route\n Mobile IPv  is defined in RFC \n There is another kind of mobility that is also being defined for the Internet\n Some airplanes have built-in wireless networking that passengers can use to connect their laptops to the Internet\n The plane has a router that connects to the rest of the Internet via a wireless link\n (Did you expect a wired link?) So now we have a flying router  which means that the whole network is mobile\n Network mobility designs support this situation without the laptops realizing that the plane is mobile\n As far as they are concerned  it is just another network\n Of course  some of the laptops may be using mobile IP to keep their home addresses while they are on the plane  so we have two levels of mobility\n Network mobility is defined for IPv  in RFC   SUMMARY The network layer provides services to the transport layer\n It can be based on either datagrams or virtual circuits\n In both cases  its main job is routing packets from the source to the destination\n In datagram networks  a routing decision is made on every packet\n In virtual-circuit networks  it is made when the virtual circuit is set up\n Many routing algorithms are used in computer networks\n Flooding is a simple algorithm to send a packet along all paths\n Most algorithms find the shortest path and adapt to changes in the network topology\n The main algorithms are distance vector routing and link state routing\n Most actual networks use one of these\n Other important routing topics are the use of hierarchy in large networks  routing for mobile hosts  and broadcast  multicast  and anycast routing\n   SUMMARY Networks can easily become congested  leading to increased delay and lost packets\n Network designers attempt to avoid congestion by designing the network to have enough capacity  choosing uncongested routes  refusing to accept more traffic  signaling sources to slow down  and shedding load\n The next step beyond just dealing with congestion is to actually try to achieve a promised quality of service\n Some applications care more about throughput whereas others care more about delay and jitter\n The methods that can be used to provide different qualities of service include a combination of traffic shaping  reserving resources at routers  and admission control\n Approaches that have been designed for good quality of service include IETF integrated services (including RSVP) and differentiated services\n Networks differ in various ways  so when multiple networks are interconnected  problems can occur\n When different networks have different maximum packet sizes  fragmentation may be needed\n Different networks may run different routing protocols internally but need to run a common protocol externally\n Sometimes the problems can be finessed by tunneling a packet through a hostile network  but if the source and destination networks are different  this approach fails\n The Internet has a rich variety of protocols related to the network layer\n These include the datagram protocol  IP  and associated control protocols such as ICMP  ARP  and DHCP\n A connection-oriented protocol called MPLS carries IP packets across some networks\n One of the main routing protocols used within networks is OSPF  and the routing protocol used across networks is BGP\n The Internet is rapidly running out of IP addresses  so a new version of IP  IPv  has been developed and is ever-so-slowly being deployed\n PROBLEMS  \n Give two example computer applications for which connection-oriented service is appropriate\n Now give two examples for which connectionless service is best Datagram networks route each packet as a separate unit  independent of all others\n Virtual-circuit networks do not have to do this  since each data packet follows a predetermined route\n Does this observation mean that virtual-circuit networks do not need the capability to route isolated packets from an arbitrary source to an arbitrary destination? Explain your answer Give three examples of protocol parameters that might be negotiated when a connection is set up Assuming that all routers and hosts are working properly and that all software in both is free of all errors  is there any chance  however small  that a packet will be delivered to the wrong destination? THE NETWORK LAYER  \n   \n Give a simple heuristic for finding two paths through a network from a given source to a given destination that can survive the loss of any communication line (assuming two such paths exist)\n The routers are considered reliable enough  so it is not necessary to worry about the possibility of router crashes Consider the network of Fig\n  -  (a)\n Distance vector routing is used  and the following vectors have just come in to router C: from B: (    ); from D: (     ); and from E: (   )\n The cost of the links from C to B  D  and E  are  and   respectively\n What is C’s new routing table? Give both the outgoing line to use and the cost If costs are recorded as  -bit numbers in a  -router network  and distance vectors are exchanged twice a ond  how much bandwidth per (full-duplex) line is chewed up by the distributed routing algorithm? Assume that each router has three lines to other routers In Fig\n  -  the Boolean OR of the two sets of ACF bits are in every row\n Is this just an accident here  or does it hold for all networks under all circumstances?  \n For hierarchical routing with  routers  what region and cluster sizes should be chosen to minimize the size of the routing table for a three-layer hierarchy? A good starting place is the hypothesis that a solution with k clusters of k regions of k routers is close to optimal  which means that k is about the cube root of  (around  )\n Use trial and error to check out combinations where all three parameters are in the general vicinity of   In the text it was stated that when a mobile host is not at home  packets sent to its home LAN are intercepted by its home agent on that LAN\n For an IP network on an   \n  LAN  how does the home agent accomplish this interception?  \n Looking at the network of Fig\n  -  how many packets are generated by a broadcast from B  using (a) reverse path forwarding? (b) the sink tree?  \n Consider the network of Fig\n  -  (a)\n Imagine that one new line is added  between F and G  but the sink tree of Fig\n  -  (b) remains unchanged\n What changes occur to Fig\n  -  (c)?  \n Compute a multicast spanning tree for router C in the following network for a group with members at routers A  B  C  D  E  F  I  and K\n A G H I L D K B C F E J  \n  PROBLEMS  \n Suppose that node B in Fig\n  -  has just rebooted and has no routing information in its tables\n It suddenly needs a route to H\n It sends out broadcasts with TtL set to  and so on\n How many rounds does it take to find a route?  \n As a possible congestion control mechanism in a network using virtual circuits internally  a router could refrain from acknowledging a received packet until ( ) it knows its last transmission along the virtual circuit was received successfully and ( ) it has a free buffer\n For simplicity  assume that the routers use a stop-and-wait protocol and that each virtual circuit has one buffer dedicated to it for each direction of traffic\n If it takes T  to transmit a packet (data or acknowledgement) and there are n routers on the path  what is the rate at which packets are delivered to the destination host? Assume that transmission errors are rare and that the host-router connection is infinitely fast A datagram network allows routers to drop packets whenever they need to\n The probability of a router discarding a packet is p\n Consider the case of a source host connected to the source router  which is connected to the destination router  and then to the destination host\n If either of the routers discards a packet  the source host eventually times out and tries again\n If both host-router and router-router lines are counted as hops  what is the mean number of (a) hops a packet makes per transmission? (b) transmissions a packet makes? (c) hops required per received packet?  \n Describe two major differences between the ECN method and the RED method of congestion avoidance A token bucket scheme is used for traffic shaping\n A new token is put into the bucket every  μ\n Each token is good for one short packet  which contains   bytes of data\n What is the maximum sustainable data rate?  \n A computer on a  -Mbps network is regulated by a token bucket\n The token bucket is filled at a rate of  Mbps\n It is initially filled to capacity with  megabits\n How long can the computer transmit at the full  Mbps?  \n The network of Fig\n  -  uses RSVP with multicast trees for hosts  and  as shown\n Suppose that host  requests a channel of bandwidth  MB/ for a flow from host  and another channel of bandwidth  MB/ for a flow from host  \n At the same time  host  requests a channel of bandwidth  MB/ for a flow from host  and host  requests a channel of bandwidth  MB/ for a flow from host  \n How much total bandwidth will be reserved for these requests at routers A  B  C  E  H  J  K  and L?  \n A router can process  million packets/\n The load offered to it is  \n  million packets/  on average\n If a route from source to destination contains   routers  how much time is spent being queued and serviced by the router?  \n Consider the user of differentiated services with expedited forwarding\n Is there a guarantee that expedited packets experience a shorter delay than regular packets? Why or why not? THE NETWORK LAYER   Suppose that host A is connected to a router R   R  is connected to another router  R   and R  is connected to host B\n Suppose that a TCP message that contains bytes of data and   bytes of TCP header is passed to the IP code at host A for delivery to B\n Show the Total length  Identification  DF  MF  and Fragment offset fields of the IP header in each packet transmitted over the three links\n Assume that link A-R  can support a maximum frame size of  bytes including a  -byte frame header  link R -R  can support a maximum frame size of bytes  including an  -byte frame header  and link R -B can support a maximum frame size of bytes including a  -byte frame header A router is blasting out IP packets whose total length (data plus header) is  bytes\n Assuming that packets live for     what is the maximum line speed the router can operate at without danger of cycling through the IP datagram ID number space?  \n An IP datagram using the Strict source routing option has to be fragmented\n Do you think the option is copied into each fragment  or is it sufficient to just put it in the first fragment? Explain your answer Suppose that instead of using   bits for the network part of a class B address originally bits had been used\n How many class B networks would there have been?  \n Convert the IP address whose hexadecimal representation is C  F to dotted decimal notation A network on the Internet has a subnet mask of      What is the maximum number of hosts it can handle?  \n While IP addresses are tried to specific networks  Ethernet addresses are not\n Can you think of a good reason why they are not?  \n A large number of conutive IP addresses are available starting at   \n   \n Suppose that four organizations  A  B  C  and D  request     and  addresses  respectively  and in that order\n For each of these  give the first IP address assigned  the last IP address assigned  and the mask in the  \n /s notation A router has just received the following new IP addresses:    \n /    \n /    \n /   and    \n /  \n If all of them use the same outgoing line  can they be aggregated? If so  to what? If not  why not?  \n The set of IP addresses from  \n    to    \n   has been aggregated to  \n   /  \n However  there is a gap of  unassigned addresses from    \n  to    \n   that are now suddenly assigned to a host using a different outgoing line\n Is it now necessary to split up the aggregate address into its constituent blocks  add the new block to the table  and then see if any reaggregation is possible? If not  what can be done instead?  \n A router has the following (CIDR) entries in its routing table: Address/mask Next hop     \n /  Interface    \n /  Interface    \n /  Router  default Router \n  PROBLEMS For each of the following IP addresses  what does the router do if a packet with that address arrives? (a)     \n  (b)     \n  (c)     \n  (d)     \n  (e)     \n   \n Many companies have a policy of having two (or more) routers connecting the company to the Internet to provide some redundancy in case one of them goes down\n Is this policy still possible with NAT? Explain your answer You have just explained the ARP protocol to a friend\n When you are all done  he says: ‘‘I’ve got it\n ARP provides a service to the network layer  so it is part of the data link layer\n’’ What do you say to him?  \n Describe a way to reassemble IP fragments at the destination Most IP datagram reassembly algorithms have a timer to avoid having a lost fragment tie up reassembly buffers forever\n Suppose that a datagram is fragmented into four fragments\n The first three fragments arrive  but the last one is delayed\n Eventually  the timer goes off and the three fragments in the receiver’s memory are discarded\n A little later  the last fragment stumbles in\n What should be done with it?  \n In IP  the checksum covers only the header and not the data\n Why do you suppose this design was chosen?  \n A person who lives in Boston travels to Minneapolis  taking her portable computer with her\n To her surprise  the LAN at her destination in Minneapolis is a wireless IP LAN  so she does not have to plug in\n Is it still necessary to go through the entire business with home agents and foreign agents to make email and other traffic arrive correctly?  \n IPv  uses  -byte addresses\n If a block of  million addresses is allocated every picoond  how long will the addresses last?  \n The Protocol field used in the IPv  header is not present in the fixed IPv  header\n Why not?  \n When the IPv  protocol is introduced  does the ARP protocol have to be changed? If so  are the changes conceptual or technical?  \n Write a program to simulate routing using flooding\n Each packet should contain a counter that is decremented on each hop\n When the counter gets to zero  the packet is discarded\n Time is discrete  with each line handling one packet per time interval\n Make three versions of the program: all lines are flooded  all lines except the input line are flooded  and only the (statically chosen) best k lines are flooded\n Compare flooding with deterministic routing (k =  ) in terms of both delay and the bandwidth used Write a program that simulates a computer network using discrete time\n The first packet on each router queue makes one hop per time interval\n Each router has only a finite number of buffers\n If a packet arrives and there is no room for it  it is discarded THE NETWORK LAYER  \n  and not retransmitted\n Instead  there is an end-to-end protocol  complete with timeouts and acknowledgement packets  that eventually regenerates the packet from the source router\n Plot the throughput of the network as a function of the end-to-end timeout interval  parameterized by error rate Write a function to do forwarding in an IP router\n The procedure has one parameter  an IP address\n It also has access to a global table consisting of an array of triples\n Each triple contains three integers: an IP address  a subnet mask  and the outline line to use\n The function looks up the IP address in the table using CIDR and returns the line to use as its value Use the traceroute (UNIX) or tracert (Windows) programs to trace the route from your computer to various universities on other continents\n Make a list of transoceanic links you have discovered\n Some sites to try are   (California)   (Massachusetts)   (Amsterdam)  \n  (London)  \n  (Sydney)  -  (Tokyo)  \n  (Cape Town)  THE TRANSPORT LAYER Together with the network layer  the transport layer is the heart of the protocol hierarchy\n The network layer provides end-to-end packet delivery using datagrams or virtual circuits\n The transport layer builds on the network layer to provide data transport from a process on a source machine to a process on a destination machine with a desired level of reliability that is independent of the physical networks currently in use\n It provides the abstractions that applications need to use the network\n Without the transport layer  the whole concept of layered protocols would make little sense\n In this  ter  we will study the transport layer in detail  including its services and choice of API design to tackle issues of reliability  connections and congestion control  protocols such as TCP and UDP  and performance  THE TRANSPORT SERVICE In the following tions  we will provide an introduction to the transport service\n We look at what kind of service is provided to the application layer\n To make the issue of transport service more concrete  we will examine two sets of transport layer primitives\n First comes a simple (but hypothetical) one to show the basic ideas\n Then comes the interface commonly used in the Internet\n    THE TRANSPORT LAYER  \n     Services Provided to the Upper Layers The ultimate goal of the transport layer is to provide efficient  reliable  and cost-effective data transmission service to its users  normally processes in the application layer\n To achieve this  the transport layer makes use of the services provided by the network layer\n The software and/or hardware within the transport layer that does the work is called the transport entity\n The transport entity can be located in the operating system kernel  in a library package bound into network applications  in a separate user process  or even on the network interface card\n The first two options are most common on the Internet\n The (logical) relationship of the network  transport  and application layers is illustrated in Fig\n  - \n Application/transport interface Transport/network interface Application (or session) layer Transport entity Transport address Network address Network layer Application (or session) layer Transport entity Network layer Segment Transport protocol Host  Host  Figure  - \n The network  transport  and application layers\n Just as there are two types of network service  connection-oriented and connectionless  there are also two types of transport service\n The connection-oriented transport service is similar to the connection-oriented network service in many ways\n In both cases  connections have three phases: establishment  data transfer  and release\n Addressing and flow control are also similar in both layers\n Furthermore  the connectionless transport service is also very similar to the connectionless network service\n However  note that it can be difficult to provide a connectionless transport service on top of a connection-oriented network service  since it is inefficient to set up a connection to send a single packet and then tear it down immediately afterwards\n The obvious question is this: if the transport layer service is so similar to the network layer service  why are there two distinct layers? Why is one layer not   THE TRANSPORT SERVICE adequate? The answer is subtle  but crucial\n The transport code runs entirely on the users’ machines  but the network layer mostly runs on the routers  which are operated by the carrier (at least for a wide area network)\n What happens if the network layer offers inadequate service? What if it frequently loses packets? What happens if routers crash from time to time? Problems occur  that’s what\n The users have no real control over the network layer  so they cannot solve the problem of poor service by using better routers or putting more error handling in the data link layer because they don’t own the routers\n The only possibility is to put on top of the network layer another layer that improves the quality of the service\n If  in a connectionless network  packets are lost or mangled  the transport entity can detect the problem and compensate for it by using retransmissions\n If  in a connection-oriented network  a transport entity is informed halfway through a long transmission that its network connection has been abruptly terminated  with no indication of what has happened to the data currently in transit  it can set up a new network connection to the remote transport entity\n Using this new network connection  it can send a query to its peer asking which data arrived and which did not  and knowing where it was  pick up from where it left off\n In essence  the existence of the transport layer makes it possible for the transport service to be more reliable than the underlying network\n Furthermore  the transport primitives can be implemented as calls to library procedures to make them independent of the network primitives\n The network service calls may vary considerably from one network to another ( \n  calls based on a connectionless Ethernet may be quite different from calls on a connection-oriented WiMAX network)\n Hiding the network service behind a set of transport service primitives ensures that changing the network merely requires replacing one set of library procedures with another one that does the same thing with a different underlying service\n Thanks to the transport layer  application programmers can write code according to a standard set of primitives and have these programs work on a wide variety of networks  without having to worry about dealing with different network interfaces and levels of reliability\n If all real networks were flawless and all had the same service primitives and were guaranteed never  ever to change  the transport layer might not be needed\n However  in the real world it fulfills the key function of isolating the upper layers from the technology  design  and imperfections of the network\n For this reason  many people have made a qualitative distinction between layers  through  on the one hand and layer(s) above  on the other\n The bottom four layers can be seen as the transport service provider  whereas the upper layer(s) are the transport service user\n This distinction of provider versus user has a considerable impact on the design of the layers and puts the transport layer in a key position  since it forms the major boundary between the provider and user of the reliable data transmission service\n It is the level that applications see\n THE TRANSPORT LAYER  \n     Transport Service Primitives To allow users to access the transport service  the transport layer must provide some operations to application programs  that is  a transport service interface\n Each transport service has its own interface\n In this tion  we will first examine a simple (hypothetical) transport service and its interface to see the bare essentials\n In the following tion  we will look at a real example\n The transport service is similar to the network service  but there are also some important differences\n The main difference is that the network service is intended to model the service offered by real networks  warts and all\n Real networks can lose packets  so the network service is generally unreliable\n The connection-oriented transport service  in contrast  is reliable\n Of course  real networks are not error-free  but that is precisely the purpose of the transport layer—to provide a reliable service on top of an unreliable network\n As an example  consider two processes on a single machine connected by a pipe in UNIX (or any other interprocess communication facility)\n They assume the connection between them is   % perfect\n They do not want to know about acknowledgements  lost packets  congestion  or anything at all like that\n What they want is a   % reliable connection\n Process A puts data into one end of the pipe  and process B takes it out of the other\n This is what the connection-oriented transport service is all about—hiding the imperfections of the network service so that user processes can just assume the existence of an error-free bit stream even when they are on different machines\n As an aside  the transport layer can also provide unreliable (datagram) service\n However  there is relatively little to say about that besides ‘‘it’s datagrams ’’ so we will mainly concentrate on the connection-oriented transport service in this  ter\n Nevertheless  there are some applications  such as client-server computing and streaming multimedia  that build on a connectionless transport service  and we will say a little bit about that later on\n A ond difference between the network service and transport service is whom the services are intended for\n The network service is used only by the transport entities\n Few users write their own transport entities  and thus few users or programs ever see the bare network service\n In contrast  many programs (and thus programmers) see the transport primitives\n Consequently  the transport service must be convenient and easy to use\n To get an idea of what a transport service might be like  consider the five primitives listed in Fig\n  - \n This transport interface is truly bare bones  but it gives the essential flavor of what a connection-oriented transport interface has to do\n It allows application programs to establish  use  and then release connections  which is sufficient for many applications\n To see how these primitives might be used  consider an application with a server and a number of remote clients\n To start with  the server executes a LISTEN primitive  typically by calling a library procedure that makes a system call that   THE TRANSPORT SERVICE Primitive Packet sent Meaning LISTEN (none) Block until some process tries to connect CONNECT CONNECTION REQ\n Actively attempt to establish a connection SEND DATA Send information RECEIVE (none) Block until a DATA packet arrives DISCONNECT DISCONNECTION REQ\n Request a release of the connection Figure  - \n The primitives for a simple transport service\n blocks the server until a client turns up\n When a client wants to talk to the server  it executes a CONNECT primitive\n The transport entity carries out this primitive by blocking the caller and sending a packet to the server\n Encapsulated in the payload of this packet is a transport layer message for the server’s transport entity\n A quick note on terminology is now in order\n For lack of a better term  we will use the term segment for messages sent from transport entity to transport entity\n TCP  UDP and other Internet protocols use this term\n Some older protocols used the ungainly name TPDU (Transport Protocol Data Unit)\n That term is not used much any more now but you may see it in older papers and books\n Thus  segments (exchanged by the transport layer) are contained in packets (exchanged by the network layer)\n In turn  these packets are contained in frames (exchanged by the data link layer)\n When a frame arrives  the data link layer processes the frame header and  if the destination address matches for local delivery  passes the contents of the frame payload field up to the network entity\n The network entity similarly processes the packet header and then passes the contents of the packet payload up to the transport entity\n This nesting is illustrated in Fig\n  - \n Frame header Packet header Segment header Segment payload Frame payload Packet payload Figure  - \n Nesting of segments  packets  and frames\n Getting back to our client-server example  the client’s CONNECT call causes a CONNECTION REQUEST segment to be sent to the server\n When it arrives  the THE TRANSPORT LAYER  \n  transport entity checks to see that the server is blocked on a LISTEN ( \n  is interested in handling requests)\n If so  it then unblocks the server and sends a CONNECTION ACCEPTED segment back to the client\n When this segment arrives  the client is unblocked and the connection is established\n Data can now be exchanged using the SEND and RECEIVE primitives\n In the simplest form  either party can do a (blocking) RECEIVE to wait for the other party to do a SEND\n When the segment arrives  the receiver is unblocked\n It can then process the segment and send a reply\n As long as both sides can keep track of whose turn it is to send  this scheme works fine\n Note that in the transport layer  even a simple unidirectional data exchange is more complicated than at the network layer\n Every data packet sent will also be acknowledged (eventually)\n The packets bearing control segments are also acknowledged  implicitly or explicitly\n These acknowledgements are managed by the transport entities  using the network layer protocol  and are not visible to the transport users\n Similarly  the transport entities need to worry about timers and retransmissions\n None of this machinery is visible to the transport users\n To the transport users  a connection is a reliable bit pipe: one user stuffs bits in and they magically appear in the same order at the other end\n This ability to hide complexity is the reason that layered protocols are such a powerful tool\n When a connection is no longer needed  it must be released to free up table space within the two transport entities\n Disconnection has two variants: asymmetric and symmetric\n In the asymmetric variant  either transport user can issue a DISCONNECT primitive  which results in a DISCONNECT segment being sent to the remote transport entity\n Upon its arrival  the connection is released\n In the symmetric variant  each direction is closed separately  independently of the other one\n When one side does a DISCONNECT  that means it has no more data to send but it is still willing to accept data from its partner\n In this model  a connection is released when both sides have done a DISCONNECT\n A state diagram for connection establishment and release for these simple primitives is given in Fig\n  - \n Each transition is triggered by some event  either a primitive executed by the local transport user or an incoming packet\n For simplicity  we assume here that each segment is separately acknowledged\n We also assume that a symmetric disconnection model is used  with the client going first\n Please note that this model is quite unsophisticated\n We will look at more realistic models later on when we describe how TCP works\n    Berkeley Sockets Let us now briefly inspect another set of transport primitives  the socket primitives as they are used for TCP\n Sockets were first released as part of the Berkeley UNIX  \n BSD software distribution in \n They quickly became popular\n The primitives are now widely used for Internet programming on many operating   THE TRANSPORT SERVICE ACTIVE ESTABLISHMENT PENDING PASSIVE ESTABLISHMENT PENDING PASSIVE DISCONNECT PENDING ACTIVE DISCONNECT PENDING IDLE IDLE ESTABLISHED Disconnection request segment received Disconnect primitive executed Disconnect primitive executed Disconnection request segment received Connection request segment received Connection accepted segment received Connect primitive executed Connect primitive executed Figure  - \n A state diagram for a simple connection management scheme\n Transitions labeled in italics are caused by packet arrivals\n The solid lines show the client’s state sequence\n The dashed lines show the server’s state sequence\n systems  especially UNIX-based systems  and there is a socket-style API for Windows called ‘‘winsock\n’’ The primitives are listed in Fig\n  - \n Roughly speaking  they follow the model of our first example but offer more features and flexibility\n We will not look at the corresponding segments here\n That discussion will come later\n Primitive Meaning SOCKET Create a new communication endpoint BIND Associate a local address with a socket LISTEN Announce willingness to accept connections; give queue size ACCEPT Passively establish an incoming connection CONNECT Actively attempt to establish a connection SEND Send some data over the connection RECEIVE Receive some data from the connection CLOSE Release the connection Figure  - \n The socket primitives for TCP\n THE TRANSPORT LAYER  \n  The first four primitives in the list are executed in that order by servers\n The SOCKET primitive creates a new endpoint and allocates table space for it within the transport entity\n The parameters of the call specify the addressing format to be used  the type of service desired ( \n  reliable byte stream)  and the protocol\n A successful SOCKET call returns an ordinary file descriptor for use in succeeding calls  the same way an OPEN call on a file does\n Newly created sockets do not have network addresses\n These are assigned using the BIND primitive\n Once a server has bound an address to a socket  remote clients can connect to it\n The reason for not having the SOCKET call create an address directly is that some processes care about their addresses ( \n  they have been using the same address for years and everyone knows this address)  whereas others do not\n Next comes the LISTEN call  which allocates space to queue incoming calls for the case that several clients try to connect at the same time\n In contrast to LISTEN in our first example  in the socket model LISTEN is not a blocking call\n To block waiting for an incoming connection  the server executes an ACCEPT primitive\n When a segment asking for a connection arrives  the transport entity creates a new socket with the same properties as the original one and returns a file descriptor for it\n The server can then fork off a process or thread to handle the connection on the new socket and go back to waiting for the next connection on the original socket\n ACCEPT returns a file descriptor  which can be used for reading and writing in the standard way  the same as for files\n Now let us look at the client side\n Here  too  a socket must first be created using the SOCKET primitive  but BIND is not required since the address used does not matter to the server\n The CONNECT primitive blocks the caller and actively starts the connection process\n When it completes ( \n  when the appropriate segment is received from the server)  the client process is unblocked and the connection is established\n Both sides can now use SEND and RECEIVE to transmit and receive data over the full-duplex connection\n The standard UNIX READ and WRITE system calls can also be used if none of the special options of SEND and RECEIVE are required\n Connection release with sockets is symmetric\n When both sides have executed a CLOSE primitive  the connection is released\n Sockets have proved tremendously popular and are the de facto standard for abstracting transport services to applications\n The socket API is often used with the TCP protocol to provide a connection-oriented service called a reliable byte stream  which is simply the reliable bit pipe that we described\n However  other protocols could be used to implement this service using the same API\n It should all be the same to the transport service users\n A strength of the socket API is that is can be used by an application for other transport services\n For instance  sockets can be used with a connectionless transport service\n In this case  CONNECT sets the address of the remote transport peer and SEND and RECEIVE send and receive datagrams to and from the remote peer\n   THE TRANSPORT SERVICE (It is also common to use an expanded set of calls  for example  SENDTO and RECEIVEFROM  that emphasize messages and do not limit an application to a single transport peer\n) Sockets can also be used with transport protocols that provide a message stream rather than a byte stream and that do or do not have congestion control\n For example  DCCP (Datagram Congestion Controlled Protocol) is a version of UDP with congestion control (Kohler et al\n  )\n It is up to the transport users to understand what service they are getting\n However  sockets are not likely to be the final word on transport interfaces\n For example  applications often work with a group of related streams  such as a Web browser that requests several objects from the same server\n With sockets  the most natural fit is for application programs to use one stream per object\n This structure means that congestion control is applied separately for each stream  not across the group  which is suboptimal\n It punts to the application the burden of managing the set\n Newer protocols and interfaces have been devised that support groups of related streams more effectively and simply for the application\n Two examples are SCTP (Stream Control Transmission Protocol) defined in RFC  and SST (Structured Stream Transport) (Ford  )\n These protocols must change the socket API slightly to get the benefits of groups of related streams  and they also support features such as a mix of connection-oriented and connectionless traffic and even multiple network paths\n Time will tell if they are successful\n    An Example of Socket Programming: An Internet File Server As an example of the nitty-gritty of how real socket calls are made  consider the client and server code of Fig\n  - \n Here we have a very primitive Internet file server along with an example client that uses it\n The code has many limitations (discussed below)  but in principle the server code can be compiled and run on any UNIX system connected to the Internet\n The client code can be compiled and run on any other UNIX machine on the Internet  anywhere in the world\n The client code can be executed with appropriate parameters to fetch any file to which the server has access on its machine\n The file is written to standard output  which  of course  can be redirected to a file or pipe\n Let us look at the server code first\n It starts out by including some standard headers  the last three of which contain the main Internet-related definitions and data structures\n Next comes a definition of SERVER PORT as  \n This number was chosen arbitrarily\n Any number between  and  will work just as well  as long as it is not in use by some other process; ports below  are reserved for privileged users\n The next two lines in the server define two constants needed\n The first one determines the chunk size in bytes used for the file transfer\n The ond one determines how many pending connections can be held before additional ones are discarded upon arrival\n THE TRANSPORT LAYER  \n  /* This page contains a client program that can request a file from the server program * on the next page\n The server responds by sending the whole file\n */ #include <sys/ > #include <sys/ > #include <netinet/ > #include < > #define SERVER PORT  /* arbitrary  but client & server must agree */ #define BUF SIZE  /* block transfer size */ int main(int argc  char **argv) { int c  s  bytes; char buf[BUF SIZE]; /* buffer for incoming file */ struct hostent *h; /* info about server */ struct sockaddr in channel; /* holds IP address */ if (argc !=  ) fatal("Usage: client server-name file-name"); h = gethostbyname(argv[ ]); /* look up host’s IP address */ if (!h) fatal("gethostbyname failed"); s = socket(PF INET  SOCK STREAM  IPPROTO TCP); if (s < ) fatal("socket"); memset(&channel sizeof(channel));   family= AF INET; memcpy(&    addr  h->h addr  h->h length);   port= htons(SERVER PORT); c = connect(s  (struct sockaddr *) &channel  sizeof(channel)); if (c <  ) fatal("connect failed"); /* Connection is now established\n Send file name including  byte at end\n */ write(s  argv[ ]  strlen(argv[ ])+ ); /* Go get the file and write it to standard output\n */ while ( ) { bytes = read(s  buf  BUF SIZE); /* read from socket */ if (bytes <=  ) exit( ); /* check for end of file */ write(  buf  bytes); /* write to standard output */ } } fatal(char *string) { printf("%s\n"  string); exit( ); } Figure  - \n Client code using sockets\n The server code is on the next page\n   THE TRANSPORT SERVICE #include <sys/ > /* This is the server code */ #include <sys/ > #include <sys/ > #include <netinet/ > #include < > #define SERVER PORT  /* arbitrary  but client & server must agree */ #define BUF SIZE  /* block transfer size */ #define QUEUE SIZE   int main(int argc  char *argv[]) { int s  b  l  fd  sa  bytes  on =  ; char buf[BUF SIZE]; /* buffer for outgoing file */ struct sockaddr in channel; /* holds IP address */ /* Build address structure to bind to socket\n */ memset(&channel sizeof(channel)); /* zero channel */   family = AF INET;     addr = htonl(INADDR ANY);   port = htons(SERVER PORT); /* Passive open\n Wait for connection\n */ s = socket(AF INET  SOCK STREAM  IPPROTO TCP); /* create socket */ if (s <  ) fatal("socket failed"); setsockopt(s  SOL SOCKET  SO REUSEADDR  (char *) &on  sizeof(on)); b = bind(s  (struct sockaddr *) &channel  sizeof(channel)); if (b <  ) fatal("bind failed"); l = listen(s  QUEUE SIZE); /* specify queue size */ if (l <  ) fatal("listen failed"); /* Socket is now set up and bound\n Wait for connection and process it\n */ while ( ) { sa = accept(s  ); /* block for connection request */ if (sa <  ) fatal("accept failed"); read(sa  buf  BUF SIZE); /* read file name from socket */ /* Get and return the file\n */ fd = open(buf  O RDONLY); /* open the file to be sent back */ if (fd <  ) fatal("open failed"); while ( ) { bytes = read(fd  buf  BUF SIZE); /* read from file */ if (bytes <=  ) break; /* check for end of file */ write(sa  buf  bytes); /* write bytes to socket */ } close(fd); /* close file */ close(sa); /* close connection */ } } THE TRANSPORT LAYER  \n  After the declarations of local variables  the server code begins\n It starts out by initializing a data structure that will hold the server’s IP address\n This data structure will soon be bound to the server’s socket\n The call to memset sets the data structure to all  s\n The three assignments following it fill in three of its fields\n The last of these contains the server’s port\n The functions htonl and htons have to do with converting values to a standard format so the code runs correctly on both little-endian machines ( \n  Intel x  ) and big-endian machines ( \n  the SPARC)\n Their exact semantics are not relevant here\n Next  the server creates a socket and checks for errors (indicated by s <  )\n In a production version of the code  the error message could be a trifle more explanatory\n The call to setsockopt is needed to allow the port to be reused so the server can run indefinitely  fielding request after request\n Now the IP address is bound to the socket and a check is made to see if the call to bind succeeded\n The final step in the initialization is the call to listen to announce the server’s willingness to accept incoming calls and tell the system to hold up to QUEUE SIZE of them in case new requests arrive while the server is still processing the current one\n If the queue is full and additional requests arrive  they are quietly discarded\n At this point  the server enters its main loop  which it never leaves\n The only way to stop it is to kill it from outside\n The call to accept blocks the server until some client tries to establish a connection with it\n If the accept call succeeds  it returns a socket descriptor that can be used for reading and writing  analogous to how file descriptors can be used to read from and write to pipes\n However  unlike pipes  which are unidirectional  sockets are bidirectional  so sa (the accepted socket) can be used for reading from the connection and also for writing to it\n A pipe file descriptor is for reading or writing but not both\n After the connection is established  the server reads the file name from it\n If the name is not yet available  the server blocks waiting for it\n After getting the file name  the server opens the file and enters a loop that alternately reads blocks from the file and writes them to the socket until the entire file has been copied\n Then the server closes the file and the connection and waits for the next connection to show up\n It repeats this loop forever\n Now let us look at the client code\n To understand how it works  it is necessary to understand how it is invoked\n Assuming it is called client  a typical call is client  \n  /usr/tom/filename >f This call only works if the server is already running on  \n  and the file /usr/tom/filename exists and the server has read access to it\n If the call is successful  the file is transferred over the Internet and written to f  after which the client program exits\n Since the server continues after a transfer  the client can be started again and again to get other files\n The client code starts with some includes and declarations\n Execution begins by checking to see if it has been called with the right number of arguments (argc =  means the program name plus two arguments)\n Note that argv [ ] contains the   THE TRANSPORT SERVICE name of the server ( \n   \n ) and is converted to an IP address by gethostbyname\n This function uses DNS to look up the name\n We will study DNS in   Next  a socket is created and initialized\n After that  the client attempts to establish a TCP connection to the server  using connect\n If the server is up and running on the named machine and attached to SERVER PORT and is either idle or has room in its listen queue  the connection will (eventually) be established\n Using the connection  the client sends the name of the file by writing on the socket\n The number of bytes sent is one larger than the name proper  since the  byte terminating the name must also be sent to tell the server where the name ends\n Now the client enters a loop  reading the file block by block from the socket and copying it to standard output\n When it is done  it just exits\n The procedure fatal prints an error message and exits\n The server needs the same procedure  but it was omitted due to lack of space on the page\n Since the client and server are compiled separately and normally run on different computers  they cannot share the code of fatal\n These two programs (as well as other material related to this book) can be fetched from the book’s Web site http:// /tanenbaum Just for the record  this server is not the last word in serverdom\n Its error checking is meager and its error reporting is mediocre\n Since it handles all requests strictly sequentially (because it has only a single thread)  its performance is poor\n It has clearly never heard about urity  and using bare UNIX system calls is not the way to gain platform independence\n It also makes some assumptions that are technically illegal  such as assuming that the file name fits in the buffer and is transmitted atomically\n These shortcomings notwithstanding  it is a working Internet file server\n In the exercises  the reader is invited to improve it\n For more information about programming with sockets  see Donahoo and Calvert (  )  ELEMENTS OF TRANSPORT PROTOCOLS The transport service is implemented by a transport protocol used between the two transport entities\n In some ways  transport protocols resemble the data link protocols we studied in detail in   Both have to deal with error control  sequencing  and flow control  among other issues\n However  significant differences between the two also exist\n These differences are due to major dissimilarities between the environments in which the two protocols operate  as shown in Fig\n  - \n At the data link layer  two routers THE TRANSPORT LAYER  \n  communicate directly via a physical channel  whether wired or wireless  whereas at the transport layer  this physical channel is replaced by the entire network\n This difference has many important implications for the protocols\n Router Router Physical communication channel Host (a) (b) Network Figure  - \n (a) Environment of the data link layer\n (b) Environment of the transport layer\n For one thing  over point-to-point links such as wires or optical fiber  it is usually not necessary for a router to specify which router it wants to talk to—each outgoing line leads directly to a particular router\n In the transport layer  explicit addressing of destinations is required\n For another thing  the process of establishing a connection over the wire of Fig\n  - (a) is simple: the other end is always there (unless it has crashed  in which case it is not there)\n Either way  there is not much to do\n Even on wireless links  the process is not much different\n Just sending a message is sufficient to have it reach all other destinations\n If the message is not acknowledged due to an error  it can be resent\n In the transport layer  initial connection establishment is complicated  as we will see\n Another (exceedingly annoying) difference between the data link layer and the transport layer is the potential existence of storage capacity in the network\n When a router sends a packet over a link  it may arrive or be lost  but it cannot bounce around for a while  go into hiding in a far corner of the world  and suddenly emerge after other packets that were sent much later\n If the network uses datagrams  which are independently routed inside  there is a nonnegligible probability that a packet may take the scenic route and arrive late and out of the expected order  or even that duplicates of the packet will arrive\n The consequences of the network’s ability to delay and duplicate packets can sometimes be disastrous and can require the use of special protocols to correctly transport information\n A final difference between the data link and transport layers is one of degree rather than of kind\n Buffering and flow control are needed in both layers  but the presence in the transport layer of a large and varying number of connections with bandwidth that fluctuates as the connections compete with each other may require a different approach than we used in the data link layer\n Some of the protocols discussed in  \n  allocate a fixed number of buffers to each line  so that when a frame arrives a buffer is always available\n In the transport layer  the larger number of connections that must be managed and variations in the bandwidth each   ELEMENTS OF TRANSPORT PROTOCOLS connection may receive make the idea of dedicating many buffers to each one less attractive\n In the following tions  we will examine all of these important issues  and others\n    Addressing When an application ( \n  a user) process wishes to set up a connection to a remote application process  it must specify which one to connect to\n (Connectionless transport has the same problem: to whom should each message be sent?) The method normally used is to define transport addresses to which processes can listen for connection requests\n In the Internet  these endpoints are called ports\n We will use the generic term TSAP (Transport Service Access Point) to mean a specific endpoint in the transport layer\n The analogous endpoints in the network layer ( \n  network layer addresses) are not-surprisingly called NSAPs (Network Service Access Points)\n IP addresses are examples of NSAPs\n Figure  -  illustrates the relationship between the NSAPs  the TSAPs  and a transport connection\n Application processes  both clients and servers  can attach themselves to a local TSAP to establish a connection to a remote TSAP\n These connections run through NSAPs on each host  as shown\n The purpose of having TSAPs is that in some networks  each computer has a single NSAP  so some way is needed to distinguish multiple transport endpoints that share that NSAP\n Application process Application layer Transport connection TSAP  TSAP  NSAP NSAP Transport layer Network layer Data link layer Physical layer Server  Host  Host  Server  TSAP Figure  - \n TSAPs  NSAPs  and transport connections\n THE TRANSPORT LAYER  \n  A possible scenario for a transport connection is as follows:  \n A mail server process attaches itself to TSAP  on host  to wait for an incoming call\n How a process attaches itself to a TSAP is outside the networking model and depends entirely on the local operating system\n A call such as our LISTEN might be used  for example An application process on host  wants to send an email message  so it attaches itself to TSAP  and issues a CONNECT request\n The request specifies TSAP  on host  as the source and TSAP  on host  as the destination\n This action ultimately results in a transport connection being established between the application process and the server The application process sends over the mail message The mail server responds to say that it will deliver the message The transport connection is released\n Note that there may well be other servers on host  that are attached to other TSAPs and are waiting for incoming connections that arrive over the same NSAP\n The picture painted above is fine  except we have swept one little problem under the rug: how does the user process on host  know that the mail server is attached to TSAP ? One possibility is that the mail server has been attaching itself to TSAP  for years and gradually all the network users have learned this\n In this model  services have stable TSAP addresses that are listed in files in well-known places\n For example  the /etc/services file on UNIX systems lists which servers are permanently attached to which ports  including the fact that the mail server is found on TCP port  \n While stable TSAP addresses work for a small number of key services that never change ( \n  the Web server)  user processes  in general  often want to talk to other user processes that do not have TSAP addresses that are known in advance  or that may exist for only a short time\n To handle this situation  an alternative scheme can be used\n In this scheme  there exists a special process called a portmapper\n To find the TSAP address corresponding to a given service name  such as ‘‘BitTorrent ’’ a user sets up a connection to the portmapper (which listens to a well-known TSAP)\n The user then sends a message specifying the service name  and the portmapper sends back the TSAP address\n Then the user releases the connection with the portmapper and establishes a new one with the desired service\n In this model  when a new service is created  it must register itself with the portmapper  giving both its service name (typically  an ASCII string) and its TSAP\n The portmapper records this information in its internal database so that when queries come in later  it will know the answers\n   ELEMENTS OF TRANSPORT PROTOCOLS The function of the portmapper is analogous to that of a directory assistance operator in the telephone system—it provides a mapping of names onto numbers\n Just as in the telephone system  it is essential that the address of the well-known TSAP used by the portmapper is indeed well known\n If you do not know the number of the information operator  you cannot call the information operator to find it out\n If you think the number you dial for information is obvious  try it in a foreign country sometime\n Many of the server processes that can exist on a machine will be used only rarely\n It is wasteful to have each of them active and listening to a stable TSAP address all day long\n An alternative scheme is shown in Fig\n  -  in a simplified form\n It is known as the initial connection protocol\n Instead of every conceivable server listening at a well-known TSAP  each machine that wishes to offer services to remote users has a special process server that acts as a proxy for less heavily used servers\n This server is called inetd on UNIX systems\n It listens to a set of ports at the same time  waiting for a connection request\n Potential users of a service begin by doing a CONNECT request  specifying the TSAP address of the service they want\n If no server is waiting for them  they get a connection to the process server  as shown in Fig\n  - (a)\n Layer  TSAP Mail server (a) (b) Host  Host  Host  Host  Process server User Process User server Figure  - \n How a user process in host  establishes a connection with a mail server in host  via a process server\n After it gets the incoming request  the process server spawns the requested server  allowing it to inherit the existing connection with the user\n The new server THE TRANSPORT LAYER  \n  does the requested work  while the process server goes back to listening for new requests  as shown in Fig\n  - (b)\n This method is only applicable when servers can be created on demand\n    Connection Establishment Establishing a connection sounds easy  but it is actually surprisingly tricky\n At first glance  it would seem sufficient for one transport entity to just send a CONNECTION REQUEST segment to the destination and wait for a CONNECTION ACCEPTED reply\n The problem occurs when the network can lose  delay  corrupt  and duplicate packets\n This behavior causes serious complications\n Imagine a network that is so congested that acknowledgements hardly ever get back in time and each packet times out and is retransmitted two or three times\n Suppose that the network uses datagrams inside and that every packet follows a different route\n Some of the packets might get stuck in a traffic jam inside the network and take a long time to arrive\n That is  they may be delayed in the network and pop out much later  when the sender thought that they had been lost\n The worst possible nightmare is as follows\n A user establishes a connection with a bank  sends messages telling the bank to transfer a large amount of money to the account of a not-entirely-trustworthy person\n Unfortunately  the packets decide to take the scenic route to the destination and go off exploring a remote corner of the network\n The sender then times out and sends them all again\n This time the packets take the shortest route and are delivered quickly so the sender releases the connection\n Unfortunately  eventually the initial batch of packets finally come out of hiding and arrive at the destination in order  asking the bank to establish a new connection and transfer money (again)\n The bank has no way of telling that these are duplicates\n It must assume that this is a ond  independent transaction  and transfers the money again\n This scenario may sound unlikely  or even implausible but the point is this: protocols must be designed to be correct in all cases\n Only the common cases need be implemented efficiently to obtain good network performance  but the protocol must be able to cope with the uncommon cases without breaking\n If it cannot  we have built a fair-weather network that can fail without warning when the conditions get tough\n For the remainder of this tion  we will study the problem of delayed duplicates  with emphasis on algorithms for establishing connections in a reliable way  so that nightmares like the one above cannot happen\n The crux of the problem is that the delayed duplicates are thought to be new packets\n We cannot prevent packets from being duplicated and delayed\n But if and when this happens  the packets must be rejected as duplicates and not processed as fresh packets\n The problem can be attacked in various ways  none of them very satisfactory\n One way is to use throwaway transport addresses\n In this approach  each time a   ELEMENTS OF TRANSPORT PROTOCOLS transport address is needed  a new one is generated\n When a connection is released  the address is discarded and never used again\n Delayed duplicate packets then never find their way to a transport process and can do no damage\n However  this approach makes it more difficult to connect with a process in the first place\n Another possibility is to give each connection a unique identifier ( \n  a sequence number incremented for each connection established) chosen by the initiating party and put in each segment  including the one requesting the connection\n After each connection is released  each transport entity can update a table listing obsolete connections as (peer transport entity  connection identifier) pairs\n Whenever a connection request comes in  it can be checked against the table to see if it belongs to a previously released connection\n Unfortunately  this scheme has a basic flaw: it requires each transport entity to maintain a certain amount of history information indefinitely\n This history must persist at both the source and destination machines\n Otherwise  if a machine crashes and loses its memory  it will no longer know which connection identifiers have already been used by its peers\n Instead  we need to take a different tack to simplify the problem\n Rather than allowing packets to live forever within the network  we devise a mechanism to kill off aged packets that are still hobbling about\n With this restriction  the problem becomes somewhat more manageable\n Packet lifetime can be restricted to a known maximum using one (or more) of the following techniques:  \n Restricted network design Putting a hop counter in each packet Timestamping each packet\n The first technique includes any method that prevents packets from looping  combined with some way of bounding delay including congestion over the (now known) longest possible path\n It is difficult  given that internets may range from a single city to international in scope\n The ond method consists of having the hop count initialized to some appropriate value and decremented each time the packet is forwarded\n The network protocol simply discards any packet whose hop counter becomes zero\n The third method requires each packet to bear the time it was created  with the routers agreeing to discard any packet older than some agreed-upon time\n This latter method requires the router clocks to be synchronized  which itself is a nontrivial task  and in practice a hop counter is a close enough approximation to age\n In practice  we will need to guarantee not only that a packet is dead  but also that all acknowledgements to it are dead  too  so we will now introduce a period T  which is some small multiple of the true maximum packet lifetime\n The maximum packet lifetime is a conservative constant for a network; for the Internet  it is somewhat arbitrarily taken to be onds\n The multiple is protocol dependent THE TRANSPORT LAYER  \n  and simply has the effect of making T longer\n If we wait a time T s after a packet has been sent  we can be sure that all traces of it are now gone and that neither it nor its acknowledgements will suddenly appear out of the blue to complicate matters\n With packet lifetimes bounded  it is possible to devise a practical and foolproof way to reject delayed duplicate segments\n The method described below is due to Tomlinson (   )  as refined by Sunshine and Dalal (   )\n Variants of it are widely used in practice  including in TCP\n The heart of the method is for the source to label segments with sequence numbers that will not be reused within T s\n The period  T  and the rate of packets per ond determine the size of the sequence numbers\n In this way  only one packet with a given sequence number may be outstanding at any given time\n Duplicates of this packet may still occur  and they must be discarded by the destination\n However  it is no longer the case that a delayed duplicate of an old packet may beat a new packet with the same sequence number and be accepted by the destination in its stead\n To get around the problem of a machine losing all memory of where it was after a crash  one possibility is to require transport entities to be idle for T s after a recovery\n The idle period will let all old segments die off  so the sender can start again with any sequence number\n However  in a complex internetwork  T may be large  so this strategy is unattractive\n Instead  Tomlinson proposed equipping each host with a time-of-day clock\n The clocks at different hosts need not be synchronized\n Each clock is assumed to take the form of a binary counter that increments itself at uniform intervals\n Furthermore  the number of bits in the counter must equal or exceed the number of bits in the sequence numbers\n Last  and most important  the clock is assumed to continue running even if the host goes down\n When a connection is set up  the low-order k bits of the clock are used as the k-bit initial sequence number\n Thus  unlike our protocols of  \n   each connection starts numbering its segments with a different initial sequence number\n The sequence space should be so large that by the time sequence numbers wrap around  old segments with the same sequence number are long gone\n This linear relation between time and initial sequence numbers is shown in Fig\n  -  (a)\n The forbidden region shows the times for which segment sequence numbers are illegal leading up to their use\n If any segment is sent with a sequence number in this region  it could be delayed and impersonate a different packet with the same sequence number that will be issued slightly later\n For example  if the host crashes and restarts at time   onds  it will use initial sequence numbers based on the clock to pick up after it left off; the host does not start with a lower sequence number in the forbidden region\n Once both transport entities have agreed on the initial sequence number  any sliding window protocol can be used for data flow control\n This window protocol will correctly find and discard duplicates of packets after they have already been   ELEMENTS OF TRANSPORT PROTOCOLS      Time (a) Time (b)  Sequence numbers Sequence numbers Restart after crash with   T T Actual sequence numbers used  k–  Forbidden region Figure  -  \n (a) Segments may not enter the forbidden region\n (b) The resynchronization problem\n accepted\n In reality  the initial sequence number curve (shown by the heavy line) is not linear  but a staircase  since the clock advances in discrete steps\n For simplicity  we will ignore this detail\n To keep packet sequence numbers out of the forbidden region  we need to take care in two respects\n We can get into trouble in two distinct ways\n If a host sends too much data too fast on a newly opened connection  the actual sequence number versus time curve may rise more steeply than the initial sequence number versus time curve  causing the sequence number to enter the forbidden region\n To prevent this from happening  the maximum data rate on any connection is one segment per clock tick\n This also means that the transport entity must wait until the clock ticks before opening a new connection after a crash restart  lest the same number be used twice\n Both of these points argue in favor of a short clock tick (  μ or less)\n But the clock cannot tick too fast relative to the sequence number\n For a clock rate of C and a sequence number space of size S  we must have S/C>T so that the sequence numbers cannot wrap around too quickly\n Entering the forbidden region from underneath by sending too fast is not the only way to get into trouble\n From Fig\n  -  (b)  we see that at any data rate less than the clock rate  the curve of actual sequence numbers used versus time will eventually run into the forbidden region from the left as the sequence numbers wrap around\n The greater the slope of the actual sequence numbers  the longer this event will be delayed\n Avoiding this situation limits how slowly sequence numbers can advance on a connection (or how long the connections may last)\n The clock-based method solves the problem of not being able to distinguish delayed duplicate segments from new segments\n However  there is a practical snag for using it for establishing connections\n Since we do not normally remember sequence numbers across connections at the destination  we still have no way of THE TRANSPORT LAYER  \n  knowing if a CONNECTION REQUEST segment containing an initial sequence number is a duplicate of a recent connection\n This snag does not exist during a connection because the sliding window protocol does remember the current sequence number\n To solve this specific problem  Tomlinson (   ) introduced the three-way handshake\n This establishment protocol involves one peer checking with the other that the connection request is indeed current\n The normal setup procedure when host  initiates is shown in Fig\n  -  (a)\n Host  chooses a sequence number  x  and sends a CONNECTION REQUEST segment containing it to host  \n Host  replies with an ACK segment acknowledging x and announcing its own initial sequence number  y\n Finally  host  acknowledges host  ’s choice of an initial sequence number in the first data segment that it sends\n Now let us see how the three-way handshake works in the presence of delayed duplicate control segments\n In Fig\n  -  (b)  the first segment is a delayed duplicate CONNECTION REQUEST from an old connection\n This segment arrives at host  without host  ’s knowledge\n Host  reacts to this segment by sending host  an ACK segment  in effect asking for verification that host  was indeed trying to set up a new connection\n When host  rejects host  ’s attempt to establish a connection  host  realizes that it was tricked by a delayed duplicate and abandons the connection\n In this way  a delayed duplicate does no damage\n The worst case is when both a delayed CONNECTION REQUEST and an ACK are floating around in the subnet\n This case is shown in Fig\n  -  (c)\n As in the previous example  host  gets a delayed CONNECTION REQUEST and replies to it\n At this point  it is crucial to realize that host  has proposed using y as the initial sequence number for host  to host  traffic  knowing full well that no segments containing sequence number y or acknowledgements to y are still in existence\n When the ond delayed segment arrives at host   the fact that z has been acknowledged rather than y tells host  that this  too  is an old duplicate\n The important thing to realize here is that there is no combination of old segments that can cause the protocol to fail and have a connection set up by accident when no one wants it\n TCP uses this three-way handshake to establish connections\n Within a connection  a timestamp is used to extend the  -bit sequence number so that it will not wrap within the maximum packet lifetime  even for gigabit-per-ond connections\n This mechanism is a fix to TCP that was needed as it was used on faster and faster links\n It is described in RFC  and called PAWS (Protection Against Wrapped Sequence numbers)\n Across connections  for the initial sequence numbers and before PAWS can come into play  TCP originally used the clock-based scheme just described\n However  this turned out to have a urity vulnerability\n The clock made it easy for an attacker to predict the next initial sequence number and send packets that tricked the three-way handshake and established a forged connection\n To close this hole  pseudorandom initial sequence numbers are used for connections in practice\n However  it remains important that   ELEMENTS OF TRANSPORT PROTOCOLS Time Time Time DATA (seq = x  ACK = y) ACK (seq = y  ACK = x) CR (seq = x) Host  Host  REJECT (ACK = y) DATA (seq = x  ACK = z) ACK (seq = y  ACK = x) CR (seq = x) Host  Host  REJECT (ACK =y) ACK (seq = y  ACK =x) CR (seq = x) Host  Host  Old duplicate Old duplicate Old duplicate (a) (b) (c) Figure  -  \n Three protocol scenarios for establishing a connection using a three-way handshake\n CR denotes CONNECTION REQUEST\n (a) Normal operation\n (b) Old duplicate CONNECTION REQUEST appearing out of nowhere\n (c) Duplicate CONNECTION REQUEST and duplicate ACK\n the initial sequence numbers not repeat for an interval even though they appear random to an observer\n Otherwise  delayed duplicates can wreak havoc\n    Connection Release Releasing a connection is easier than establishing one\n Nevertheless  there are more pitfalls than one might expect here\n As we mentioned earlier  there are two styles of terminating a connection: asymmetric release and symmetric release\n THE TRANSPORT LAYER  \n  Asymmetric release is the way the telephone system works: when one party hangs up  the connection is broken\n Symmetric release treats the connection as two separate unidirectional connections and requires each one to be released separately\n Asymmetric release is abrupt and may result in data loss\n Consider the scenario of Fig\n  -  \n After the connection is established  host  sends a segment that arrives properly at host  \n Then host  sends another segment\n Unfortunately  host  issues a DISCONNECT before the ond segment arrives\n The result is that the connection is released and data are lost\n Time CR DATA DATA Host  Host  ACK DR No data are delivered after a disconnect request Figure  -  \n Abrupt disconnection with loss of data\n Clearly  a more sophisticated release protocol is needed to avoid data loss\n One way is to use symmetric release  in which each direction is released independently of the other one\n Here  a host can continue to receive data even after it has sent a DISCONNECT segment\n Symmetric release does the job when each process has a fixed amount of data to send and clearly knows when it has sent it\n In other situations  determining that all the work has been done and the connection should be terminated is not so obvious\n One can envision a protocol in which host  says ‘‘I am done\n Are you done too?’’ If host  responds: ‘‘I am done too\n Goodbye  the connection can be safely released\n’’ Unfortunately  this protocol does not always work\n There is a famous problem that illustrates this issue\n It is called the two-army problem\n Imagine that a white army is encamped in a valley  as shown in Fig\n  -  \n On both of the surrounding hillsides are blue armies\n The white army is larger than either of the blue armies alone  but together the blue armies are larger than the white army\n If either blue army attacks by itself  it will be defeated  but if the two blue armies attack simultaneously  they will be victorious\n The blue armies want to synchronize their attacks\n However  their only communication medium is to send messengers on foot down into the valley  where   ELEMENTS OF TRANSPORT PROTOCOLS W B B White army Blue army #  Blue army #  Figure  -  \n The two-army problem\n they might be captured and the message lost ( \n  they have to use an unreliable communication channel)\n The question is: does a protocol exist that allows the blue armies to win? Suppose that the commander of blue army #  sends a message reading: ‘‘I propose we attack at dawn on March  \n How about it?’’ Now suppose that the message arrives  the commander of blue army #  agrees  and his reply gets safely back to blue army # \n Will the attack happen? Probably not  because commander #  does not know if his reply got through\n If it did not  blue army #  will not attack  so it would be foolish for him to charge into battle\n Now let us improve the protocol by making it a three-way handshake\n The initiator of the original proposal must acknowledge the response\n Assuming no messages are lost  blue army #  will get the acknowledgement  but the commander of blue army #  will now hesitate\n After all  he does not know if his acknowledgement got through  and if it did not  he knows that blue army #  will not attack\n We could now make a four-way handshake protocol  but that does not help either\n In fact  it can be proven that no protocol exists that works\n Suppose that some protocol did exist\n Either the last message of the protocol is essential  or it is not\n If it is not  we can remove it (and any other unessential messages) until we are left with a protocol in which every message is essential\n What happens if the final message does not get through? We just said that it was essential  so if it is lost  the attack does not take place\n Since the sender of the final message can never be sure of its arrival  he will not risk attacking\n Worse yet  the other blue army knows this  so it will not attack either\n To see the relevance of the two-army problem to releasing connections  rather than to military affairs  just substitute ‘‘disconnect’’ for ‘‘attack\n’’ If neither side is THE TRANSPORT LAYER  \n  prepared to disconnect until it is convinced that the other side is prepared to disconnect too  the disconnection will never happen\n In practice  we can avoid this quandary by foregoing the need for agreement and pushing the problem up to the transport user  letting each side independently decide when it is done\n This is an easier problem to solve\n Figure  -  illustrates four scenarios of releasing using a three-way handshake\n While this protocol is not infallible  it is usually adequate\n In Fig\n  -  (a)  we see the normal case in which one of the users sends a DR (DISCONNECTION REQUEST) segment to initiate the connection release\n When it arrives  the recipient sends back a DR segment and starts a timer  just in case its DR is lost\n When this DR arrives  the original sender sends back an ACK segment and releases the connection\n Finally  when the ACK segment arrives  the receiver also releases the connection\n Releasing a connection means that the transport entity removes the information about the connection from its table of currently open connections and signals the connection’s owner (the transport user) somehow\n This action is different from a transport user issuing a DISCONNECT primitive\n If the final ACK segment is lost  as shown in Fig\n  -  (b)  the situation is saved by the timer\n When the timer expires  the connection is released anyway\n Now consider the case of the ond DR being lost\n The user initiating the disconnection will not receive the expected response  will time out  and will start all over again\n In Fig\n  -  (c)  we see how this works  assuming that the ond time no segments are lost and all segments are delivered correctly and on time\n Our last scenario  Fig\n  -  (d)  is the same as Fig\n  -  (c) except that now we assume all the repeated attempts to retransmit the DR also fail due to lost segments\n After N retries  the sender just gives up and releases the connection\n Meanwhile  the receiver times out and also exits\n While this protocol usually suffices  in theory it can fail if the initial DR and N retransmissions are all lost\n The sender will give up and release the connection  while the other side knows nothing at all about the attempts to disconnect and is still fully active\n This situation results in a half-open connection\n We could have avoided this problem by not allowing the sender to give up after N retries and forcing it to go on forever until it gets a response\n However  if the other side is allowed to time out  the sender will indeed go on forever  because no response will ever be forthcoming\n If we do not allow the receiving side to time out  the protocol hangs in Fig\n  -  (d)\n One way to kill off half-open connections is to have a rule saying that if no segments have arrived for a certain number of onds  the connection is automatically disconnected\n That way  if one side ever disconnects  the other side will detect the lack of activity and also disconnect\n This rule also takes care of the case where the connection is broken (because the network can no longer deliver packets between the hosts) without either end disconnecting first\n Of course  if this rule is introduced  it is necessary for each transport entity to have a timer that is stopped and then restarted whenever a segment is sent\n If this timer expires  a   ELEMENTS OF TRANSPORT PROTOCOLS DR ACK ACK Host  Host  DR DR Send DR + start timer Send DR + start timer Send ACK Release connection (Timeout) release connection (Timeout) release connection (N Timeouts) release connection ( Timeout) send DR + start timer Release connection DR DR Host  Host  DR Send DR + start timer Send DR & start timer Send DR & start timer Send DR & start timer Send ACK Release connection Release connection DR ACK Host  Host  DR Send DR + start timer Send DR + start timer Send ACK Release connection Lost Lost ( Timeout) send DR + start timer DR Host  Host  Send DR + start timer Lost Lost (a) (b) (c) (d) Figure  -  \n Four protocol scenarios for releasing a connection\n (a) Normal case of three-way handshake\n (b) Final ACK lost\n (c) Response lost\n (d) Response lost and subsequent DRs lost\n dummy segment is transmitted  just to keep the other side from disconnecting\n On the other hand  if the automatic disconnect rule is used and too many dummy segments in a row are lost on an otherwise idle connection  first one side  then the other will automatically disconnect\n We will not belabor this point any more  but by now it should be clear that releasing a connection without data loss is not nearly as simple as it first appears\n The lesson here is that the transport user must be involved in deciding when to THE TRANSPORT LAYER  \n  disconnect—the problem cannot be cleanly solved by the transport entities themselves\n To see the importance of the application  consider that while TCP normally does a symmetric close (with each side independently closing its half of the connection with a FIN packet when it has sent its data)  many Web servers send the client a RST packet that causes an abrupt close of the connection that is more like an asymmetric close\n This works only because the Web server knows the pattern of data exchange\n First it receives a request from the client  which is all the data the client will send  and then it sends a response to the client\n When the Web server is finished with its response  all of the data has been sent in either direction\n The server can send the client a warning and abruptly shut the connection\n If the client gets this warning  it will release its connection state then and there\n If the client does not get the warning  it will eventually realize that the server is no longer talking to it and release the connection state\n The data has been successfully transferred in either case\n    Error Control and Flow Control Having examined connection establishment and release in some detail  let us now look at how connections are managed while they are in use\n The key issues are error control and flow control\n Error control is ensuring that the data is delivered with the desired level of reliability  usually that all of the data is delivered without any errors\n Flow control is keeping a fast transmitter from overrunning a slow receiver\n Both of these issues have come up before  when we studied the data link layer\n The solutions that are used at the transport layer are the same mechanisms that we studied in   As a very brief recap:  \n A frame carries an error-detecting code ( \n  a CRC or checksum) that is used to check if the information was correctly received A frame carries a sequence number to identify itself and is retransmitted by the sender until it receives an acknowledgement of successful receipt from the receiver\n This is called ARQ (Automatic Repeat reQuest) There is a maximum number of frames that the sender will allow to be outstanding at any time  pausing if the receiver is not acknowledging frames quickly enough\n If this maximum is one packet the protocol is called stop-and-wait\n Larger windows enable pipelining and improve performance on long  fast links The sliding window protocol combines these features and is also used to support bidirectional data transfer\n Given that these mechanisms are used on frames at the link layer  it is natural to wonder why they would be used on segments at the transport layer as well\n   ELEMENTS OF TRANSPORT PROTOCOLS However  there is little duplication between the link and transport layers in practice\n Even though the same mechanisms are used  there are differences in function and degree\n For a difference in function  consider error detection\n The link layer checksum protects a frame while it crosses a single link\n The transport layer checksum protects a segment while it crosses an entire network path\n It is an end-to-end check  which is not the same as having a check on every link\n Saltzer et al\n (   ) describe a situation in which packets were corrupted inside a router\n The link layer checksums protected the packets only while they traveled across a link  not while they were inside the router\n Thus  packets were delivered incorrectly even though they were correct according to the checks on every link\n This and other examples led Saltzer et al\n to articulate the end-to-end argument\n According to this argument  the transport layer check that runs end-to-end is essential for correctness  and the link layer checks are not essential but nonetheless valuable for improving performance (since without them a corrupted packet can be sent along the entire path unnecessarily)\n As a difference in degree  consider retransmissions and the sliding window protocol\n Most wireless links  other than satellite links  can have only a single frame outstanding from the sender at a time\n That is  the bandwidth-delay product for the link is small enough that not even a whole frame can be stored inside the link\n In this case  a small window size is sufficient for good performance\n For example \n  uses a stop-and-wait protocol  transmitting or retransmitting each frame and waiting for it to be acknowledged before moving on to the next frame\n Having a window size larger than one frame would add complexity without improving performance\n For wired and optical fiber links  such as (switched) Ethernet or ISP backbones  the error-rate is low enough that link-layer retransmissions can be omitted because the end-to-end retransmissions will repair the residual frame loss\n On the other hand  many TCP connections have a bandwidth-delay product that is much larger than a single segment\n Consider a connection sending data across the  \n at  Mbps with a round-trip time of m\n Even for this slow connection  Kbit of data will be stored at the receiver in the time it takes to send a segment and receive an acknowledgement\n For these situations  a large sliding window must be used\n Stop-and-wait will cripple performance\n In our example it would limit performance to one segment every m  or  segments/  no matter how fast the network really is\n Given that transport protocols generally use larger sliding windows  we will look at the issue of buffering data more carefully\n Since a host may have many connections  each of which is treated separately  it may need a substantial amount of buffering for the sliding windows\n The buffers are needed at both the sender and the receiver\n Certainly they are needed at the sender to hold all transmitted but as yet unacknowledged segments\n They are needed there because these segments may be lost and need to be retransmitted\n THE TRANSPORT LAYER  \n  However  since the sender is buffering  the receiver may or may not dedicate specific buffers to specific connections  as it sees fit\n The receiver may  for example  maintain a single buffer pool shared by all connections\n When a segment comes in  an attempt is made to dynamically acquire a new buffer\n If one is available  the segment is accepted; otherwise  it is discarded\n Since the sender is prepared to retransmit segments lost by the network  no permanent harm is done by having the receiver drop segments  although some resources are wasted\n The sender just keeps trying until it gets an acknowledgement\n The best trade-off between source buffering and destination buffering depends on the type of traffic carried by the connection\n For low-bandwidth bursty traffic  such as that produced by an interactive terminal  it is reasonable not to dedicate any buffers  but rather to acquire them dynamically at both ends  relying on buffering at the sender if segments must occasionally be discarded\n On the other hand  for file transfer and other high-bandwidth traffic  it is better if the receiver does dedicate a full window of buffers  to allow the data to flow at maximum speed\n This is the strategy that TCP uses\n There still remains the question of how to organize the buffer pool\n If most segments are nearly the same size  it is natural to organize the buffers as a pool of identically sized buffers  with one segment per buffer  as in Fig\n  -  (a)\n However  if there is wide variation in segment size  from short requests for Web pages to large packets in peer-to-peer file transfers  a pool of fixed-sized buffers presents problems\n If the buffer size is chosen to be equal to the largest possible segment  space will be wasted whenever a short segment arrives\n If the buffer size is chosen to be less than the maximum segment size  multiple buffers will be needed for long segments  with the attendant complexity\n Another approach to the buffer size problem is to use variable-sized buffers  as in Fig\n  -  (b)\n The advantage here is better memory utilization  at the price of more complicated buffer management\n A third possibility is to dedicate a single large circular buffer per connection  as in Fig\n  -  (c)\n This system is simple and elegant and does not depend on segment sizes  but makes good use of memory only when the connections are heavily loaded\n As connections are opened and closed and as the traffic pattern changes  the sender and receiver need to dynamically adjust their buffer allocations\n Consequently  the transport protocol should allow a sending host to request buffer space at the other end\n Buffers could be allocated per connection  or collectively  for all the connections running between the two hosts\n Alternatively  the receiver  knowing its buffer situation (but not knowing the offered traffic) could tell the sender ‘‘I have reserved X buffers for you\n’’ If the number of open connections should increase  it may be necessary for an allocation to be reduced  so the protocol should provide for this possibility\n A reasonably general way to manage dynamic buffer allocation is to decouple the buffering from the acknowledgements  in contrast to the sliding window protocols of   Dynamic buffer management means  in effect  a variable-sized   ELEMENTS OF TRANSPORT PROTOCOLS Segment  Segment  Segment  Segment  (a) (b) (c) Unused space Figure  -  \n (a) Chained fixed-size buffers\n (b) Chained variable-sized buffers\n (c) One large circular buffer per connection\n window\n Initially  the sender requests a certain number of buffers  based on its expected needs\n The receiver then grants as many of these as it can afford\n Every time the sender transmits a segment  it must decrement its allocation  stopping altogether when the allocation reaches zero\n The receiver separately piggybacks both acknowledgements and buffer allocations onto the reverse traffic\n TCP uses this scheme  carrying buffer allocations in a header field called Window size\n Figure  -  shows an example of how dynamic window management might work in a datagram network with  -bit sequence numbers\n In this example  data flows in segments from host A to host B and acknowledgements and buffer allocations flow in segments in the reverse direction\n Initially  A wants eight buffers  but it is granted only four of these\n It then sends three segments  of which the third is lost\n Segment  acknowledges receipt of all segments up to and including sequence number   thus allowing A to release those buffers  and furthermore informs A that it has permission to send three more segments starting beyond  ( \n  segments  and  )\n A knows that it has already sent number   so it thinks that it may send segments  and   which it proceeds to do\n At this point it is blocked and must wait for more buffer allocation\n Timeout-induced retransmissions (line  )  however  may occur while blocked  since they use buffers that have already been allocated\n In line B acknowledges receipt of all segments up to and including  but refuses to let A continue\n Such a situation is impossible with the fixed-window protocols of   The next segment from B to A allocates THE TRANSPORT LAYER  \n  another buffer and allows A to continue\n This will happen when B has buffer space  likely because the transport user has accepted more segment data\n      < request  buffers> <ack = buf =  > <seq =   data = m > <seq =   data = m > <seq =   data = m > <ack =   buf =  > <seq =   data = m > <seq =   data = m > <seq =   data = m > <ack =   buf =  > <ack =   buf =  > <ack =   buf =  > <seq =   data = m > <seq =   data = m > <ack =   buf =  > <ack =   buf =  > A wants  buffers B grants messages  -  only A has  buffers left now A has  buffers left now Message lost but A thinks it has  left B acknowledges  and   permits  -  A has  buffer left A has  buffers left  and must stop A times out and retransmits Everything acknowledged  but A still blocked A may now send  B found a new buffer somewhere A has  buffer left A is now blocked again A is still blocked Potential deadlock A Message B Comments Figure  -  \n Dynamic buffer allocation\n The arrows show the direction of transmission\n An ellipsis (\n\n) indicates a lost segment\n Problems with buffer allocation schemes of this kind can arise in datagram networks if control segments can get lost—which they most certainly can\n Look at line  \n B has now allocated more buffers to A  but the allocation segment was lost\n Oops\n Since control segments are not sequenced or timed out  A is now deadlocked\n To prevent this situation  each host should periodically send control segments giving the acknowledgement and buffer status on each connection\n That way  the deadlock will be broken  sooner or later\n Until now we have tacitly assumed that the only limit imposed on the sender’s data rate is the amount of buffer space available in the receiver\n This is often not the case\n Memory was once expensive but prices have fallen dramatically\n Hosts may be equipped with sufficient memory that the lack of buffers is rarely  if ever  a problem  even for wide area connections\n Of course  this depends on the buffer size being set to be large enough  which has not always been the case for TCP (Zhang et al\n  )\n When buffer space no longer limits the maximum flow  another bottleneck will appear: the carrying capacity of the network\n If adjacent routers can exchange at most x packets/ and there are k disjoint paths between a pair of hosts  there is no way that those hosts can exchange more than kx segments/  no matter how much buffer space is available at each end\n If the sender pushes too hard   ELEMENTS OF TRANSPORT PROTOCOLS ( \n  sends more than kx segments/)  the network will become congested because it will be unable to deliver segments as fast as they are coming in\n What is needed is a mechanism that limits transmissions from the sender based on the network’s carrying capacity rather than on the receiver’s buffering capacity\n Belsnes (   ) proposed using a sliding window flow-control scheme in which the sender dynamically adjusts the window size to match the network’s carrying capacity\n This means that a dynamic sliding window can implement both flow control and congestion control\n If the network can handle c segments/ and the round-trip time (including transmission  propagation  queueing  processing at the receiver  and return of the acknowledgement) is r  the sender’s window should be cr\n With a window of this size  the sender normally operates with the pipeline full\n Any small decrease in network performance will cause it to block\n Since the network capacity available to any given flow varies over time  the window size should be adjusted frequently  to track changes in the carrying capacity\n As we will see later  TCP uses a similar scheme\n    Multiplexing Multiplexing  or sharing several conversations over connections  virtual circuits  and physical links plays a role in several layers of the network architecture\n In the transport layer  the need for multiplexing can arise in a number of ways\n For example  if only one network address is available on a host  all transport connections on that machine have to use it\n When a segment comes in  some way is needed to tell which process to give it to\n This situation  called multiplexing  is shown in Fig\n  -  (a)\n In this figure  four distinct transport connections all use the same network connection ( \n  IP address) to the remote host\n Multiplexing can also be useful in the transport layer for another reason\n Suppose  for example  that a host has multiple network paths that it can use\n If a user needs more bandwidth or more reliability than one of the network paths can provide  a way out is to have a connection that distributes the traffic among multiple network paths on a round-robin basis  as indicated in Fig\n  -  (b)\n This modus operandi is called inverse multiplexing\n With k network connections open  the effective bandwidth might be increased by a factor of k\n An example of inverse multiplexing is SCTP (Stream Control Transmission Protocol)  which can run a connection using multiple network interfaces\n In contrast  TCP uses a single network endpoint\n Inverse multiplexing is also found at the link layer  when several low-rate links are used in parallel as one high-rate link\n    Crash Recovery If hosts and routers are subject to crashes or connections are long-lived ( \n  large software or media downloads)  recovery from these crashes becomes an issue\n If the transport entity is entirely within the hosts  recovery from network THE TRANSPORT LAYER  \n  Layer    To router Router lines Transport address Network address (a) (b) Figure  -  \n (a) Multiplexing\n (b) Inverse multiplexing\n and router crashes is straightforward\n The transport entities expect lost segments all the time and know how to cope with them by using retransmissions\n A more troublesome problem is how to recover from host crashes\n In particular  it may be desirable for clients to be able to continue working when servers crash and quickly reboot\n To illustrate the difficulty  let us assume that one host  the client  is sending a long file to another host  the file server  using a simple stop-and-wait protocol\n The transport layer on the server just passes the incoming segments to the transport user  one by one\n Partway through the transmission  the server crashes\n When it comes back up  its tables are reinitialized  so it no longer knows precisely where it was\n In an attempt to recover its previous status  the server might send a broadcast segment to all other hosts  announcing that it has just crashed and requesting that its clients inform it of the status of all open connections\n Each client can be in one of two states: one segment outstanding  S  or no segments outstanding  S \n Based on only this state information  the client must decide whether to retransmit the most recent segment\n At first glance  it would seem obvious: the client should retransmit if and only if it has an unacknowledged segment outstanding ( \n  is in state S ) when it learns of the crash\n However  a closer inspection reveals difficulties with this naive approach\n Consider  for example  the situation in which the server’s transport entity first sends an acknowledgement and then  when the acknowledgement has been sent  writes to the application process\n Writing a segment onto the output stream and sending an acknowledgement are two distinct events that cannot be done simultaneously\n If a crash occurs after the acknowledgement has been sent but before the write has been fully completed  the client will receive the   ELEMENTS OF TRANSPORT PROTOCOLS acknowledgement and thus be in state S  when the crash recovery announcement arrives\n The client will therefore not retransmit  (incorrectly) thinking that the segment has arrived\n This decision by the client leads to a missing segment\n At this point you may be thinking: ‘‘That problem can be solved easily\n All you have to do is reprogram the transport entity to first do the write and then send the acknowledgement\n’’ Try again\n Imagine that the write has been done but the crash occurs before the acknowledgement can be sent\n The client will be in state S  and thus retransmit  leading to an undetected duplicate segment in the output stream to the server application process\n No matter how the client and server are programmed  there are always situations where the protocol fails to recover properly\n The server can be programmed in one of two ways: acknowledge first or write first\n The client can be programmed in one of four ways: always retransmit the last segment  never retransmit the last segment  retransmit only in state S  or retransmit only in state S \n This gives eight combinations  but as we shall see  for each combination there is some set of events that makes the protocol fail\n Three events are possible at the server: sending an acknowledgement (A)  writing to the output process (W)  and crashing (C)\n The three events can occur in six different orderings: AC(W)  AWC  C(AW)  C(WA)  WAC  and WC(A)  where the parentheses are used to indicate that neither A nor W can follow C ( \n  once it has crashed  it has crashed)\n Figure  -  shows all eight combinations of client and server strategies and the valid event sequences for each one\n Notice that for each strategy there is some sequence of events that causes the protocol to fail\n For example  if the client always retransmits  the AWC event will generate an undetected duplicate  even though the other two events work properly\n Always retransmit OK DUP OK LOST OK LOST OK DUP LOST LOST OK OK Never retransmit Retransmit in S  Retransmit in S  AC(W) Strategy used by sending host AWC First ACK  then write First write  then ACK C(AW) OK DUP DUP LOST OK OK LOST DUP OK OK OK DUP C(WA) W AC WC(A) OK = Protocol functions correctly DUP = Protocol generates a duplicate message LOST = Protocol loses a message Strategy used by receiving host Figure  -  \n Different combinations of client and server strategies\n THE TRANSPORT LAYER  \n  Making the protocol more elaborate does not help\n Even if the client and server exchange several segments before the server attempts to write  so that the client knows exactly what is about to happen  the client has no way of knowing whether a crash occurred just before or just after the write\n The conclusion is inescapable: under our ground rules of no simultaneous events—that is  separate events happen one after another not at the same time—host crash and recovery cannot be made transparent to higher layers\n Put in more general terms  this result can be restated as ‘‘recovery from a layer N crash can only be done by layer N +  ’’ and then only if the higher layer retains enough status information to reconstruct where it was before the problem occurred\n This is consistent with the case mentioned above that the transport layer can recover from failures in the network layer  provided that each end of a connection keeps track of where it is\n This problem gets us into the issue of what a so-called end-to-end acknowledgement really means\n In principle  the transport protocol is end-to-end and not chained like the lower layers\n Now consider the case of a user entering requests for transactions against a remote database\n Suppose that the remote transport entity is programmed to first pass segments to the next layer up and then acknowledge\n Even in this case  the receipt of an acknowledgement back at the user’s machine does not necessarily mean that the remote host stayed up long enough to actually update the database\n A truly end-to-end acknowledgement  whose receipt means that the work has actually been done and lack thereof means that it has not  is probably impossible to achieve\n This point is discussed in more detail by Saltzer et al\n (   )  CONGESTION CONTROL If the transport entities on many machines send too many packets into the network too quickly  the network will become congested  with performance degraded as packets are delayed and lost\n Controlling congestion to avoid this problem is the combined responsibility of the network and transport layers\n Congestion occurs at routers  so it is detected at the network layer\n However  congestion is ultimately caused by traffic sent into the network by the transport layer\n The only effective way to control congestion is for the transport protocols to send packets into the network more slowly\n In  \n   we studied congestion control mechanisms in the network layer\n In this tion  we will study the other half of the problem  congestion control mechanisms in the transport layer\n After describing the goals of congestion control  we will describe how hosts can regulate the rate at which they send packets into the network\n The Internet relies heavily on the transport layer for congestion control  and specific algorithms are built into TCP and other protocols\n   CONGESTION CONTROL    Desirable Bandwidth Allocation Before we describe how to regulate traffic  we must understand what we are trying to achieve by running a congestion control algorithm\n That is  we must specify the state in which a good congestion control algorithm will operate the network\n The goal is more than to simply avoid congestion\n It is to find a good allocation of bandwidth to the transport entities that are using the network\n A good allocation will deliver good performance because it uses all the available bandwidth but avoids congestion  it will be fair across competing transport entities  and it will quickly track changes in traffic demands\n We will make each of these criteria more precise in turn\n Efficiency and Power An efficient allocation of bandwidth across transport entities will use all of the network capacity that is available\n However  it is not quite right to think that if there is a   -Mbps link  five transport entities should get   Mbps each\n They should usually get less than   Mbps for good performance\n The reason is that the traffic is often bursty\n Recall that in   we described the goodput (or rate of useful packets arriving at the receiver) as a function of the offered load\n This curve and a matching curve for the delay as a function of the offered load are given in Fig\n  -  \n Capacity (a) Offered load (packets/) Congestion collapse Offered load (packets/) Goodput (packets/) Desired response Delay (onds) (b) Onset of congestion Figure  -  \n (a) Goodput and (b) delay as a function of offered load\n As the load increases in Fig\n  -  (a) goodput initially increases at the same rate  but as the load approaches the capacity  goodput rises more gradually\n This falloff is because bursts of traffic can occasionally mount up and cause some losses at buffers inside the network\n If the transport protocol is poorly designed and retransmits packets that have been delayed but not lost  the network can enter congestion collapse\n In this state  senders are furiously sending packets  but increasingly little useful work is being accomplished\n THE TRANSPORT LAYER  \n  The corresponding delay is given in Fig\n  -  (b) Initially the delay is fixed  representing the propagation delay across the network\n As the load approaches the capacity  the delay rises  slowly at first and then much more rapidly\n This is again because of bursts of traffic that tend to mound up at high load\n The delay cannot really go to infinity  except in a model in which the routers have infinite buffers\n Instead  packets will be lost after experiencing the maximum buffering delay\n For both goodput and delay  performance begins to degrade at the onset of congestion\n Intuitively  we will obtain the best performance from the network if we allocate bandwidth up until the delay starts to climb rapidly\n This point is below the capacity\n To identify it  Kleinrock (   ) proposed the metric of power  where power = delay load Power will initially rise with offered load  as delay remains small and roughly constant  but will reach a maximum and fall as delay grows rapidly\n The load with the highest power represents an efficient load for the transport entity to place on the network\n Max-Min Fairness In the preceding discussion  we did not talk about how to divide bandwidth between different transport senders\n This sounds like a simple question to answer—give all the senders an equal fraction of the bandwidth—but it involves several considerations\n Perhaps the first consideration is to ask what this problem has to do with congestion control\n After all  if the network gives a sender some amount of bandwidth to use  the sender should just use that much bandwidth\n However  it is often the case that networks do not have a strict bandwidth reservation for each flow or connection\n They may for some flows if quality of service is supported  but many connections will seek to use whatever bandwidth is available or be lumped together by the network under a common allocation\n For example  IETF’s differentiated services separates traffic into two classes and connections compete for bandwidth within each class\n IP routers often have all connections competing for the same bandwidth\n In this situation  it is the congestion control mechanism that is allocating bandwidth to the competing connections\n A ond consideration is what a fair portion means for flows in a network\n It is simple enough if N flows use a single link  in which case they can all have  /N of the bandwidth (although efficiency will dictate that they use slightly less if the traffic is bursty)\n But what happens if the flows have different  but overlapping  network paths? For example  one flow may cross three links  and the other flows may cross one link\n The three-link flow consumes more network resources\n It might be fairer in some sense to give it less bandwidth than the one-link flows\n It   CONGESTION CONTROL should certainly be possible to support more one-link flows by reducing the bandwidth of the three-link flow\n This point demonstrates an inherent tension between fairness and efficiency\n However  we will adopt a notion of fairness that does not depend on the length of the network path\n Even with this simple model  giving connections an equal fraction of bandwidth is a bit complicated because different connections will take different paths through the network and these paths will themselves have different capacities\n In this case  it is possible for a flow to be bottlenecked on a downstream link and take a smaller portion of an upstream link than other flows; reducing the bandwidth of the other flows would slow them down but would not help the bottlenecked flow at all\n The form of fairness that is often desired for network usage is max-min fairness\n An allocation is max-min fair if the bandwidth given to one flow cannot be increased without decreasing the bandwidth given to another flow with an allocation that is no larger\n That is  increasing the bandwidth of a flow will only make the situation worse for flows that are less well off\n Let us see an example\n A max-min fair allocation is shown for a network with four flows  A  B  C  and D  in Fig\n  -  \n Each of the links between routers has the same capacity  taken to be  unit  though in the general case the links will have different capacities\n Three flows compete for the bottom-left link between routers R  and R \n Each of these flows therefore gets  /  of the link\n The remaining flow  A  competes with B on the link from R  to R \n Since B has an allocation of  /  A gets the remaining  /  of the link\n Notice that all of the other links have spare capacity\n However  this capacity cannot be given to any of the flows without decreasing the capacity of another  lower flow\n For example  if more of the bandwidth on the link between R  and R  is given to flow B  there will be less for flow A\n This is reasonable as flow A already has more bandwidth\n However  the capacity of flow C or D (or both) must be decreased to give more bandwidth to B  and these flows will have less bandwidth than B\n Thus  the allocation is max-min fair\n  /  R  R  D C B A  /  /  /  /  /  /  D C B A R  R  R  R  /  /  Figure  -  \n Max-min bandwidth allocation for four flows\n Max-min allocations can be computed given a global knowledge of the network\n An intuitive way to think about them is to imagine that the rate for all of the THE TRANSPORT LAYER  \n  flows starts at zero and is slowly increased\n When the rate reaches a bottleneck for any flow  then that flow stops increasing\n The other flows all continue to increase  sharing equally in the available capacity  until they too reach their respective bottlenecks\n A third consideration is the level over which to consider fairness\n A network could be fair at the level of connections  connections between a pair of hosts  or all connections per host\n We examined this issue when we were discussing WFQ (Weighted Fair Queueing) in   and concluded that each of these definitions has its problems\n For example  defining fairness per host means that a busy server will fare no better than a mobile phone  while defining fairness per connection encourages hosts to open more connections\n Given that there is no clear answer  fairness is often considered per connection  but precise fairness is usually not a concern\n It is more important in practice that no connection be starved of bandwidth than that all connections get precisely the same amount of bandwidth\n In fact  with TCP it is possible to open multiple connections and compete for bandwidth more aggressively\n This tactic is used by bandwidth-hungry applications such as BitTorrent for peer-to-peer file sharing\n Convergence A final criterion is that the congestion control algorithm converge quickly to a fair and efficient allocation of bandwidth\n The discussion of the desirable operating point above assumes a static network environment\n However  connections are always coming and going in a network  and the bandwidth needed by a given connection will vary over time too  for example  as a user browses Web pages and occasionally downloads large videos\n Because of the variation in demand  the ideal operating point for the network varies over time\n A good congestion control algorithm should rapidly converge to the ideal operating point  and it should track that point as it changes over time\n If the convergence is too slow  the algorithm will never be close to the changing operating point\n If the algorithm is not stable  it may fail to converge to the right point in some cases  or even oscillate around the right point\n An example of a bandwidth allocation that changes over time and converges quickly is shown in Fig\n  -  \n Initially  flow  has all of the bandwidth\n One ond later  flow  starts\n It needs bandwidth as well\n The allocation quickly changes to give each of these flows half the bandwidth\n At  onds  a third flow joins\n However  this flow uses only  % of the bandwidth  which is less than its fair share (which is a third)\n Flows  and  quickly adjust  dividing the available bandwidth to each have  % of the bandwidth\n At  onds  the ond flow leaves  and the third flow remains unchanged\n The first flow quickly captures  % of the bandwidth\n At all times  the total allocated bandwidth is approximately   %  so that the network is fully used  and competing flows get equal treatment (but do not have to use more bandwidth than they need)\n   CONGESTION CONTROL Flow   \n  Time (s) Bandwidth allocation  Flow  Flow  stops Flow  starts Figure  -  \n Changing bandwidth allocation over time\n    Regulating the Sending Rate Now it is time for the main course\n How do we regulate the sending rates to obtain a desirable bandwidth allocation? The sending rate may be limited by two factors\n The first is flow control  in the case that there is insufficient buffering at the receiver\n The ond is congestion  in the case that there is insufficient capacity in the network\n In Fig\n  -   we see this problem illustrated hydraulically\n In Fig\n  -  (a)  we see a thick pipe leading to a small-capacity receiver\n This is a flow-control limited situation\n As long as the sender does not send more water than the bucket can contain  no water will be lost\n In Fig\n  -  (b)  the limiting factor is not the bucket capacity  but the internal carrying capacity of the network\n If too much water comes in too fast  it will back up and some will be lost (in this case  by overflowing the funnel)\n These cases may appear similar to the sender  as transmitting too fast causes packets to be lost\n However  they have different causes and call for different solutions\n We have already talked about a flow-control solution with a variable-sized window\n Now we will consider a congestion control solution\n Since either of these problems can occur  the transport protocol will in general need to run both solutions and slow down if either problem occurs\n The way that a transport protocol should regulate the sending rate depends on the form of the feedback returned by the network\n Different network layers may return different kinds of feedback\n The feedback may be explicit or implicit  and it may be precise or imprecise\n An example of an explicit  precise design is when routers tell the sources the rate at which they may send\n Designs in the literature such as XCP (eXplicit Congestion Protocol) operate in this manner (Katabi et al\n  )\n An explicit  imprecise design is the use of ECN (Explicit Congestion Notification) with TCP\n In this design  routers set bits on packets that experience congestion to warn the senders to slow down  but they do not tell them how much to slow down\n THE TRANSPORT LAYER  \n  Transmission rate adjustment Transmission network Internal congestion Small-capacity receiver Large-capacity receiver (a) (b) Figure  -  \n (a) A fast network feeding a low-capacity receiver\n (b) A slow network feeding a high-capacity receiver\n In other designs  there is no explicit signal\n FAST TCP measures the roundtrip delay and uses that metric as a signal to avoid congestion (Wei et al\n  )\n Finally  in the form of congestion control most prevalent in the Internet today  TCP with drop-tail or RED routers  packet loss is inferred and used to signal that the network has become congested\n There are many variants of this form of TCP  including CUBIC TCP  which is used in Linux (Ha et al\n  )\n Combinations are also possible\n For example  Windows includes Compound TCP that uses both packet loss and delay as feedback signals (Tan et al\n  )\n These designs are summarized in Fig\n  -  \n If an explicit and precise signal is given  the transport entity can use that signal to adjust its rate to the new operating point\n For example  if XCP tells senders the rate to use  the senders may simply use that rate\n In the other cases  however  some guesswork is involved\n In the absence of a congestion signal  the senders should decrease their rates\n When a congestion signal is given  the senders should decrease their rates\n The way in which the rates are increased or decreased is given by a control law\n These laws have a major effect on performance\n   CONGESTION CONTROL Protocol Signal Explicit? Precise? XCP Rate to use Yes Yes TCP with ECN Congestion warning Yes No FAST TCP End-to-end delay No Yes Compound TCP Packet loss & end-to-end delay No Yes CUBIC TCP Packet loss No No TCP Packet loss No No Figure  -  \n Signals of some congestion control protocols\n Chiu and Jain (   ) studied the case of binary congestion feedback and concluded that AIMD (Additive Increase Multiplicative Decrease) is the appropriate control law to arrive at the efficient and fair operating point\n To argue this case  they constructed a graphical argument for the simple case of two connections competing for the bandwidth of a single link\n The graph in Fig\n  -  shows the bandwidth allocated to user  on the x-axis and to user  on the y-axis\n When the allocation is fair  both users will receive the same amount of bandwidth\n This is shown by the dotted fairness line\n When the allocations sum to   %  the capacity of the link  the allocation is efficient\n This is shown by the dotted efficiency line\n A congestion signal is given by the network to both users when the sum of their allocations crosses this line\n The intertion of these lines is the desired operating point  when both users have the same bandwidth and all of the network bandwidth is used\n Additive increase and decrease User  ’s bandwidth Fairness line Efficiency line Optimal point User  ’s bandwidth  Multiplicative increase and decrease   %   % Figure  -  \n Additive and multiplicative bandwidth adjustments\n Consider what happens from some starting allocation if both user  and user  additively increase their respective bandwidths over time\n For example  the users may each increase their sending rate by  Mbps every ond\n Eventually  the THE TRANSPORT LAYER  \n  operating point crosses the efficiency line and both users receive a congestion signal from the network\n At this stage  they must reduce their allocations\n However  an additive decrease would simply cause them to oscillate along an additive line\n This situation is shown in Fig\n  -  \n The behavior will keep the operating point close to efficient  but it will not necessarily be fair\n Similarly  consider the case when both users multiplicatively increase their bandwidth over time until they receive a congestion signal\n For example  the users may increase their sending rate by  % every ond\n If they then multiplicatively decrease their sending rates  the operating point of the users will simply oscillate along a multiplicative line\n This behavior is also shown in Fig\n  -  \n The multiplicative line has a different slope than the additive line\n (It points to the origin  while the additive line has an angle of   degrees\n) But it is otherwise no better\n In neither case will the users converge to the optimal sending rates that are both fair and efficient\n Now consider the case that the users additively increase their bandwidth allocations and then multiplicatively decrease them when congestion is signaled\n This behavior is the AIMD control law  and it is shown in Fig\n  -  \n It can be seen that the path traced by this behavior does converge to the optimal point that is both fair and efficient\n This convergence happens no matter what the starting point  making AIMD broadly useful\n By the same argument  the only other combination  multiplicative increase and additive decrease  would diverge from the optimal point\n Start User  ’s bandwidth   % Fairness line Efficiency line Optimal point User  ’s bandwidth = Additive increase (up at   ) = Multiplicative decrease (line points to origin) Legend:   % Figure  -  \n Additive Increase Multiplicative Decrease (AIMD) control law\n AIMD is the control law that is used by TCP  based on this argument and another stability argument (that it is easy to drive the network into congestion and difficult to recover  so the increase policy should be gentle and the decrease policy aggressive)\n It is not quite fair  since TCP connections adjust their window size by a given amount every round-trip time\n Different connections will have different round-trip times\n This leads to a bias in which connections to closer hosts receive more bandwidth than connections to distant hosts  all else being equal\n   CONGESTION CONTROL In   we will describe in detail how TCP implements an AIMD control law to adjust the sending rate and provide congestion control\n This task is more difficult than it sounds because rates are measured over some interval and traffic is bursty\n Instead of adjusting the rate directly  a strategy that is often used in practice is to adjust the size of a sliding window\n TCP uses this strategy\n If the window size is W and the round-trip time is RTT  the equivalent rate is W/RTT\n This strategy is easy to combine with flow control  which already uses a window  and has the advantage that the sender paces packets using acknowledgements and hence slows down in one RTT if it stops receiving reports that packets are leaving the network\n As a final issue  there may be many different transport protocols that send traffic into the network\n What will happen if the different protocols compete with different control laws to avoid congestion? Unequal bandwidth allocations  that is what\n Since TCP is the dominant form of congestion control in the Internet  there is significant community pressure for new transport protocols to be designed so that they compete fairly with it\n The early streaming media protocols caused problems by excessively reducing TCP throughput because they did not compete fairly\n This led to the notion of TCP-friendly congestion control in which TCP and non-TCP transport protocols can be freely mixed with no ill effects (Floyd et al\n  )\n    Wireless Issues Transport protocols such as TCP that implement congestion control should be independent of the underlying network and link layer technologies\n That is a good theory  but in practice there are issues with wireless networks\n The main issue is that packet loss is often used as a congestion signal  including by TCP as we have just discussed\n Wireless networks lose packets all the time due to transmission errors\n With the AIMD control law  high throughput requires very small levels of packet loss\n Analyses by Padhye et al\n (   ) show that the throughput goes up as the inverse square-root of the packet loss rate\n What this means in practice is that the loss rate for fast TCP connections is very small;  % is a moderate loss rate  and by the time the loss rate reaches  % the connection has effectively stopped working\n However  for wireless networks such as   \n  LANs  frame loss rates of at least  % are common\n This difference means that  absent protective measures  congestion control schemes that use packet loss as a signal will unnecessarily throttle connections that run over wireless links to very low rates\n To function well  the only packet losses that the congestion control algorithm should observe are losses due to insufficient bandwidth  not losses due to transmission errors\n One solution to this problem is to mask the wireless losses by using retransmissions over the wireless link\n For example \n  uses a stopand- wait protocol to deliver each frame  retrying transmissions multiple times if THE TRANSPORT LAYER  \n  need be before reporting a packet loss to the higher layer\n In the normal case  each packet is delivered despite transient transmission errors that are not visible to the higher layers\n Fig\n  -  shows a path with a wired and wireless link for which the masking strategy is used\n There are two aspects to note\n First  the sender does not necessarily know that the path includes a wireless link  since all it sees is the wired link to which it is attached\n Internet paths are heterogeneous and there is no general method for the sender to tell what kind of links comprise the path\n This complicates the congestion control problem  as there is no easy way to use one protocol for wireless links and another protocol for wired links\n Wired link Sender Receiver Transport with end-to-end congestion control (loss = congestion) Link layer retransmission (loss = transmission error) Wireless link Figure  -  \n Congestion control over a path with a wireless link\n The ond aspect is a puzzle\n The figure shows two mechanisms that are driven by loss: link layer frame retransmissions  and transport layer congestion control\n The puzzle is how these two mechanisms can co-exist without getting confused\n After all  a loss should cause only one mechanism to take action because it is either a transmission error or a congestion signal\n It cannot be both\n If both mechanisms take action (by retransmitting the frame and slowing down the sending rate) then we are back to the original problem of transports that run far too slowly over wireless links\n Consider this puzzle for a moment and see if you can solve it\n The solution is that the two mechanisms act at different timescales\n Link layer retransmissions happen on the order of microonds to millionds for wireless links such as    Loss timers in transport protocols fire on the order of millionds to onds\n The difference is three orders of magnitude\n This allows wireless links to detect frame losses and retransmit frames to repair transmission errors long before packet loss is inferred by the transport entity\n The masking strategy is sufficient to let most transport protocols run well across most wireless links\n However  it is not always a fitting solution\n Some wireless links have long round-trip times  such as satellites\n For these links other techniques must be used to mask loss  such as FEC (Forward Error Correction)  or the transport protocol must use a non-loss signal for congestion control\n   CONGESTION CONTROL A ond issue with congestion control over wireless links is variable capacity\n That is  the capacity of a wireless link changes over time  sometimes abruptly  as nodes move and the signal-to-noise ratio varies with the changing channel conditions\n This is unlike wired links whose capacity is fixed\n The transport protocol must adapt to the changing capacity of wireless links  otherwise it will either congest the network or fail to use the available capacity\n One possible solution to this problem is simply not to worry about it\n This strategy is feasible because congestion control algorithms must already handle the case of new users entering the network or existing users changing their sending rates\n Even though the capacity of wired links is fixed  the changing behavior of other users presents itself as variability in the bandwidth that is available to a given user\n Thus it is possible to simply run TCP over a path with an   \n  wireless link and obtain reasonable performance\n However  when there is much wireless variability  transport protocols designed for wired links may have trouble keeping up and deliver poor performance\n The solution in this case is a transport protocol that is designed for wireless links\n A particularly challenging setting is a wireless mesh network in which multiple  interfering wireless links must be crossed  routes change due to mobility  and there is lots of loss\n Research in this area is ongoing\n See Li et al\n (   ) for an example of wireless transport protocol design  THE INTERNET TRANSPORT PROTOCOLS: UDP The Internet has two main protocols in the transport layer  a connectionless protocol and a connection-oriented one\n The protocols complement each other\n The connectionless protocol is UDP\n It does almost nothing beyond sending packets between applications  letting applications build their own protocols on top as needed\n The connection-oriented protocol is TCP\n It does almost everything\n It makes connections and adds reliability with retransmissions  along with flow control and congestion control  all on behalf of the applications that use it\n In the following tions  we will study UDP and TCP\n We will start with UDP because it is simplest\n We will also look at two uses of UDP\n Since UDP is a transport layer protocol that typically runs in the operating system and protocols that use UDP typically run in user space  these uses might be considered applications\n However  the techniques they use are useful for many applications and are better considered to belong to a transport service  so we will cover them here\n    Introduction to UDP The Internet protocol suite supports a connectionless transport protocol called UDP (User Datagram Protocol)\n UDP provides a way for applications to send encapsulated IP datagrams without having to establish a connection\n UDP is described in RFC   \n THE TRANSPORT LAYER  \n  UDP transmits segments consisting of an  -byte header followed by the payload\n The header is shown in Fig\n  -  \n The two ports serve to identify the endpoints within the source and destination machines\n When a UDP packet arrives  its payload is handed to the process attached to the destination port\n This attachment occurs when the BIND primitive or something similar is used  as we saw in Fig\n  -  for TCP (the binding process is the same for UDP)\n Think of ports as mailboxes that applications can rent to receive packets\n We will have more to say about them when we describe TCP  which also uses ports\n In fact  the main value of UDP over just using raw IP is the addition of the source and destination ports\n Without the port fields  the transport layer would not know what to do with each incoming packet\n With them  it delivers the embedded segment to the correct application\n   Bits Source port UDP length Destination port UDP checksum Figure  -  \n The UDP header\n The source port is primarily needed when a reply must be sent back to the source\n By copying the Source port field from the incoming segment into the Destination port field of the outgoing segment  the process sending the reply can specify which process on the sending machine is to get it\n The UDP length field includes the  -byte header and the data\n The minimum length is  bytes  to cover the header\n The maximum length is   bytes  which is lower than the largest number that will fit in   bits because of the size limit on IP packets\n An optional Checksum is also provided for extra reliability\n It checksums the header  the data  and a conceptual IP pseudoheader\n When performing this computation  the Checksum field is set to zero and the data field is padded out with an additional zero byte if its length is an odd number\n The checksum algorithm is simply to add up all the  -bit words in one’s complement and to take the one’s complement of the sum\n As a consequence  when the receiver performs the calculation on the entire segment  including the Checksum field  the result should be  \n If the checksum is not computed  it is stored as a   since by a happy coincidence of one’s complement arithmetic a true computed  is stored as all  s\n However  turning it off is foolish unless the quality of the data does not matter ( \n  for digitized speech)\n The pseudoheader for the case of IPv  is shown in Fig\n  -  \n It contains the  -bit IPv  addresses of the source and destination machines  the protocol number for UDP (  )  and the byte count for the UDP segment (including the header)\n It   THE INTERNET TRANSPORT PROTOCOLS: UDP is different but analogous for IPv \n Including the pseudoheader in the UDP checksum computation helps detect misdelivered packets  but including it also violates the protocol hierarchy since the IP addresses in it belong to the IP layer  not to the UDP layer\n TCP uses the same pseudoheader for its checksum\n   Bits Source address Destination address    Protocol =   UDP length Figure  -  \n The IPv  pseudoheader included in the UDP checksum\n It is probably worth mentioning explicitly some of the things that UDP does not do\n It does not do flow control  congestion control  or retransmission upon receipt of a bad segment\n All of that is up to the user processes\n What it does do is provide an interface to the IP protocol with the added feature of demultiplexing multiple processes using the ports and optional end-to-end error detection\n That is all it does\n For applications that need to have precise control over the packet flow  error control  or timing  UDP provides just what the doctor ordered\n One area where it is especially useful is in client-server situations\n Often  the client sends a short request to the server and expects a short reply back\n If either the request or the reply is lost  the client can just time out and try again\n Not only is the code simple  but fewer messages are required (one in each direction) than with a protocol requiring an initial setup like TCP\n An application that uses UDP this way is DNS (Domain Name System)  which we will study in   In brief  a program that needs to look up the IP address of some host name  for example   \n   can send a UDP packet containing the host name to a DNS server\n The server replies with a UDP packet containing the host’s IP address\n No setup is needed in advance and no release is needed afterward\n Just two messages go over the network\n    Remote Procedure Call In a certain sense  sending a message to a remote host and getting a reply back is a lot like making a function call in a programming language\n In both cases  you start with one or more parameters and you get back a result\n This observation has led people to try to arrange request-reply interactions on networks to be cast in the THE TRANSPORT LAYER  \n  form of procedure calls\n Such an arrangement makes network applications much easier to program and more familiar to deal with\n For example  just imagine a procedure named get IP address (host name) that works by sending a UDP packet to a DNS server and waiting for the reply  timing out and trying again if one is not forthcoming quickly enough\n In this way  all the details of networking can be hidden from the programmer\n The key work in this area was done by Birrell and Nelson (   )\n In a nutshell  what Birrell and Nelson suggested was allowing programs to call procedures located on remote hosts\n When a process on machine  calls a procedure on machine   the calling process on  is suspended and execution of the called procedure takes place on  \n Information can be transported from the caller to the callee in the parameters and can come back in the procedure result\n No message passing is visible to the application programmer\n This technique is known as RPC (Remote Procedure Call) and has become the basis for many networking applications\n Traditionally  the calling procedure is known as the client and the called procedure is known as the server  and we will use those names here too\n The idea behind RPC is to make a remote procedure call look as much as possible like a local one\n In the simplest form  to call a remote procedure  the client program must be bound with a small library procedure  called the client stub  that represents the server procedure in the client’s address space\n Similarly  the server is bound with a procedure called the server stub\n These procedures hide the fact that the procedure call from the client to the server is not local\n The actual steps in making an RPC are shown in Fig\n  -  \n Step  is the client calling the client stub\n This call is a local procedure call  with the parameters pushed onto the stack in the normal way\n Step  is the client stub packing the parameters into a message and making a system call to send the message\n Packing the parameters is called marshaling\n Step  is the operating system sending the message from the client machine to the server machine\n Step  is the operating system passing the incoming packet to the server stub\n Finally  step  is the server stub calling the server procedure with the unmarshaled parameters\n The reply traces the same path in the other direction\n The key item to note here is that the client procedure  written by the user  just makes a normal ( \n  local) procedure call to the client stub  which has the same name as the server procedure\n Since the client procedure and client stub are in the same address space  the parameters are passed in the usual way\n Similarly  the server procedure is called by a procedure in its address space with the parameters it expects\n To the server procedure  nothing is unusual\n In this way  instead of I/O being done on sockets  network communication is done by faking a normal procedure call\n Despite the conceptual elegance of RPC  there are a few snakes hiding under the grass\n A big one is the use of pointer parameters\n Normally  passing a pointer to a procedure is not a problem\n The called procedure can use the pointer in the same way the caller can because both procedures live in the same virtual address   THE INTERNET TRANSPORT PROTOCOLS: UDP Client CPU Client stub Client Operating system Server CPU Server stub  Operating system Server Network Figure  -  \n Steps in making a remote procedure call\n The stubs are shaded\n space\n With RPC  passing pointers is impossible because the client and server are in different address spaces\n In some cases  tricks can be used to make it possible to pass pointers\n Suppose that the first parameter is a pointer to an integer  k\n The client stub can marshal k and send it along to the server\n The server stub then creates a pointer to k and passes it to the server procedure  just as it expects\n When the server procedure returns control to the server stub  the latter sends k back to the client  where the new k is copied over the old one  just in case the server changed it\n In effect  the standard calling sequence of call-by-reference has been replaced by call-bycopy- restore\n Unfortunately  this trick does not always work  for example  if the pointer points to a graph or other complex data structure\n For this reason  some restrictions must be placed on parameters to procedures called remotely  as we shall see\n A ond problem is that in weakly typed languages  like C  it is perfectly legal to write a procedure that computes the inner product of two vectors (arrays)  without specifying how large either one is\n Each could be terminated by a special value known only to the calling and called procedures\n Under these circumstances  it is essentially impossible for the client stub to marshal the parameters: it has no way of determining how large they are\n A third problem is that it is not always possible to deduce the types of the parameters  not even from a formal specification or the code itself\n An example is printf  which may have any number of parameters (at least one)  and the parameters can be an arbitrary mixture of integers  shorts  longs  characters  strings  floating- point numbers of various lengths  and other types\n Trying to call printf as a remote procedure would be practically impossible because C is so permissive\n However  a rule saying that RPC can be used provided that you do not program in C (or C++) would not be popular with a lot of programmers\n THE TRANSPORT LAYER  \n  A fourth problem relates to the use of global variables\n Normally  the calling and called procedure can communicate by using global variables  in addition to communicating via parameters\n But if the called procedure is moved to a remote machine  the code will fail because the global variables are no longer shared\n These problems are not meant to suggest that RPC is hopeless\n In fact  it is widely used  but some restrictions are needed to make it work well in practice\n In terms of transport layer protocols  UDP is a good base on which to implement RPC\n Both requests and replies may be sent as a single UDP packet in the simplest case and the operation can be fast\n However  an implementation must include other machinery as well\n Because the request or the reply may be lost  the client must keep a timer to retransmit the request\n Note that a reply serves as an implicit acknowledgement for a request  so the request need not be separately acknowledged\n Sometimes the parameters or results may be larger than the maximum UDP packet size  in which case some protocol is needed to deliver large messages\n If multiple requests and replies can overlap (as in the case of concurrent programming)  an identifier is needed to match the request with the reply\n A higher-level concern is that the operation may not be idempotent ( \n  safe to repeat)\n The simple case is idempotent operations such as DNS requests and replies\n The client can safely retransmit these requests again and again if no replies are forthcoming\n It does not matter whether the server never received the request  or it was the reply that was lost\n The answer  when it finally arrives  will be the same (assuming the DNS database is not updated in the meantime)\n However  not all operations are idempotent  for example  because they have important side-effects such as incrementing a counter\n RPC for these operations requires stronger semantics so that when the programmer calls a procedure it is not executed multiple times\n In this case  it may be necessary to set up a TCP connection and send the request over it rather than using UDP\n    Real-Time Transport Protocols Client-server RPC is one area in which UDP is widely used\n Another one is for real-time multimedia applications\n In particular  as Internet radio  Internet telephony  music-on-demand  videoconferencing  video-on-demand  and other multimedia applications became more commonplace  people have discovered that each application was reinventing more or less the same real-time transport protocol\n It gradually became clear that having a generic real-time transport protocol for multiple applications would be a good idea\n Thus was RTP (Real-time Transport Protocol) born\n It is described in RFC  and is now in widespread use for multimedia applications\n We will describe two aspects of real-time transport\n The first is the RTP protocol for transporting audio and video data in packets\n The ond is the processing that takes place  mostly at the receiver  to play out the audio and video at the right time\n These functions fit into the protocol stack as shown in Fig\n  -  \n   THE INTERNET TRANSPORT PROTOCOLS: UDP Multimedia application RTP Socket interface UDP IP Ethernet (a) (b) Ethernet header IP header UDP header RTP header RTP payload UDP payload IP payload Ethernet payload User space OS Kernel Figure  -  \n (a) The position of RTP in the protocol stack\n (b) Packet nesting\n RTP normally runs in user space over UDP (in the operating system)\n It operates as follows\n The multimedia application consists of multiple audio  video  text  and possibly other streams\n These are fed into the RTP library  which is in user space along with the application\n This library multiplexes the streams and encodes them in RTP packets  which it stuffs into a socket\n On the operating system side of the socket  UDP packets are generated to wrap the RTP packets and handed to IP for transmission over a link such as Ethernet\n The reverse process happens at the receiver\n The multimedia application eventually receives multimedia data from the RTP library\n It is responsible for playing out the media\n The protocol stack for this situation is shown in Fig\n  -  (a)\n The packet nesting is shown in Fig\n  -  (b)\n As a consequence of this design  it is a little hard to say which layer RTP is in\n Since it runs in user space and is linked to the application program  it certainly looks like an application protocol\n On the other hand  it is a generic  applicationindependent protocol that just provides transport facilities  so it also looks like a transport protocol\n Probably the best description is that it is a transport protocol that just happens to be implemented in the application layer  which is why we are covering it in this  ter\n RTP—The Real-time Transport Protocol The basic function of RTP is to multiplex several real-time data streams onto a single stream of UDP packets\n The UDP stream can be sent to a single destination (unicasting) or to multiple destinations (multicasting)\n Because RTP just uses normal UDP  its packets are not treated specially by the routers unless some normal IP quality-of-service features are enabled\n In particular  there are no special guarantees about delivery  and packets may be lost  delayed  corrupted  etc\n The RTP format contains several features to help receivers work with multimedia information\n Each packet sent in an RTP stream is given a number one THE TRANSPORT LAYER  \n  higher than its predecessor\n This numbering allows the destination to determine if any packets are missing\n If a packet is missing  the best action for the destination to take is up to the application\n It may be to skip a video frame if the packets are carrying video data  or to approximate the missing value by interpolation if the packets are carrying audio data\n Retransmission is not a practical option since the retransmitted packet would probably arrive too late to be useful\n As a consequence  RTP has no acknowledgements  and no mechanism to request retransmissions\n Each RTP payload may contain multiple samples  and they may be coded any way that the application wants\n To allow for interworking  RTP defines several profiles ( \n  a single audio stream)  and for each profile  multiple encoding formats may be allowed\n For example  a single audio stream may be encoded as  - bit PCM samples at  kHz using delta encoding  predictive encoding  GSM encoding  MP  encoding  and so on\n RTP provides a header field in which the source can specify the encoding but is otherwise not involved in how encoding is done\n Another facility many real-time applications need is timestamping\n The idea here is to allow the source to associate a timestamp with the first sample in each packet\n The timestamps are relative to the start of the stream  so only the differences between timestamps are significant\n The absolute values have no meaning\n As we will describe shortly  this mechanism allows the destination to do a small amount of buffering and play each sample the right number of millionds after the start of the stream  independently of when the packet containing the sample arrived\n Not only does timestamping reduce the effects of variation in network delay  but it also allows multiple streams to be synchronized with each other\n For example  a digital television program might have a video stream and two audio streams\n The two audio streams could be for stereo broadcasts or for handling films with an original language soundtrack and a soundtrack dubbed into the local language  giving the viewer a choice\n Each stream comes from a different physical device  but if they are timestamped from a single counter  they can be played back synchronously  even if the streams are transmitted and/or received somewhat erratically\n The RTP header is illustrated in Fig\n  -  \n It consists of three  -bit words and potentially some extensions\n The first word contains the Version field  which is already at  \n Let us hope this version is very close to the ultimate version since there is only one code point left (although  could be defined as meaning that the real version was in an extension word)\n The P bit indicates that the packet has been padded to a multiple of  bytes\n The last padding byte tells how many bytes were added\n The X bit indicates that an extension header is present\n The format and meaning of the extension header are not defined\n The only thing that is defined is that the first word of the extension gives the length\n This is an escape hatch for any unforeseen requirements\n   THE INTERNET TRANSPORT PROTOCOLS: UDP   bits Ver\n P X M Payload type Sequence number Timestamp Synchronization source identifier Contributing source identifier CC Figure  -  \n The RTP header\n The CC field tells how many contributing sources are present  from  to   (see below)\n The M bit is an application-specific marker bit\n It can be used to mark the start of a video frame  the start of a word in an audio channel  or something else that the application understands\n The Payload type field tells which encoding algorithm has been used ( \n  uncompressed  -bit audio  MP  etc\n)\n Since every packet carries this field  the encoding can change during transmission\n The Sequence number is just a counter that is incremented on each RTP packet sent\n It is used to detect lost packets\n The Timestamp is produced by the stream’s source to note when the first sample in the packet was made\n This value can help reduce timing variability called jitter at the receiver by decoupling the playback from the packet arrival time\n The Synchronization source identifier tells which stream the packet belongs to\n It is the method used to multiplex and demultiplex multiple data streams onto a single stream of UDP packets\n Finally  the Contributing source identifiers  if any  are used when mixers are present in the studio\n In that case  the mixer is the synchronizing source  and the streams being mixed are listed here\n RTCP—The Real-time Transport Control Protocol RTP has a little sister protocol (little sibling protocol?) called RTCP (Realtime Transport Control Protocol)\n It is defined along with RTP in RFC  and handles feedback  synchronization  and the user interface\n It does not transport any media samples\n The first function can be used to provide feedback on delay  variation in delay or jitter  bandwidth  congestion  and other network properties to the sources\n This information can be used by the encoding process to increase the data rate (and give better quality) when the network is functioning well and to cut back the data THE TRANSPORT LAYER  \n  rate when there is trouble in the network\n By providing continuous feedback  the encoding algorithms can be continuously adapted to provide the best quality possible under the current circumstances\n For example  if the bandwidth increases or decreases during the transmission  the encoding may switch from MP  to  -bit PCM to delta encoding as required\n The Payload type field is used to tell the destination what encoding algorithm is used for the current packet  making it possible to vary it on demand\n An issue with providing feedback is that the RTCP reports are sent to all participants\n For a multicast application with a large group  the bandwidth used by RTCP would quickly grow large\n To prevent this from happening  RTCP senders scale down the rate of their reports to collectively consume no more than  say  % of the media bandwidth\n To do this  each participant needs to know the media bandwidth  which it learns from the sender  and the number of participants  which it estimates by listening to other RTCP reports\n RTCP also handles interstream synchronization\n The problem is that different streams may use different clocks  with different granularities and different drift rates\n RTCP can be used to keep them in sync\n Finally  RTCP provides a way for naming the various sources ( \n  in ASCII text)\n This information can be displayed on the receiver’s screen to indicate who is talking at the moment\n More information about RTP can be found in Perkins (   )\n Playout with Buffering and Jitter Control Once the media information reaches the receiver  it must be played out at the right time\n In general  this will not be the time at which the RTP packet arrived at the receiver because packets will take slightly different amounts of time to transit the network\n Even if the packets are injected with exactly the right intervals between them at the sender  they will reach the receiver with different relative times\n This variation in delay is called jitter\n Even a small amount of packet jitter can cause distracting media artifacts  such as jerky video frames and unintelligible audio  if the media is simply played out as it arrives\n The solution to this problem is to buffer packets at the receiver before they are played out to reduce the jitter\n As an example  in Fig\n  -  we see a stream of packets being delivered with a substantial amount of jitter\n Packet  is sent from the server at t =   and arrives at the client at t =  \n Packet  undergoes more delay and takes   to arrive\n As the packets arrive  they are buffered on the client machine\n At t =     playback begins\n At this time  packets  through  have been buffered so that they can be removed from the buffer at uniform intervals for smooth play\n In the general case  it is not necessary to use uniform intervals because the RTP timestamps tell when the media should be played\n   THE INTERNET TRANSPORT PROTOCOLS: UDP      Time () Time in buffer  Gap in playback  Packet removed from buffer Packet arrives at buffer  Packet departs source    Figure  -  \n Smoothing the output stream by buffering packets\n Unfortunately  we can see that packet  has been delayed so much that it is not available when its play slot comes up\n There are two options\n Packet  can be skipped and the player can move on to subsequent packets\n Alternatively  playback can stop until packet  arrives  creating an annoying gap in the music or movie\n In a live media application like a voice-over-IP call  the packet will typically be skipped\n Live applications do not work well on hold\n In a streaming media application  the player might pause\n This problem can be alleviated by delaying the starting time even more  by using a larger buffer\n For a streaming audio or video player  buffers of about   onds are often used to ensure that the player receives all of the packets (that are not dropped in the network) in time\n For live applications like videoconferencing  short buffers are needed for responsiveness\n A key consideration for smooth playout is the playback point  or how long to wait at the receiver for media before playing it out\n Deciding how long to wait depends on the jitter\n The difference between a low-jitter and high-jitter connection is shown in Fig\n  -  \n The average delay may not differ greatly between the two  but if there is high jitter the playback point may need to be much further out to capture  % of the packets than if there is low jitter\n To pick a good playback point  the application can measure the jitter by looking at the difference between the RTP timestamps and the arrival time\n Each difference gives a sample of the delay (plus an arbitrary  fixed offset)\n However  the delay can change over time due to other  competing traffic and changing routes\n To accommodate this change  applications can adapt their playback point while they are running\n However  if not done well  changing the playback point can produce an observable glitch to the user\n One way to avoid this problem for audio is to adapt the playback point between talkspurts  in the gaps in a conversation\n No one will notice the difference between a short and slightly longer silence\n RTP lets applications set the M marker bit to indicate the start of a new talkspurt for this purpose\n If the absolute delay until media is played out is too long  live applications will suffer\n Nothing can be done to reduce the propagation delay if a direct path is THE TRANSPORT LAYER  \n  High jitter Low jitter Minimum delay (due to speed of light) Delay (a) Fraction of packets Fraction of packets Delay (b) Figure  -  \n (a) High jitter\n (b) Low jitter\n already being used\n The playback point can be pulled in by simply accepting that a larger fraction of packets will arrive too late to be played\n If this is not acceptable  the only way to pull in the playback point is to reduce the jitter by using a better quality of service  for example  the expedited forwarding differentiated service\n That is  a better network is needed  THE INTERNET TRANSPORT PROTOCOLS: TCP UDP is a simple protocol and it has some very important uses  such as clientserver interactions and multimedia  but for most Internet applications  reliable  sequenced delivery is needed\n UDP cannot provide this  so another protocol is required\n It is called TCP and is the main workhorse of the Internet\n Let us now study it in detail\n    Introduction to TCP TCP (Transmission Control Protocol) was specifically designed to provide a reliable end-to-end byte stream over an unreliable internetwork\n An internetwork differs from a single network because different parts may have wildly different topologies  bandwidths  delays  packet sizes  and other parameters\n TCP was designed to dynamically adapt to properties of the internetwork and to be robust in the face of many kinds of failures\n TCP was formally defined in RFC in September \n As time went on  many improvements have been made  and various errors and inconsistencies have been fixed\n To give you a sense of the extent of TCP  the important RFCs are   THE INTERNET TRANSPORT PROTOCOLS: TCP now RFC plus: clarifications and bug fixes in RFC ; extensions for high-performance in RFC ; selective acknowledgements in RFC ; congestion control in RFC ; repurposing of header fields for quality of service in RFC ; improved retransmission timers in RFC ; and explicit congestion notification in RFC \n The full collection is even larger  which led to a guide to the many RFCs  published of course as another RFC document  RFC \n Each machine supporting TCP has a TCP transport entity  either a library procedure  a user process  or most commonly part of the kernel\n In all cases  it manages TCP streams and interfaces to the IP layer\n A TCP entity accepts user data streams from local processes  breaks them up into pieces not exceeding   KB (in practice  often  data bytes in order to fit in a single Ethernet frame with the IP and TCP headers)  and sends each piece as a separate IP datagram\n When datagrams containing TCP data arrive at a machine  they are given to the TCP entity  which reconstructs the original byte streams\n For simplicity  we will sometimes use just ‘‘TCP’’ to mean the TCP transport entity (a piece of software) or the TCP protocol (a set of rules)\n From the context it will be clear which is meant\n For example  in ‘‘The user gives TCP the data ’’ the TCP transport entity is clearly intended\n The IP layer gives no guarantee that datagrams will be delivered properly  nor any indication of how fast datagrams may be sent\n It is up to TCP to send datagrams fast enough to make use of the capacity but not cause congestion  and to time out and retransmit any datagrams that are not delivered\n Datagrams that do arrive may well do so in the wrong order; it is also up to TCP to reassemble them into messages in the proper sequence\n In short  TCP must furnish good performance with the reliability that most applications want and that IP does not provide\n    The TCP Service Model TCP service is obtained by both the sender and the receiver creating end points  called sockets  as discussed in \n   \n Each socket has a socket number (address) consisting of the IP address of the host and a  -bit number local to that host  called a port\n A port is the TCP name for a TSAP\n For TCP service to be obtained  a connection must be explicitly established between a socket on one machine and a socket on another machine\n The socket calls are listed in Fig\n  - \n A socket may be used for multiple connections at the same time\n In other words  two or more connections may terminate at the same socket\n Connections are identified by the socket identifiers at both ends  that is  (socket  socket )\n No virtual circuit numbers or other identifiers are used\n Port numbers below  are reserved for standard services that can usually only be started by privileged users ( \n  root in UNIX systems)\n They are called well-known ports\n For example  any process wishing to remotely retrieve mail from a host can connect to the destination host’s port to contact its IMAP THE TRANSPORT LAYER  \n  daemon\n The list of well-known ports is given at  \n Over have been assigned\n A few of the better-known ones are listed in Fig\n  -  \n Port Protocol Use   FTP File transfer   SSH Remote login  replacement for Telnet   SMTP Email   HTTP World Wide Web POP-  Remote email access IMAP Remote email access HTTPS ure Web (HTTP over SSL/TLS) RTSP Media player control IPP Printer sharing Figure  -  \n Some assigned ports\n Other ports from  through  can be registered with IANA for use by unprivileged users  but applications can and do choose their own ports\n For example  the BitTorrent peer-to-peer file-sharing application (unofficially) uses ports –  but may run on other ports as well\n It would certainly be possible to have the FTP daemon attach itself to port   at boot time  the SSH daemon attach itself to port   at boot time  and so on\n However  doing so would clutter up memory with daemons that were idle most of the time\n Instead  what is commonly done is to have a single daemon  called inetd (Internet daemon) in UNIX  attach itself to multiple ports and wait for the first incoming connection\n When that occurs  inetd forks off a new process and executes the appropriate daemon in it  letting that daemon handle the request\n In this way  the daemons other than inetd are only active when there is work for them to do\n Inetd learns which ports it is to use from a configuration file\n Consequently  the system administrator can set up the system to have permanent daemons on the busiest ports ( \n  port  ) and inetd on the rest\n All TCP connections are full duplex and point-to-point\n Full duplex means that traffic can go in both directions at the same time\n Point-to-point means that each connection has exactly two end points\n TCP does not support multicasting or broadcasting\n A TCP connection is a byte stream  not a message stream\n Message boundaries are not preserved end to end\n For example  if the sending process does four   -byte writes to a TCP stream  these data may be delivered to the receiving process as four   -byte chunks  two -byte chunks  one -byte chunk (see Fig\n  -  )  or some other way\n There is no way for the receiver to detect the unit(s) in which the data were written  no matter how hard it tries\n   THE INTERNET TRANSPORT PROTOCOLS: TCP A B C D AB C D IP header TCP header (a) (b) Figure  -  \n (a) Four   -byte segments sent as separate IP datagrams\n (b) The  bytes of data delivered to the application in a single READ call\n Files in UNIX have this property too\n The reader of a file cannot tell whether the file was written a block at a time  a byte at a time  or all in one blow\n As with a UNIX file  the TCP software has no idea of what the bytes mean and no interest in finding out\n A byte is just a byte\n When an application passes data to TCP  TCP may send it immediately or buffer it (in order to collect a larger amount to send at once)  at its discretion\n However  sometimes the application really wants the data to be sent immediately\n For example  suppose a user of an interactive game wants to send a stream of updates\n It is essential that the updates be sent immediately  not buffered until there is a collection of them\n To force data out  TCP has the notion of a PUSH flag that is carried on packets\n The original intent was to let applications tell TCP implementations via the PUSH flag not to delay the transmission\n However  applications cannot literally set the PUSH flag when they send data\n Instead  different operating systems have evolved different options to expedite transmission ( \n  TCP NODELAY in Windows and Linux)\n For Internet archaeologists  we will also mention one interesting feature of TCP service that remains in the protocol but is rarely used: urgent data\n When an application has high priority data that should be processed immediately  for example  if an interactive user hits the CTRL-C key to break off a remote computation that has already begun  the sending application can put some control information in the data stream and give it to TCP along with the URGENT flag\n This event causes TCP to stop accumulating data and transmit everything it has for that connection immediately\n When the urgent data are received at the destination  the receiving application is interrupted ( \n  given a signal in UNIX terms) so it can stop whatever it was doing and read the data stream to find the urgent data\n The end of the urgent data is marked so the application knows when it is over\n The start of the urgent data is not marked\n It is up to the application to figure that out\n This scheme provides a crude signaling mechanism and leaves everything else up to the application\n However  while urgent data is potentially useful  it found no compelling application early on and fell into disuse\n Its use is now discouraged because of implementation differences  leaving applications to handle their own signaling\n Perhaps future transport protocols will provide better signaling\n THE TRANSPORT LAYER  \n     The TCP Protocol In this tion  we will give a general overview of the TCP protocol\n In the next one  we will go over the protocol header  field by field\n A key feature of TCP  and one that dominates the protocol design  is that every byte on a TCP connection has its own  -bit sequence number\n When the Internet began  the lines between routers were mostly  -kbps leased lines  so a host blasting away at full speed took over  week to cycle through the sequence numbers\n At modern network speeds  the sequence numbers can be consumed at an alarming rate  as we will see later\n Separate  -bit sequence numbers are carried on packets for the sliding window position in one direction and for acknowledgements in the reverse direction  as discussed below\n The sending and receiving TCP entities exchange data in the form of segments\n A TCP segment consists of a fixed  -byte header (plus an optional part) followed by zero or more data bytes\n The TCP software decides how big segments should be\n It can accumulate data from several writes into one segment or can split data from one write over multiple segments\n Two limits restrict the segment size\n First  each segment  including the TCP header  must fit in the  - byte IP payload\n ond  each link has an MTU (Maximum Transfer Unit)\n Each segment must fit in the MTU at the sender and receiver so that it can be sent and received in a single  unfragmented packet\n In practice  the MTU is generally  bytes (the Ethernet payload size) and thus defines the upper bound on segment size\n However  it is still possible for IP packets carrying TCP segments to be fragmented when passing over a network path for which some link has a small MTU\n If this happens  it degrades performance and causes other problems (Kent and Mogul  )\n Instead  modern TCP implementations perform path MTU discovery by using the technique outlined in RFC  that we described in \n   \n This technique uses ICMP error messages to find the smallest MTU for any link on the path\n TCP then adjusts the segment size downwards to avoid fragmentation\n The basic protocol used by TCP entities is the sliding window protocol with a dynamic window size\n When a sender transmits a segment  it also starts a timer\n When the segment arrives at the destination  the receiving TCP entity sends back a segment (with data if any exist  and otherwise without) bearing an acknowledgement number equal to the next sequence number it expects to receive and the remaining window size\n If the sender’s timer goes off before the acknowledgement is received  the sender transmits the segment again\n Although this protocol sounds simple  there are many sometimes subtle ins and outs  which we will cover below\n Segments can arrive out of order  so bytes – can arrive but cannot be acknowledged because bytes – have not turned up yet\n Segments can also be delayed so long in transit that the sender times out and retransmits them\n The retransmissions may include different byte   THE INTERNET TRANSPORT PROTOCOLS: TCP ranges than the original transmission  requiring careful administration to keep track of which bytes have been correctly received so far\n However  since each byte in the stream has its own unique offset  it can be done\n TCP must be prepared to deal with these problems and solve them in an efficient way\n A considerable amount of effort has gone into optimizing the performance of TCP streams  even in the face of network problems\n A number of the algorithms used by many TCP implementations will be discussed below\n    The TCP Segment Header Figure  -  shows the layout of a TCP segment\n Every segment begins with a fixed-format   -byte header\n The fixed header may be followed by header options\n After the options  if any  up to   −   −   =   data bytes may follow  where the first   refer to the IP header and the ond to the TCP header\n Segments without any data are legal and are commonly used for acknowledgements and control messages\n   Bits Source port Destination port Sequence number Acknowledgement number TCP header length URG ACK PSH RST SYN FIN Window size Checksum Urgent pointer Options (  or more  -bit words) Data (optional) ECE CWR Figure  -  \n The TCP header\n Let us dist the TCP header field by field\n The Source port and Destination port fields identify the local end points of the connection\n A TCP port plus its host’s IP address forms a  -bit unique end point\n The source and destination end points together identify the connection\n This connection identifier is called a  tuple because it consists of five pieces of information: the protocol (TCP)  source IP and source port  and destination IP and destination port\n THE TRANSPORT LAYER  \n  The Sequence number and Acknowledgement number fields perform their usual functions\n Note that the latter specifies the next in-order byte expected  not the last byte correctly received\n It is a cumulative acknowledgement because it summarizes the received data with a single number\n It does not go beyond lost data\n Both are   bits because every byte of data is numbered in a TCP stream\n The TCP header length tells how many  -bit words are contained in the TCP header\n This information is needed because the Options field is of variable length  so the header is  too\n Technically  this field really indicates the start of the data within the segment  measured in  -bit words  but that number is just the header length in words  so the effect is the same\n Next comes a  -bit field that is not used\n The fact that these bits have remained unused for   years (as only  of the original reserved  bits have been reclaimed) is testimony to how well thought out TCP is\n Lesser protocols would have needed these bits to fix bugs in the original design\n Now come eight  -bit flags\n CWR and ECE are used to signal congestion when ECN (Explicit Congestion Notification) is used  as specified in RFC \n ECE is set to signal an ECN-Echo to a TCP sender to tell it to slow down when the TCP receiver gets a congestion indication from the network\n CWR is set to signal Congestion Window Reduced from the TCP sender to the TCP receiver so that it knows the sender has slowed down and can stop sending the ECN-Echo\n We discuss the role of ECN in TCP congestion control in \n    \n URG is set to  if the Urgent pointer is in use\n The Urgent pointer is used to indicate a byte offset from the current sequence number at which urgent data are to be found\n This facility is in lieu of interrupt messages\n As we mentioned above  this facility is a bare-bones way of allowing the sender to signal the receiver without getting TCP itself involved in the reason for the interrupt  but it is seldom used\n The ACK bit is set to  to indicate that the Acknowledgement number is valid\n This is the case for nearly all packets\n If ACK is   the segment does not contain an acknowledgement  so the Acknowledgement number field is ignored\n The PSH bit indicates PUSHed data\n The receiver is hereby kindly requested to deliver the data to the application upon arrival and not buffer it until a full buffer has been received (which it might otherwise do for efficiency)\n The RST bit is used to abruptly reset a connection that has become confused due to a host crash or some other reason\n It is also used to reject an invalid segment or refuse an attempt to open a connection\n In general  if you get a segment with the RST bit on  you have a problem on your hands\n The SYN bit is used to establish connections\n The connection request has SYN =  and ACK =  to indicate that the piggyback acknowledgement field is not in use\n The connection reply does bear an acknowledgement  however  so it has SYN =  and ACK =  \n In essence  the SYN bit is used to denote both CONNECTION REQUEST and CONNECTION ACCEPTED  with the ACK bit used to distinguish between those two possibilities\n   THE INTERNET TRANSPORT PROTOCOLS: TCP The FIN bit is used to release a connection\n It specifies that the sender has no more data to transmit\n However  after closing a connection  the closing process may continue to receive data indefinitely\n Both SYN and FIN segments have sequence numbers and are thus guaranteed to be processed in the correct order\n Flow control in TCP is handled using a variable-sized sliding window\n The Window size field tells how many bytes may be sent starting at the byte acknowledged\n A Window size field of  is legal and says that the bytes up to and including Acknowledgement number −  have been received  but that the receiver has not had a chance to consume the data and would like no more data for the moment  thank you\n The receiver can later grant permission to send by transmitting a segment with the same Acknowledgement number and a nonzero Window size field\n In the protocols of  \n   acknowledgements of frames received and permission to send new frames were tied together\n This was a consequence of a fixed window size for each protocol\n In TCP  acknowledgements and permission to send additional data are completely decoupled\n In effect  a receiver can say: ‘‘I have received bytes up through k but I do not want any more just now  thank you\n’’ This decoupling (in fact  a variable-sized window) gives additional flexibility\n We will study it in detail below\n A Checksum is also provided for extra reliability\n It checksums the header  the data  and a conceptual pseudoheader in exactly the same way as UDP  except that the pseudoheader has the protocol number for TCP ( ) and the checksum is mandatory\n Please see \n    for details\n The Options field provides a way to add extra facilities not covered by the regular header\n Many options have been defined and several are commonly used\n The options are of variable length  fill a multiple of   bits by using padding with zeros  and may extend to   bytes to accommodate the longest TCP header that can be specified\n Some options are carried when a connection is established to negotiate or inform the other side of capabilities\n Other options are carried on packets during the lifetime of the connection\n Each option has a Type-Length-Value encoding\n A widely used option is the one that allows each host to specify the MSS (Maximum Segment Size) it is willing to accept\n Using large segments is more efficient than using small ones because the  -byte header can be amortized over more data  but small hosts may not be able to handle big segments\n During connection setup  each side can announce its maximum and see its partner’s\n If a host does not use this option  it defaults to a   -byte payload\n All Internet hosts are required to accept TCP segments of +   = bytes\n The maximum segment size in the two directions need not be the same\n For lines with high bandwidth  high delay  or both  the  -KB window corresponding to a  -bit field is a problem\n For example  on an OC-  line (of roughly Mbps)  it takes less than  m to output a full  -KB window\n If the round-trip propagation delay is   m (which is typical for a transcontinental THE TRANSPORT LAYER  \n  fiber)  the sender will be idle more than  % of the time waiting for acknowledgements\n A larger window size would allow the sender to keep pumping data out\n The window scale option allows the sender and receiver to negotiate a window scale factor at the start of a connection\n Both sides use the scale factor to shift the Window size field up to   bits to the left  thus allowing windows of up to bytes\n Most TCP implementations support this option\n The timestamp option carries a timestamp sent by the sender and echoed by the receiver\n It is included in every packet  once its use is established during connection setup  and used to compute round-trip time samples that are used to estimate when a packet has been lost\n It is also used as a logical extension of the  - bit sequence number\n On a fast connection  the sequence number may wrap around quickly  leading to possible confusion between old and new data\n The PAWS (Protection Against Wrapped Sequence numbers) scheme discards arriving segments with old timestamps to prevent this problem\n Finally  the SACK (Selective ACKnowledgement) option lets a receiver tell a sender the ranges of sequence numbers that it has received\n It supplements the Acknowledgement number and is used after a packet has been lost but subsequent (or duplicate) data has arrived\n The new data is not reflected by the Acknowledgement number field in the header because that field gives only the next in-order byte that is expected\n With SACK  the sender is explicitly aware of what data the receiver has and hence can determine what data should be retransmitted\n SACK is defined in RFC  and RFC  and is increasingly used\n We describe the use of SACK along with congestion control in \n    \n    TCP Connection Establishment Connections are established in TCP by means of the three-way handshake discussed in \n   \n To establish a connection  one side  say  the server  passively waits for an incoming connection by executing the LISTEN and ACCEPT primitives in that order  either specifying a specific source or nobody in particular\n The other side  say  the client  executes a CONNECT primitive  specifying the IP address and port to which it wants to connect  the maximum TCP segment size it is willing to accept  and optionally some user data ( \n  a password)\n The CONNECT primitive sends a TCP segment with the SYN bit on and ACK bit off and waits for a response\n When this segment arrives at the destination  the TCP entity there checks to see if there is a process that has done a LISTEN on the port given in the Destination port field\n If not  it sends a reply with the RST bit on to reject the connection\n If some process is listening to the port  that process is given the incoming TCP segment\n It can either accept or reject the connection\n If it accepts  an acknowledgement segment is sent back\n The sequence of TCP segments sent in the normal case is shown in Fig\n  -  (a)\n Note that a SYN segment consumes  byte of sequence space so that it can be acknowledged unambiguously\n   THE INTERNET TRANSPORT PROTOCOLS: TCP Time Host  Host  SYN (SEQ = y  ACK=x+ ) SYN (SEQ = x) (SEQ = x +   ACK = y +  ) Host  Host  SYN (SEQ = y  ACK = x +  ) SYN (SEQ = x) SYN (SEQ = y) SYN (SEQ = x  ACK = y +  ) (a) (b) Figure  -  \n (a) TCP connection establishment in the normal case\n (b) Simultaneous connection establishment on both sides\n In the event that two hosts simultaneously attempt to establish a connection between the same two sockets  the sequence of events is as illustrated in Fig\n  -  (b)\n The result of these events is that just one connection is established  not two  because connections are identified by their end points\n If the first setup results in a connection identified by (x  y) and the ond one does too  only one table entry is made  namely  for (x  y)\n Recall that the initial sequence number chosen by each host should cycle slowly  rather than be a constant such as  \n This rule is to protect against delayed duplicate packets  as we discussed in    \n Originally this was accomplished with a clock-based scheme in which the clock ticked every  μ\n However  a vulnerability with implementing the three-way handshake is that the listening process must remember its sequence number as soon it responds with its own SYN segment\n This means that a malicious sender can tie up resources on a host by sending a stream of SYN segments and never following through to complete the connection\n This attack is called a SYN flood  and it crippled many Web servers in the s\n One way to defend against this attack is to use SYN cookies\n Instead of remembering the sequence number  a host chooses a cryptographically generated sequence number  puts it on the outgoing segment  and forgets it\n If the three-way handshake completes  this sequence number (plus  ) will be returned to the host\n It can then regenerate the correct sequence number by running the same cryptographic function  as long as the inputs to that function are known  for example  the other host’s IP address and port  and a local ret\n This procedure allows the host to check that an acknowledged sequence number is correct without having to THE TRANSPORT LAYER  \n  remember the sequence number separately\n There are some caveats  such as the inability to handle TCP options  so SYN cookies may be used only when the host is subject to a SYN flood\n However  they are an interesting twist on connection establishment\n For more information  see RFC  and Lemon (   )\n    TCP Connection Release Although TCP connections are full duplex  to understand how connections are released it is best to think of them as a pair of simplex connections\n Each simplex connection is released independently of its sibling\n To release a connection  either party can send a TCP segment with the FIN bit set  which means that it has no more data to transmit\n When the FIN is acknowledged  that direction is shut down for new data\n Data may continue to flow indefinitely in the other direction  however\n When both directions have been shut down  the connection is released\n Normally  four TCP segments are needed to release a connection: one FIN and one ACK for each direction\n However  it is possible for the first ACK and the ond FIN to be contained in the same segment  reducing the total count to three\n Just as with telephone calls in which both people say goodbye and hang up the phone simultaneously  both ends of a TCP connection may send FIN segments at the same time\n These are each acknowledged in the usual way  and the connection is shut down\n There is  in fact  no essential difference between the two hosts releasing sequentially or simultaneously\n To avoid the two-army problem (discussed in \n   )  timers are used\n If a response to a FIN is not forthcoming within two maximum packet lifetimes  the sender of the FIN releases the connection\n The other side will eventually notice that nobody seems to be listening to it anymore and will time out as well\n While this solution is not perfect  given the fact that a perfect solution is theoretically impossible  it will have to do\n In practice  problems rarely arise\n    TCP Connection Management Modeling The steps required to establish and release connections can be represented in a finite state machine with the   states listed in Fig\n  -  \n In each state  certain events are legal\n When a legal event happens  some action may be taken\n If some other event happens  an error is reported\n Each connection starts in the CLOSED state\n It leaves that state when it does either a passive open (LISTEN) or an active open (CONNECT)\n If the other side does the opposite one  a connection is established and the state becomes ESTABLISHED\n Connection release can be initiated by either side\n When it is complete  the state returns to CLOSED\n The finite state machine itself is shown in Fig\n  -  \n The common case of a client actively connecting to a passive server is shown with heavy lines—solid for the client  dotted for the server\n The lightface lines are unusual event sequences\n   THE INTERNET TRANSPORT PROTOCOLS: TCP State Description CLOSED No connection is active or pending LISTEN The server is waiting for an incoming call SYN RCVD A connection request has arrived; wait for ACK SYN SENT The application has started to open a connection ESTABLISHED The normal data transfer state FIN WAIT  The application has said it is finished FIN WAIT  The other side has agreed to release TIME WAIT Wait for all packets to die off CLOSING Both sides have tried to close simultaneously CLOSE WAIT The other side has initiated a release LAST ACK Wait for all packets to die off Figure  -  \n The states used in the TCP connection management finite state machine\n Each line in Fig\n  -  is marked by an event/action pair\n The event can either be a user-initiated system call (CONNECT  LISTEN  SEND  or CLOSE)  a segment arrival (SYN  FIN  ACK  or RST)  or  in one case  a timeout of twice the maximum packet lifetime\n The action is the sending of a control segment (SYN  FIN  or RST) or nothing  indicated by —\n Comments are shown in parentheses\n One can best understand the diagram by first following the path of a client (the heavy solid line)  then later following the path of a server (the heavy dashed line)\n When an application program on the client machine issues a CONNECT request  the local TCP entity creates a connection record  marks it as being in the SYN SENT state  and shoots off a SYN segment\n Note that many connections may be open (or being opened) at the same time on behalf of multiple applications  so the state is per connection and recorded in the connection record\n When the SYN+ACK arrives  TCP sends the final ACK of the three-way handshake and switches into the ESTABLISHED state\n Data can now be sent and received\n When an application is finished  it executes a CLOSE primitive  which causes the local TCP entity to send a FIN segment and wait for the corresponding ACK (dashed box marked ‘‘active close’’)\n When the ACK arrives  a transition is made to the state FIN WAIT  and one direction of the connection is closed\n When the other side closes  too  a FIN comes in  which is acknowledged\n Now both sides are closed  but TCP waits a time equal to twice the maximum packet lifetime to guarantee that all packets from the connection have died off  just in case the acknowledgement was lost\n When the timer goes off  TCP deletes the connection record\n Now let us examine connection management from the server’s viewpoint\n The server does a LISTEN and settles down to see who turns up\n When a SYN THE TRANSPORT LAYER  \n  CLOSED LISTEN ESTABLISHED CLOSING CLOSE WAIT (Start) CONNECT/SYN (Step  of the  -way handshake) LISTEN/– SYN/SYN + ACK SYN RCVD FIN WAIT  TIME WAIT LAST ACK FIN WAIT  SYN SENT RST/– ACK/– (Active close) FIN/ACK FIN + ACK/ACK FIN/ACK ACK/– ACK/– ACK/– SEND/SYN SYN/SYN + ACK (simultaneous open) (Data transfer state) SYN + ACK/ACK (Step  of the  -way handshake) CLOSE/FIN CLOSE/FIN FIN/ACK CLOSE/– CLOSE/– CLOSE/FIN CLOSED (Passive close) (Timeout/) (Go back to start) (Step  of the  -way handshake) Figure  -  \n TCP connection management finite state machine\n The heavy solid line is the normal path for a client\n The heavy dashed line is the normal path for a server\n The light lines are unusual events\n Each transition is labeled with the event causing it and the action resulting from it  separated by a slash\n comes in  it is acknowledged and the server goes to the SYN RCVD state\n When the server’s SYN is itself acknowledged  the three-way handshake is complete and the server goes to the ESTABLISHED state\n Data transfer can now occur\n When the client is done transmitting its data  it does a CLOSE  which causes a FIN to arrive at the server (dashed box marked ‘‘passive close’’)\n The server is then signaled\n When it  too  does a CLOSE  a FIN is sent to the client\n When the   THE INTERNET TRANSPORT PROTOCOLS: TCP client’s acknowledgement shows up  the server releases the connection and deletes the connection record\n    TCP Sliding Window As mentioned earlier  window management in TCP decouples the issues of acknowledgement of the correct receipt of segments and receiver buffer allocation\n For example  suppose the receiver has a -byte buffer  as shown in Fig\n  -  \n If the sender transmits a -byte segment that is correctly received  the receiver will acknowledge the segment\n However  since it now has only  bytes of buffer space (until the application removes some data from the buffer)  it will advertise a window of  starting at the next byte expected\n Application does a  -KB write Application does a  -KB write Application reads  KB Sender is blocked Sender may send up to  -KB Receiver’s buffer   KB  KB  KB Empty Full  KB SEQ = KB SEQ =   KB SEQ =  ACK =  WIN =  ACK =  WIN =  ACK =  WIN =   KB  KB Sender Receiver Figure  -  \n Window management in TCP\n Now the sender transmits another  bytes  which are acknowledged  but the advertised window is of size  \n The sender must stop until the application THE TRANSPORT LAYER  \n  process on the receiving host has removed some data from the buffer  at which time TCP can advertise a larger window and more data can be sent\n When the window is   the sender may not normally send segments  with two exceptions\n First  urgent data may be sent  for example  to allow the user to kill the process running on the remote machine\n ond  the sender may send a  -byte segment to force the receiver to reannounce the next byte expected and the window size\n This packet is called a window probe\n The TCP standard explicitly provides this option to prevent deadlock if a window update ever gets lost\n Senders are not required to transmit data as soon as they come in from the application\n Neither are receivers required to send acknowledgements as soon as possible\n For example  in Fig\n  -   when the first  KB of data came in  TCP  knowing that it had a  -KB window  would have been completely correct in just buffering the data until another  KB came in  to be able to transmit a segment with a  -KB payload\n This freedom can be used to improve performance\n Consider a connection to a remote terminal  for example using SSH or telnet  that reacts on every keystroke\n In the worst case  whenever a character arrives at the sending TCP entity  TCP creates a  -byte TCP segment  which it gives to IP to send as a  -byte IP datagram\n At the receiving side  TCP immediately sends a  -byte acknowledgement (  bytes of TCP header and   bytes of IP header)\n Later  when the remote terminal has read the byte  TCP sends a window update  moving the window  byte to the right\n This packet is also   bytes\n Finally  when the remote terminal has processed the character  it echoes the character for local display using a  -byte packet\n In all  bytes of bandwidth are used and four segments are sent for each character typed\n When bandwidth is scarce  this method of doing business is not desirable\n One approach that many TCP implementations use to optimize this situation is called delayed acknowledgements\n The idea is to delay acknowledgements and window updates for up to m in the hope of acquiring some data on which to hitch a free ride\n Assuming the terminal echoes within m  only one  -byte packet now need be sent back by the remote side  cutting the packet count and bandwidth usage in half\n Although delayed acknowledgements reduce the load placed on the network by the receiver  a sender that sends multiple short packets ( \n   -byte packets containing  byte of data) is still operating inefficiently\n A way to reduce this usage is known as Nagle’s algorithm (Nagle  )\n What Nagle suggested is simple: when data come into the sender in small pieces  just send the first piece and buffer all the rest until the first piece is acknowledged\n Then send all the buffered data in one TCP segment and start buffering again until the next segment is acknowledged\n That is  only one short packet can be outstanding at any time\n If many pieces of data are sent by the application in one round-trip time  Nagle’s algorithm will put the many pieces in one segment  greatly reducing the bandwidth used\n The algorithm additionally says that a new segment should be sent if enough data have trickled in to fill a maximum segment\n   THE INTERNET TRANSPORT PROTOCOLS: TCP Nagle’s algorithm is widely used by TCP implementations  but there are times when it is better to disable it\n In particular  in interactive games that are run over the Internet  the players typically want a rapid stream of short update packets\n Gathering the updates to send them in bursts makes the game respond erratically  which makes for unhappy users\n A more subtle problem is that Nagle’s algorithm can sometimes interact with delayed acknowledgements to cause a temporary deadlock: the receiver waits for data on which to piggyback an acknowledgement  and the sender waits on the acknowledgement to send more data\n This interaction can delay the downloads of Web pages\n Because of these problems  Nagle’s algorithm can be disabled (which is called the TCP NODELAY option)\n Mogul and Minshall (   ) discuss this and other solutions\n Another problem that can degrade TCP performance is the silly window syndrome (Clark  )\n This problem occurs when data are passed to the sending TCP entity in large blocks  but an interactive application on the receiving side reads data only  byte at a time\n To see the problem  look at Fig\n  -  \n Initially  the TCP buffer on the receiving side is full ( \n  it has a window of size  ) and the sender knows this\n Then the interactive application reads one character from the TCP stream\n This action makes the receiving TCP happy  so it sends a window update to the sender saying that it is all right to send  byte\n The sender obliges and sends  byte\n The buffer is now full  so the receiver acknowledges the  -byte segment and sets the window to  \n This behavior can go on forever\n Clark’s solution is to prevent the receiver from sending a window update for  byte\n Instead  it is forced to wait until it has a decent amount of space available and advertise that instead\n Specifically  the receiver should not send a window update until it can handle the maximum segment size it advertised when the connection was established or until its buffer is half empty  whichever is smaller\n Furthermore  the sender can also help by not sending tiny segments\n Instead  it should wait until it can send a full segment  or at least one containing half of the receiver’s buffer size\n Nagle’s algorithm and Clark’s solution to the silly window syndrome are complementary\n Nagle was trying to solve the problem caused by the sending application delivering data to TCP a byte at a time\n Clark was trying to solve the problem of the receiving application sucking the data up from TCP a byte at a time\n Both solutions are valid and can work together\n The goal is for the sender not to send small segments and the receiver not to ask for them\n The receiving TCP can go further in improving performance than just doing window updates in large units\n Like the sending TCP  it can also buffer data  so it can block a READ request from the application until it has a large chunk of data for it\n Doing so reduces the number of calls to TCP (and the overhead)\n It also increases the response time  but for noninteractive applications like file transfer  efficiency may be more important than response time to individual requests\n Another issue that the receiver must handle is that segments may arrive out of order\n The receiver will buffer the data until it can be passed up to the application THE TRANSPORT LAYER  \n  Application reads  byte Window update segment sent New byte arrives Header Header Receiver's buffer is full Receiver's buffer is full Room for one more byte  Byte Figure  -  \n Silly window syndrome\n in order\n Actually  nothing bad would happen if out-of-order segments were discarded  since they would eventually be retransmitted by the sender  but it would be wasteful\n Acknowledgements can be sent only when all the data up to the byte acknowledged have been received\n This is called a cumulative acknowledgement\n If the receiver gets segments     and   it can acknowledge everything up to and including the last byte in segment  \n When the sender times out  it then retransmits segment  \n As the receiver has buffered segments  through   upon receipt of segment  it can acknowledge all bytes up to the end of segment  \n    TCP Timer Management TCP uses multiple timers (at least conceptually) to do its work\n The most important of these is the RTO (Retransmission TimeOut)\n When a segment is sent  a retransmission timer is started\n If the segment is acknowledged before the timer expires  the timer is stopped\n If  on the other hand  the timer goes off before the acknowledgement comes in  the segment is retransmitted (and the timer os started again)\n The question that arises is: how long should the timeout be? This problem is much more difficult in the transport layer than in data link protocols such as    In the latter case  the expected delay is measured in   THE INTERNET TRANSPORT PROTOCOLS: TCP microonds and is highly predictable ( \n  has a low variance)  so the timer can be set to go off just slightly after the acknowledgement is expected  as shown in Fig\n  -  (a)\n Since acknowledgements are rarely delayed in the data link layer (due to lack of congestion)  the absence of an acknowledgement at the expected time generally means either the frame or the acknowledgement has been lost  T T  T     Round-trip time (microonds) (a) (b) Probability    \n   Probability    Round-trip time (millionds)  Figure  -  \n (a) Probability density of acknowledgement arrival times in the data link layer\n (b) Probability density of acknowledgement arrival times for TCP\n TCP is faced with a radically different environment\n The probability density function for the time it takes for a TCP acknowledgement to come back looks more like Fig\n  -  (b) than Fig\n  -  (a)\n It is larger and more variable\n Determining the round-trip time to the destination is tricky\n Even when it is known  deciding on the timeout interval is also difficult\n If the timeout is set too short  say  T  in Fig\n  -  (b)  unnecessary retransmissions will occur  clogging the Internet with useless packets\n If it is set too long ( \n  T )  performance will suffer due to the long retransmission delay whenever a packet is lost\n Furthermore  the mean and variance of the acknowledgement arrival distribution can change rapidly within a few onds as congestion builds up or is resolved\n The solution is to use a dynamic algorithm that constantly adapts the timeout interval  based on continuous measurements of network performance\n The algorithm generally used by TCP is due to Jacobson (   ) and works as follows\n For each connection  TCP maintains a variable  SRTT (Smoothed Round-Trip Time)  that is the best current estimate of the round-trip time to the destination in question\n When a segment is sent  a timer is started  both to see how long the acknowledgement takes and also to trigger a retransmission if it takes too long\n If THE TRANSPORT LAYER  \n  the acknowledgement gets back before the timer expires  TCP measures how long the acknowledgement took  say  R\n It then updates SRTT according to the formula SRTT = α SRTT + (  − α) R where α is a smoothing factor that determines how quickly the old values are forgotten\n Typically  α =  / \n This kind of formula is an EWMA (Exponentially Weighted Moving Average) or low-pass filter that discards noise in the samples\n Even given a good value of SRTT  choosing a suitable retransmission timeout is a nontrivial matter\n Initial implementations of TCP used  xRTT  but experience showed that a constant value was too inflexible because it failed to respond when the variance went up\n In particular  queueing models of random ( \n  Poisson) traffic predict that when the load approaches capacity  the delay becomes large and highly variable\n This can lead to the retransmission timer firing and a copy of the packet being retransmitted although the original packet is still transiting the network\n It is all the more likely to happen under conditions of high load  which is the worst time at which to send additional packets into the network\n To fix this problem  Jacobson proposed making the timeout value sensitive to the variance in round-trip times as well as the smoothed round-trip time\n This change requires keeping track of another smoothed variable  RTTVAR (Round- Trip Time VARiation) that is updated using the formula RTTVAR = β RTTVAR + (  − β) |SRTT − R | This is an EWMA as before  and typically β =  / \n The retransmission timeout  RTO  is set to be RTO = SRTT +  × RTTVAR The choice of the factor  is somewhat arbitrary  but multiplication by  can be done with a single shift  and less than  % of all packets come in more than four standard deviations late\n Note that RTTVAR is not exactly the same as the standard deviation (it is really the mean deviation)  but it is close enough in practice\n Jacobson’s paper is full of clever tricks to compute timeouts using only integer adds  subtracts  and shifts\n This economy is not needed for modern hosts  but it has become part of the culture that allows TCP to run on all manner of devices  from supercomputers down to tiny devices\n So far nobody has put it on an RFID chip  but someday? Who knows\n More details of how to compute this timeout  including initial settings of the variables  are given in RFC \n The retransmission timer is also held to a minimum of  ond  regardless of the estimates\n This is a conservative value chosen to prevent spurious retransmissions based on measurements (Allman and Paxson  )\n One problem that occurs with gathering the samples  R  of the round-trip time is what to do when a segment times out and is sent again\n When the acknowledgement comes in  it is unclear whether the acknowledgement refers to the first   THE INTERNET TRANSPORT PROTOCOLS: TCP transmission or a later one\n Guessing wrong can seriously contaminate the retransmission timeout\n Phil Karn discovered this problem the hard way\n Karn is an amateur radio enthusiast interested in transmitting TCP/IP packets by ham radio  a notoriously unreliable medium\n He made a simple proposal: do not update estimates on any segments that have been retransmitted\n Additionally  the timeout is doubled on each successive retransmission until the segments get through the first time\n This fix is called Karn’s algorithm (Karn and Partridge  )\n Most TCP implementations use it\n The retransmission timer is not the only timer TCP uses\n A ond timer is the persistence timer\n It is designed to prevent the following deadlock\n The receiver sends an acknowledgement with a window size of   telling the sender to wait\n Later  the receiver updates the window  but the packet with the update is lost\n Now the sender and the receiver are each waiting for the other to do something\n When the persistence timer goes off  the sender transmits a probe to the receiver\n The response to the probe gives the window size\n If it is still   the persistence timer is set again and the cycle repeats\n If it is nonzero  data can now be sent\n A third timer that some implementations use is the keepalive timer\n When a connection has been idle for a long time  the keepalive timer may go off to cause one side to check whether the other side is still there\n If it fails to respond  the connection is terminated\n This feature is controversial because it adds overhead and may terminate an otherwise healthy connection due to a transient network partition\n The last timer used on each TCP connection is the one used in the TIME WAIT state while closing\n It runs for twice the maximum packet lifetime to make sure that when a connection is closed  all packets created by it have died off\n    TCP Congestion Control We have saved one of the key functions of TCP for last: congestion control\n When the load offered to any network is more than it can handle  congestion builds up\n The Internet is no exception\n The network layer detects congestion when queues grow large at routers and tries to manage it  if only by dropping packets\n It is up to the transport layer to receive congestion feedback from the network layer and slow down the rate of traffic that it is sending into the network\n In the Internet  TCP plays the main role in controlling congestion  as well as the main role in reliable transport\n That is why it is such a special protocol\n We covered the general situation of congestion control in \n   One key takeaway was that a transport protocol using an AIMD (Additive Increase Multiplicative Decrease) control law in response to binary congestion signals from the network would converge to a fair and efficient bandwidth allocation\n TCP congestion control is based on implementing this approach using a window and with packet loss as the binary signal\n To do so  TCP maintains a congestion window THE TRANSPORT LAYER  \n  whose size is the number of bytes the sender may have in the network at any time\n The corresponding rate is the window size divided by the round-trip time of the connection\n TCP adjusts the size of the window according to the AIMD rule\n Recall that the congestion window is maintained in addition to the flow control window  which specifies the number of bytes that the receiver can buffer\n Both windows are tracked in parallel  and the number of bytes that may be sent is the smaller of the two windows\n Thus  the effective window is the smaller of what the sender thinks is all right and what the receiver thinks is all right\n It takes two to tango\n TCP will stop sending data if either the congestion or the flow control window is temporarily full\n If the receiver says ‘‘send   KB’’ but the sender knows that bursts of more than   KB clog the network  it will send   KB\n On the other hand  if the receiver says ‘‘send   KB’’ and the sender knows that bursts of up to KB get through effortlessly  it will send the full   KB requested\n The flow control window was described earlier  and in what follows we will only describe the congestion window\n Modern congestion control was added to TCP largely through the efforts of Van Jacobson (   )\n It is a fascinating story\n Starting in  the growing popularity of the early Internet led to the first occurrence of what became known as a congestion collapse  a prolonged period during which goodput dropped precipitously ( \n  by more than a factor of   ) due to congestion in the network\n Jacobson (and many others) set out to understand what was happening and remedy the situation\n The high-level fix that Jacobson implemented was to approximate an AIMD congestion window\n The interesting part  and much of the complexity of TCP congestion control  is how he added this to an existing implementation without changing any of the message formats  which made it instantly deployable\n To start  he observed that packet loss is a suitable signal of congestion\n This signal comes a little late (as the network is already congested) but it is quite dependable\n After all  it is difficult to build a router that does not drop packets when it is overloaded\n This fact is unlikely to change\n Even when terabyte memories appear to buffer vast numbers of packets  we will probably have terabit/ networks to fill up those memories\n However  using packet loss as a congestion signal depends on transmission errors being relatively rare\n This is not normally the case for wireless links such as   \n   which is why they include their own retransmission mechanism at the link layer\n Because of wireless retransmissions  network layer packet loss due to transmission errors is normally masked on wireless networks\n It is also rare on other links because wires and optical fibers typically have low bit-error rates\n All the Internet TCP algorithms assume that lost packets are caused by congestion and monitor timeouts and look for signs of trouble the way miners watch their canaries\n A good retransmission timer is needed to detect packet loss signals accurately and in a timely manner\n We have already discussed how the TCP retransmission timer includes estimates of the mean and variation in round-trip   THE INTERNET TRANSPORT PROTOCOLS: TCP times\n Fixing this timer  by including the variation factor  was an important step in Jacobson’s work\n Given a good retransmission timeout  the TCP sender can track the outstanding number of bytes  which are loading the network\n It simply looks at the difference between the sequence numbers that are transmitted and acknowledged\n Now it seems that our task is easy\n All we need to do is to track the congestion window  using sequence and acknowledgement numbers  and adjust the congestion window using an AIMD rule\n As you might have expected  it is more complicated than that\n A first consideration is that the way packets are sent into the network  even over short periods of time  must be matched to the network path\n Otherwise the traffic will cause congestion\n For example  consider a host with a congestion window of   KB attached to a  -Gbps switched Ethernet\n If the host sends the entire window at once  this burst of traffic may travel over a slow  -Mbps ADSL line further along the path\n The burst that took only half a milliond on the  -Gbps line will clog the  -Mbps line for half a ond  completely disrupting protocols such as voice over IP\n This behavior might be a good idea for a protocol designed to cause congestion  but not for a protocol to control it\n However  it turns out that we can use small bursts of packets to our advantage\n Fig\n  -  shows what happens when a sender on a fast network (the  -Gbps link) sends a small burst of four packets to a receiver on a slow network (the  - Mbps link) that is the bottleneck or slowest part of the path\n Initially the four packets travel over the link as quickly as they can be sent by the sender\n At the router  they are queued while being sent because it takes longer to send a packet over the slow link than to receive the next packet over the fast link\n But the queue is not large because only a small number of packets were sent at once\n Note the increased length of the packets on the slow link\n The same packet  of  KB say  is now longer because it takes more time to send it on a slow link than on a fast one\n Fast link Slow link (bottleneck)  : Burst of packets sent on fast link  : Burst queues at router and drains onto slow link  : Receive acks packets at slow link rate  : Acks preserve slow link timing at sender Ack clock Sender Receiver          Figure  -  \n A burst of packets from a sender and the returning ack clock\n Eventually the packets get to the receiver  where they are acknowledged\n The times for the acknowledgements reflect the times at which the packets arrived at the receiver after crossing the slow link\n They are spread out compared to the original packets on the fast link\n As these acknowledgements travel over the network and back to the sender they preserve this timing\n THE TRANSPORT LAYER  \n  The key observation is this: the acknowledgements return to the sender at about the rate that packets can be sent over the slowest link in the path\n This is precisely the rate that the sender wants to use\n If it injects new packets into the network at this rate  they will be sent as fast as the slow link permits  but they will not queue up and congest any router along the path\n This timing is known as an ack clock\n It is an essential part of TCP\n By using an ack clock  TCP smoothes out traffic and avoids unnecessary queues at routers\n A ond consideration is that the AIMD rule will take a very long time to reach a good operating point on fast networks if the congestion window is started from a small size\n Consider a modest network path that can support   Mbps with an RTT of m\n The appropriate congestion window is the bandwidth-delay product  which is  Mbit or packets of  bytes each\n If the congestion window starts at  packet and increases by  packet every RTT  it will be RTTs or   onds before the connection is running at about the right rate\n That is a long time to wait just to get to the right speed for a transfer\n We could reduce this startup time by starting with a larger initial window  say of   packets\n But this window would be far too large for slow or short links\n It would cause congestion if used all at once  as we have just described\n Instead  the solution Jacobson chose to handle both of these considerations is a mix of linear and multiplicative increase\n When a connection is established  the sender initializes the congestion window to a small initial value of at most four segments; the details are described in RFC  and the use of four segments is an increase from an earlier initial value of one segment based on experience\n The sender then sends the initial window\n The packets will take a round-trip time to be acknowledged\n For each segment that is acknowledged before the retransmission timer goes off  the sender adds one segment’s worth of bytes to the congestion window\n Plus  as that segment has been acknowledged  there is now one less segment in the network\n The upshot is that every acknowledged segment allows two more segments to be sent\n The congestion window is doubling every roundtrip time\n This algorithm is called slow start  but it is not slow at all—it is exponential growth—except in comparison to the previous algorithm that let an entire flow control window be sent all at once\n Slow start is shown in Fig\n  -  \n In the first round-trip time  the sender injects one packet into the network (and the receiver receives one packet)\n Two packets are sent in the next round-trip time  then four packets in the third round-trip time\n Slow-start works well over a range of link speeds and round-trip times  and uses an ack clock to match the rate of sender transmissions to the network path\n Take a look at the way acknowledgements return from the sender to the receiver in Fig\n  -  \n When the sender gets an acknowledgement  it increases the congestion window by one and immediately sends two packets into the network\n (One packet is the increase by one; the other packet is a replacement for the packet that has been acknowledged and left the network\n At all times  the number of   THE INTERNET TRANSPORT PROTOCOLS: TCP cwnd = RTT   packet cwnd =  cwnd =  cwnd =  cwnd =  cwnd =  cwnd =  cwnd = RTT   packets  RTT   packets  RTT   packets (pipe is full) Data Acknowledgement TCP sender TCP receiver Figure  -  \n Slow start from an initial congestion window of one segment\n unacknowledged packets is given by the congestion window\n) However  these two packets will not necessarily arrive at the receiver as closely spaced as when they were sent\n For example  suppose the sender is on a   -Mbps Ethernet\n Each packet of  bytes takes μ to send\n So the delay between the packets can be as small as μ\n The situation changes if these packets go across a  - Mbps ADSL link anywhere along the path\n It now takes   m to send the same packet\n This means that the minimum spacing between the two packets has grown by a factor of   \n Unless the packets have to wait together in a queue on a later link  the spacing will remain large\n In Fig\n  -   this effect is shown by enforcing a minimum spacing between data packets arriving at the receiver\n The same spacing is kept when the receiver sends acknowledgements  and thus when the sender receives the acknowledgements\n If the network path is slow  acknowledgements will come in slowly (after a delay of an RTT)\n If the network path is fast  acknowledgements will come in quickly (again  after the RTT)\n All the sender has to do is follow the timing of the ack clock as it injects new packets  which is what slow start does\n Because slow start causes exponential growth  eventually (and sooner rather than later) it will send too many packets into the network too quickly\n When this happens  queues will build up in the network\n When the queues are full  one or more packets will be lost\n After this happens  the TCP sender will time out when an acknowledgement fails to arrive in time\n There is evidence of slow start growing too fast in Fig\n  -  \n After three RTTs  four packets are in the network\n These four packets take an entire RTT to arrive at the receiver\n That is  a congestion window of four packets is the right size for this connection\n However  as these packets are acknowledged  slow start continues to grow the congestion window  reaching eight packets in another RTT\n Only four of these packets can reach the receiver in one RTT  no matter how many are sent\n That is  the network pipe is full\n Additional packets placed into the network by the sender will build up in THE TRANSPORT LAYER  \n  router queues  since they cannot be delivered to the receiver quickly enough\n Congestion and packet loss will occur soon\n To keep slow start under control  the sender keeps a threshold for the connection called the slow start threshold\n Initially this value is set arbitrarily high  to the size of the flow control window  so that it will not limit the connection\n TCP keeps increasing the congestion window in slow start until a timeout occurs or the congestion window exceeds the threshold (or the receiver’s window is filled)\n Whenever a packet loss is detected  for example  by a timeout  the slow start threshold is set to be half of the congestion window and the entire process is restarted\n The idea is that the current window is too large because it caused congestion previously that is only now detected by a timeout\n Half of the window  which was used successfully at an earlier time  is probably a better estimate for a congestion window that is close to the path capacity but will not cause loss\n In our example in Fig\n  -   growing the congestion window to eight packets may cause loss  while the congestion window of four packets in the previous RTT was the right value\n The congestion window is then reset to its small initial value and slow start resumes\n Whenever the slow start threshold is crossed  TCP switches from slow start to additive increase\n In this mode  the congestion window is increased by one segment every round-trip time\n Like slow start  this is usually implemented with an increase for every segment that is acknowledged  rather than an increase once per RTT\n Call the congestion window cwnd and the maximum segment size MSS\n A common approximation is to increase cwnd by (MSS × MSS)/cwnd for each of the cwnd /MSS packets that may be acknowledged\n This increase does not need to be fast\n The whole idea is for a TCP connection to spend a lot of time with its congestion window close to the optimum value—not so small that throughput will be low  and not so large that congestion will occur\n Additive increase is shown in Fig\n  -  for the same situation as slow start\n At the end of every RTT  the sender’s congestion window has grown enough that it can inject an additional packet into the network\n Compared to slow start  the linear rate of growth is much slower\n It makes little difference for small congestion windows  as is the case here  but a large difference in the time taken to grow the congestion window to segments  for example\n There is something else that we can do to improve performance too\n The defect in the scheme so far is waiting for a timeout\n Timeouts are relatively long because they must be conservative\n After a packet is lost  the receiver cannot acknowledge past it  so the acknowledgement number will stay fixed  and the sender will not be able to send any new packets into the network because its congestion window remains full\n This condition can continue for a relatively long period until the timer fires and the lost packet is retransmitted\n At that stage  TCP slow starts again\n There is a quick way for the sender to recognize that one of its packets has been lost\n As packets beyond the lost packet arrive at the receiver  they trigger   THE INTERNET TRANSPORT PROTOCOLS: TCP cwnd = RTT   packets cwnd =  cwnd =  cwnd = RTT   packets  RTT   packets  RTT   packets (pipe is full) Data Acknowledgement TCP sender TCP receiver cwnd = RTT   packet Figure  -  \n Additive increase from an initial congestion window of one segment\n acknowledgements that return to the sender\n These acknowledgements bear the same acknowledgement number\n They are called duplicate acknowledgements\n Each time the sender receives a duplicate acknowledgement  it is likely that another packet has arrived at the receiver and the lost packet still has not shown up\n Because packets can take different paths through the network  they can arrive out of order\n This will trigger duplicate acknowledgements even though no packets have been lost\n However  this is uncommon in the Internet much of the time\n When there is reordering across multiple paths  the received packets are usually not reordered too much\n Thus  TCP somewhat arbitrarily assumes that three duplicate acknowledgements imply that a packet has been lost\n The identity of the lost packet can be inferred from the acknowledgement number as well\n It is the very next packet in sequence\n This packet can then be retransmitted right away  before the retransmission timeout fires\n This heuristic is called fast retransmission\n After it fires  the slow start threshold is still set to half the current congestion window  just as with a timeout\n Slow start can be restarted by setting the congestion window to one packet\n With this window size  a new packet will be sent after the one round-trip time that it takes to acknowledge the retransmitted packet along with all data that had been sent before the loss was detected\n An illustration of the congestion algorithm we have built up so far is shown in Fig\n  -  \n This version of TCP is called TCP Tahoe after the  \n BSD Tahoe release in  in which it was included\n The maximum segment size here is  KB\n Initially  the congestion window was   KB  but a timeout occurred  so the threshold is set to   KB and the congestion window to  KB for transmission  \n The congestion window grows exponentially until it hits the threshold (  KB)\n The THE TRANSPORT LAYER  \n  window is increased every time a new acknowledgement arrives rather than continuously  which leads to the discrete staircase pattern\n After the threshold is passed  the window grows linearly\n It is increased by one segment every RTT\n  Transmission round (RTTs) Additive increase Threshold  KB Packet loss Congestion window (KB or packets)          Slow start  Threshold  KB Figure  -  \n Slow start followed by additive increase in TCP Tahoe\n The transmissions in round   are unlucky (they should have known)  and one of them is lost in the network\n This is detected when three duplicate acknowledgements arrive\n At that time  the lost packet is retransmitted  the threshold is set to half the current window (by now   KB  so half is   KB)  and slow start is initiated all over again\n Restarting with a congestion window of one packet takes one round-trip time for all of the previously transmitted data to leave the network and be acknowledged  including the retransmitted packet\n The congestion window grows with slow start as it did previously  until it reaches the new threshold of   KB\n At that time  the growth becomes linear again\n It will continue in this fashion until another packet loss is detected via duplicate acknowledgements or a timeout (or the receiver’s window becomes the limit)\n TCP Tahoe (which included good retransmission timers) provided a working congestion control algorithm that solved the problem of congestion collapse\n Jacobson realized that it is possible to do even better\n At the time of the fast retransmission  the connection is running with a congestion window that is too large  but it is still running with a working ack clock\n Every time another duplicate acknowledgement arrives  it is likely that another packet has left the network\n Using duplicate acknowledgements to count the packets in the network  makes it possible to let some packets exit the network and continue to send a new packet for each additional duplicate acknowledgement\n Fast recovery is the heuristic that implements this behavior\n It is a temporary mode that aims to maintain the ack clock running with a congestion window that is the new threshold  or half the value of the congestion window at the time of the   THE INTERNET TRANSPORT PROTOCOLS: TCP fast retransmission\n To do this  duplicate acknowledgements are counted (including the three that triggered fast retransmission) until the number of packets in the network has fallen to the new threshold\n This takes about half a round-trip time\n From then on  a new packet can be sent for each duplicate acknowledgement that is received\n One round-trip time after the fast retransmission  the lost packet will have been acknowledged\n At that time  the stream of duplicate acknowledgements will cease and fast recovery mode will be exited\n The congestion window will be set to the new slow start threshold and grows by linear increase\n The upshot of this heuristic is that TCP avoids slow start  except when the connection is first started and when a timeout occurs\n The latter can still happen when more than one packet is lost and fast retransmission does not recover adequately\n Instead of repeated slow starts  the congestion window of a running connection follows a sawtooth pattern of additive increase (by one segment every RTT) and multiplicative decrease (by half in one RTT)\n This is exactly the AIMD rule that we sought to implement\n This sawtooth behavior is shown in Fig\n  -  \n It is produced by TCP Reno  named after the  \n BSD Reno release in  in which it was included\n TCP Reno is essentially TCP Tahoe plus fast recovery\n After an initial slow start  the congestion window climbs linearly until a packet loss is detected by duplicate acknowledgements\n The lost packet is retransmitted and fast recovery is used to keep the ack clock running until the retransmission is acknowledged\n At that time  the congestion window is resumed from the new slow start threshold  rather than from  \n This behavior continues indefinitely  and the connection spends most of the time with its congestion window close to the optimum value of the bandwidth- delay product\n  Transmission round (RTTs) Additive Packet increase loss Congestion window (KB or packets)        Slow start  Thresh\n Threshold Fast recovery Multiplicative decrease Threshold Figure  -  \n Fast recovery and the sawtooth pattern of TCP Reno\n TCP Reno with its mechanisms for adjusting the congestion window has formed the basis for TCP congestion control for more than two decades\n Most of THE TRANSPORT LAYER  \n  the changes in the intervening years have adjusted these mechanisms in minor ways  for example  by changing the choices of the initial window and removing various ambiguities\n Some improvements have been made for recovering from two or more losses in a window of packets\n For example  the TCP NewReno version uses a partial advance of the acknowledgement number after a retransmission to find and repair another loss (Hoe  )  as described in RFC \n Since the mid-   s  several variations have emerged that follow the principles we have described but use slightly different control laws\n For example  Linux uses a variant called CUBIC TCP (Ha et al\n  ) and Windows includes a variant called Compound TCP (Tan et al\n  )\n Two larger changes have also affected TCP implementations\n First  much of the complexity of TCP comes from inferring from a stream of duplicate acknowledgements which packets have arrived and which packets have been lost\n The cumulative acknowledgement number does not provide this information\n A simple fix is the use of SACK (Selective ACKnowledgements)  which lists up to three ranges of bytes that have been received\n With this information  the sender can more directly decide what packets to retransmit and track the packets in flight to implement the congestion window\n When the sender and receiver set up a connection  they each send the SACK permitted TCP option to signal that they understand selective acknowledgements\n Once SACK is enabled for a connection  it works as shown in Fig\n  -  \n A receiver uses the TCP Acknowledgement number field in the normal manner  as a cumulative acknowledgement of the highest in-order byte that has been received\n When it receives packet  out of order (because packet  was lost)  it sends a SACK option for the received data along with the (duplicate) cumulative acknowledgement for packet  \n The SACK option gives the byte ranges that have been received above the number given by the cumulative acknowledgement\n The first range is the packet that triggered the duplicate acknowledgement\n The next ranges  if present  are older blocks\n Up to three ranges are commonly used\n By the time packet  is received  two SACK byte ranges are used to indicate that packet  and packets  to  have been received  in addition to all packets up to packet  \n From the information in each SACK option that it receives  the sender can decide which packets to retransmit\n In this case  retransmitting packets  and  would be a good idea\n SACK is strictly advisory information\n The actual detection of loss using duplicate acknowledgements and adjustments to the congestion window proceed just as before\n However  with SACK  TCP can recover more easily from situations in which multiple packets are lost at roughly the same time  since the TCP sender knows which packets have not been received\n SACK is now widely deployed\n It is described in RFC  and TCP congestion control using SACK is described in RFC \n The ond change is the use of ECN (Explicit Congestion Notification) in addition to packet loss as a congestion signal\n ECN is an IP layer mechanism to   THE INTERNET TRANSPORT PROTOCOLS: TCP    Lost packets ACK:  ACK:  SACK:  ACK:  SACK:  -  ACK:  SACK: -  Sender Receiver Retransmit  and  ! Figure  -  \n Selective acknowledgements\n notify hosts of congestion that we described in \n   \n With it  the TCP receiver can receive congestion signals from IP\n The use of ECN is enabled for a TCP connection when both the sender and receiver indicate that they are capable of using ECN by setting the ECE and CWR bits during connection establishment\n If ECN is used  each packet that carries a TCP segment is flagged in the IP header to show that it can carry an ECN signal\n Routers that support ECN will set a congestion signal on packets that can carry ECN flags when congestion is approaching  instead of dropping those packets after congestion has occurred\n The TCP receiver is informed if any packet that arrives carries an ECN congestion signal\n The receiver then uses the ECE (ECN Echo) flag to signal the TCP sender that its packets have experienced congestion\n The sender tells the receiver that it has heard the signal by using the CWR (Congestion Window Reduced) flag\n The TCP sender reacts to these congestion notifications in exactly the same way as it does to packet loss that is detected via duplicate acknowledgements\n However  the situation is strictly better\n Congestion has been detected and no packet was harmed in any way\n ECN is described in RFC \n It requires both host and router support  and is not yet widely used on the Internet\n For more information on the complete set of congestion control behaviors that are implemented in TCP  see RFC \n    The Future of TCP As the workhorse of the Internet  TCP has been used for many applications and extended over time to give good performance over a wide range of networks\n Many versions are deployed with slightly different implementations than the classic algorithms we have described  especially for congestion control and robustness against attacks\n It is likely that TCP will continue to evolve with the Internet\n We will mention two particular issues\n The first one is that TCP does not provide the transport semantics that all applications want\n For example  some applications want to send messages or records whose boundaries need to be preserved\n Other applications work with a group of THE TRANSPORT LAYER  \n  related conversations  such as a Web browser that transfers several objects from the same server\n Still other applications want better control over the network paths that they use\n TCP with its standard sockets interface does not meet these needs well\n Essentially  the application has the burden of dealing with any problem not solved by TCP\n This has led to proposals for new protocols that would provide a slightly different interface\n Two examples are SCTP (Stream Control Transmission Protocol)  defined in RFC  and SST (Structured Stream Transport) (Ford  )\n However  whenever someone proposes changing something that has worked so well for so long  there is always a huge battle between the ‘‘Users are demanding more features’’ and ‘‘If it ain’t broke  don’t fix it’’ camps\n The ond issue is congestion control\n You may have expected that this is a solved problem after our deliberations and the mechanisms that have been developed over time\n Not so\n The form of TCP congestion control that we described  and which is widely used  is based on packet losses as a signal of congestion\n When Padhye et al\n (   ) modeled TCP throughput based on the sawtooth pattern  they found that the packet loss rate must drop off rapidly with increasing speed\n To reach a throughput of  Gbps with a round-trip time of ms and  byte packets  one packet can be lost approximately every   minutes\n That is a packet loss rate of  ×  −  which is incredibly small\n It is too infrequent to serve as a good congestion signal  and any other source of loss ( \n  packet transmission error rates of  − ) can easily dominate it  limiting the throughput\n This relationship has not been a problem in the past  but networks are getting faster and faster  leading many people to revisit congestion control\n One possibility is to use an alternate congestion control in which the signal is not packet loss at all\n We gave several examples in \n   The signal might be round-trip time  which grows when the network becomes congested  as is used by FAST TCP (Wei et al\n  )\n Other approaches are possible too  and time will tell which is the best  PERFORMANCE ISSUES Performance issues are very important in computer networks\n When hundreds or thousands of computers are interconnected  complex interactions  with unforeseen consequences  are common\n Frequently  this complexity leads to poor performance and no one knows why\n In the following tions  we will examine many issues related to network performance to see what kinds of problems exist and what can be done about them\n Unfortunately  understanding network performance is more an art than a science\n There is little underlying theory that is actually of any use in practice\n The best we can do is give some rules of thumb gained from hard experience and present examples taken from the real world\n We have delayed this discussion until we studied the transport layer because the performance that applications receive   PERFORMANCE ISSUES depends on the combined performance of the transport  network and link layers  and to be able to use TCP as an example in various places\n In the next tions  we will look at six aspects of network performance:  \n Performance problems Measuring network performance Host design for fast networks Fast segment processing Header compression Protocols for ‘‘long fat’’ networks\n These aspects consider network performance both at the host and across the network  and as networks are increased in speed and size\n    Performance Problems in Computer Networks Some performance problems  such as congestion  are caused by temporary resource overloads\n If more traffic suddenly arrives at a router than the router can handle  congestion will build up and performance will suffer\n We studied congestion in detail in this and the previous  ter\n Performance also degrades when there is a structural resource imbalance\n For example  if a gigabit communication line is attached to a low-end PC  the poor host will not be able to process the incoming packets fast enough and some will be lost\n These packets will eventually be retransmitted  adding delay  wasting bandwidth  and generally reducing performance\n Overloads can also be synchronously triggered\n As an example  if a segment contains a bad parameter ( \n  the port for which it is destined)  in many cases the receiver will thoughtfully send back an error notification\n Now consider what could happen if a bad segment is broadcast to  machines: each one might send back an error message\n The resulting broadcast storm could cripple the network\n UDP suffered from this problem until the ICMP protocol was changed to cause hosts to refrain from responding to errors in UDP segments sent to broadcast addresses\n Wireless networks must be particularly careful to avoid unchecked broadcast responses because broadcast occurs naturally and the wireless bandwidth is limited\n A ond example of synchronous overload is what happens after an electrical power failure\n When the power comes back on  all the machines simultaneously start rebooting\n A typical reboot sequence might require first going to some (DHCP) server to learn one’s true identity  and then to some file server to get a copy of the operating system\n If hundreds of machines in a data center all do this at once  the server will probably collapse under the load\n THE TRANSPORT LAYER  \n  Even in the absence of synchronous overloads and the presence of sufficient resources  poor performance can occur due to lack of system tuning\n For example  if a machine has plenty of CPU power and memory but not enough of the memory has been allocated for buffer space  flow control will slow down segment reception and limit performance\n This was a problem for many TCP connections as the Internet became faster but the default size of the flow control window stayed fixed at   KB\n Another tuning issue is setting timeouts\n When a segment is sent  a timer is set to guard against loss of the segment\n If the timeout is set too short  unnecessary retransmissions will occur  clogging the wires\n If the timeout is set too long  unnecessary delays will occur after a segment is lost\n Other tunable parameters include how long to wait for data on which to piggyback before sending a separate acknowledgement  and how many retransmissions to make before giving up\n Another performance problem that occurs with real-time applications like audio and video is jitter\n Having enough bandwidth on average is not sufficient for good performance\n Short transmission delays are also required\n Consistently achieving short delays demands careful engineering of the load on the network  quality-of-service support at the link and network layers  or both\n    Network Performance Measurement When a network performs poorly  its users often complain to the folks running it  demanding improvements\n To improve the performance  the operators must first determine exactly what is going on\n To find out what is really happening  the operators must make measurements\n In this tion  we will look at network performance measurements\n Much of the discussion below is based on the seminal work of Mogul (   )\n Measurements can be made in different ways and at many locations (both in the protocol stack and physically)\n The most basic kind of measurement is to start a timer when beginning some activity and see how long that activity takes\n For example  knowing how long it takes for a segment to be acknowledged is a key measurement\n Other measurements are made with counters that record how often some event has happened ( \n  number of lost segments)\n Finally  one is often interested in knowing the amount of something  such as the number of bytes processed in a certain time interval\n Measuring network performance and parameters has many potential pitfalls\n We list a few of them here\n Any systematic attempt to measure network performance should be careful to avoid these\n Make Sure That the Sample Size Is Large Enough Do not measure the time to send one segment  but repeat the measurement  say  one million times and take the average\n Startup effects  such as the   \n  NIC or cable modem getting a bandwidth reservation after an idle period  can   PERFORMANCE ISSUES slow the first segment  and queueing introduces variability\n Having a large sample will reduce the uncertainty in the measured mean and standard deviation\n This uncertainty can be computed using standard statistical formulas\n Make Sure That the Samples Are Representative Ideally  the whole sequence of one million measurements should be repeated at different times of the day and the week to see the effect of different network conditions on the measured quantity\n Measurements of congestion  for example  are of little use if they are made at a moment when there is no congestion\n Sometimes the results may be counterintuitive at first  such as heavy congestion at    \n  and   \n  but no congestion at noon (when all the users are at lunch)\n With wireless networks  location is an important variable because of signal propagation\n Even a measurement node placed close to a wireless client may not observe the same packets as the client due to differences in the antennas\n It is best to take measurements from the wireless client under study to see what it sees\n Failing that  it is possible to use techniques to combine the wireless measurements taken at different vantage points to gain a more complete picture of what is going on (Mahajan et al\n  )\n Caching Can Wreak Havoc with Measurements Repeating a measurement many times will return an unexpectedly fast answer if the protocols use caching mechanisms\n For instance  fetching a Web page or looking up a DNS name (to find the IP address) may involve a network exchange the first time  and then return the answer from a local cache without sending any packets over the network\n The results from such a measurement are essentially worthless (unless you want to measure cache performance)\n Buffering can have a similar effect\n TCP/IP performance tests have been known to report that UDP can achieve a performance substantially higher than the network allows\n How does this occur? A call to UDP normally returns control as soon as the message has been accepted by the kernel and added to the transmission queue\n If there is sufficient buffer space  timing  UDP calls does not mean that all the data have been sent\n Most of them may still be in the kernel  but the performance test program thinks they have all been transmitted\n Caution is advised to be absolutely sure that you understand how data can be cached and buffered as part of a network operation\n Be Sure That Nothing Unexpected Is Going On during Your Tests Making measurements at the same time that some user has decided to run a video conference over your network will often give different results than if there is no video conference\n It is best to run tests on an idle network and create the THE TRANSPORT LAYER  \n  entire workload yourself\n Even this approach has pitfalls  though\n While you might think nobody will be using the network at   \n  that might be when the automatic backup program begins copying all the disks to tape\n Or  there might be heavy traffic for your wonderful Web pages from distant time zones\n Wireless networks are challenging in this respect because it is often not possible to separate them from all sources of interference\n Even if there are no other wireless networks sending traffic nearby  someone may microwave popcorn and inadvertently cause interference that degrades   \n  performance\n For these reasons  it is a good practice to monitor the overall network activity so that you can at least realize when something unexpected does happen\n Be Careful When Using a Coarse-Grained Clock Computer clocks function by incrementing some counter at regular intervals\n For example  a milliond timer adds  to a counter every  m\n Using such a timer to measure an event that takes less than  m is possible but requires some care\n Some computers have more accurate clocks  of course  but there are always shorter events to measure too\n Note that clocks are not always as accurate as the precision with which the time is returned when they are read\n To measure the time to make a TCP connection  for example  the clock (say  in millionds) should be read out when the transport layer code is entered and again when it is exited\n If the true connection setup time is μ  the difference between the two readings will be either  or   both wrong\n However  if the measurement is repeated one million times and the total of all measurements is added up and divided by one million  the mean time will be accurate to better than  μ\n Be Careful about Extrapolating the Results Suppose that you make measurements with simulated network loads running from  (idle) to  \n  (  % of capacity)\n For example  the response time to send a voice-over-IP packet over an   \n  network might be as shown by the data points and solid line through them in Fig\n  -  \n It may be tempting to extrapolate linearly  as shown by the dotted line\n However  many queueing results involve a factor of  /(  − ρ)  where ρ is the load  so the true values may look more like the dashed line  which rises much faster than linearly when the load gets high\n That is  beware contention effects that become much more pronounced at high load\n    Host Design for Fast Networks Measuring and tinkering can improve performance considerably  but they cannot substitute for good design in the first place\n A poorly designed network can be improved only so much\n Beyond that  it has to be redesigned from scratch\n   PERFORMANCE ISSUES    Response time         Load      Figure  -  \n Response as a function of load\n In this tion  we will present some rules of thumb for software implementation of network protocols on hosts\n Surprisingly  experience shows that this is often a performance bottleneck on otherwise fast networks  for two reasons\n First  NICs (Network Interface Cards) and routers have already been engineered (with hardware support) to run at ‘‘wire speed\n’’ This means that they can process packets as quickly as the packets can possibly arrive on the link\n ond  the relevant performance is that which applications obtain\n It is not the link capacity  but the throughput and delay after network and transport processing\n Reducing software overheads improves performance by increasing throughput and decreasing delay\n It can also reduce the energy that is spent on networking  which is an important consideration for mobile computers\n Most of these ideas have been common knowledge to network designers for years\n They were first stated explicitly by Mogul (   ); our treatment largely follows his\n Another relevant source is Metcalfe (   )\n Host Speed Is More Important Than Network Speed Long experience has shown that in nearly all fast networks  operating system and protocol overhead dominate actual time on the wire\n For example  in theory  the minimum RPC time on a  -Gbps Ethernet is  μ  corresponding to a minimum (  -byte) request followed by a minimum (  -byte) reply\n In practice  overcoming the software overhead and getting the RPC time anywhere near there is a substantial achievement\n It rarely happens in practice\n THE TRANSPORT LAYER  \n  Similarly  the biggest problem in running at  Gbps is often getting the bits from the user’s buffer out onto the network fast enough and having the receiving host process them as fast as they come in\n If you double the host (CPU and memory) speed  you often can come close to doubling the throughput\n Doubling the network capacity has no effect if the bottleneck is in the hosts\n Reduce Packet Count to Reduce Overhead Each segment has a certain amount of overhead ( \n  the header) as well as data ( \n  the payload)\n Bandwidth is required for both components\n Processing is also required for both components ( \n  header processing and doing the checksum)\n When  million bytes are being sent  the data cost is the same no matter what the segment size is\n However  using   -byte segments means   times as much per-segment overhead as using  -KB segments\n The bandwidth and processing overheads add up fast to reduce throughput\n Per-packet overhead in the lower layers amplifies this effect\n Each arriving packet causes a fresh interrupt if the host is keeping up\n On a modern pipelined processor  each interrupt breaks the CPU pipeline  interferes with the cache  requires a change to the memory management context  voids the branch prediction table  and forces a substantial number of CPU registers to be saved\n An n-fold reduction in segments sent thus reduces the interrupt and packet overhead by a factor of n\n You might say that both people and computers are poor at multitasking\n This observation underlies the desire to send MTU packets that are as large as will pass along the network path without fragmentation\n Mechanisms such as Nagle’s algorithm and Clark’s solution are also attempts to avoid sending small packets\n Minimize Data Touching The most straightforward way to implement a layered protocol stack is with one module for each layer\n Unfortunately  this leads to copying (or at least accessing the data on multiple passes) as each layer does its own work\n For example  after a packet is received by the NIC  it is typically copied to a kernel buffer\n From there  it is copied to a network layer buffer for network layer processing  then to a transport layer buffer for transport layer processing  and finally to the receiving application process\n It is not unusual for an incoming packet to be copied three or four times before the segment enclosed in it is delivered\n All this copying can greatly degrade performance because memory operations are an order of magnitude slower than register–register instructions\n For example  if  % of the instructions actually go to memory ( \n  are cache misses)  which is likely when touching incoming packets  the average instruction execution time is slowed down by a factor of  \n  ( \n  ×  +  \n  ×  )\n Hardware assistance will not help here\n The problem is too much copying by the operating system\n   PERFORMANCE ISSUES A clever operating system will minimize copying by combining the processing of multiple layers\n For example  TCP and IP are usually implemented together (as ‘‘TCP/IP’’) so that it is not necessary to copy the payload of the packet as processing switches from network to transport layer\n Another common trick is to perform multiple operations within a layer in a single pass over the data\n For example  checksums are often computed while copying the data (when it has to be copied) and the newly computed checksum is appended to the end\n Minimize Context Switches A related rule is that context switches ( \n  from kernel mode to user mode) are deadly\n They have the bad properties of interrupts and copying combined\n This cost is why transport protocols are often implemented in the kernel\n Like reducing packet count  context switches can be reduced by having the library procedure that sends data do internal buffering until it has a substantial amount of them\n Similarly  on the receiving side  small incoming segments should be collected together and passed to the user in one fell swoop instead of individually  to minimize context switches\n In the best case  an incoming packet causes a context switch from the current user to the kernel  and then a switch to the receiving process to give it the newly arrived data\n Unfortunately  with some operating systems  additional context switches happen\n For example  if the network manager runs as a special process in user space  a packet arrival is likely to cause a context switch from the current user to the kernel  then another one from the kernel to the network manager  followed by another one back to the kernel  and finally one from the kernel to the receiving process\n This sequence is shown in Fig\n  -  \n All these context switches on each packet are wasteful of CPU time and can have a devastating effect on network performance\n User space Kernel space    User process running at the time of the packet arrival Network manager Receiving process Figure  -  \n Four context switches to handle one packet with a user-space network manager\n THE TRANSPORT LAYER  \n  Avoiding Congestion Is Better Than Recovering from It The old maxim that an ounce of prevention is worth a pound of cure certainly holds for network congestion\n When a network is congested  packets are lost  bandwidth is wasted  useless delays are introduced  and more\n All of these costs are unnecessary  and recovering from congestion takes time and patience\n Not having it occur in the first place is better\n Congestion avoidance is like getting your DTP vaccination: it hurts a little at the time you get it  but it prevents something that would hurt a lot more in the future\n Avoid Timeouts Timers are necessary in networks  but they should be used sparingly and timeouts should be minimized\n When a timer goes off  some action is generally repeated\n If it is truly necessary to repeat the action  so be it  but repeating it unnecessarily is wasteful\n The way to avoid extra work is to be careful that timers are set a little bit on the conservative side\n A timer that takes too long to expire adds a small amount of extra delay to one connection in the (unlikely) event of a segment being lost\n A timer that goes off when it should not have uses up host resources  wastes bandwidth  and puts extra load on perhaps dozens of routers for no good reason\n    Fast Segment Processing Now that we have covered general rules  we will look at some specific methods for speeding up segment processing\n For more information  see Clark et al\n (   )  and Chase et al\n (   )\n Segment processing overhead has two components: overhead per segment and overhead per byte\n Both must be attacked\n The key to fast segment processing is to separate out the normal  successful case (one-way data transfer) and handle it specially\n Many protocols tend to emphasize what to do when something goes wrong ( \n  a packet getting lost)  but to make the protocols run fast  the designer should aim to minimize processing time when everything goes right\n Minimizing processing time when an error occurs is ondary\n Although a sequence of special segments is needed to get into the ESTABLISHED state  once there  segment processing is straightforward until one side starts to close the connection\n Let us begin by examining the sending side in the ESTABLISHED state when there are data to be transmitted\n For the sake of clarity  we assume here that the transport entity is in the kernel  although the same ideas apply if it is a user-space process or a library inside the sending process\n In Fig\n  -   the sending process traps into the kernel to do the SEND\n The first thing the transport entity does is test to see if this is the normal case: the state is ESTABLISHED  neither side is trying to close the connection  a regular ( \n  not an   PERFORMANCE ISSUES out-of-band) full segment is being sent  and enough window space is available at the receiver\n If all conditions are met  no further tests are needed and the fast path through the sending transport entity can be taken\n Typically  this path is taken most of the time\n Trap into the kernel to send segment Test Segment passed to the receiving process Test S S Sending process Receiving process Network Figure  -  \n The fast path from sender to receiver is shown with a heavy line\n The processing steps on this path are shaded\n In the usual case  the headers of conutive data segments are almost the same\n To take advantage of this fact  a prototype header is stored within the transport entity\n At the start of the fast path  it is copied as fast as possible to a scratch buffer  word by word\n Those fields that change from segment to segment are overwritten in the buffer\n Frequently  these fields are easily derived from state variables  such as the next sequence number\n A pointer to the full segment header plus a pointer to the user data are then passed to the network layer\n Here  the same strategy can be followed (not shown in Fig\n  -  )\n Finally  the network layer gives the resulting packet to the data link layer for transmission\n As an example of how this principle works in practice  let us consider TCP/IP\n Fig\n  -  (a) shows the TCP header\n The fields that are the same between conutive segments on a one-way flow are shaded\n All the sending transport entity has to do is copy the five words from the prototype header into the output buffer  fill in the next sequence number (by copying it from a word in memory)  compute the checksum  and increment the sequence number in memory\n It can then hand the header and data to a special IP procedure for sending a regular  maximum segment\n IP then copies its five-word prototype header [see Fig\n  -  (b)] into the buffer  fills in the Identification field  and computes its checksum\n The packet is now ready for transmission\n Now let us look at fast path processing on the receiving side of Fig\n  -  \n Step  is locating the connection record for the incoming segment\n For TCP  the THE TRANSPORT LAYER  \n  Sequence number (a) (b) Header checksum Identification Source port Acknowledgement number Len Unused Window size Checksum Urgent pointer Destination port Fragment offset VER\n IHL Diff\n Serv\n Total length TTL Protocol Source address Destination address Diff\n Serv\n Figure  -  \n (a) TCP header\n (b) IP header\n In both cases  they are taken from the prototype without change\n connection record can be stored in a hash table for which some simple function of the two IP addresses and two ports is the key\n Once the connection record has been located  both addresses and both ports must be compared to verify that the correct record has been found\n An optimization that often speeds up connection record lookup even more is to maintain a pointer to the last one used and try that one first\n Clark et al\n (   ) tried this and observed a hit rate exceeding  %\n The segment is checked to see if it is a normal one: the state is ESTABLISHED  neither side is trying to close the connection  the segment is a full one  no special flags are set  and the sequence number is the one expected\n These tests take just a handful of instructions\n If all conditions are met  a special fast path TCP procedure is called\n The fast path updates the connection record and copies the data to the user\n While it is copying  it also computes the checksum  eliminating an extra pass over the data\n If the checksum is correct  the connection record is updated and an acknowledgement is sent back\n The general scheme of first making a quick check to see if the header is what is expected and then having a special procedure handle that case is called header prediction\n Many TCP implementations use it\n When this optimization and all the other ones discussed in this  ter are used together  it is possible to get TCP to run at  % of the speed of a local memory-to-memory copy  assuming the network itself is fast enough\n Two other areas where major performance gains are possible are buffer management and timer management\n The issue in buffer management is avoiding unnecessary copying  as mentioned above\n Timer management is important because nearly all timers set do not expire\n They are set to guard against segment loss  but most segments and their acknowledgements arrive correctly\n Hence  it is important to optimize timer management for the case of timers rarely expiring\n A common scheme is to use a linked list of timer events sorted by expiration time\n The head entry contains a counter telling how many ticks away from expiry it is\n Each successive entry contains a counter telling how many ticks after the   PERFORMANCE ISSUES previous entry it is\n Thus  if timers expire in   and   ticks  respectively  the three counters are  and   respectively\n At every clock tick  the counter in the head entry is decremented\n When it hits zero  its event is processed and the next item on the list becomes the head\n Its counter does not have to be changed\n This way  inserting and deleting timers are expensive operations  with execution times proportional to the length of the list\n A much more efficient approach can be used if the maximum timer interval is bounded and known in advance\n Here  an array called a timing wheel can be used  as shown in Fig\n  -  \n Each slot corresponds to one clock tick\n The current time shown is T =  \n Timers are scheduled to expire at   and   ticks from now\n If a new timer suddenly is set to expire in seven ticks  an entry is just made in slot  \n Similarly  if the timer set for T +   has to be canceled  the list starting in slot   has to be searched and the required entry removed\n Note that the array of Fig\n  -  cannot accommodate timers beyond T +  \n        Slot     Pointer to list of timers for T +   Pointer to list of timers for T +  Pointer to list of timers for T +   Current time  T Figure  -  \n A timing wheel\n When the clock ticks  the current time pointer is advanced by one slot (circularly)\n If the entry now pointed to is nonzero  all of its timers are processed\n Many variations on the basic idea are discussed by Varghese and Lauck (   )\n    Header Compression We have been looking at fast networks for too long\n There is more out there\n Let us now consider performance on wireless and other networks in which bandwidth is limited\n Reducing software overhead can help mobile computers run THE TRANSPORT LAYER  \n  more efficiently  but it does nothing to improve performance when the network links are the bottleneck\n To use bandwidth well  protocol headers and payloads should be carried with the minimum of bits\n For payloads  this means using compact encodings of information  such as images that are in JPEG format rather than a bitmap  or document formats such as PDF that include compression\n It also means application-level caching mechanisms  such as Web caches that reduce transfers in the first place\n What about for protocol headers? At the link layer  headers for wireless networks are typically compact because they were designed with scarce bandwidth in mind\n For example \n  headers have short connection identifiers instead of longer addresses\n However  higher layer protocols such as IP  TCP and UDP come in one version for all link layers  and they are not designed with compact headers\n In fact  streamlined processing to reduce software overhead often leads to headers that are not as compact as they could otherwise be ( \n  IPv  has a more loosely packed headers than IPv )\n The higher-layer headers can be a significant performance hit\n Consider  for example  voice-over-IP data that is being carried with the combination of IP  UDP  and RTP\n These protocols require   bytes of header (  for IPv for UDP  and   for RTP)\n With IPv  the situation is even worse:   bytes  including the  -byte IPv  header\n The headers can wind up as the majority of the transmitted data and consume more than half the bandwidth\n Header compression is used to reduce the bandwidth taken over links by higher-layer protocol headers\n Specially designed schemes are used instead of general purpose methods\n This is because headers are short  so they do not compress well individually  and decompression requires all prior data to be received\n This will not be the case if a packet is lost\n Header compression obtains large gains by using knowledge of the protocol format\n One of the first schemes was designed by Van Jacobson (   ) for compressing TCP/IP headers over slow serial links\n It is able to compress a typical TCP/IP header of   bytes down to an average of  bytes\n The trick to this method is hinted at in Fig\n  -  \n Many of the header fields do not change from packet to packet\n There is no need  for example  to send the same IP TTL or the same TCP port numbers in each and every packet\n They can be omitted on the sending side of the link and filled in on the receiving side\n Similarly  other fields change in a predictable manner\n For example  barring loss  the TCP sequence number advances with the data\n In these cases  the receiver can predict the likely value\n The actual number only needs to be carried when it differs from what is expected\n Even then  it may be carried as a small change from the previous value  as when the acknowledgement number increases when new data is received in the reverse direction\n With header compression  it is possible to have simple headers in higher-layer protocols and compact encodings over low bandwidth links\n ROHC (RObust Header Compression) is a modern version of header compression that is defined   PERFORMANCE ISSUES as a framework in RFC \n It is designed to tolerate the loss that can occur on wireless links\n There is a profile for each set of protocols to be compressed  such as IP/UDP/RTP\n Compressed headers are carried by referring to a context  which is essentially a connection; header fields may easily be predicted for packets of the same connection  but not for packets of different connections\n In typical operation  ROHC reduces IP/UDP/RTP headers from   bytes to  to  bytes\n While header compression is mainly targeted at reducing bandwidth needs  it can also be useful for reducing delay\n Delay is comprised of propagation delay  which is fixed given a network path  and transmission delay  which depends on the bandwidth and amount of data to be sent\n For example  a  -Mbps link sends  bit in  μ\n In the case of media over wireless networks  the network is relatively slow so transmission delay may be an important factor in overall delay and consistently low delay is important for quality of service\n Header compression can help by reducing the amount of data that is sent  and hence reducing transmission delay\n The same effect can be achieved by sending smaller packets\n This will trade increased software overhead for decreased transmission delay\n Note that another potential source of delay is queueing delay to access the wireless link\n This can also be significant because wireless links are often heavily used as the limited resource in a network\n In this case  the wireless link must have quality-of-service mechanisms that give low delay to real-time packets\n Header compression alone is not sufficient\n    Protocols for Long Fat Networks Since the s  there have been gigabit networks that transmit data over large distances\n Because of the combination of a fast network  or ‘‘fat pipe ’’ and long delay  these networks are called long fat networks\n When these networks arose  people’s first reaction was to use the existing protocols on them  but various problems quickly arose\n In this tion  we will discuss some of the problems with scaling up the speed and delay of network protocols\n The first problem is that many protocols use  -bit sequence numbers\n When the Internet began  the lines between routers were mostly  -kbps leased lines  so a host blasting away at full speed took over  week to cycle through the sequence numbers\n To the TCP designers  was a pretty decent approximation of infinity because there was little danger of old packets still being around a week after they were transmitted\n With  -Mbps Ethernet  the wrap time became   minutes  much shorter  but still manageable\n With a  -Gbps Ethernet pouring data out onto the Internet  the wrap time is about   onds  well under the   - maximum packet lifetime on the Internet\n All of a sudden  is not nearly as good an approximation to infinity since a fast sender can cycle through the sequence space while old packets still exist\n The problem is that many protocol designers simply assumed  without stating it  that the time required to use up the entire sequence space would greatly exceed THE TRANSPORT LAYER  \n  the maximum packet lifetime\n Consequently  there was no need to even worry about the problem of old duplicates still existing when the sequence numbers wrapped around\n At gigabit speeds  that unstated assumption fails\n Fortunately  it proved possible to extend the effective sequence number by treating the timestamp that can be carried as an option in the TCP header of each packet as the high-order bits\n This mechanism is called PAWS (Protection Against Wrapped Sequence numbers) and is described in RFC \n A ond problem is that the size of the flow control window must be greatly increased\n Consider  for example  sending a  -KB burst of data from San Diego to Boston in order to fill the receiver’s  -KB buffer\n Suppose that the link is  Gbps and the one-way speed-of-light-in-fiber delay is   m\n Initially  at t =   the pipe is empty  as illustrated in Fig\n  -  (a)\n Only μ later  in Fig\n  -  (b)  all the segments are out on the fiber\n The lead segment will now be somewhere in the vicinity of Brawley  still deep in Southern California\n However  the transmitter must stop until it gets a window update\n (a) (b) (c) (d) Data Acknowledgements Figure  -  \n The state of transmitting  Mbit from San Diego to Boston\n (a) At t =  \n (b) After μ\n (c) After   m\n (d) After   m\n After   m  the lead segment hits Boston  as shown in Fig\n  -  (c)  and is acknowledged\n Finally m after starting  the first acknowledgement gets   PERFORMANCE ISSUES back to the sender and the ond burst can be transmitted\n Since the transmission line was used for  \n  m out of  the efficiency is about  \n  %\n This situation is typical of an older protocols running over gigabit lines\n A useful quantity to keep in mind when analyzing network performance is the bandwidth-delay product\n It is obtained by multiplying the bandwidth (in bits/) by the round-trip delay time (in )\n The product is the capacity of the pipe from the sender to the receiver and back (in bits)\n For the example of Fig\n  -   the bandwidth-delay product is   million bits\n In other words  the sender would have to transmit a burst of   million bits to be able to keep going full speed until the first acknowledgement came back\n It takes this many bits to fill the pipe (in both directions)\n This is why a burst of half a million bits only achieves a  \n  % efficiency: it is only  \n  % of the pipe’s capacity\n The conclusion that can be drawn here is that for good performance  the receiver’s window must be at least as large as the bandwidth-delay product  and preferably somewhat larger since the receiver may not respond instantly\n For a transcontinental gigabit line  at least  MB are required\n A third and related problem is that simple retransmission schemes  such as the go-back-n protocol  perform poorly on lines with a large bandwidth-delay product\n Consider  the  -Gbps transcontinental link with a round-trip transmission time of   m\n A sender can transmit  MB in one round trip\n If an error is detected  it will be   m before the sender is told about it\n If go-back-n is used  the sender will have to retransmit not just the bad packet  but also the  MB worth of packets that came afterward\n Clearly  this is a massive waste of resources\n More complex protocols such as selective-repeat are needed\n A fourth problem is that gigabit lines are fundamentally different from megabit lines in that long gigabit lines are delay limited rather than bandwidth limited\n In Fig\n  -  we show the time it takes to transfer a  -Mbit file  km at various transmission speeds\n At speeds up to  Mbps  the transmission time is dominated by the rate at which the bits can be sent\n By  Gbps  the  -m round-trip delay dominates the  m it takes to put the bits on the fiber\n Further increases in bandwidth have hardly any effect at all\n Figure  -  has unfortunate implications for network protocols\n It says that stop-and-wait protocols  such as RPC  have an inherent upper bound on their performance\n This limit is dictated by the speed of light\n No amount of technological progress in optics will ever improve matters (new laws of physics would help  though)\n Unless some other use can be found for a gigabit line while a host is waiting for a reply  the gigabit line is no better than a megabit line  just more expensive\n A fifth problem is that communication speeds have improved faster than computing speeds\n (Note to computer engineers: go out and beat those communication engineers! We are counting on you\n) In the s  the ARPANET ran at   kbps and had computers that ran at about  MIPS\n Compare these numbers to THE TRANSPORT LAYER  \n          m   m  m File transfer time Data rate (bps)        Figure  -  \n Time to transfer and acknowledge a  -Mbit file over a -km line\n -MIPS computers exchanging packets over a  -Gbps line\n The number of instructions per byte has decreased by more than a factor of  \n The exact numbers are debatable depending on dates and scenarios  but the conclusion is this: there is less time available for protocol processing than there used to be  so protocols must become simpler\n Let us now turn from the problems to ways of dealing with them\n The basic principle that all high-speed network designers should learn by heart is: Design for speed  not for bandwidth optimization\n Old protocols were often designed to minimize the number of bits on the wire  frequently by using small fields and packing them together into bytes and words\n This concern is still valid for wireless networks  but not for gigabit networks\n Protocol processing is the problem  so protocols should be designed to minimize it\n The IPv  designers clearly understood this principle\n A tempting way to go fast is to build fast network interfaces in hardware\n The difficulty with this strategy is that unless the protocol is exceedingly simple  hardware just means a plug-in board with a ond CPU and its own program\n To make sure the network coprocessor is cheaper than the main CPU  it is often a slower chip\n The consequence of this design is that much of the time the main (fast) CPU is idle waiting for the ond (slow) CPU to do the critical work\n It is a myth to think that the main CPU has other work to do while waiting\n Furthermore  when two general-purpose CPUs communicate  race conditions can occur  so elaborate protocols are needed between the two processors to synchronize   PERFORMANCE ISSUES them correctly and avoid races\n Usually  the best approach is to make the protocols simple and have the main CPU do the work\n Packet layout is an important consideration in gigabit networks\n The header should contain as few fields as possible  to reduce processing time  and these fields should be big enough to do the job and be word-aligned for fast processing\n In this context  ‘‘big enough’’ means that problems such as sequence numbers wrapping around while old packets still exist  receivers being unable to advertise enough window space because the window field is too small  etc\n do not occur\n The maximum data size should be large  to reduce software overhead and permit efficient operation\n  bytes is too small for high-speed networks  which is why gigabit Ethernet supports jumbo frames of up to  KB and IPv  supports jumbogram packets in excess of   KB\n Let us now look at the issue of feedback in high-speed protocols\n Due to the (relatively) long delay loop  feedback should be avoided: it takes too long for the receiver to signal the sender\n One example of feedback is governing the transmission rate by using a sliding window protocol\n Future protocols may switch to rate-based protocols to avoid the (long) delays inherent in the receiver sending window updates to the sender\n In such a protocol  the sender can send all it wants to  provided it does not send faster than some rate the sender and receiver have agreed upon in advance\n A ond example of feedback is Jacobson’s slow start algorithm\n This algorithm makes multiple probes to see how much the network can handle\n With high-speed networks  making half a dozen or so small probes to see how the network responds wastes a huge amount of bandwidth\n A more efficient scheme is to have the sender  receiver  and network all reserve the necessary resources at connection setup time\n Reserving resources in advance also has the advantage of making it easier to reduce jitter\n In short  going to high speeds inexorably pushes the design toward connection-oriented operation  or something fairly close to it\n Another valuable feature is the ability to send a normal amount of data along with the connection request\n In this way  one round-trip time can be saved  DELAY-TOLERANT NETWORKING We will finish this  ter by describing a new kind of transport that may one day be an important component of the Internet\n TCP and most other transport protocols are based on the assumption that the sender and the receiver are continuously connected by some working path  or else the protocol fails and data cannot be delivered\n In some networks there is often no end-to-end path\n An example is a space network as LEO (Low-Earth Orbit) satellites pass in and out of range of ground stations\n A given satellite may be able to communicate to a ground station only at particular times  and two satellites may never be able to communicate with each other at any time  even via a ground station  because one of the satellites THE TRANSPORT LAYER  \n  may always be out of range\n Other example networks involve submarines  buses  mobile phones  and other devices with computers for which there is intermittent connectivity due to mobility or extreme conditions\n In these occasionally connected networks  data can still be communicated by storing them at nodes and forwarding them later when there is a working link\n This technique is called message switching\n Eventually the data will be relayed to the destination\n A network whose architecture is based on this approach is called a DTN (Delay-Tolerant Network  or a Disruption-Tolerant Network)\n Work on DTNs started in  when IETF set up a research group on the topic\n The inspiration for DTNs came from an unlikely source: efforts to send packets in space\n Space networks must deal with intermittent communication and very long delays\n Kevin Fall observed that the ideas for these Interplanetary Internets could be applied to networks on Earth in which intermittent connectivity was the norm (Fall  )\n This model gives a useful generalization of the Internet in which storage and delays can occur during communication\n Data delivery is akin to delivery in the postal system  or electronic mail  rather than packet switching at routers\n Since  the DTN architecture has been refined  and the applications of the DTN model have grown\n As a mainstream application  consider large datasets of many terabytes that are produced by scientific experiments  media events  or Web-based services and need to be copied to datacenters at different locations around the world\n Operators would like to send this bulk traffic at off-peak times to make use of bandwidth that has already been paid for but is not being used  and are willing to tolerate some delay\n It is like doing the backups at night when other applications are not making heavy use of the network\n The problem is that  for global services  the off-peak times are different at locations around the world\n There may be little overlap in the times when datacenters in Boston and Perth have off-peak network bandwidth because night for one city is day for the other\n However  DTN models allow for storage and delays during transfer\n With this model  it becomes possible to send the dataset from Boston to Amsterdam using off-peak bandwidth  as the cities have time zones that are only  hours apart\n The dataset is then stored in Amsterdam until there is off-peak bandwidth between Amsterdam and Perth\n It is then sent to Perth to complete the transfer\n Laoutaris et al\n (   ) have studied this model and find that it can provide substantial capacity at little cost  and that the use of a DTN model often doubles that capacity compared with a traditional end-to-end model\n In what follows  we will describe the IETF DTN architecture and protocols\n    DTN Architecture The main assumption in the Internet that DTNs seek to relax is that an endto- end path between a source and a destination exists for the entire duration of a communication session\n When this is not the case  the normal Internet protocols   DELAY-TOLERANT NETWORKING fail\n DTNs get around the lack of end-to-end connectivity with an architecture that is based on message switching  as shown in Fig\n  -  \n It is also intended to tolerate links with low reliability and large delays\n The architecture is specified in RFC \n Contact (working link) Stored bundle Source Storage Sent bundle DTN node Intermittent link (not working) Destination Figure  -  \n Delay-tolerant networking architecture\n In DTN terminology  a message is called a bundle\n DTN nodes are equipped with storage  typically persistent storage such as a disk or flash memory\n They store bundles until links become available and then forward the bundles\n The links work intermittently\n Fig\n  -  shows five intermittent links that are not currently working  and two links that are working\n A working link is called a contact\n Fig\n  -  also shows bundles stored at two DTN nodes awaiting contacts to send the bundles onward\n In this way  the bundles are relayed via contacts from the source to their destination\n The storing and forwarding of bundles at DTN nodes sounds similar to the queueing and forwarding of packets at routers  but there are qualitative differences\n In routers in the Internet  queueing occurs for millionds or at most onds\n At DTN nodes  bundles may be stored for hours  until a bus arrives in town  while an airplane completes a flight  until a sensor node harvests enough solar energy to run  until a sleeping computer wakes up  and so forth\n These examples also point to a ond difference  which is that nodes may move (with a bus or plane) while they hold stored data  and this movement may even be a key part of data delivery\n Routers in the Internet are not allowed to move\n The whole process of moving bundles might be better known as ‘‘store-carry-forward\n’’ As an example  consider the scenario shown in Fig\n  -  that was the first use of DTN protocols in space (Wood et al\n  )\n The source of bundles is an LEO satellite that is recording Earth images as part of the Disaster Monitoring Constellation of satellites\n The images must be returned to the collection point\n However  the satellite has only intermittent contact with three ground stations as it orbits the Earth\n It comes into contact with each ground station in turn\n Each of the satellite  ground stations  and collection point act as a DTN node\n At each contact  a THE TRANSPORT LAYER  \n  bundle (or a portion of a bundle) is sent to a ground station\n The bundles are then sent over a backhaul terrestrial network to the collection point to complete the transfer\n Intermittent link (not working) Storage at DTN nodes Satellite Contact Bundle (working link) Ground station Collection point Figure  -  \n Use of a DTN in space\n The primary advantage of the DTN architecture in this example is that it naturally fits the situation of the satellite needing to store images because there is no connectivity at the time the image is taken\n There are two further advantages\n First  there may be no single contact long enough to send the images\n However  they can be spread across the contacts with three ground stations\n ond  the use of the link between the satellite and ground station is decoupled from the link over the backhaul network\n This means that the satellite download is not limited by a slow terrestrial link\n It can proceed at full speed  with the bundle stored at the ground station until it can be relayed to the collection point\n An important issue that is not specified by the architecture is how to find good routes via DTN nodes\n A route in this path to use\n Good routes depend on the nature of the architecture describes when to send data  and also which contacts\n Some contacts are known ahead of time\n A good example is the motion of heavenly bodies in the space example\n For the space experiment  it was known ahead of time when contacts would occur  that the contact intervals ranged from  to   minutes per pass with each ground station  and that the downlink capacity was  \n   Mbps\n Given this knowledge  the transport of a bundle of images can be planned ahead of time\n In other cases  the contacts can be predicted  but with less certainty\n Examples include buses that make contact with each other in mostly regular ways  due to a timetable  yet with some variation  and the times and amount of off-peak bandwidth in ISP networks  which are predicted from past data\n At the other extreme  the contacts are occasional and random\n One example is carrying data from user   DELAY-TOLERANT NETWORKING to user on mobile phones depending on which users make contact with each other during the day\n When there is unpredictability in contacts  one routing strategy is to send copies of the bundle along different paths in the hope that one of the copies is delivered to the destination before the lifetime is reached\n    The Bundle Protocol To take a closer look at the operation of DTNs  we will now look at the IETF protocols\n DTNs are an emerging kind of network  and experimental DTNs have used different protocols  as there is no requirement that the IETF protocols be used\n However  they are at least a good place to start and highlight many of the key issues\n The DTN protocol stack is shown in Fig\n  -  \n The key protocol is the Bundle protocol  which is specified in RFC \n It is responsible for accepting messages from the application and sending them as one or more bundles via storecarry- forward operations to the destination DTN node\n It is also apparent from Fig\n  -  that the Bundle protocol runs above the level of TCP/IP\n In other words  TCP/IP may be used over each contact to move bundles between DTN nodes\n This positioning raises the issue of whether the Bundle protocol is a transport layer protocol or an application layer protocol\n Just as with RTP  we take the position that  despite running over a transport protocol  the Bundle protocol is providing a transport service to many different applications  and so we cover DTNs in this  ter\n Application Bundle Protocol Convergence layer TCP/IP Internet   Other internet Convergence layer Upper layers DTN layer Lower layers Figure  -  \n Delay-tolerant networking protocol stack\n In Fig\n  -   we see that the Bundle protocol may be run over other kinds of protocols such as UDP  or even other kinds of internets\n For example  in a space network the links may have very long delays\n The round-trip time between Earth and Mars can easily be   minutes depending on the relative position of the planets\n Imagine how well TCP acknowledgements and retransmissions will work over that link  especially for relatively short messages\n Not well at all\n Instead  THE TRANSPORT LAYER  \n  another protocol that uses error-correcting codes might be used\n Or in sensor networks that are very resource constrained  a more lightweight protocol than TCP may be used\n Since the Bundle protocol is fixed  yet it is intended to run over a variety of transports  there is must be a gap in functionality between the protocols\n That gap is the reason for the inclusion of a convergence layer in Fig\n  -  \n The convergence layer is just a glue layer that matches the interfaces of the protocols that it joins\n By definition there is a different convergence layer for each different lower layer transport\n Convergence layers are commonly found in standards to join new and existing protocols\n The format of Bundle protocol messages is shown in Fig\n  -  \n The different fields in these messages tell us some of the key issues that are handled by the Bundle protocol\n Bits Type Primary block Payload block Optional blocks Ver\n Flags Dest\n Source Report Custodian Creation Lifetime Dictionary Flags Length Data variable  Status report Class of service General Bits  variable Figure  -  \n Bundle protocol message format\n Each message consists of a primary block  which can be thought of as a header  a payload block for the data  and optionally other blocks  for example to carry urity parameters\n The primary block begins with a Version field (currently  ) followed by a Flags field\n Among other functions  the flags encode a class of service to let a source mark its bundles as higher or lower priority  and other handling requests such as whether the destination should acknowledge the bundle\n Then come addresses  which highlight three interesting parts of the design\n As well as a Destination and Source identifier field  there is a Custodian identifier\n The custodian is the party responsible for seeing that the bundle is delivered\n In the Internet  the source node is usually the custodian  as it is the node that retransmits if the data is not ultimately delivered to the destination\n However  in a DTN  the source node may not always be connected and may have no way of knowing whether the data has been delivered\n DTNs deal with this problem using the notion of custody transfer  in which another node  closer to the destination  can assume responsibility for seeing the data safely delivered\n For example  if a bundle is stored on an airplane for forwarding at a later time and location  the airplane may become the custodian of the bundle\n   DELAY-TOLERANT NETWORKING The ond interesting aspect is that these identifiers are not IP addresses\n Because the Bundle protocol is intended to work across a variety of transports and internets  it defines its own identifiers\n These identifiers are really more like high-level names  such as Web page URLs  than low-level addresses  such as IP addresses\n They give DTNs an aspect of application-level routing  such as email delivery or the distribution of software updates\n The third interesting aspect is the way the identifiers are encoded\n There is also a Report identifier for diagnostic messages\n All of the identifiers are encoded as references to a variable length Dictionary field\n This provides compression when the custodian or report nodes are the same as the source or the destination\n In fact  much of the message format has been designed with both extensibility and efficiency in mind by using a compact representation of variable length fields\n The compact representation is important for wireless links and resourceconstrained nodes such as in a sensor network\n Next comes a Creation field carrying the time at which the bundle was created  along with a sequence number from the source for ordering  plus a Lifetime field that tells the time at which the bundle data is no longer useful\n These fields exist because data may be stored for a long period at DTN nodes and there must be some way to remove stale data from the network\n Unlike the Internet  they require that DTN nodes have loosely synchronized clocks\n The primary block is completed with the Dictionary field\n Then comes the payload block\n This block starts with a short Type field that identifies it as a payload  followed by a small set of Flags that describe processing options\n Then comes the Data field  preceded by a Length field\n Finally  there may be other  optional blocks  such as a block that carries urity parameters\n Many aspects of DTNs are being explored in the research community\n Good strategies for routing depend on the nature of the contacts  as was mentioned above\n Storing data inside the network raises other issues\n Now congestion control must consider storage at nodes as another kind of resource that can be depleted\n The lack of end-to-end communication also exacerbates urity problems\n Before a DTN node takes custody of a bundle  it may want to know that the sender is authorized to use the network and that the bundle is probably wanted by the destination\n Solutions to these problems will depend on the kind of DTN  as space networks are different from sensor networks  SUMMARY The transport layer is the key to understanding layered protocols\n It provides various services  the most important of which is an end-to-end  reliable  connection- oriented byte stream from sender to receiver\n It is accessed through service primitives that permit the establishment  use  and release of connections\n A common transport layer interface is the one provided by Berkeley sockets\n THE TRANSPORT LAYER  \n  Transport protocols must be able to do connection management over unreliable networks\n Connection establishment is complicated by the existence of delayed duplicate packets that can reappear at inopportune moments\n To deal with them  three-way handshakes are needed to establish connections\n Releasing a connection is easier than establishing one but is still far from trivial due to the two-army problem\n Even when the network layer is completely reliable  the transport layer has plenty of work to do\n It must handle all the service primitives  manage connections and timers  allocate bandwidth with congestion control  and run a variablesized sliding window for flow control\n Congestion control should allocate all of the available bandwidth between competing flows fairly  and it should track changes in the usage of the network\n The AIMD control law converges to a fair and efficient allocation\n The Internet has two main transport protocols: UDP and TCP\n UDP is a connectionless protocol that is mainly a wrapper for IP packets with the additional feature of multiplexing and demultiplexing multiple processes using a single IP address\n UDP can be used for client-server interactions  for example  using RPC\n It can also be used for building real-time protocols such as RTP\n The main Internet transport protocol is TCP\n It provides a reliable  bidirectional  congestion-controlled byte stream with a  -byte header on all segments\n A great deal of work has gone into optimizing TCP performance  using algorithms from Nagle  Clark  Jacobson  Karn  and others\n Network performance is typically dominated by protocol and segment processing overhead  and this situation gets worse at higher speeds\n Protocols should be designed to minimize the number of segments and work for large bandwidthdelay paths\n For gigabit networks  simple protocols and streamlined processing are called for\n Delay-tolerant networking provides a delivery service across networks that have occasional connectivity or long delays across links\n Intermediate nodes store  carry  and forward bundles of information so that it is eventually delivered  even if there is no working path from sender to receiver at any time\n PROBLEMS  \n In our example transport primitives of Fig\n  -  LISTEN is a blocking call\n Is this strictly necessary? If not  explain how a nonblocking primitive could be used\n What advantage would this have over the scheme described in the text?  \n Primitives of transport service assume asymmetry between the two end points during connection establishment  one end (server) executes LISTEN while the other end (client) executes CONNECT\n However  in peer to peer applications such file sharing  \n  PROBLEMS systems   \n BitTorrent  all end points are peers\n There is no server or client functionality\n How can transport service primitives may be used to build such peer to peer applications?  \n In the underlying model of Fig\n  -  it is assumed that packets may be lost by the network layer and thus must be individually acknowledged\n Suppose that the network layer is percent reliable and never loses packets\n What changes  if any  are needed to Fig\n  - ?  \n In both parts of Fig\n  -  there is a comment that the value of SERVER PORT must be the same in both client and server\n Why is this so important?  \n In the Internet File Server example (Figure  - )  can the connect( ) system call on the client fail for any reason other than listen queue being full on the server? Assume that the network is perfect One criteria for deciding whether to have a server active all the time or have it start on demand using a process server is how frequently the service provided is used\n Can you think of any other criteria for making this decision?  \n Suppose that the clock-driven scheme for generating initial sequence numbers is used with a  -bit wide clock counter\n The clock ticks once every m  and the maximum packet lifetime is   \n How often need resynchronization take place (a) in the worst case? (b) when the data consumes sequence numbers/min?  \n Why does the maximum packet lifetime  T  have to be large enough to ensure that not only the packet but also its acknowledgements have vanished?  \n Imagine that a two-way handshake rather than a three-way handshake were used to set up connections\n In other words  the third message was not required\n Are deadlocks now possible? Give an example or show that none exist Imagine a generalized n-army problem  in which the agreement of any two of the blue armies is sufficient for victory\n Does a protocol exist that allows blue to win?  \n Consider the problem of recovering from host crashes ( \n  Fig\n  -  )\n If the interval between writing and sending an acknowledgement  or vice versa  can be made relatively small  what are the two best sender-receiver strategies for minimizing the chance of a protocol failure?  \n In Figure  -   suppose a new flow E is added that takes a path from R  to R  to R \n How does the max-min bandwidth allocation change for the five flows?  \n Discuss the advantages and disadvantages of credits versus sliding window protocols Some other policies for fairness in congestion control are Additive Increase Additive Decrease (AIAD)  Multiplicative Increase Additive Decrease (MIAD)  and Multiplicative Increase Multiplicative Decrease (MIMD)\n Discuss these three policies in terms of convergence and stability Why does UDP exist? Would it not have been enough to just let user processes send raw IP packets? THE TRANSPORT LAYER   Consider a simple application-level protocol built on top of UDP that allows a client to retrieve a file from a remote server residing at a well-known address\n The client first sends a request with a file name  and the server responds with a sequence of data packets containing different parts of the requested file\n To ensure reliability and sequenced delivery  client and server use a stop-and-wait protocol\n Ignoring the obvious performance issue  do you see a problem with this protocol? Think carefully about the possibility of processes crashing A client sends a   -byte request to a server located km away over a  -gigabit optical fiber\n What is the efficiency of the line during the remote procedure call?  \n Consider the situation of the previous problem again\n Compute the minimum possible response time both for the given  -Gbps line and for a  -Mbps line\n What conclusion can you draw?  \n Both UDP and TCP use port numbers to identify the destination entity when delivering a message\n Give two reasons why these protocols invented a new abstract ID (port numbers)  instead of using process IDs  which already existed when these protocols were designed Several RPC implementations provide an option to the client to use RPC implemented over UDP or RPC implemented over TCP\n Under what conditions will a client prefer to use RPC over UDP and under what conditions will he prefer to use RPC over TCP?  \n Consider two networks  N  and N  that have the same average delay between a source A and a destination D\n In N  the delay experienced by different packets is unformly distributed with maximum delay being   onds  while in N % of the packets experience less than one ond delay with no limit on maximum delay\n Discuss how RTP may be used in these two cases to transmit live audio/video stream What is the total size of the minimum TCP MTU  including TCP and IP overhead but not including data link layer overhead?  \n Datagram fragmentation and reassembly are handled by IP and are invisible to TCP\n Does this mean that TCP does not have to worry about data arriving in the wrong order?  \n RTP is used to transmit CD-quality audio  which makes a pair of  -bit samples   times/  one sample for each of the stereo channels\n How many packets per ond must RTP transmit?  \n Would it be possible to place the RTP code in the operating system kernel  along with the UDP code? Explain your answer A process on host  has been assigned port p  and a process on host  has been assigned port q\n Is it possible for there to be two or more TCP connections between these two ports at the same time?  \n In Fig\n  -  we saw that in addition to the  -bit acknowledgement field  there is an ACK bit in the fourth word\n Does this really add anything? Why or why not?  \n The maximum payload of a TCP segment is   bytes\n Why was such a strange number chosen?  \n  PROBLEMS  \n Describe two ways to get into the SYN RCVD state of Fig\n  -   Consider the effect of using slow start on a line with a  -m round-trip time and no congestion\n The receive window is   KB and the maximum segment size is  KB\n How long does it take before the first full window can be sent?  \n Suppose that the TCP congestion window is set to   KB and a timeout occurs\n How big will the window be if the next four transmission bursts are all successful? Assume that the maximum segment size is  KB If the TCP round-trip time  RTT  is currently   m and the following acknowledgements come in after    and   m  respectively  what is the new RTT estimate using the Jacobson algorithm? Use α =    \n A TCP machine is sending full windows of   bytes over a  -Gbps channel that has a  -m one-way delay\n What is the maximum throughput achievable? What is the line efficiency?  \n What is the fastest line speed at which a host can blast out -byte TCP payloads with a   - maximum packet lifetime without having the sequence numbers wrap around? Take TCP  IP  and Ethernet overhead into consideration\n Assume that Ethernet frames may be sent continuously To address the limitations of IP version   a major effort had to be undertaken via IETF that resulted in the design of IP version  and there are still is significant reluctance in the adoption of this new version\n However  no such major effort is needed to address the limitations of TCP\n Explain why this is the case In a network whose max segment is bytes  max segment lifetime is     and has  -bit sequence numbers  what is the maximum data rate per connection?  \n Suppose that you are measuring the time to receive a segment\n When an interrupt occurs  you read out the system clock in millionds\n When the segment is fully processed  you read out the clock again\n You measure  m    times and  m    times\n How long does it take to receive a segment?  \n A CPU executes instructions at the rate of  MIPS\n Data can be copied   bits at a time  with each word copied costing   instructions\n If an coming packet has to be copied four times  can this system handle a  -Gbps line? For simplicity  assume that all instructions  even those instructions that read or write memory  run at the full -MIPS rate To get around the problem of sequence numbers wrapping around while old packets still exist  one could use  -bit sequence numbers\n However  theoretically  an optical fiber can run at   Tbps\n What maximum packet lifetime is required to make sure that future  -Tbps networks do not have wraparound problems even with  -bit sequence numbers? Assume that each byte has its own sequence number  as TCP does In \n    we calculated that a gigabit line dumps   packets/ on the host  giving it only  instructions to process it and leaving half the CPU time for applications\n This calculation assumed a -byte packet\n Redo the calculation for an ARPANET-sized packet (   bytes)\n In both cases  assume that the packet sizes given include all overhead\n THE TRANSPORT LAYER   For a  -Gbps network operating over  km  the delay is the limiting factor  not the bandwidth\n Consider a MAN with the average source and destination   km apart\n At what data rate does the round-trip delay due to the speed of light equal the transmission delay for a  -KB packet?  \n Calculate the bandwidth-delay product for the following networks: ( ) T  ( \n  Mbps)  ( ) Ethernet (  Mbps)  ( ) T  (  Mbps)  and ( ) STS-  (   Mbps)\n Assume an RTT of m\n Recall that a TCP header has   bits reserved for Window Size\n What are its implications in light of your calculations?  \n What is the bandwidth-delay product for a  -Mbps channel on a geostationary satellite? If the packets are all  bytes (including overhead)  how big should the window be in packets?  \n The file server of Fig\n  -  is far from perfect and could use a few improvements\n Make the following modifications\n (a) Give the client a third argument that specifies a byte range\n (b) Add a client flag –w that allows the file to be written to the server One common function that all network protocols need is to manipulate messages\n Recall that protocols manipulate messages by adding/striping headers\n Some protocols may break a single message into multiple fragments  and later join these multiple fragments back into a single message\n To this end  design and implement a message management library that provides support for creating a new message  attaching a header to a message  stripping a header from a message  breaking a message into two messages  combining two messages into a single message  and saving a copy of a message\n Your implementation must minimize data copying from one buffer to another as much as possible\n It is critical that the operations that manipulate messages do not touch the data in a message  but rather  only manipulate pointers Design and implement a chat system that allows multiple groups of users to chat\n A chat coordinator resides at a well-known network address  uses UDP for communication with chat clients  sets up chat servers for each chat session  and maintains a chat session directory\n There is one chat server per chat session\n A chat server uses TCP for communication with clients\n A chat client allows users to start  join  and leave a chat session\n Design and implement the coordinator  server  and client code\n  THE APPLICATION LAYER Having finished all the preliminaries  we now come to the layer where all the applications are found\n The layers below the application layer are there to provide transport services  but they do not do real work for users\n In this  ter  we will study some real network applications\n However  even in the application layer there is a need for support protocols  to allow the applications to function\n Accordingly  we will look at an important one of these before starting with the applications themselves\n The item in question is DNS  which handles naming within the Internet\n After that  we will examine three real applications: electronic mail  the World Wide Web  and multimedia\n We will finish the  ter by saying more about content distribution  including by peer-to-peer networks  DNS—THE DOMAIN NAME SYSTEM Although programs theoretically could refer to Web pages  mailboxes  and other resources by using the network ( \n  IP) addresses of the computers on which they are stored  these addresses are hard for people to remember\n Also  browsing a company’s Web pages from     \n  means that if the company moves the Web server to a different machine with a different IP address  everyone needs to be told the new IP address\n Consequently  high-level  readable names were introduced in order to decouple machine names from machine addresses\n In    THE APPLICATION LAYER  \n  this way  the company’s Web server might be known as  \n  regardless of its IP address\n Nevertheless  since the network itself understands only numerical addresses  some mechanism is required to convert the names to network addresses\n In the following tions  we will study how this mapping is accomplished in the Internet\n Way back in the ARPANET days  there was simply a file     that listed all the computer names and their IP addresses\n Every night  all the hosts would fetch it from the site at which it was maintained\n For a network of a few hundred large timesharing machines  this approach worked reasonably well\n However  well before many millions of PCs were connected to the Internet  everyone involved with it realized that this approach could not continue to work forever\n For one thing  the size of the file would become too large\n However  even more importantly  host name conflicts would occur constantly unless names were centrally managed  something unthinkable in a huge international network due to the load and latency\n To solve these problems  DNS (Domain Name System) was invented in \n It has been a key part of the Internet ever since\n The essence of DNS is the invention of a hierarchical  domain-based naming scheme and a distributed database system for implementing this naming scheme\n It is primarily used for mapping host names to IP addresses but can also be used for other purposes\n DNS is defined in RFCs     and further elaborated in many others\n Very briefly  the way DNS is used is as follows\n To map a name onto an IP address  an application program calls a library procedure called the resolver  passing it the name as a parameter\n We saw an example of a resolver  gethostbyname  in Fig\n  - \n The resolver sends a query containing the name to a local DNS server  which looks up the name and returns a response containing the IP address to the resolver  which then returns it to the caller\n The query and response messages are sent as UDP packets\n Armed with the IP address  the program can then establish a TCP connection with the host or send it UDP packets\n    The DNS Name Space Managing a large and constantly changing set of names is a nontrivial problem\n In the postal system  name management is done by requiring letters to specify (implicitly or explicitly) the country  state or province  city  street address  and name of the addressee\n Using this kind of hierarchical addressing ensures that there is no confusion between the Marvin Anderson on Main St\n in White Plains   \n and the Marvin Anderson on Main St\n in Austin  Texas\n DNS works the same way\n For the Internet  the top of the naming hierarchy is managed by an organization called ICANN (Internet Corporation for Assigned Names and Numbers)\n ICANN was created for this purpose in  as part of the maturing of the Internet to a worldwide  economic concern\n Conceptually  the Internet is divided into   DNS—THE DOMAIN NAME SYSTEM over top-level domains  where each domain covers many hosts\n Each domain is partitioned into subdomains  and these are further partitioned  and so on\n All these domains can be represented by a tree  as shown in Fig\n  - \n The leaves of the tree represent domains that have no subdomains (but do contain machines  of course)\n A leaf domain may contain a single host  or it may represent a company and contain thousands of hosts  eng cisco acm ieee eng washington cs robot jack jill ac co csl nec cs uwa keio edu vu oce cs law aero com edu gov museum org net au jp uk us nl Generic Countries  \n filts fluit Figure  - \n A portion of the Internet domain name space\n The top-level domains come in two flavors: generic and countries\n The generic domains  listed in Fig\n  -  include original domains from the s and domains introduced via applications to ICANN\n Other generic top-level domains will be added in the future\n The country domains include one entry for every country  as defined in ISO \n Internationalized country domain names that use non-Latin alphabets were introduced in \n These domains let people name hosts in Arabic  Cyrillic  Chinese  or other languages\n Getting a ond-level domain  such as name-of-   is easy\n The top-level domains are run by registrars appointed by ICANN\n Getting a name merely requires going to a corresponding registrar (for com in this case) to check if the desired name is available and not somebody else’s trademark\n If there are no problems  the requester pays the registrar a small annual fee and gets the name\n However  as the Internet has become more commercial and more international  it has also become more contentious  especially in matters related to naming\n This controversy includes ICANN itself\n For example  the creation of the xxx domain took several years and court cases to resolve\n Is voluntarily placing adult content in its own domain a good or a bad thing? (Some people did not want adult content available at all on the Internet while others wanted to put it all in one domain so nanny filters could easily find and block it from children)\n Some of the domains self-organize  while others have restrictions on who can obtain a name  as noted in Fig\n  - \n But what restrictions are appropriate? Take the pro domain  THE APPLICATION LAYER  \n  Domain Intended use Start date Restricted? com Commercial  No edu Educational institutions  Yes gov Government  Yes int International organizations  Yes mil Military  Yes net Network providers  No org Non-profit organizations  No aero Air transport  Yes biz Businesses  No coop Cooperatives  Yes info Informational  No museum Museums  Yes name People  No pro Professionals  Yes cat Catalan  Yes jobs Employment  Yes mobi Mobile devices  Yes tel Contact details  Yes travel Travel industry  Yes xxx Sex industry  No Figure  - \n Generic top-level domains\n for example\n It is for qualified professionals\n But who is a professional? Doctors and lawyers clearly are professionals\n But what about freelance photographers  piano teachers  magicians  plumbers  barbers  exterminators  tattoo artists  mercenaries  and prostitutes? Are these occupations eligible? According to whom? There is also money in names\n Tuvalu (the country) sold a lease on its tv domain for $  million  all because the country code is well-suited to advertising television sites\n Virtually every common (English) word has been taken in the com domain  along with the most common misspellings\n Try household articles  animals  plants  body parts  etc\n The practice of registering a domain only to turn around and sell it off to an interested party at a much higher price even has a name\n It is called cybersquatting\n Many companies that were slow off the mark when the Internet era began found their obvious domain names already taken when they tried to acquire them\n In general  as long as no trademarks are being violated and no fraud is involved  it is first-come  first-served with names\n Nevertheless  policies to resolve naming disputes are still being refined\n   DNS—THE DOMAIN NAME SYSTEM Each domain is named by the path upward from it to the (unnamed) root\n The components are separated by periods (pronounced ‘‘dot’’)\n Thus  the engineering department at Cisco might be  \n  rather than a UNIX-style name such as /com/cisco/eng\n Notice that this hierarchical naming means that  \n does not conflict with a potential use of eng in  \n  which might be used by the English department at the University of Washington\n Domain names can be either absolute or relative\n An absolute domain name always ends with a period ( \n   \n)  whereas a relative one does not\n Relative names have to be interpreted in some context to uniquely determine their true meaning\n In both cases  a named domain refers to a specific node in the tree and all the nodes under it\n Domain names are case-insensitive  so edu  Edu  and EDU mean the same thing\n Component names can be up to   characters long  and full path names must not exceed characters\n In principle  domains can be inserted into the tree in either generic or country domains\n For example    could equally well be listed under the us country domain as   In practice  however  most organizations in the United States are under generic domains  and most outside the United States are under the domain of their country\n There is no rule against registering under multiple top-level domains\n Large companies often do so ( \n        and  )\n Each domain controls how it allocates the domains under it\n For example  Japan has domains   and   that mirror edu and com\n The Netherlands does not make this distinction and puts all organizations directly under nl\n Thus  all three of the following are university computer science departments:  edu (University of Washington  in the  \n)   (Vrije Universiteit  in The Netherlands)  \n  (Keio University  in Japan)\n To create a new domain  permission is required of the domain in which it will be included\n For example  if a VLSI group is started at the University of Washington and wants to be known as  \n   it has to get permission from whoever manages  \n Similarly  if a new university is chartered  say  the University of Northern South Dakota  it must ask the manager of the edu domain to assign it   (if that is still available)\n In this way  name conflicts are avoided and each domain can keep track of all its subdomains\n Once a new domain has been created and registered  it can create subdomains  such as    without getting permission from anybody higher up the tree\n Naming follows organizational boundaries  not physical networks\n For example  if the computer science and electrical engineering departments are located in the same building and share the same LAN  they can nevertheless have distinct THE APPLICATION LAYER  \n  domains\n Similarly  even if computer science is split over Babbage Hall and Turing Hall  the hosts in both buildings will normally belong to the same domain\n    Domain Resource Records Every domain  whether it is a single host or a top-level domain  can have a set of resource records associated with it\n These records are the DNS database\n For a single host  the most common resource record is just its IP address  but many other kinds of resource records also exist\n When a resolver gives a domain name to DNS  what it gets back are the resource records associated with that name\n Thus  the primary function of DNS is to map domain names onto resource records\n A resource record is a five-tuple\n Although they are encoded in binary for efficiency  in most expositions resource records are presented as ASCII text  one line per resource record\n The format we will use is as follows: Domain name Time to live Class Type Value The Domain name tells the domain to which this record applies\n Normally  many records exist for each domain and each copy of the database holds information about multiple domains\n This field is thus the primary search key used to satisfy queries\n The order of the records in the database is not significant\n The Time to live field gives an indication of how stable the record is\n Information that is highly stable is assigned a large value  such as  (the number of onds in  day)\n Information that is highly volatile is assigned a small value  such as   (  minute)\n We will come back to this point later when we have discussed caching\n The third field of every resource record is the Class\n For Internet information  it is always IN\n For non-Internet information  other codes can be used  but in practice these are rarely seen\n The Type field tells what kind of record this is\n There are many kinds of DNS records\n The important types are listed in Fig\n  - \n An SOA record provides the name of the primary source of information about the name server’s zone (described below)  the email address of its administrator  a unique serial number  and various flags and timeouts\n The most important record type is the A (Address) record\n It holds a  -bit IPv  address of an interface for some host\n The corresponding AAAA  or ‘‘quad A ’’ record holds a   -bit IPv  address\n Every Internet host must have at least one IP address so that other machines can communicate with it\n Some hosts have two or more network interfaces  in which case they will have two or more type A or AAAA resource records\n Consequently  DNS can return multiple addresses for a single name\n A common record type is the MX record\n It specifies the name of the host prepared to accept email for the specified domain\n It is used because not every   DNS—THE DOMAIN NAME SYSTEM Type Meaning Value SOA Start of authority Parameters for this zone A IPv  address of a host  -Bit integer AAAA IPv  address of a host   -Bit integer MX Mail exchange Priority  domain willing to accept email NS Name server Name of a server for this domain CNAME Canonical name Domain name PTR Pointer Alias for an IP address SPF Sender policy framework Text encoding of mail sending policy SRV Service Host that provides it TXT Text Descriptive ASCII text Figure  - \n The principal DNS resource record types\n machine is prepared to accept email\n If someone wants to send email to  for example  bill@   the sending host needs to find some mail server located at   that is willing to accept email\n The MX record can provide this information\n Another important record type is the NS record\n It specifies a name server for the domain or subdomain\n This is a host that has a copy of the database for a domain\n It is used as part of the process to look up names  which we will describe shortly\n CNAME records allow aliases to be created\n For example  a person familiar with Internet naming in general and wanting to send a message to user paul in the computer science department at  \n might guess that paul@  will work\n Actually  this address will not work  because the domain for  \n’s computer science department is  \n However  as a service to people who do not know this   \n could create a CNAME entry to point people and programs in the right direction\n An entry like this one might do the job:    IN CNAME   Like CNAME  PTR points to another name\n However  unlike CNAME  which is really just a macro definition ( \n  a mechanism to replace one string by another)  PTR is a regular DNS data type whose interpretation depends on the context in which it is found\n In practice  it is nearly always used to associate a name with an IP address to allow lookups of the IP address and return the name of the corresponding machine\n These are called reverse lookups\n SRV is a newer type of record that allows a host to be identified for a given service in a domain\n For example  the Web server for   could be identified as   This record generalizes the MX record that performs the same task but it is just for mail servers\n THE APPLICATION LAYER  \n  SPF is also a newer type of record\n It lets a domain encode information about what machines in the domain will send mail to the rest of the Internet\n This helps receiving machines check that mail is valid\n If mail is being received from a machine that calls itself dodgy but the domain records say that mail will only be sent out of the domain by a machine called smtp  chances are that the mail is forged junk mail\n Last on the list  TXT records were originally provided to allow domains to identify themselves in arbitrary ways\n Nowadays  they usually encode machinereadable information  typically the SPF information\n Finally  we have the Value field\n This field can be a number  a domain name  or an ASCII string\n The semantics depend on the record type\n A short description of the Value fields for each of the principal record types is given in Fig\n  - \n For an example of the kind of information one might find in the DNS database of a domain  see Fig\n  - \n This figure depicts part of a (hypothetical) database for the   domain shown in Fig\n  - \n The database contains seven types of resource records\n ; Authoritative data for    \n  IN SOA star boss (     )  \n  IN MX  zephyr  \n  IN MX  top  \n  IN NS star star  IN A     \n   zephyr  IN A     \n  top  IN A     \n  www  IN CNAME  \n  ftp  IN CNAME  \n  flits  IN A     \n   flits  IN A     \n   flits  IN MX  flits flits  IN MX  zephyr flits  IN MX  top rowboat IN A     \n   IN MX  rowboat IN MX  zephyr little-sister IN A     \n  laserjet IN A     \n   Figure  - \n A portion of a possible DNS database for  \n The first noncomment line of Fig\n  -  gives some basic information about the domain  which will not concern us further\n Then come two entries giving the first   DNS—THE DOMAIN NAME SYSTEM and ond places to try to deliver email sent to person@ \n The zephyr (a specific machine) should be tried first\n If that fails  the top should be tried as the next choice\n The next line identifies the name server for the domain as star\n After the blank line (added for readability) come lines giving the IP addresses for the star  zephyr  and top\n These are followed by an alias   \n   so that this address can be used without designating a specific machine\n Creating this alias allows   to change its World Wide Web server without invalidating the address people use to get to it\n A similar argument holds for   The tion for the machine flits lists two IP addresses and three choices are given for handling email sent to   First choice is naturally the flits itself  but if it is down  the zephyr and top are the ond and third choices\n The next three lines contain a typical entry for a computer  in this case    The information provided contains the IP address and the primary and ondary mail drops\n Then comes an entry for a computer that is not capable of receiving mail itself  followed by an entry that is likely for a printer that is connected to the Internet\n    Name Servers In theory at least  a single name server could contain the entire DNS database and respond to all queries about it\n In practice  this server would be so overloaded as to be useless\n Furthermore  if it ever went down  the entire Internet would be crippled\n To avoid the problems associated with having only a single source of information  the DNS name space is divided into nonoverlapping zones\n One possible way to divide the name space of Fig\n  -  is shown in Fig\n  - \n Each circled zone contains some part of the tree  eng cisco acm ieee eng washington cs robot jack jill ac co csl nec cs uwa keio edu vu oce cs law aero com edu gov museum org net au jp uk us nl Generic Countries  \n flits fluit Figure  - \n Part of the DNS name space divided into zones (which are circled)\n THE APPLICATION LAYER  \n  Where the zone boundaries are placed within a zone is up to that zone’s administrator\n This decision is made in large part based on how many name servers are desired  and where\n For example  in Fig\n  -  the University of Washington has a zone for   that handles   but does not handle  \n That is a separate zone with its own name servers\n Such a decision might be made when a department such as English does not wish to run its own name server  but a department such as Computer Science does\n Each zone is also associated with one or more name servers\n These are hosts that hold the database for the zone\n Normally  a zone will have one primary name server  which gets its information from a file on its disk  and one or more ondary name servers  which get their information from the primary name server\n To improve reliability  some of the name servers can be located outside the zone\n The process of looking up a name and finding an address is called name resolution\n When a resolver has a query about a domain name  it passes the query to a local name server\n If the domain being sought falls under the jurisdiction of the name server  such as  \n  falling under    it returns the authoritative resource records\n An authoritative record is one that comes from the authority that manages the record and is thus always correct\n Authoritative records are in contrast to cached records  which may be out of date\n What happens when the domain is remote  such as when  \n  wants to find the IP address of  \n  at UW (University of Washington)? In this case  and if there is no cached information about the domain available locally  the name server begins a remote query\n This query follows the process shown in Fig\n  - \n Step  shows the query that is sent to the local name server\n The query contains the domain name sought  the type (A)  and the class(IN)\n  :  \n   : query  : query  : edu  :    : query  : query  :    :  \n   : query Local ( ) name server UWCS name server UW name server Edu name server ( - ) Root name server ( - )  \n  Originator Figure  - \n Example of a resolver looking up a remote name in   steps\n The next step is to start at the top of the name hierarchy by asking one of the root name servers\n These name servers have information about each top-level   DNS—THE DOMAIN NAME SYSTEM domain\n This is shown as step  in Fig\n  - \n To contact a root server  each name server must have information about one or more root name servers\n This information is normally present in a system configuration file that is loaded into the DNS cache when the DNS server is started\n It is simply a list of NS records for the root and the corresponding A records\n There are   root DNS servers  unimaginatively called a-root-  through  - \n Each root server could logically be a single computer\n However  since the entire Internet depends on the root servers  they are powerful and heavily replicated computers\n Most of the servers are present in multiple geographical locations and reached using anycast routing  in which a packet is delivered to the nearest instance of a destination address; we described anycast in  \n  The replication improves reliability and performance\n The root name server is unlikely to know the address of a machine at UW  and probably does not know the name server for UW either\n But it must know the name server for the edu domain  in which   is located\n It returns the name and IP address for that part of the answer in step  \n The local name server then continues its quest\n It sends the entire query to the edu name server ( - )\n That name server returns the name server for UW\n This is shown in steps  and  \n Closer now  the local name server sends the query to the UW name server (step  )\n If the domain name being sought was in the English department  the answer would be found  as the UW zone includes the English department\n But the Computer Science department has chosen to run its own name server\n The query returns the name and IP address of the UW Computer Science name server (step  )\n Finally  the local name server queries the UW Computer Science name server (step  )\n This server is authoritative for the domain    so it must have the answer\n It returns the final answer (step  )  which the local name server forwards as a response to  \n  (step  )\n The name has been resolved\n You can explore this process using standard tools such as the dig program that is installed on most UNIX systems\n For example  typing dig@ -   \n  will send a query for  \n  to the  -  name server and print out the result\n This will show you the information obtained in step  in the example above  and you will learn the name and IP address of the UW name servers\n There are three technical points to discuss about this long scenario\n First  two different query mechanisms are at work in Fig\n  - \n When the host  \n  sends its query to the local name server  that name server handles the resolution on behalf of flits until it has the desired answer to return\n It does not return partial answers\n They might be helpful  but they are not what the query was seeking\n This mechanism is called a recursive query\n THE APPLICATION LAYER  \n  On the other hand  the root name server (and each subsequent name server) does not recursively continue the query for the local name server\n It just returns a partial answer and moves on to the next query\n The local name server is responsible for continuing the resolution by issuing further queries\n This mechanism is called an iterative query\n One name resolution can involve both mechanisms  as this example showed\n A recursive query may always seem preferable  but many name servers (especially the root) will not handle them\n They are too busy\n Iterative queries put the burden on the originator\n The rationale for the local name server supporting a recursive query is that it is providing a service to hosts in its domain\n Those hosts do not have to be configured to run a full name server  just to reach the local one\n The ond point is caching\n All of the answers  including all the partial answers returned  are cached\n In this way  if another   host queries for  \n  the answer will already be known\n Even better  if a host queries for a different host in the same domain  say  \n   the query can be sent directly to the authoritative name server\n Similarly  queries for other domains in   can start directly from the   name server\n Using cached answers greatly reduces the steps in a query and improves performance\n The original scenario we sketched is in fact the worst case that occurs when no useful information is cached\n However  cached answers are not authoritative  since changes made at   will not be propagated to all the caches in the world that may know about it\n For this reason  cache entries should not live too long\n This is the reason that the Time to live field is included in each resource record\n It tells remote name servers how long to cache records\n If a certain machine has had the same IP address for years  it may be safe to cache that information for  day\n For more volatile information  it might be safer to purge the records after a few onds or a minute\n The third issue is the transport protocol that is used for the queries and responses\n It is UDP\n DNS messages are sent in UDP packets with a simple format for queries  answers  and name servers that can be used to continue the resolution\n We will not go into the details of this format\n If no response arrives within a short time  the DNS client repeats the query  trying another server for the domain after a small number of retries\n This process is designed to handle the case of the server being down as well as the query or response packet getting lost\n A  -bit identifier is included in each query and copied to the response so that a name server can match answers to the corresponding query  even if multiple queries are outstanding at the same time\n Even though its purpose is simple  it should be clear that DNS is a large and complex distributed system that is comprised of millions of name servers that work together\n It forms a key link between human-readable domain names and the IP addresses of machines\n It includes replication and caching for performance and reliability and is designed to be highly robust\n   DNS—THE DOMAIN NAME SYSTEM We have not covered urity  but as you might imagine  the ability to change the name-to-address mapping can have devastating consequences if done maliciously\n For that reason  urity extensions called DNS have been developed for DNS\n We will describe them in   There is also application demand to use names in more flexible ways  for example  by naming content and resolving to the IP address of a nearby host that has the content\n This fits the model of searching for and downloading a movie\n It is the movie that matters  not the computer that has a copy of it  so all that is wanted is the IP address of any nearby computer that has a copy of the movie\n Content distribution networks are one way to accomplish this mapping\n We will describe how they build on the DNS later in this  ter  in \n    \n  ELECTRONIC MAIL Electronic mail  or more commonly email  has been around for over three decades\n Faster and cheaper than paper mail  email has been a popular application since the early days of the Internet\n Before  it was mostly used in academia\n During the s  it became known to the public at large and grew exponentially  to the point where the number of emails sent per day now is vastly more than the number of snail mail ( \n  paper) letters\n Other forms of network communication  such as instant messaging and voice-over-IP calls have expanded greatly in use over the past decade  but email remains the workhorse of Internet communication\n It is widely used within industry for intracompany communication  for example  to allow far-flung employees all over the world to cooperate on complex projects\n Unfortunately  like paper mail  the majority of email—some  out of   messages—is junk mail or spam (McAfee  )\n Email  like most other forms of communication  has developed its own conventions and styles\n It is very informal and has a low threshold of use\n People who would never dream of calling up or even writing a letter to a Very Important Person do not hesitate for a ond to send a sloppily written email to him or her\n By eliminating most cues associated with rank  age  and gender  email debates often focus on content  not status\n With email  a brilliant idea from a summer student can have more impact than a dumb one from an executive vice president\n Email is full of jargon such as BTW (By The Way)  ROTFL (Rolling On The Floor Laughing)  and IMHO (In My Humble Opinion)\n Many people also use little ASCII symbols called smileys  starting with the ubiquitous ‘‘:-)’’\n Rotate the book   degrees clockwise if this symbol is unfamiliar\n This symbol and other emoticons help to convey the tone of the message\n They have spread to other terse forms of communication  such as instant messaging\n The email protocols have evolved during the period of their use  too\n The first email systems simply consisted of file transfer protocols  with the convention that the first line of each message ( \n  file) contained the recipient’s address\n As time THE APPLICATION LAYER  \n  went on  email diverged from file transfer and many features were added  such as the ability to send one message to a list of recipients\n Multimedia capabilities became important in the s to send messages with images and other non-text material\n Programs for reading email became much more sophisticated too  shifting from text-based to graphical user interfaces and adding the ability for users to access their mail from their laptops wherever they happen to be\n Finally  with the prevalence of spam  mail readers and the mail transfer protocols must now pay attention to finding and removing unwanted email\n In our description of email  we will focus on the way that mail messages are moved between users  rather than the look and feel of mail reader programs\n Nevertheless  after describing the overall architecture  we will begin with the user-facing part of the email system  as it is familiar to most readers\n    Architecture and Services In this tion  we will provide an overview of how email systems are organized and what they can do\n The architecture of the email system is shown in Fig\n  - \n It consists of two kinds of subsystems: the user agents  which allow people to read and send email  and the message transfer agents  which move the messages from the source to the destination\n We will also refer to message transfer agents informally as mail servers\n Message Transfer Agent Message Transfer Agent SMTP Sender User Agent Mailbox Receiver User Agent Email  : Mail submission  : Message transfer  : Final delivery Figure  - \n Architecture of the email system\n The user agent is a program that provides a graphical interface  or sometimes a text- and command-based interface that lets users interact with the email system\n It includes a means to compose messages and replies to messages  display incoming messages  and organize messages by filing  searching  and discarding them\n The act of sending new messages into the mail system for delivery is called mail submission\n Some of the user agent processing may be done automatically  anticipating what the user wants\n For example  incoming mail may be filtered to extract or   ELECTRONIC MAIL deprioritize messages that are likely spam\n Some user agents include advanced features  such as arranging for automatic email responses (‘‘I’m having a wonderful vacation and it will be a while before I get back to you’’)\n A user agent runs on the same computer on which a user reads her mail\n It is just another program and may be run only some of the time\n The message transfer agents are typically system processes\n They run in the background on mail server machines and are intended to be always available\n Their job is to automatically move email through the system from the originator to the recipient with SMTP (Simple Mail Transfer Protocol)\n This is the message transfer step\n SMTP was originally specified as RFC and revised to become the current RFC \n It sends mail over connections and reports back the delivery status and any errors\n Numerous applications exist in which confirmation of delivery is important and may even have legal significance (‘‘Well  Your Honor  my email system is just not very reliable  so I guess the electronic subpoena just got lost somewhere’’)\n Message transfer agents also implement mailing lists  in which an identical copy of a message is delivered to everyone on a list of email addresses\n Other advanced features are carbon copies  blind carbon copies  high-priority email  ret ( \n  encrypted) email  alternative recipients if the primary one is not currently available  and the ability for assistants to read and answer their bosses’ email\n Linking user agents and message transfer agents are the concepts of mailboxes and a standard format for email messages\n Mailboxes store the email that is received for a user\n They are maintained by mail servers\n User agents simply present users with a view of the contents of their mailboxes\n To do this  the user agents send the mail servers commands to manipulate the mailboxes  inspecting their contents  deleting messages  and so on\n The retrieval of mail is the final delivery (step  ) in Fig\n  - \n With this architecture  one user may use different user agents on multiple computers to access one mailbox\n Mail is sent between message transfer agents in a standard format\n The original format  RFC  has been revised to the current RFC  and extended with support for multimedia content and international text\n This scheme is called MIME and will be discussed later\n People still refer to Internet email as RFC  though\n A key idea in the message format is the distinction between the envelope and its contents\n The envelope encapsulates the message\n It contains all the information needed for transporting the message  such as the destination address  priority  and urity level  all of which are distinct from the message itself\n The message transport agents use the envelope for routing  just as the post office does\n The message inside the envelope consists of two separate parts: the header and the body\n The header contains control information for the user agents\n The body is entirely for the human recipient\n None of the agents care much about it\n Envelopes and messages are illustrated in Fig\n  - \n THE APPLICATION LAYER  \n  Mr\n Daniel Dumkopf   Willow Lane White Plains  NY  United Gizmo Main St Boston  MA  Sept\n    Yours truly United Gizmo Yours truly United Gizmo Subject: Invoice  Dear Mr\n Dumkopf  Our computer records show that you still have not paid the above invoice of $  Please send us a check for $ \n  promptly\n Dear Mr\n Dumkopf  Our computer records show that you still have not paid the above invoice of $  Please send us a check for $ \n  promptly\n Name: Mr\n Daniel Dumkopf Street:   Willow Lane City: White Plains State: NY Zip code:  Priority: Urgent Encryption: None From: United Gizmo Address: Main St\n Location: Boston  MA  Date: Sept\n    Subject: Invoice  Envelope Message (a) (b) Body Header Envelope  ¢ Figure  - \n Envelopes and messages\n (a) Paper mail\n (b) Electronic mail\n We will examine the pieces of this architecture in more detail by looking at the steps that are involved in sending email from one user to another\n This journey starts with the user agent\n    The User Agent A user agent is a program (sometimes called an email reader) that accepts a variety of commands for composing  receiving  and replying to messages  as well as for manipulating mailboxes\n There are many popular user agents  including Google gmail  Microsoft Outlook  Mozilla Thunderbird  and Apple Mail\n They can vary greatly in their appearance\n Most user agents have a menu- or icondriven graphical interface that requires a mouse  or a touch interface on smaller mobile devices\n Older user agents  such as Elm  mh  and Pine  provide text-based interfaces and expect one-character commands from the keyboard\n Functionally  these are the same  at least for text messages\n The typical elements of a user agent interface are shown in Fig\n  - \n Your mail reader is likely to be much flashier  but probably has equivalent functions\n   ELECTRONIC MAIL When a user agent is started  it will usually present a summary of the messages in the user’s mailbox\n Often  the summary will have one line for each message in some sorted order\n It highlights key fields of the message that are extracted from the message envelope or header\n Mail Folders All items Inbox Networks Travel Junk Mail Message summary From trudy Andy djw Amy   guido lazowska lazowska        \n Subject Not all Trudys are nasty Material on RFID privacy Have you seen this? Request for information Re: Paper acceptance More on that New report out Received Today Today Mar  Mar  Mar  Mar  Mar  Mailbox search ! A\n Student Dear Professor  I recently completed my undergraduate studies with distinction at an excellent university\n I will be visiting your Message folders Search Graduate studies? Mar  Message Figure  - \n Typical elements of the user agent interface\n Seven summary lines are shown in the example of Fig\n  - \n The lines use the From  Subject  and Received fields  in that order  to display who sent the message  what it is about  and when it was received\n All the information is formatted in a user-friendly way rather than displaying the literal contents of the message fields  but it is based on the message fields\n Thus  people who fail to include a Subject field often discover that responses to their emails tend not to get the highest priority\n Many other fields or indications are possible\n The icons next to the message subjects in Fig\n  -  might indicate  for example  unread mail (the envelope)  attached material (the paperclip)  and important mail  at least as judged by the sender (the exclamation point)\n Many sorting orders are also possible\n The most common is to order messages based on the time that they were received  most recent first  with some indication as to whether the message is new or has already been read by the user\n The fields in the summary and the sort order can be customized by the user according to her preferences\n User agents must also be able to display incoming messages as needed so that people can read their email\n Often a short preview of a message is provided  as in Fig\n  -  to help users decide when to read further\n Previews may use small icons or images to describe the contents of the message\n Other presentation processing THE APPLICATION LAYER  \n  includes reformatting messages to fit the display  and translating or converting contents to more convenient formats ( \n  digitized speech to recognized text)\n After a message has been read  the user can decide what to do with it\n This is called message disposition\n Options include deleting the message  sending a reply  forwarding the message to another user  and keeping the message for later reference\n Most user agents can manage one mailbox for incoming mail with multiple folders for saved mail\n The folders allow the user to save message according to sender  topic  or some other category\n Filing can be done automatically by the user agent as well  before the user reads the messages\n A common example is that the fields and contents of messages are inspected and used  along with feedback from the user about previous messages  to determine if a message is likely to be spam\n Many ISPs and companies run software that labels mail as important or spam so that the user agent can file it in the corresponding mailbox\n The ISP and company have the advantage of seeing mail for many users and may have lists of known spammers\n If hundreds of users have just received a similar message  it is probably spam\n By presorting incoming mail as ‘‘probably legitimate’’ and ‘‘probably spam ’’ the user agent can save users a fair amount of work separating the good stuff from the junk\n And the most popular spam? It is generated by collections of compromised computers called botnets and its content depends on where you live\n Fake diplomas are topical in Asia  and cheap drugs and other dubious product offers are topical in the  \n Unclaimed Nigerian bank accounts still abound\n Pills for enlarging various body parts are common everywhere\n Other filing rules can be constructed by users\n Each rule specifies a condition and an action\n For example  a rule could say that any message received from the boss goes to one folder for immediate reading and any message from a particular mailing list goes to another folder for later reading\n Several folders are shown in Fig\n  - \n The most important folders are the Inbox  for incoming mail not filed elsewhere  and Junk Mail  for messages that are thought to be spam\n As well as explicit constructs like folders  user agents now provide rich capabilities to search the mailbox\n This feature is also shown in Fig\n  - \n Search capabilities let users find messages quickly  such as the message about ‘‘where to buy Vegemite’’ that someone sent in the last month\n Email has come a long way from the days when it was just file transfer\n Providers now routinely support mailboxes with up to  GB of stored mail that details a user’s interactions over a long period of time\n The sophisticated mail handling of user agents with search and automatic forms of processing is what makes it possible to manage these large volumes of email\n For people who send and receive thousands of messages a year  these tools are invaluable\n Another useful feature is the ability to automatically respond to messages in some way\n One response is to forward incoming email to a different address  for example  a computer operated by a commercial paging service that pages the user   ELECTRONIC MAIL by using radio or satellite and displays the Subject: line on his pager\n These autoresponders must run in the mail server because the user agent may not run all the time and may only occasionally retrieve email\n Because of these factors  the user agent cannot provide a true automatic response\n However  the interface for automatic responses is usually presented by the user agent\n A different example of an automatic response is a vacation agent\n This is a program that examines each incoming message and sends the sender an insipid reply such as: ‘‘Hi\n I’m on vacation\n I’ll be back on the  th of August\n Talk to you then\n’’ Such replies can also specify how to handle urgent matters in the interim  other people to contact for specific problems  etc\n Most vacation agents keep track of whom they have sent canned replies to and refrain from sending the same person a ond reply\n There are pitfalls with these agents  however\n For example  it is not advisable to send a canned reply to a large mailing list\n Let us now turn to the scenario of one user sending a message to another user\n One of the basic features user agents support that we have not yet discussed is mail composition\n It involves creating messages and answers to messages and sending these messages into the rest of the mail system for delivery\n Although any text editor can be used to create the body of the message  editors are usually integrated with the user agent so that it can provide assistance with addressing and the numerous header fields attached to each message\n For example  when answering a message  the email system can extract the originator’s address from the incoming email and automatically insert it into the proper place in the reply\n Other common features are appending a signature block to the bottom of a message  correcting spelling  and computing digital signatures that show the message is valid\n Messages that are sent into the mail system have a standard format that must be created from the information supplied to the user agent\n The most important part of the message for transfer is the envelope  and the most important part of the envelope is the destination address\n This address must be in a format that the message transfer agents can deal with\n The expected form of an address is user@dns-address\n Since we studied DNS earlier in this  ter  we will not repeat that material here\n However  it is worth noting that other forms of addressing exist\n In particular  X\n   addresses look radically different from DNS addresses\n X\n   is an ISO standard for message-handling systems that was at one time a competitor to SMTP\n SMTP won out handily  though X\n   systems are still used  mostly outside of the  \n X\n   addresses are composed of attribute=value pairs separated by slashes  for example  /C=US/ST=MASSACHUSETTS/L=CAMBRIDGE/PA=   MEMORIAL DR\n/CN=KEN SMITH/ This address specifies a country  state  locality  personal address  and common name (Ken Smith)\n Many other attributes are possible  so you can send email to THE APPLICATION LAYER  \n  someone whose exact email address you do not know  provided you know enough other attributes ( \n  company and job title)\n Although X\n   names are considerably less convenient than DNS names  the issue is moot for user agents because they have user-friendly aliases (sometimes called nicknames) that allow users to enter or select a person’s name and get the correct email address\n Consequently  it is usually not necessary to actually type in these strange strings\n A final point we will touch on for sending mail is mailing lists  which let users send the same message to a list of people with a single command\n There are two choices for how the mailing list is maintained\n It might be maintained locally  by the user agent\n In this case  the user agent can just send a separate message to each intended recipient\n Alternatively  the list may be maintained remotely at a message transfer agent\n Messages will then be expanded in the message transfer system  which has the effect of allowing multiple users to send to the list\n For example  if a group of bird watchers has a mailing list called birders installed on the transfer agent    any message sent to birders@  will be routed to the University of Arizona and expanded into individual messages to all the mailing list members  wherever in the world they may be\n Users of this mailing list cannot tell that it is a mailing list\n It could just as well be the personal mailbox of Prof\n Gabriel O\n Birders\n    Message Formats Now we turn from the user interface to the format of the email messages themselves\n Messages sent by the user agent must be placed in a standard format to be handled by the message transfer agents\n First we will look at basic ASCII email using RFC  which is the latest revision of the original Internet message format as described in RFC   \n After that  we will look at multimedia extensions to the basic format\n RFC —The Internet Message Format Messages consist of a primitive envelope (described as part of SMTP in RFC )  some number of header fields  a blank line  and then the message body\n Each header field (logically) consists of a single line of ASCII text containing the field name  a colon  and  for most fields  a value\n The original RFC was designed decades ago and did not clearly distinguish the envelope fields from the header fields\n Although it has been revised to RFC  completely redoing it was not possible due to its widespread usage\n In normal usage  the user agent builds a message and passes it to the message transfer agent  which then uses some of the header fields to construct the actual envelope  a somewhat oldfashioned mixing of message and envelope\n   ELECTRONIC MAIL The principal header fields related to message transport are listed in Fig\n  -  \n The To: field gives the DNS address of the primary recipient\n Having multiple recipients is also allowed\n The Cc: field gives the addresses of any ondary recipients\n In terms of delivery  there is no distinction between the primary and ondary recipients\n It is entirely a psychological difference that may be important to the people involved but is not important to the mail system\n The term Cc: (Carbon copy) is a bit dated  since computers do not use carbon paper  but it is well established\n The Bcc: (Blind carbon copy) field is like the Cc: field  except that this line is deleted from all the copies sent to the primary and ondary recipients\n This feature allows people to send copies to third parties without the primary and ondary recipients knowing this\n Header Meaning To: Email address(es) of primary recipient(s) Cc: Email address(es) of ondary recipient(s) Bcc: Email address(es) for blind carbon copies From: Person or people who created the message Sender: Email address of the actual sender Received: Line added by each transfer agent along the route Return-Path: Can be used to identify a path back to the sender Figure  -  \n RFC  header fields related to message transport\n The next two fields  From: and Sender:  tell who wrote and sent the message  respectively\n These need not be the same\n For example  a business executive may write a message  but her assistant may be the one who actually transmits it\n In this case  the executive would be listed in the From: field and the assistant in the Sender: field\n The From: field is required  but the Sender: field may be omitted if it is the same as the From: field\n These fields are needed in case the message is undeliverable and must be returned to the sender\n A line containing Received: is added by each message transfer agent along the way\n The line contains the agent’s identity  the date and time the message was received  and other information that can be used for debugging the routing system\n The Return-Path: field is added by the final message transfer agent and was intended to tell how to get back to the sender\n In theory  this information can be gathered from all the Received: headers (except for the name of the sender’s mailbox)  but it is rarely filled in as such and typically just contains the sender’s address\n In addition to the fields of Fig\n  -   RFC  messages may also contain a variety of header fields used by the user agents or human recipients\n The most common ones are listed in Fig\n  -  \n Most of these are self-explanatory  so we will not go into all of them in much detail\n THE APPLICATION LAYER  \n  Header Meaning Date: The date and time the message was sent Reply-To: Email address to which replies should be sent Message-Id: Unique number for referencing this message later In-Reply-To: Message-Id of the message to which this is a reply References: Other relevant Message-Ids Keywords: User-chosen keywords Subject: Short summary of the message for the one-line display Figure  -  \n Some fields used in the RFC  message header\n The Reply-To: field is sometimes used when neither the person composing the message nor the person sending the message wants to see the reply\n For example  a marketing manager may write an email message telling customers about a new product\n The message is sent by an assistant  but the Reply-To: field lists the head of the sales department  who can answer questions and take orders\n This field is also useful when the sender has two email accounts and wants the reply to go to the other one\n The Message-Id: is an automatically generated number that is used to link messages together ( \n  when used in the In-Reply-To: field) and to prevent duplicate delivery\n The RFC  document explicitly says that users are allowed to invent optional headers for their own private use\n By convention since RFC  these headers start with the string X-\n It is guaranteed that no future headers will use names starting with X-  to avoid conflicts between official and private headers\n Sometimes wiseguy undergraduates make up fields like X-Fruit-of-the-Day: or X-Disease-of-the-Week:  which are legal  although not always illuminating\n After the headers comes the message body\n Users can put whatever they want here\n Some people terminate their messages with elaborate signatures  including quotations from greater and lesser authorities  political statements  and disclaimers of all kinds ( \n  The XYZ Corporation is not responsible for my opinions; in fact  it cannot even comprehend them)\n MIME—The Multipurpose Internet Mail Extensions In the early days of the ARPANET  email consisted exclusively of text messages written in English and expressed in ASCII\n For this environment  the early RFC format did the job completely: it specified the headers but left the content entirely up to the users\n In the s  the worldwide use of the Internet and demand to send richer content through the mail system meant that this approach was no longer adequate\n The problems included sending and receiving messages   ELECTRONIC MAIL in languages with accents ( \n  French and German)  non-Latin alphabets ( \n  Hebrew and Russian)  or no alphabets ( \n  Chinese and Japanese)  as well as sending messages not containing text at all ( \n  audio  images  or binary documents and programs)\n The solution was the development of MIME (Multipurpose Internet Mail Extensions)\n It is widely used for mail messages that are sent across the Internet  as well as to describe content for other applications such as Web browsing\n MIME is described in RFCs –    and \n The basic idea of MIME is to continue to use the RFC format (the precursor to RFC  the time MIME was proposed) but to add structure to the message body and define encoding rules for the transfer of non-ASCII messages\n Not deviating from RFC allowed MIME messages to be sent using the existing mail transfer agents and protocols (based on RFC then  and RFC  now)\n All that had to be changed were the sending and receiving programs  which users could do for themselves\n MIME defines five new message headers  as shown in Fig\n  -  \n The first of these simply tells the user agent receiving the message that it is dealing with a MIME message  and which version of MIME it uses\n Any message not containing a MIME-Version: header is assumed to be an English plaintext message (or at least one using only ASCII characters) and is processed as such\n Header Meaning MIME-Version: Identifies the MIME version Content-Description: Human-readable string telling what is in the message Content-Id: Unique identifier Content-Transfer-Encoding: How the body is wrapped for transmission Content-Type: Type and format of the content Figure  -  \n Message headers added by MIME\n The Content-Description: header is an ASCII string telling what is in the message\n This header is needed so the recipient will know whether it is worth decoding and reading the message\n If the string says ‘‘Photo of Barbara’s hamster’’ and the person getting the message is not a big hamster fan  the message will probably be discarded rather than decoded into a high-resolution color photograph\n The Content-Id: header identifies the content\n It uses the same format as the standard Message-Id: header\n The Content-Transfer-Encoding: tells how the body is wrapped for transmission through the network\n A key problem at the time MIME was developed was that the mail transfer (SMTP) protocols expected ASCII messages in which no line exceeded  characters\n ASCII characters use  bits out of each  -bit byte\n Binary data such as executable programs and images use all  bits of each byte  as THE APPLICATION LAYER  \n  do extended character sets\n There was no guarantee this data would be transferred safely\n Hence  some method of carrying binary data that made it look like a regular ASCII mail message was needed\n Extensions to SMTP since the development of MIME do allow  -bit binary data to be transferred  though even today binary data may not always go through the mail system correctly if unencoded\n MIME provides five transfer encoding schemes  plus an escape to new schemes—just in case\n The simplest scheme is just ASCII text messages\n ASCII characters use  bits and can be carried directly by the email protocol  provided that no line exceeds  characters\n The next simplest scheme is the same thing  but using  -bit characters  that is  all values from  up to and including are allowed\n Messages using the  -bit encoding must still adhere to the standard maximum line length\n Then there are messages that use a true binary encoding\n These are arbitrary binary files that not only use all  bits but also do not adhere to the -character line limit\n Executable programs fall into this category\n Nowadays  mail servers can negotiate to send data in binary (or  -bit) encoding  falling back to ASCII if both ends do not support the extension\n The ASCII encoding of binary data is called base  encoding\n In this scheme  groups of   bits are broken up into four  -bit units  with each unit being sent as a legal ASCII character\n The coding is ‘‘A’’ for   ‘‘B’’ for   and so on  followed by the   lowercase letters  the   digits  and finally + and / for   and respectively\n The == and = sequences indicate that the last group contained only  or   bits  respectively\n Carriage returns and line feeds are ignored  so they can be inserted at will in the encoded character stream to keep the lines short enough\n Arbitrary binary text can be sent safely using this scheme  albeit inefficiently\n This encoding was very popular before binary-capable mail servers were widely deployed\n It is still commonly seen\n For messages that are almost entirely ASCII but with a few non-ASCII characters  base  encoding is somewhat inefficient\n Instead  an encoding known as quoted-printable encoding is used\n This is just  -bit ASCII  with all the characters above encoded as an equals sign followed by the character’s value as two hexadecimal digits\n Control characters  some punctuation marks and math symbols  as well as trailing spaces are also so encoded\n Finally  when there are valid reasons not to use one of these schemes  it is possible to specify a user-defined encoding in the Content-Transfer-Encoding: header\n The last header shown in Fig\n  -  is really the most interesting one\n It specifies the nature of the message body and has had an impact well beyond email\n For instance  content downloaded from the Web is labeled with MIME types so that the browser knows how to present it\n So is content sent over streaming media and real-time transports such as voice over IP\n Initially  seven MIME types were defined in RFC \n Each type has one or more available subtypes\n The type and subtype are separated by a slash  as in   ELECTRONIC MAIL ‘‘Content-Type: video/mpeg’’\n Since then  hundreds of subtypes have been added  along with another type\n Additional entries are being added all the time as new types of content are developed\n The list of assigned types and subtypes is maintained online by IANA at  /assignments/media-types\n The types  along with examples of commonly used subtypes  are given in Fig\n  -  \n Let us briefly go through them  starting with text\n The text/plain combination is for ordinary messages that can be displayed as received  with no encoding and no further processing\n This option allows ordinary messages to be transported in MIME with only a few extra headers\n The text/html subtype was added when the Web became popular (in RFC ) to allow Web pages to be sent in RFC email\n A subtype for the eXtensible Markup Language  text/xml  is defined in RFC \n XML documents have proliferated with the development of the Web\n We will study HTML and XML in \n   Type Example subtypes Description text plain  html  xml  css Text in various formats image gif  jpeg  tiff Pictures audio basic  mpeg  mp  Sounds video mpeg  mp  quicktime Movies model vrml  D model application octet-stream  pdf  javascript  zip Data produced by applications message http  rfc   Encapsulated message multipart mixed  alternative  parallel  digest Combination of multiple types Figure  -  \n MIME content types and example subtypes\n The next MIME type is image  which is used to transmit still pictures\n Many formats are widely used for storing and transmitting images nowadays  both with and without compression\n Several of these  including GIF  JPEG  and TIFF  are built into nearly all browsers\n Many other formats and corresponding subtypes exist as well\n The audio and video types are for sound and moving pictures  respectively\n Please note that video may include only the visual information  not the sound\n If a movie with sound is to be transmitted  the video and audio portions may have to be transmitted separately  depending on the encoding system used\n The first video format defined was the one devised by the modestly named Moving Picture Experts Group (MPEG)  but others have been added since\n In addition to audio/basic  a new audio type  audio/mpeg  was added in RFC  to allow people to email MP  audio files\n The video/mp  and audio/mp  types signal video and audio data that are stored in the newer MPEG  format\n The model type was added after the other content types\n It is intended for describing  D model data\n However  it has not been widely used to date\n THE APPLICATION LAYER  \n  The application type is a catchall for formats that are not covered by one of the other types and that require an application to interpret the data\n We have listed the subtypes pdf  javascript  and zip as examples for PDF documents  Java- Script programs  and Zip archives  respectively\n User agents that receive this content use a third-party library or external program to display the content; the display may or may not appear to be integrated with the user agent\n By using MIME types  user agents gain the extensibility to handle new types of application content as it is developed\n This is a significant benefit\n On the other hand  many of the new forms of content are executed or interpreted by applications  which presents some dangers\n Obviously  running an arbitrary executable program that has arrived via the mail system from ‘‘friends’’ poses a urity hazard\n The program may do all sorts of nasty damage to the parts of the computer to which it has access  especially if it can read and write files and use the network\n Less obviously  document formats can pose the same hazards\n This is because formats such as PDF are full-blown programming languages in disguise\n While they are interpreted and restricted in scope  bugs in the interpreter often allow devious documents to escape the restrictions\n Besides these examples  there are many more application subtypes because there are many more applications\n As a fallback to be used when no other subtype is known to be more fitting  the octet-stream subtype denotes a sequence of uninterpreted bytes\n Upon receiving such a stream  it is likely that a user agent will display it by suggesting to the user that it be copied to a file\n Subsequent processing is then up to the user  who presumably knows what kind of content it is\n The last two types are useful for composing and manipulating messages themselves\n The message type allows one message to be fully encapsulated inside another\n This scheme is useful for forwarding email  for example\n When a complete RFC message is encapsulated inside an outer message  the rfc   subtype should be used\n Similarly  it is common for HTML documents to be encapsulated\n And the partial subtype makes it possible to break an encapsulated message into pieces and send them separately (for example  if the encapsulated message is too long)\n Parameters make it possible to reassemble all the parts at the destination in the correct order\n Finally  the multipart type allows a message to contain more than one part  with the beginning and end of each part being clearly delimited\n The mixed subtype allows each part to be a different type  with no additional structure imposed\n Many email programs allow the user to provide one or more attachments to a text message\n These attachments are sent using the multipart type\n In contrast to mixed  the alternative subtype allows the same message to be included multiple times but expressed in two or more different media\n For example  a message could be sent in plain ASCII  in HMTL  and in PDF\n A properly designed user agent getting such a message would display it according to user preferences\n Likely PDF would be the first choice  if that is possible\n The ond choice would be HTML\n If neither of these were possible  then the flat ASCII   ELECTRONIC MAIL text would be displayed\n The parts should be ordered from simplest to most complex to help recipients with pre-MIME user agents make some sense of the message ( \n  even a pre-MIME user can read flat ASCII text)\n The alternative subtype can also be used for multiple languages\n In this context  the Rosetta Stone can be thought of as an early multipart/alternative message\n Of the other two example subtypes  the parallel subtype is used when all parts must be ‘‘viewed’’ simultaneously\n For example  movies often have an audio channel and a video channel\n Movies are more effective if these two channels are played back in parallel  instead of conutively\n The digest subtype is used when multiple messages are packed together into a composite message\n For example  some discussion groups on the Internet collect messages from subscribers and then send them out to the group periodically as a single multipart/digest message\n As an example of how MIME types may be used for email messages  a multimedia message is shown in Fig\n  -  \n Here  a birthday greeting is transmitted in alternative forms as HTML and as an audio file\n Assuming the receiver has audio capability  the user agent there will play the sound file\n In this example  the sound is carried by reference as a message/external-body subtype  so first the user agent must fetch the sound file   using FTP\n If the user agent has no audio capability  the lyrics are displayed on the screen in stony silence\n The two parts are delimited by two hyphens followed by a (software-generated) string specified in the boundary parameter\n Note that the Content-Type header occurs in three positions within this example\n At the top level  it indicates that the message has multiple parts\n Within each part  it gives the type and subtype of that part\n Finally  within the body of the ond part  it is required to tell the user agent what kind of external file it is to fetch\n To indicate this slight difference in usage  we have used lowercase letters here  although all headers are case insensitive\n The Content-Transfer-Encoding is similarly required for any external body that is not encoded as  -bit ASCII\n    Message Transfer Now that we have described user agents and mail messages  we are ready to look at how the message transfer agents relay messages from the originator to the recipient\n The mail transfer is done with the SMTP protocol\n The simplest way to move messages is to establish a transport connection from the source machine to the destination machine and then just transfer the message\n This is how SMTP originally worked\n Over the years  however  two different uses of SMTP have been differentiated\n The first use is mail submission  step  in the email architecture of Fig\n  - \n This is the means by which user agents send messages into the mail system for delivery\n The ond use is to transfer messages between message transfer agents (step  in Fig\n  - )\n This THE APPLICATION LAYER  \n  From: alice@  To: bob@ \n  MIME-Version:  \n  Message-Id: <   @ > Content-Type: multipart/alternative; boundary=qwertyuiopasdfghjklzxcvbnm Subject: Earth orbits sun integral number of times This is the preamble\n The user agent ignores it\n Have a nice day\n --qwertyuiopasdfghjklzxcvbnm Content-Type: text/html <p>Happy birthday to you<br> Happy birthday to you<br> Happy birthday dear <b> Bob </b><br> Happy birthday to you</p> --qwertyuiopasdfghjklzxcvbnm Content-Type: message/external-body; access-type="anon-ftp"; site=" \n "; directory="pub"; name=" " content-type: audio/basic content-transfer-encoding: base  --qwertyuiopasdfghjklzxcvbnm-- Figure  -  \n A multipart message containing HTML and audio alternatives\n sequence delivers mail all the way from the sending to the receiving message transfer agent in one hop\n Final delivery is accomplished with different protocols that we will describe in the next tion\n In this tion  we will describe the basics of the SMTP protocol and its extension mechanism\n Then we will discuss how it is used differently for mail submission and message transfer\n SMTP (Simple Mail Transfer Protocol) and Extensions Within the Internet  email is delivered by having the sending computer establish a TCP connection to port   of the receiving computer\n Listening to this port is a mail server that speaks SMTP (Simple Mail Transfer Protocol)\n This server accepts incoming connections  subject to some urity checks  and accepts messages for delivery\n If a message cannot be delivered  an error report containing the first part of the undeliverable message is returned to the sender\n SMTP is a simple ASCII protocol\n This is not a weakness but a feature\n Using ASCII text makes protocols easy to develop  test  and debug\n They can be   ELECTRONIC MAIL tested by sending commands manually  and records of the messages are easy to read\n Most application-level Internet protocols now work this way ( \n  HTTP)\n We will walk through a simple message transfer between mail servers that delivers a message\n After establishing the TCP connection to port the sending machine  operating as the client  waits for the receiving machine  operating as the server  to talk first\n The server starts by sending a line of text giving its identity and telling whether it is prepared to receive mail\n If it is not  the client releases the connection and tries again later\n If the server is willing to accept email  the client announces whom the email is coming from and whom it is going to\n If such a recipient exists at the destination  the server gives the client the go-ahead to send the message\n Then the client sends the message and the server acknowledges it\n No checksums are needed because TCP provides a reliable byte stream\n If there is more email  that is now sent\n When all the email has been exchanged in both directions  the connection is released\n A sample dialog for sending the message of Fig\n  -   including the numerical codes used by SMTP  is shown in Fig\n  -  \n The lines sent by the client ( \n  the sender) are marked C:\n Those sent by the server ( \n  the receiver) are marked S:\n The first command from the client is indeed meant to be HELO\n Of the various four-character abbreviations for HELLO  this one has numerous advantages over its biggest competitor\n Why all the commands had to be four characters has been lost in the mists of time\n In Fig\n  -   the message is sent to only one recipient  so only one RCPT command is used\n Such commands are allowed to send a single message to multiple receivers\n Each one is individually acknowledged or rejected\n Even if some recipients are rejected (because they do not exist at the destination)  the message can be sent to the other ones\n Finally  although the syntax of the four-character commands from the client is rigidly specified  the syntax of the replies is less rigid\n Only the numerical code really counts\n Each implementation can put whatever string it wants after the code\n The basic SMTP works well  but it is limited in several respects\n It does not include authentication\n This means that the FROM command in the example could give any sender address that it pleases\n This is quite useful for sending spam\n Another limitation is that SMTP transfers ASCII messages  not binary data\n This is why the base  MIME content transfer encoding was needed\n However  with that encoding the mail transmission uses bandwidth inefficiently  which is an issue for large messages\n A third limitation is that SMTP sends messages in the clear\n It has no encryption to provide a measure of privacy against prying eyes\n To allow these and many other problems related to message processing to be addressed  SMTP was revised to have an extension mechanism\n This mechanism is a mandatory part of the RFC  standard\n The use of SMTP with extensions is called ESMTP (Extended SMTP)\n THE APPLICATION LAYER  \n  S:  \n  SMTP service ready C: HELO   S:   says hello to  \n  C: MAIL FROM: <alice@ > S: sender ok C: RCPT TO: <bob@ \n > S: recipient ok C: DATA S: Send mail; end with "\n" on a line by itself C: From: alice@  C: To: bob@ \n  C: MIME-Version:  \n  C: Message-Id: <   @ \n > C: Content-Type: multipart/alternative; boundary=qwertyuiopasdfghjklzxcvbnm C: Subject: Earth orbits sun integral number of times C: C: This is the preamble\n The user agent ignores it\n Have a nice day\n C: C: --qwertyuiopasdfghjklzxcvbnm C: Content-Type: text/html C: C: <p>Happy birthday to you C: Happy birthday to you C: Happy birthday dear <bold> Bob </bold> C: Happy birthday to you C: C: --qwertyuiopasdfghjklzxcvbnm C: Content-Type: message/external-body; C: access-type="anon-ftp"; C: site=" \n "; C: directory="pub"; C: name=" " C: C: content-type: audio/basic C: content-transfer-encoding: base  C: --qwertyuiopasdfghjklzxcvbnm C: \n S: message accepted C: QUIT S:  \n  closing connection Figure  -  \n Sending a message from alice@  to bob@  Clients wanting to use an extension send an EHLO message instead of HELO initially\n If this is rejected  the server is a regular SMTP server  and the client should proceed in the usual way\n If the EHLO is accepted  the server replies with the extensions that it supports\n The client may then use any of these extensions\n Several common extensions are shown in Fig\n  -  \n The figure gives the keyword   ELECTRONIC MAIL as used in the extension mechanism  along with a description of the new functionality\n We will not go into extensions in further detail\n Keyword Description AUTH Client authentication BINARYMIME Server accepts binary messages CHUNKING Server accepts large messages in chunks SIZE Check message size before trying to send STARTTLS Switch to ure transport (TLS; see  \n  ) UTF SMTP Internationalized addresses Figure  -  \n Some SMTP extensions\n To get a better feel for how SMTP and some of the other protocols described in this  ter work  try them out\n In all cases  first go to a machine connected to the Internet\n On a UNIX (or Linux) system  in a shell  type telnet     substituting the DNS name of your ISP’s mail server for  \n On a Windows XP system  click on Start  then Run  and type the command in the dialog box\n On a Vista or Windows  machine  you may have to first install the telnet program (or equivalent) and then start it yourself\n This command will establish a telnet ( \n  TCP) connection to port   on that machine\n Port   is the SMTP port; see Fig\n  -  for the ports for other common protocols\n You will probably get a response something like this: Trying     \n Connected to   Escape character is ’ˆ]’com Smail #  ready at Thu Sept   :  + The first three lines are from telnet  telling you what it is doing\n The last line is from the SMTP server on the remote machine  announcing its willingness to talk to you and accept email\n To find out what commands it accepts  type HELP From this point on  a command sequence such as the one in Fig\n  -  is possible if the server is willing to accept mail from you\n Mail Submission Originally  user agents ran on the same computer as the sending message transfer agent\n In this setting  all that is required to send a message is for the user agent to talk to the local mail server  using the dialog that we have just described\n However  this setting is no longer the usual case\n THE APPLICATION LAYER  \n  User agents often run on laptops  home PCs  and mobile phones\n They are not always connected to the Internet\n Mail transfer agents run on ISP and company servers\n They are always connected to the Internet\n This difference means that a user agent in Boston may need to contact its regular mail server in Seattle to send a mail message because the user is traveling\n By itself  this remote communication poses no problem\n It is exactly what the TCP/IP protocols are designed to support\n However  an ISP or company usually does not want any remote user to be able to submit messages to its mail server to be delivered elsewhere\n The ISP or company is not running the server as a public service\n In addition  this kind of open mail relay attracts spammers\n This is because it provides a way to launder the original sender and thus make the message more difficult to identify as spam\n Given these considerations  SMTP is normally used for mail submission with the AUTH extension\n This extension lets the server check the credentials (username and password) of the client to confirm that the server should be providing mail service\n There are several other differences in the way SMTP is used for mail submission\n For example  port is used in preference to port   and the SMTP server can check and correct the format of the messages sent by the user agent\n For more information about the restricted use of SMTP for mail submission  please see RFC \n Message Transfer Once the sending mail transfer agent receives a message from the user agent  it will deliver it to the receiving mail transfer agent using SMTP\n To do this  the sender uses the destination address\n Consider the message in Fig\n  -   addressed to bob@  To what mail server should the message be delivered? To determine the correct mail server to contact  DNS is consulted\n In the previous tion  we described how DNS contains multiple types of records  including the MX  or mail exchanger  record\n In this case  a DNS query is made for the MX records of the domain   This query returns an ordered list of the names and IP addresses of one or more mail servers\n The sending mail transfer agent then makes a TCP connection on port   to the IP address of the mail server to reach the receiving mail transfer agent  and uses SMTP to relay the message\n The receiving mail transfer agent will then place mail for the user bob in the correct mailbox for Bob to read it at a later time\n This local delivery step may involve moving the message among computers if there is a large mail infrastructure\n With this delivery process  mail travels from the initial to the final mail transfer agent in a single hop\n There are no intermediate servers in the message transfer stage\n It is possible  however  for this delivery process to occur multiple times\n One example that we have described already is when a message transfer agent   ELECTRONIC MAIL implements a mailing list\n In this case  a message is received for the list\n It is then expanded as a message to each member of the list that is sent to the individual member addresses\n As another example of relaying  Bob may have graduated from  \n and also be reachable via the address bob@ \n Rather than reading mail on multiple accounts  Bob can arrange for mail sent to this address to be forwarded to bob@ \n In this case  mail sent to bob@  will undergo two deliveries\n First  it will be sent to the mail server for  \n Then  it will be sent to the mail server for   Each of these legs is a complete and separate delivery as far as the mail transfer agents are concerned\n Another consideration nowadays is spam\n Nine out of ten messages sent today are spam (McAfee  )\n Few people want more spam  but it is hard to avoid because it masquerades as regular mail\n Before accepting a message  additional checks may be made to reduce the opportunities for spam\n The message for Bob was sent from alice@ \n The receiving mail transfer agent can look up the sending mail transfer agent in DNS\n This lets it check that the IP address of the other end of the TCP connection matches the DNS name\n More generally  the receiving agent may look up the sending domain in DNS to see if it has a mail sending policy\n This information is often given in the TXT and SPF records\n It may indicate that other checks can be made\n For example  mail sent from   may always be sent from the host   If the sending mail transfer agent is not june  there is a problem\n If any of these checks fail  the mail is probably being forged with a fake sending address\n In this case  it is discarded\n However  passing these checks does not imply that mail is not spam\n The checks merely ensure that the mail seems to be coming from the region of the network that it purports to come from\n The idea is that spammers should be forced to use the correct sending address when they send mail\n This makes spam easier to recognize and delete when it is unwanted\n    Final Delivery Our mail message is almost delivered\n It has arrived at Bob’s mailbox\n All that remains is to transfer a copy of the message to Bob’s user agent for display\n This is step  in the architecture of Fig\n  - \n This task was straightforward in the early Internet  when the user agent and mail transfer agent ran on the same machine as different processes\n The mail transfer agent simply wrote new messages to the end of the mailbox file  and the user agent simply checked the mailbox file for new mail\n Nowadays  the user agent on a PC  laptop  or mobile  is likely to be on a different machine than the ISP or company mail server\n Users want to be able to access their mail remotely  from wherever they are\n They want to access email from work  from their home PCs  from their laptops when on business trips  and from cybercafes when on so-called vacation\n They also want to be able to work offline  THE APPLICATION LAYER  \n  then reconnect to receive incoming mail and send outgoing mail\n Moreover  each user may run several user agents depending on what computer it is convenient to use at the moment\n Several user agents may even be running at the same time\n In this setting  the job of the user agent is to present a view of the contents of the mailbox  and to allow the mailbox to be remotely manipulated\n Several different protocols can be used for this purpose  but SMTP is not one of them\n SMTP is a push-based protocol\n It takes a message and connects to a remote server to transfer the message\n Final delivery cannot be achieved in this manner both because the mailbox must continue to be stored on the mail transfer agent and because the user agent may not be connected to the Internet at the moment that SMTP attempts to relay messages\n IMAP—The Internet Message Access Protocol One of the main protocols that is used for final delivery is IMAP (Internet Message Access Protocol)\n Version  of the protocol is defined in RFC \n To use IMAP  the mail server runs an IMAP server that listens to port   \n The user agent runs an IMAP client\n The client connects to the server and begins to issue commands from those listed in Fig\n  -  \n First  the client will start a ure transport if one is to be used (in order to keep the messages and commands confidential)  and then log in or otherwise authenticate itself to the server\n Once logged in  there are many commands to list folders and messages  fetch messages or even parts of messages  mark messages with flags for later deletion  and organize messages into folders\n To avoid confusion  please note that we use the term ‘‘folder’’ here to be consistent with the rest of the material in this tion  in which a user has a single mailbox made up of multiple folders\n However  in the IMAP specification  the term mailbox is used instead\n One user thus has many IMAP mailboxes  each of which is typically presented to the user as a folder\n IMAP has many other features  too\n It has the ability to address mail not by message number  but by using attributes ( \n  give me the first message from Alice)\n Searches can be performed on the server to find the messages that satisfy certain criteria so that only those messages are fetched by the client\n IMAP is an improvement over an earlier final delivery protocol  POP  (Post Office Protocol  version  )  which is specified in RFC \n POP  is a simpler protocol but supports fewer features and is less ure in typical usage\n Mail is usually downloaded to the user agent computer  instead of remaining on the mail server\n This makes life easier on the server  but harder on the user\n It is not easy to read mail on multiple computers  plus if the user agent computer breaks  all email may be lost permanently\n Nonetheless  you will still find POP  in use\n Proprietary protocols can also be used because the protocol runs between a mail server and user agent that can be supplied by the same company\n Microsoft Exchange is a mail system with a proprietary protocol\n   ELECTRONIC MAIL Command Description CAPABILITY List server capabilities STARTTLS Start ure transport (TLS; see  \n  ) LOGIN Log on to server AUTHENTICATE Log on with other method SELECT Select a folder EXAMINE Select a read-only folder CREATE Create a folder DELETE Delete a folder RENAME Rename a folder SUBSCRIBE Add folder to active set UNSUBSCRIBE Remove folder from active set LIST List the available folders LSUB List the active folders STATUS Get the status of a folder APPEND Add a message to a folder CHECK Get a checkpoint of a folder FETCH Get messages from a folder SEARCH Find messages in a folder STORE Alter message flags COPY Make a copy of a message in a folder EXPUNGE Remove messages flagged for deletion UID Issue commands using unique identifiers NOOP Do nothing CLOSE Remove flagged messages and close folder LOGOUT Log out and close connection Figure  -  \n IMAP (version  ) commands\n Webmail An increasingly popular alternative to IMAP and SMTP for providing email service is to use the Web as an interface for sending and receiving mail\n Widely used Webmail systems include Google Gmail  Microsoft Hotmail and Yahoo! Mail\n Webmail is one example of software (in this case  a mail user agent) that is provided as a service using the Web\n In this architecture  the provider runs mail servers as usual to accept messages for users with SMTP on port  \n However  the user agent is different\n Instead of THE APPLICATION LAYER  \n  being a standalone program  it is a user interface that is provided via Web pages\n This means that users can use any browser they like to access their mail and send new messages\n We have not yet studied the Web  but a brief description that you might come back to is as follows\n When the user goes to the email Web page of the provider  a form is presented in which the user is asked for a login name and password\n The login name and password are sent to the server  which then validates them\n If the login is successful  the server finds the user’s mailbox and builds a Web page listing the contents of the mailbox on the fly\n The Web page is then sent to the browser for display\n Many of the items on the page showing the mailbox are clickable  so messages can be read  deleted  and so on\n To make the interface responsive  the Web pages will often include JavaScript programs\n These programs are run locally on the client in response to local events ( \n  mouse clicks) and can also download and upload messages in the background  to prepare the next message for display or a new message for submission\n In this model  mail submission happens using the normal Web protocols by posting data to a URL\n The Web server takes care of injecting messages into the traditional mail delivery system that we have described\n For urity  the standard Web protocols can be used as well\n These protocols concern themselves with encrypting Web pages  not whether the content of the Web page is a mail message  THE WORLD WIDE WEB The Web  as the World Wide Web is popularly known  is an architectural framework for accessing linked content spread out over millions of machines all over the Internet\n In   years it went from being a way to coordinate the design of high-energy physics experiments in Switzerland to the application that millions of people think of as being ‘‘The Internet\n’’ Its enormous popularity stems from the fact that it is easy for beginners to use and provides access with a rich graphical interface to an enormous wealth of information on almost every conceivable subject  from aardvarks to Zulus\n The Web began in  at CERN  the European Center for Nuclear Research\n The initial idea was to help large teams  often with members in half a dozen or more countries and time zones  collaborate using a constantly changing collection of reports  blueprints  drawings  photos  and other documents produced by experiments in particle physics\n The proposal for a web of linked documents came from CERN physicist Tim Berners-Lee\n The first (text-based) prototype was operational   months later\n A public demonstration given at the Hypertext ’  conference caught the attention of other researchers  which led Marc Andreessen at the University of Illinois to develop the first graphical browser\n It was called Mosaic and released in February \n   THE WORLD WIDE WEB The rest  as they say  is now history\n Mosaic was so popular that a year later Andreessen left to form a company  Netscape Communications Corp\n  whose goal was to develop Web software\n For the next three years  Netscape Navigator and Microsoft’s Internet Explorer engaged in a ‘‘browser war ’’ each one trying to capture a larger share of the new market by frantically adding more features (and thus more bugs) than the other one\n Through the s and s  Web sites and Web pages  as Web content is called  grew exponentially until there were millions of sites and billions of pages\n A small number of these sites became tremendously popular\n Those sites and the companies behind them largely define the Web as people experience it today\n Examples include: a bookstore (Amazon  started in  market capitalization $  billion)  a flea market (eBay   $  B)  search (Google   $  B)  and social networking (Facebook   private company valued at more than $  B)\n The period through  when many Web companies became worth hundreds of millions of dollars overnight  only to go bust practically the next day when they turned out to be hype  even has a name\n It is called the dot com era\n New ideas are still striking it rich on the Web\n Many of them come from students\n For example  Mark Zuckerberg was a Harvard student when he started Facebook  and Sergey Brin and Larry Page were students at Stanford when they started Google\n Perhaps you will come up with the next big thing\n In  CERN and  \n signed an agreement setting up the W C (World Wide Web Consortium)  an organization devoted to further developing the Web  standardizing protocols  and encouraging interoperability between sites\n Berners- Lee became the director\n Since then  several hundred universities and companies have joined the consortium\n Although there are now more books about the Web than you can shake a stick at  the best place to get up-to-date information about the Web is (naturally) on the Web itself\n The consortium’s home page is at   \n Interested readers are referred there for links to pages covering all of the consortium’s numerous documents and activities\n    Architectural Overview From the users’ point of view  the Web consists of a vast  worldwide collection of content in the form of Web pages  often just called pages for short\n Each page may contain links to other pages anywhere in the world\n Users can follow a link by clicking on it  which then takes them to the page pointed to\n This process can be repeated indefinitely\n The idea of having one page point to another  now called hypertext  was invented by a visionary  \n professor of electrical engineering  Vannevar Bush  in  (Bush  )\n This was long before the Internet was invented\n In fact  it was before commercial computers existed although several universities had produced crude prototypes that filled large rooms and had less power than a modern pocket calculator\n THE APPLICATION LAYER  \n  Pages are generally viewed with a program called a browser\n Firefox  Internet Explorer  and Chrome are examples of popular browsers\n The browser fetches the page requested  interprets the content  and displays the page  properly formatted  on the screen\n The content itself may be a mix of text  images  and formatting commands  in the manner of a traditional document  or other forms of content such as video or programs that produce a graphical interface with which users can interact\n A picture of a page is shown on the top-left side of Fig\n  -  \n It is the page for the Computer Science & Engineering department at the University of Washington\n This page shows text and graphical elements (that are mostly too small to read)\n Some parts of the page are associated with links to other pages\n A piece of text  icon  image  and so on associated with another page is called a hyperlink\n To follow a link  the user places the mouse cursor on the linked portion of the page area (which causes the cursor to change shape) and clicks\n Following a link is simply a way of telling the browser to fetch another page\n In the early days of the Web  links were highlighted with underlining and colored text so that they would stand out\n Nowadays  the creators of Web pages have ways to control the look of linked regions  so a link might appear as an icon or change its appearance when the mouse passes over it\n It is up to the creators of the page to make the links visually distinct  to provide a usable interface\n HTTP Request Database Web page Hyperlink Web browser Document  \n  Program HTTP Response Web server   google-  Figure  -  \n Architecture of the Web\n   THE WORLD WIDE WEB Students in the department can learn more by following a link to a page with information especially for them\n This link is accessed by clicking in the circled area\n The browser then fetches the new page and displays it  as partially shown in the bottom left of Fig\n  -  \n Dozens of other pages are linked off the first page besides this example\n Every other page can be comprised of content on the same machine(s) as the first page  or on machines halfway around the globe\n The user cannot tell\n Page fetching is done by the browser  without any help from the user\n Thus  moving between machines while viewing content is seamless\n The basic model behind the display of pages is also shown in Fig\n  -  \n The browser is displaying a Web page on the client machine\n Each page is fetched by sending a request to one or more servers  which respond with the contents of the page\n The request-response protocol for fetching pages is a simple text-based protocol that runs over TCP  just as was the case for SMTP\n It is called HTTP (HyperText Transfer Protocol)\n The content may simply be a document that is read off a disk  or the result of a database query and program execution\n The page is a static page if it is a document that is the same every time it is displayed\n In contrast  if it was generated on demand by a program or contains a program it is a dynamic page\n A dynamic page may present itself differently each time it is displayed\n For example  the front page for an electronic store may be different for each visitor\n If a bookstore customer has bought mystery novels in the past  upon visiting the store’s main page  the customer is likely to see new thrillers prominently displayed  whereas a more culinary-minded customer might be greeted with new cookbooks\n How the Web site keeps track of who likes what is a story to be told shortly\n But briefly  the answer involves cookies (even for culinarily challenged visitors)\n In the figure  the browser contacts three servers to fetch the two pages        and google- \n The content from these different servers is integrated for display by the browser\n Display entails a range of processing that depends on the kind of content\n Besides rendering text and graphics  it may involve playing a video or running a script that presents its own user interface as part of the page\n In this case  the   server supplies the main page  the   server supplies an embedded video  and the google-  server supplies nothing that the user can see but tracks visitors to the site\n We will have more to say about trackers later\n The Client Side Let us now examine the Web browser side in Fig\n  -  in more detail\n In essence  a browser is a program that can display a Web page and catch mouse clicks to items on the displayed page\n When an item is selected  the browser follows the hyperlink and fetches the page selected\n THE APPLICATION LAYER  \n  When the Web was first created  it was immediately apparent that having one page point to another Web page required mechanisms for naming and locating pages\n In particular  three questions had to be answered before a selected page could be displayed:  \n What is the page called?  \n Where is the page located?  \n How can the page be accessed? If every page were somehow assigned a unique name  there would not be any ambiguity in identifying pages\n Nevertheless  the problem would not be solved\n Consider a parallel between people and pages\n In the United States  almost everyone has a social urity number  which is a unique identifier  as no two people are supposed to have the same one\n Nevertheless  if you are armed only with a social urity number  there is no way to find the owner’s address  and certainly no way to tell whether you should write to the person in English  Spanish  or Chinese\n The Web has basically the same problems\n The solution chosen identifies pages in a way that solves all three problems at once\n Each page is assigned a URL (Uniform Resource Locator) that effectively serves as the page’s worldwide name\n URLs have three parts: the protocol (also known as the scheme)  the DNS name of the machine on which the page is located  and the path uniquely indicating the specific page (a file to read or program to run on the machine)\n In the general case  the path has a hierarchical name that models a file directory structure\n However  the interpretation of the path is up to the server; it may or may not reflect the actual directory structure\n As an example  the URL of the page shown in Fig\n  -  is http:// \n /  This URL consists of three parts: the protocol (http)  the DNS name of the host ( \n )  and the path name ( )\n When a user clicks on a hyperlink  the browser carries out a series of steps in order to fetch the page pointed to\n Let us trace the steps that occur when our example link is selected:  \n The browser determines the URL (by seeing what was selected) The browser asks DNS for the IP address of the server  \n  DNS replies with   \n     The browser makes a TCP connection to   \n    on port the well-known port for the HTTP protocol It sends over an HTTP request asking for the page / \n   THE WORLD WIDE WEB  \n The  \n  server sends the page as an HTTP response  for example  by sending the file /  If the page includes URLs that are needed for display  the browser fetches the other URLs using the same process\n In this case  the URLs include multiple embedded images also fetched from  \n   an embedded video from    and a script from google-  The browser displays the page /  as it appears in Fig\n  -   The TCP connections are released if there are no other requests to the same servers for a short period\n Many browsers display which step they are currently executing in a status line at the bottom of the screen\n In this way  when the performance is poor  the user can see if it is due to DNS not responding  a server not responding  or simply page transmission over a slow or congested network\n The URL design is open-ended in the sense that it is straightforward to have browsers use multiple protocols to get at different kinds of resources\n In fact  URLs for various other protocols have been defined\n Slightly simplified forms of the common ones are listed in Fig\n  -  \n Name Used for Example http Hypertext (HTML) http:// \n /~rob/ https Hypertext with urity https:// /accounts/ ftp FTP ftp:// \n /pub/minix/README file Local file file:///usr/suzanne/  mailto Sending email mailto:JohnUser@  rtsp Streaming media rtsp:// /  sip Multimedia calls sip:eve@  about Browser information about:plugins Figure  -  \n Some common URL schemes\n Let us briefly go over the list\n The http protocol is the Web’s native language  the one spoken by Web servers\n HTTP stands for HyperText Transfer Protocol\n We will examine it in more detail later in this tion\n The ftp protocol is used to access files by FTP  the Internet’s file transfer protocol\n FTP predates the Web and has been in use for more than three decades\n The Web makes it easy to obtain files placed on numerous FTP servers throughout the world by providing a simple  clickable interface instead of a command- line interface\n This improved access to information is one reason for the spectacular growth of the Web\n THE APPLICATION LAYER  \n  It is possible to access a local file as a Web page by using the file protocol  or more simply  by just naming it\n This approach does not require having a server\n Of course  it works only for local files  not remote ones\n The mailto protocol does not really have the flavor of fetching Web pages  but is useful anyway\n It allows users to send email from a Web browser\n Most browsers will respond when a mailto link is followed by starting the user’s mail agent to compose a message with the address field already filled in\n The rtsp and sip protocols are for establishing streaming media sessions and audio and video calls\n Finally  the about protocol is a convention that provides information about the browser\n For example  following the about:plugins link will cause most browsers to show a page that lists the MIME types that they handle with browser extensions called plug-ins\n In short  the URLs have been designed not only to allow users to navigate the Web  but to run older protocols such as FTP and email as well as newer protocols for audio and video  and to provide convenient access to local files and browser information\n This approach makes all the specialized user interface programs for those other services unnecessary and integrates nearly all Internet access into a single program: the Web browser\n If it were not for the fact that this idea was thought of by a British physicist working a research lab in Switzerland  it could easily pass for a plan dreamed up by some software company’s advertising department\n Despite all these nice properties  the growing use of the Web has turned up an inherent weakness in the URL scheme\n A URL points to one specific host  but sometimes it is useful to reference a page without simultaneously telling where it is\n For example  for pages that are heavily referenced  it is desirable to have multiple copies far apart  to reduce the network traffic\n There is no way to say: ‘‘I want page xyz  but I do not care where you get it\n’’ To solve this kind of problem  URLs have been generalized into URIs (Uniform Resource Identifiers)\n Some URIs tell how to locate a resource\n These are the URLs\n Other URIs tell the name of a resource but not where to find it\n These URIs are called URNs (Uniform Resource Names)\n The rules for writing URIs are given in RFC  while the different URI schemes in use are tracked by IANA\n There are many different kinds of URIs besides the schemes listed in Fig\n  -   but those schemes dominate the Web as it is used today\n MIME Types To be able to display the new page (or any page)  the browser has to understand its format\n To allow all browsers to understand all Web pages  Web pages are written in a standardized language called HTML\n It is the lingua franca of the Web (for now)\n We will discuss it in detail later in this  ter\n   THE WORLD WIDE WEB Although a browser is basically an HTML interpreter  most browsers have numerous buttons and features to make it easier to navigate the Web\n Most have a button for going back to the previous page  a button for going forward to the next page (only operative after the user has gone back from it)  and a button for going straight to the user’s preferred start page\n Most browsers have a button or menu item to set a bookmark on a given page and another one to display the list of bookmarks  making it possible to revisit any of them with only a few mouse clicks\n As our example shows  HTML pages can contain rich content elements and not simply text and hypertext\n For added generality  not all pages need contain HTML\n A page may consist of a video in MPEG format  a document in PDF format  a photograph in JPEG format  a song in MP  format  or any one of hundreds of other file types\n Since standard HTML pages may link to any of these  the browser has a problem when it hits a page it does not know how to interpret\n Rather than making the browsers larger and larger by building in interpreters for a rapidly growing collection of file types  most browsers have chosen a more general solution\n When a server returns a page  it also returns some additional information about the page\n This information includes the MIME type of the page (see Fig\n  -  )\n Pages of type text/html are just displayed directly  as are pages in a few other built-in types\n If the MIME type is not one of the built-in ones  the browser consults its table of MIME types to determine how to display the page\n This table associates MIME types with viewers\n There are two possibilities: plug-ins and helper applications\n A plug-in is a third-party code module that is installed as an extension to the browser  as illustrated in Fig\n  -  (a)\n Common examples are plug-ins for PDF  Flash  and Quicktime to render documents and play audio and video\n Because plug-ins run inside the browser  they have access to the current page and can modify its appearance\n Process Helper Browser Plug-in Browser application Process Process (a) (b) Figure  -  \n (a) A browser plug-in\n (b) A helper application\n Each browser has a set of procedures that all plug-ins must implement so the browser can call the plug-ins\n For example  there is typically a procedure the THE APPLICATION LAYER  \n  browser’s base code calls to supply the plug-in with data to display\n This set of procedures is the plug-in’s interface and is browser specific\n In addition  the browser makes a set of its own procedures available to the plug-in  to provide services to plug-ins\n Typical procedures in the browser interface are for allocating and freeing memory  displaying a message on the browser’s status line  and querying the browser about parameters\n Before a plug-in can be used  it must be installed\n The usual installation procedure is for the user to go to the plug-in’s Web site and download an installation file\n Executing the installation file unpacks the plug-in and makes the appropriate calls to register the plug-in’s MIME type with the browser and associate the plug-in with it\n Browsers usually come preloaded with popular plug-ins\n The other way to extend a browser is make use of a helper application\n This is a complete program  running as a separate process\n It is illustrated in Fig\n  -  (b)\n Since the helper is a separate program  the interface is at arm’s length from the browser\n It usually just accepts the name of a scratch file where the content file has been stored  opens the file  and displays the contents\n Typically  helpers are large programs that exist independently of the browser  for example  Microsoft Word or PowerPoint\n Many helper applications use the MIME type application\n As a consequence  a considerable number of subtypes have been defined for them to use  for example  application/ -powerpoint for PowerPoint files\n vnd denotes vendor-specific formats\n In this way  a URL can point directly to a PowerPoint file  and when the user clicks on it  PowerPoint is automatically started and handed the content to be displayed\n Helper applications are not restricted to using the application MIME type\n Adobe Photoshop uses image/x-photoshop  for example\n Consequently  browsers can be configured to handle a virtually unlimited number of document types with no changes to themselves\n Modern Web servers are often configured with hundreds of type/subtype combinations and new ones are often added every time a new program is installed\n A source of conflicts is that multiple plug-ins and helper applications are available for some subtypes  such as video/mpeg\n What happens is that the last one to register overwrites the existing association with the MIME type  capturing the type for itself\n As a consequence  installing a new program may change the way a browser handles existing types\n Browsers can also open local files  with no network in sight  rather than fetching them from remote Web servers\n However  the browser needs some way to determine the MIME type of the file\n The standard method is for the operating system to associate a file extension with a MIME type\n In a typical configuration  opening   will open it in the browser using an application/pdf plug-in and opening   will open it in Word as the application/msword helper\n Here  too  conflicts can arise  since many programs are willing—no  make that eager—to handle  say  mpg\n During installation  programs intended for sophisticated users often display checkboxes for the MIME types and extensions   THE WORLD WIDE WEB they are prepared to handle to allow the user to select the appropriate ones and thus not overwrite existing associations by accident\n Programs aimed at the consumer market assume that the user does not have a clue what a MIME type is and simply grab everything they can without regard to what previously installed programs have done\n The ability to extend the browser with a large number of new types is convenient but can also lead to trouble\n When a browser on a Windows PC fetches a file with the extension exe  it realizes that this file is an executable program and therefore has no helper\n The obvious action is to run the program\n However  this could be an enormous urity hole\n All a malicious Web site has to do is produce a Web page with pictures of  say  movie stars or sports heroes  all of which are linked to a virus\n A single click on a picture then causes an unknown and potentially hostile executable program to be fetched and run on the user’s machine\n To prevent unwanted guests like this  Firefox and other browsers come configured to be cautious about running unknown programs automatically  but not all users understand what choices are safe rather than convenient\n The Server Side So much for the client side\n Now let us take a look at the server side\n As we saw above  when the user types in a URL or clicks on a line of hypertext  the browser parses the URL and interprets the part between http:// and the next slash as a DNS name to look up\n Armed with the IP address of the server  the browser establishes a TCP connection to port   on that server\n Then it sends over a command containing the rest of the URL  which is the path to the page on that server\n The server then returns the page for the browser to display\n To a first approximation  a simple Web server is similar to the server of Fig\n  - \n That server is given the name of a file to look up and return via the network\n In both cases  the steps that the server performs in its main loop are:  \n Accept a TCP connection from a client (a browser) Get the path to the page  which is the name of the file requested Get the file (from disk) Send the contents of the file to the client Release the TCP connection\n Modern Web servers have more features  but in essence  this is what a Web server does for the simple case of content that is contained in a file\n For dynamic content  the third step may be replaced by the execution of a program (determined from the path) that returns the contents\n However  Web servers are implemented with a different design to serve many requests per ond\n One problem with the simple design is that accessing files is THE APPLICATION LAYER  \n  often the bottleneck\n Disk reads are very slow compared to program execution  and the same files may be read repeatedly from disk using operating system calls\n Another problem is that only one request is processed at a time\n The file may be large  and other requests will be blocked while it is transferred\n One obvious improvement (used by all Web servers) is to maintain a cache in memory of the n most recently read files or a certain number of gigabytes of content\n Before going to disk to get a file  the server checks the cache\n If the file is there  it can be served directly from memory  thus eliminating the disk access\n Although effective caching requires a large amount of main memory and some extra processing time to check the cache and manage its contents  the savings in time are nearly always worth the overhead and expense\n To tackle the problem of serving a single request at a time  one strategy is to make the server multithreaded\n In one design  the server consists of a front-end module that accepts all incoming requests and k processing modules  as shown in Fig\n  -  \n The k +  threads all belong to the same process  so the processing modules all have access to the cache within the process’ address space\n When a request comes in  the front end accepts it and builds a short record describing it\n It then hands the record to one of the processing modules\n Processing module (thread) Front end Cache Disk Request Client Response Server Figure  -  \n A multithreaded Web server with a front end and processing modules\n The processing module first checks the cache to see if the file needed is there\n If so  it updates the record to include a pointer to the file in the record\n If it is not there  the processing module starts a disk operation to read it into the cache (possibly discarding some other cached file(s) to make room for it)\n When the file comes in from the disk  it is put in the cache and also sent back to the client\n The advantage of this scheme is that while one or more processing modules are blocked waiting for a disk or network operation to complete (and thus consuming no CPU time)  other modules can be actively working on other requests\n With k processing modules  the throughput can be as much as k times higher than with a single-threaded server\n Of course  when the disk or network is the limiting   THE WORLD WIDE WEB factor  it is necessary to have multiple disks or a faster network to get any real improvement over the single-threaded model\n Modern Web servers do more than just accept path names and return files\n In fact  the actual processing of each request can get quite complicated\n For this reason  in many servers each processing module performs a series of steps\n The front end passes each incoming request to the first available module  which then carries it out using some subset of the following steps  depending on which ones are needed for that particular request\n These steps occur after the TCP connection and any ure transport mechanism (such as SSL/TLS  which will be described in  \n  ) have been established Resolve the name of the Web page requested Perform access control on the Web page Check the cache Fetch the requested page from disk or run a program to build it Determine the rest of the response ( \n  the MIME type to send) Return the response to the client Make an entry in the server log\n Step  is needed because the incoming request may not contain the actual name of a file or program as a literal string\n It may contain built-in shortcuts that need to be translated\n As a simple example  the URL http:// \n / has an empty file name\n It has to be expanded to some default file name that is usually  \n Another common rule is to map ~user/ onto user’s Web directory\n These rules can be used together\n Thus  the home page of one of the authors (AST) can be reached at http:// \n /~ast/ even though the actual file name is   in a certain default directory\n Also  modern browsers can specify configuration information such as the browser software and the user’s default language ( \n  Italian or English)\n This makes it possible for the server to select a Web page with small pictures for a mobile device and in the preferred language  if available\n In general  name expansion is not quite so trivial as it might at first appear  due to a variety of conventions about how to map paths to the file directory and programs\n Step  checks to see if any access restrictions associated with the page are met\n Not all pages are available to the general public\n Determining whether a client can fetch a page may depend on the identity of the client ( \n  as given by usernames and passwords) or the location of the client in the DNS or IP space\n For example  a page may be restricted to users inside a company\n How this is THE APPLICATION LAYER  \n  accomplished depends on the design of the server\n For the popular Apache server  for instance  the convention is to place a file called  that lists the access restrictions in the directory where the restricted page is located\n Steps  and  involve getting the page\n Whether it can be taken from the cache depends on processing rules\n For example  pages that are created by running programs cannot always be cached because they might produce a different result each time they are run\n Even files should occasionally be checked to see if their contents have changed so that the old contents can be removed from the cache\n If the page requires a program to be run  there is also the issue of setting the program parameters or input\n These data come from the path or other parts of the request\n Step  is about determining other parts of the response that accompany the contents of the page\n The MIME type is one example\n It may come from the file extension  the first few words of the file or program output  a configuration file  and possibly other sources\n Step  is returning the page across the network\n To increase performance  a single TCP connection may be used by a client and server for multiple page fetches\n This reuse means that some logic is needed to map a request to a shared connection and to return each response so that it is associated with the correct request\n Step  makes an entry in the system log for administrative purposes  along with keeping any other important statistics\n Such logs can later be mined for valuable information about user behavior  for example  the order in which people access the pages\n Cookies Navigating the Web as we have described it so far involves a series of independent page fetches\n There is no concept of a login session\n The browser sends a request to a server and gets back a file\n Then the server forgets that it has ever seen that particular client\n This model is perfectly adequate for retrieving publicly available documents  and it worked well when the Web was first created\n However  it is not suited for returning different pages to different users depending on what they have already done with the server\n This behavior is needed for many ongoing interactions with Web sites\n For example  some Web sites ( \n  newspapers) require clients to register (and possibly pay money) to use them\n This raises the question of how servers can distinguish between requests from users who have previously registered and everyone else\n A ond example is from e-commerce\n If a user wanders around an electronic store  tossing items into her virtual shopping cart from time to time  how does the server keep track of the contents of the cart? A third example is customized Web portals such as Yahoo!\n Users can set up a personalized   THE WORLD WIDE WEB detailed initial page with only the information they want ( \n  their stocks and their favorite sports teams)  but how can the server display the correct page if it does not know who the user is? At first glance  one might think that servers could track users by observing their IP addresses\n However  this idea does not work\n Many users share computers  especially at home  and the IP address merely identifies the computer  not the user\n Even worse  many companies use NAT  so that outgoing packets bear the same IP address for all users\n That is  all of the computers behind the NAT box look the same to the server\n And many ISPs assign IP addresses to customers with DHCP\n The IP addresses change over time  so to a server you might suddenly look like your neighbor\n For all of these reasons  the server cannot use IP addresses to track users\n This problem is solved with an oft-critized mechanism called cookies\n The name derives from ancient programmer slang in which a program calls a procedure and gets something back that it may need to present later to get some work done\n In this sense  a UNIX file descriptor or a Windows object handle can be considered to be a cookie\n Cookies were first implemented in the Netscape browser in  and are now specified in RFC \n When a client requests a Web page  the server can supply additional information in the form of a cookie along with the requested page\n The cookie is a rather small  named string (of at most  KB) that the server can associate with a browser\n This association is not the same thing as a user  but it is much closer and more useful than an IP address\n Browsers store the offered cookies for an interval  usually in a cookie directory on the client’s disk so that the cookies persist across browser invocations  unless the user has disabled cookies\n Cookies are just strings  not executable programs\n In principle  a cookie could contain a virus  but since cookies are treated as data  there is no official way for the virus to actually run and do damage\n However  it is always possible for some hacker to exploit a browser bug to cause activation\n A cookie may contain up to five fields  as shown in Fig\n  -  \n The Domain tells where the cookie came from\n Browsers are supposed to check that servers are not lying about their domain\n Each domain should store no more than   cookies per client\n The Path is a path in the server’s directory structure that identifies which parts of the server’s file tree may use the cookie\n It is often /  which means the whole tree\n The Content field takes the form name = value\n Both name and value can be anything the server wants\n This field is where the cookie’s content is stored\n The Expires field specifies when the cookie expires\n If this field is absent  the browser discards the cookie when it exits\n Such a cookie is called a nonpersistent cookie\n If a time and date are supplied  the cookie is said to be a persistent cookie and is kept until it expires\n Expiration times are given in Greenwich Mean Time\n To remove a cookie from a client’s hard disk  a server just sends it again  but with an expiration time in the past\n THE APPLICATION LAYER  \n  Domain Path Content Expires ure toms-  / CustomerID=   -  - :  Yes jills-  / Cart= - ; - ; -   - - :  No   / Prefs=Stk:CSCO+ORCL;Spt:Jets  -  - :  No   / UserID=    -  - :  No Figure  -  \n Some examples of cookies\n Finally  the ure field can be set to indicate that the browser may only return the cookie to a server using a ure transport  namely SSL/TLS (which we will describe in  \n  )\n This feature is used for e-commerce  banking  and other ure applications\n We have now seen how cookies are acquired  but how are they used? Just before a browser sends a request for a page to some Web site  it checks its cookie directory to see if any cookies there were placed by the domain the request is going to\n If so  all the cookies placed by that domain  and only that domain  are included in the request message\n When the server gets them  it can interpret them any way it wants to\n Let us examine some possible uses for cookies\n In Fig\n  -   the first cookie was set by toms-  and is used to identify the customer\n When the client returns next week to throw away some more money  the browser sends over the cookie so the server knows who it is\n Armed with the customer ID  the server can look up the customer’s record in a database and use this information to build an appropriate Web page to display\n Depending on the customer’s known gambling habits  this page might consist of a poker hand  a listing of today’s horse races  or a slot machine\n The ond cookie came from jills- \n The scenario here is that the client is wandering around the store  looking for good things to buy\n When she finds a bargain and clicks on it  the server adds it to her shopping cart (maintained on the server) and also builds a cookie containing the product code of the item and sends the cookie back to the client\n As the client continues to wander around the store by clicking on new pages  the cookie is returned to the server on every new page request\n As more purchases accumulate  the server adds them to the cookie\n Finally  when the client clicks on PROCEED TO CHECKOUT  the cookie  now containing the full list of purchases  is sent along with the request\n In this way  the server knows exactly what the customer wants to buy\n The third cookie is for a Web portal\n When the customer clicks on a link to the portal  the browser sends over the cookie\n This tells the portal to build a page containing the stock prices for Cisco and Oracle  and the New York Jets’ football results\n Since a cookie can be up to  KB  there is plenty of room for more detailed preferences concerning newspaper headlines  local weather  special offers  etc\n   THE WORLD WIDE WEB A more controversial use of cookies is to track the online behavior of users\n This lets Web site operators understand how users navigate their sites  and advertisers build up profiles of the ads or sites a particular user has viewed\n The controversy is that users are typically unaware that their activity is being tracked  even with detailed profiles and across seemingly unrelated Web sites\n Nonetheless  Web tracking is big business\n DoubleClick  which provides and tracks ads  is ranked among the busiest Web sites in the world by the Web monitoring company Alexa\n Google Analytics  which tracks site usage for operators  is used by more than half of the busiest    sites on the Web\n It is easy for a server to track user activity with cookies\n Suppose a server wants to keep track of how many unique visitors it has had and how many pages each visitor looked at before leaving the site\n When the first request comes in  there will be no accompanying cookie  so the server sends back a cookie containing Counter =  \n Subsequent page views on that site will send the cookie back to the server\n Each time the counter is incremented and sent back to the client\n By keeping track of the counters  the server can see how many people give up after seeing the first page  how many look at two pages  and so on\n Tracking the browsing behavior of users across sites is only slightly more complicated\n It works like this\n An advertising agency  say  Sneaky Ads  contacts major Web sites and places ads for its clients’ products on their pages  for which it pays the site owners a fee\n Instead  of giving the sites the ad as a GIF file to place on each page  it gives them a URL to add to each page\n Each URL it hands out contains a unique number in the path  such as http:// /    When a user first visits a page  P  containing such an ad  the browser fetches the HTML file\n Then the browser inspects the HTML file and sees the link to the image file at    so it sends a request there for the image\n A GIF file containing an ad is returned  along with a cookie containing a unique user ID    in Fig\n  -  \n Sneaky records the fact that the user with this ID visited page P\n This is easy to do since the path requested (   ) is referenced only on page P\n Of course  the actual ad may appear on thousands of pages  but each time with a different name\n Sneaky probably collects a fraction of a penny from the product manufacturer each time it ships out the ad\n Later  when the user visits another Web page containing any of Sneaky’s ads  the browser first fetches the HTML file from the server\n Then it sees the link to  say  http:// /    on the page and requests that file\n Since it already has a cookie from the domain    the browser includes Sneaky’s cookie containing the user’s ID\n Sneaky now knows a ond page the user has visited\n In due course  Sneaky can build up a detailed profile of the user’s browsing habits  even though the user has never clicked on any of the ads\n Of course  it does not yet have the user’s name (although it does have his IP address  which THE APPLICATION LAYER  \n  may be enough to deduce the name from other databases)\n However  if the user ever supplies his name to any site cooperating with Sneaky  a complete profile along with a name will be available for sale to anyone who wants to buy it\n The sale of this information may be profitable enough for Sneaky to place more ads on more Web sites and thus collect more information\n And if Sneaky wants to be supersneaky  the ad need not be a classical banner ad\n An ‘‘ad’’ consisting of a single pixel in the background color (and thus invisible) has exactly the same effect as a banner ad: it requires the browser to go fetch the  ×  -pixel GIF image and send it all cookies originating at the pixel’s domain\n Cookies have become a focal point for the debate over online privacy because of tracking behavior like the above\n The most insidious part of the whole business is that many users are completely unaware of this information collection and may even think they are safe because they do not click on any of the ads\n For this reason  cookies that track users across sites are considered by many to be spyware\n Have a look at the cookies that are already stored by your browser\n Most browsers will display this information along with the current privacy preferences\n You might be surprised to find names  email addresses  or passwords as well as opaque identifiers\n Hopefully  you will not find credit card numbers  but the potential for abuse is clear\n To maintain a semblance of privacy  some users configure their browsers to reject all cookies\n However  this can cause problems because many Web sites will not work properly without cookies\n Alternatively  most browsers let users block third-party cookies\n A third-party cookie is one from a different site than the main page that is being fetched  for example  the   cookie that is used when interacting with page P on a completely different Web site\n Blocking these cookies helps to prevent tracking across Web sites\n Browser extensions can also be installed to provide fine-grained control over how cookies are used (or  rather  not used)\n As the debate continues  many companies are developing privacy policies that limit how they will share information to prevent abuse\n Of course  the policies are simply how the companies say they will handle information\n For example: ‘‘We may use the information collected from you in the conduct of our business’’—which might be selling the information\n    Static Web Pages The basis of the Web is transferring Web pages from server to client\n In the simplest form  Web pages are static\n That is  they are just files sitting on some server that present themselves in the same way each time they are fetched and viewed\n Just because they are static does not mean that the pages are inert at the browser  however\n A page containing a video can be a static Web page\n As mentioned earlier  the lingua franca of the Web  in which most pages are written  is HTML\n The home pages of teachers are usually static HTML pages\n   THE WORLD WIDE WEB The home pages of companies are usually dynamic pages put together by a Web design company\n In this tion  we will take a brief look at static HTML pages as a foundation for later material\n Readers already familiar with HTML can skip ahead to the next tion  where we describe dynamic content and Web services\n HTML—The HyperText Markup Language HTML (HyperText Markup Language) was introduced with the Web\n It allows users to produce Web pages that include text  graphics  video  pointers to other Web pages  and more\n HTML is a markup language  or language for describing how documents are to be formatted\n The term ‘‘markup’’ comes from the old days when copyeditors actually marked up documents to tell the printer— in those days  a human being—which fonts to use  and so on\n Markup languages thus contain explicit commands for formatting\n For example  in HTML  <b> means start boldface mode  and </b> means leave boldface mode\n LaTeX and TeX are other examples of markup languages that are well known to most academic authors\n The key advantage of a markup language over one with no explicit markup is that it separates content from how it should be presented\n Writing a browser is then straightforward: the browser simply has to understand the markup commands and apply them to the content\n Embedding all the markup commands within each HTML file and standardizing them makes it possible for any Web browser to read and reformat any Web page\n That is crucial because a page may have been produced in a  ×  window with  -bit color on a high-end computer but may have to be displayed in a × window on a mobile phone\n While it is certainly possible to write documents like this with any plain text editor  and many people do  it is also possible to use word processors or special HTML editors that do most of the work (but correspondingly give the user less direct control over the details of the final result)\n A simple Web page written in HTML and its presentation in a browser are given in Fig\n  -  \n A Web page consists of a head and a body  each enclosed by <html> and </html> tags (formatting commands)  although most browsers do not complain if these tags are missing\n As can be seen in Fig\n  -  (a)  the head is bracketed by the <head> and </head> tags and the body is bracketed by the <body> and </body> tags\n The strings inside the tags are called directives\n Most  but not all  HTML tags have this format\n That is  they use <something> to mark the beginning of something and </something> to mark its end\n Tags can be in either lowercase or uppercase\n Thus  <head> and <HEAD> mean the same thing  but lower case is best for compatibility\n Actual layout of the HTML document is irrelevant\n HTML parsers ignore extra spaces and carriage returns since they have to reformat the text to make it fit the current display area\n Consequently  white space can be added at will to make HTML documents more THE APPLICATION LAYER  \n  readable  something most of them are badly in need of\n As another consequence  blank lines cannot be used to separate paragraphs  as they are simply ignored\n An explicit tag is required\n Some tags have (named) parameters  called attributes\n For example  the <img> tag in Fig\n  -  is used for including an image inline with the text\n It has two attributes  src and alt\n The first attribute gives the URL for the image\n The HTML standard does not specify which image formats are permitted\n In practice  all browsers support GIF and JPEG files\n Browsers are free to support other formats  but this extension is a two-edged sword\n If a user is accustomed to a browser that supports  say  TIFF files  he may include these in his Web pages and later be surprised when other browsers just ignore all of his wonderful art\n The ond attribute gives alternate text to use if the image cannot be displayed\n For each tag  the HTML standard gives a list of what the permitted parameters  if any  are  and what they mean\n Because each parameter is named  the order in which the parameters are given is not significant\n Technically  HTML documents are written in the ISO -  Latin-  character set  but for users whose keyboards support only ASCII  escape sequences are present for the special characters  such as e`\n The list of special characters is given in the standard\n All of them begin with an ampersand and end with a semicolon\n For example  &nbsp; produces a space  &egrave; produces e` and &eacute; produces e´\n Since <  >  and & have special meanings  they can be expressed only with their escape sequences  &lt;  &gt;  and &amp;  respectively\n The main item in the head is the title  delimited by <title> and </title>\n Certain kinds of metainformation may also be present  though none are present in our example\n The title itself is not displayed on the page\n Some browsers use it to label the page’s window\n Several headings are used in Fig\n  -  \n Each heading is generated by an <hn> tag  where n is a digit in the range  to  \n Thus  <h > is the most important heading; <h > is the least important one\n It is up to the browser to render these appropriately on the screen\n Typically  the lower-numbered headings will be displayed in a larger and heavier font\n The browser may also choose to use different colors for each level of heading\n Usually  <h > headings are large and boldface with at least one blank line above and below\n In contrast  <h > headings are in a smaller font with less space above and below\n The tags <b> and <i> are used to enter boldface and italics mode  respectively\n The <hr> tag forces a break and draws a horizontal line across the display\n The <p> tag starts a paragraph\n The browser might display this by inserting a blank line and some indentation  for example\n Interestingly  the </p> tag that exists to mark the end of a paragraph is often omitted by lazy HTML programmers\n HTML provides various mechanisms for making lists  including nested lists\n Unordered lists  like the ones in Fig\n  -  are started with <ul>  with <li> used to mark the start of items\n There is also an <ol> tag to starts an ordered list\n The   THE WORLD WIDE WEB <html> <head> <title> AMALGAMATED WIDGET  INC\n </title> </head> <body> <h > Welcome to AWI’s Home Page </h > <img src="http:// /images/ " ALT="AWI Logo"> <br> We are so happy that you have chosen to visit <b> Amalgamated Widget’s</b> home page\n We hope <i> you </i> will find all the information you need here\n <p>Below we have links to information about our many fine products\n You can order electronically (by WWW)  by telephone  or by email\n </p> <hr> <h > Product information </h > <ul> <li> <a href="http:// /products/big"> Big widgets </a> </li> <li> <a href="http:// /products/little"> Little widgets </a> </li> </ul> <h > Contact information </h > <ul> <li> By telephone:  -  -WIDGETS </li> <li> By email: info@amalgamated-  </li> </ul> </body> </html> (a) Welcome to AWI's Home Page We are so happy that you have chosen to visit Amalgamated Widget's home page\n We hope you will find all the information you need here\n Below we have links to information about our many fine products\n You can order electronically (by WWW)  by telephone  or by email\n Product Information \n Big widgets \n Little widgets Contact information \n By telephone:  -  -WIDGETS \n By email: info@amalgamated-  (b) Figure  -  \n (a) The HTML for a sample Web page\n (b) The formatted page\n THE APPLICATION LAYER  \n  individual items in unordered lists often appear with bullets ( ) in front of them\n Items in ordered lists are numbered by the browser\n Finally  we come to hyperlinks\n Examples of these are seen in Fig\n  -  using the <a> (anchor) and </a> tags\n The <a> tag has various parameters  the most important of which is href the linked URL\n The text between the <a> and </a> is displayed\n If it is selected  the hyperlink is followed to a new page\n It is also permitted to link other elements\n For example  an image can be given between the <a> and </a> tags using <img>\n In this case  the image is displayed and clicking on it activates the hyperlink\n There are many other HTML tags and attributes that we have not seen in this simple example\n For instance  the <a> tag can take a parameter name to plant a hyperlink  allowing a hyperlink to point to the middle of a page\n This is useful  for example  for Web pages that start out with a clickable table of contents\n By clicking on an item in the table of contents  the user jumps to the corresponding tion of the same page\n An example of a different tag is <br>\n It forces the browser to break and start a new line\n Probably the best way to understand tags is to look at them in action\n To do this  you can pick a Web page and look at the HTML in your browser to see how the page was put together\n Most browsers have a VIEW SOURCE menu item (or something similar)\n Selecting this item displays the current page’s HTML source  instead of its formatted output\n We have sketched the tags that have existed from the early Web\n HTML keeps evolving\n Fig\n  -  shows some of the features that have been added with successive versions of HTML\n HTML  \n  refers to the version of HTML used with the introduction of the Web\n HTML versions  \n   \n  and  \n  appeared in rapid succession in the space of only a few years as the Web exploded\n After HTML  \n  a period of almost ten years passed before the path to standarization of the next major version  HTML  \n  became clear\n Because it is a major upgrade that consolidates the ways that browsers handle rich content  the HTML  \n  effort is ongoing and not expected to produce a standard before  at the earliest\n Standards notwithstanding  the major browsers already support HTML  \n  functionality\n The progression through HTML versions is all about adding new features that people wanted but had to handle in nonstandard ways ( \n  plug-ins) until they became standard\n For example  HTML  \n  and HTML  \n  did not have tables\n They were added in HTML   An HTML table consists of one or more rows  each consisting of one or more table cells that can contain a wide range of material ( \n  text  images  other tables)\n Before HTML  \n  authors needing a table had to resort to ad hoc methods  such as including an image showing the table\n In HTML  \n  more new features were added\n These included accessibility features for handicapped users  object embedding (a generalization of the <img> tag so other objects can also be embedded in pages)  support for scripting languages (to allow dynamic content)  and more\n   THE WORLD WIDE WEB Item HTML  \n  HTML  \n  HTML  \n  HTML  \n  HTML  \n  Hyperlinks x x x x x Images x x x x x Lists x x x x x Active maps & images x x x x Forms x x x x Equations x x x Toolbars x x x Tables x x x Accessibility features x x Object embedding x x Style sheets x x Scripting x x Video and audio x Inline vector graphics x XML representation x Background threads x Browser storage x Drawing canvas x Figure  -  \n Some differences between HTML versions\n HTML  \n  includes many features to handle the rich media that are now routinely used on the Web\n Video and audio can be included in pages and played by the browser without requiring the user to install plug-ins\n Drawings can be built up in the browser as vector graphics  rather than using bitmap image formats (like JPEG and GIF) There is also more support for running scripts in browsers  such as background threads of computation and access to storage\n All of these features help to support Web pages that are more like traditional applications with a user interface than documents\n This is the direction the Web is heading\n Input and Forms There is one important capability that we have not discussed yet: input\n HTML  \n  was basically one-way\n Users could fetch pages from information providers  but it was difficult to send information back the other way\n It quickly became apparent that there was a need for two-way traffic to allow orders for products to be placed via Web pages  registration cards to be filled out online  search terms to be entered  and much  much more\n THE APPLICATION LAYER  \n  Sending input from the user to the server (via the browser) requires two kinds of support\n First  it requires that HTTP be able to carry data in that direction\n We describe how this is done in a later tion; it uses the POST method\n The ond requirement is to be able to present user interface elements that gather and package up the input\n Forms were included with this functionality in HTML   Forms contain boxes or buttons that allow users to fill in information or make choices and then send the information back to the page’s owner\n Forms are written just like other parts of HTML  as seen in the example of Fig\n  -  \n Note that forms are still static content\n They exhibit the same behavior regardless of who is using them\n Dynamic content  which we will cover later  provides more sophisticated ways to gather input by sending a program whose behavior may depend on the browser environment\n Like all forms  this one is enclosed between the <form> and </form> tags\n The attributes of this tag tell what to do with the data that are input  in this case using the POST method to send the data to the specified URL\n Text not enclosed in a tag is just displayed\n All the usual tags ( \n  <b>) are allowed in a form to let the author of the page control the look of the form on the screen\n Three kinds of input boxes are used in this form  each of which uses the <input> tag\n It has a variety of parameters for determining the size  nature  and usage of the box displayed\n The most common forms are blank fields for accepting user text  boxes that can be checked  and submit buttons that cause the data to be returned to the server\n The first kind of input box is a text box that follows the text ‘‘Name’’\n The box is   characters wide and expects the user to type in a string  which is then stored in the variable customer\n The next line of the form asks for the user’s street address characters wide\n Then comes a line asking for the city  state  and country\n Since no <p> tags are used between these fields  the browser displays them all on one line (instead of as separate paragraphs) if they will fit\n As far as the browser is concerned  the one paragraph contains just six items: three strings alternating with three boxes\n The next line asks for the credit card number and expiration date\n Transmitting credit card numbers over the Internet should only be done when adequate urity measures have been taken\n We will discuss some of these in   Following the expiration date  we encounter a new feature: radio buttons\n These are used when a choice must be made among two or more alternatives\n The intellectual model here is a car radio with half a dozen buttons for choosing stations\n Clicking on one button turns off all the other ones in the same group\n The visual presentation is up to the browser\n Widget size also uses two radio buttons\n The two groups are distinguished by their name parameter  not by static scoping using something like <radiobutton> \n\n </radiobutton>\n The value parameters are used to indicate which radio button was pushed\n For example  depending on which credit card options the user has chosen  the variable cc will be set to either the string ‘‘mastercard’’ or the string ‘‘visacard’’\n   THE WORLD WIDE WEB <html> <head> <title> AWI CUSTOMER ORDERING FORM </title> </head> <body> <h > Widget Order Form </h > <form ACTION="http:// /cgi-bin/ " method=POST> <p> Name <input name="customer" size=  > </p> <p> Street address <input name="address" size=  > </p> <p> City <input name="city" size=  > State <input name="state" size = > Country <input name="country" size=  > </p> <p> Credit card # <input name="cardno" size=  > Expires <input name="expires" size= > M/C <input name="cc" type=radio value="mastercard"> VISA <input name="cc" type=radio value="visacard"> </p> <p> Widget size Big <input name="product" type=radio value="expensive"> Little <input name="product" type=radio value="cheap"> Ship by express courier <input name="express" type=checkbox> </p> <p><input type=submit value="Submit order"> </p> Thank you for ordering an AWI widget  the best widget money can buy! </form> </body> </html> (a) Widget Order Form Name Street address City Credit card # Widget size Big Thank you for ordering an AWI widget  the best widget money can buy! Little Ship by express courier Expires M/C Visa State Country Submit order (b) Figure  -  \n (a) The HTML for an order form\n (b) The formatted page\n After the two sets of radio buttons  we come to the shipping option  represented by a box of type checkbox\n It can be either on or off\n Unlike radio buttons  where exactly one out of the set must be chosen  each box of type checkbox can be on or off  independently of all the others\n THE APPLICATION LAYER  \n  Finally  we come to the submit button\n The value string is the label on the button and is displayed\n When the user clicks the submit button  the browser packages the collected information into a single long line and sends it back to the server to the URL provided as part of the <form> tag\n A simple encoding is used\n The & is used to separate fields and + is used to represent space\n For our example form  the line might look like the contents of Fig\n  -  \n customer=John+Doe&address=  +Main+St\n&city=White+Plains& state=NY&country=USA&cardno=  &expires= /  &cc=mastercard& product=cheap&express=on Figure  -  \n A possible response from the browser to the server with information filled in by the user\n The string is sent back to the server as one line\n (It is broken into three lines here because the page is not wide enough\n) It is up to the server to make sense of this string  most likely by passing the information to a program that will process it\n We will discuss how this can be done in the next tion\n There are also other types of input that are not shown in this simple example\n Two other types are password and textarea\n A password box is the same as a text box (the default type that need not be named)  except that the characters are not displayed as they are typed\n A textarea box is also the same as a text box  except that it can contain multiple lines\n For long lists from which a choice must be made  the <select> and </select> tags are provided to bracket a list of alternatives\n This list is often rendered as a drop-down menu\n The semantics are those of radio buttons unless the multiple parameter is given  in which case the semantics are those of checkboxes\n Finally  there are ways to indicate default or initial values that the user can change\n For example  if a text box is given a value field  the contents are displayed in the form for the user to edit or erase\n CSS—Cascading Style Sheets The original goal of HTML was to specify the structure of the document  not its appearance\n For example  <h > Deborah’s Photos </h > instructs the browser to emphasize the heading  but does not say anything about the typeface  point size  or color\n That is left up to the browser  which knows the properties of the display ( \n  how many pixels it has)\n However  many Web page designers wanted absolute control over how their pages appeared  so new tags were added to HTML to control appearance  such as <font face="helvetica" size="  " color="red"> Deborah’s Photos </font>   THE WORLD WIDE WEB Also  ways were added to control positioning on the screen accurately\n The trouble with this approach is that it is tedious and produces bloated HTML that is not portable\n Although a page may render perfectly in the browser it is developed on  it may be a complete mess in another browser or another release of the same browser or at a different screen resolution\n A better alternative is the use of style sheets\n Style sheets in text editors allow authors to associate text with a logical style instead of a physical style  for example  ‘‘initial paragraph’’ instead of ‘‘italic text\n’’ The appearance of each style is defined separately\n In this way  if the author decides to change the initial paragraphs from  -point italics in blue to  -point boldface in shocking pink  all it requires is changing one definition to convert the entire document\n CSS (Cascading Style Sheets) introduced style sheets to the Web with HTML  \n  though widespread use and browser support did not take off until \n CSS defines a simple language for describing rules that control the appearance of tagged content\n Let us look at an example\n Suppose that AWI wants snazzy Web pages with navy text in the Arial font on an off-white background  and level headings that are an extra   % and  % larger than the text for each level  respectively\n The CSS definition in Fig\n  -  gives these rules\n body {background-color:linen; color:navy; font-family:Arial;} h  {font-size:  %;} h  {font-size:  %;} Figure  -  \n CSS example\n As can be seen  the style definitions can be compact\n Each line selects an element to which it applies and gives the values of properties\n The properties of an element apply as defaults to all other HTML elements that it contains\n Thus  the style for body sets the style for paragraphs of text in the body\n There are also convenient shorthands for color names ( \n  red)\n Any style parameters that are not defined are filled with defaults by the browser\n This behavior makes style sheet definitions optional; some reasonable presentation will occur without them\n Style sheets can be placed in an HTML file ( \n  using the <style> tag)  but it is more common to place them in a separate file and reference them\n For example  the <head> tag of the AWI page can be modified to refer to a style sheet in the file   as shown in Fig\n  -  \n The example also shows the MIME type of CSS files to be text/css\n <head> <title> AMALGAMATED WIDGET  INC\n </title> <link rel="stylesheet" type="text/css" href=" " /> </head> Figure  -  \n Including a CSS style sheet\n THE APPLICATION LAYER  \n  This strategy has two advantages\n First  it lets one set of styles be applied to many pages on a Web site\n This organization lends a consistent appearance to pages even if they were developed by different authors at different times  and allows the look of the entire site to be changed by editing one CSS file and not the HTML\n This method can be compared to an #include file in a C program: changing one macro definition there changes it in all the program files that include the header\n The ond advantage is that the HTML files that are downloaded are kept small\n This is because the browser can download one copy of the CSS file for all pages that reference it\n It does not need to download a new copy of the definitions along with each Web page\n    Dynamic Web Pages and Web Applications The static page model we have used so far treats pages as multimedia documents that are conveniently linked together\n It was a fitting model in the early days of the Web  as vast amounts of information were put online\n Nowadays  much of the excitement around the Web is using it for applications and services\n Examples include buying products on e-commerce sites  searching library catalogs  exploring maps  reading and sending email  and collaborating on documents\n These new uses are like traditional application software ( \n  mail readers and word processors)\n The twist is that these applications run inside the browser  with user data stored on servers in Internet data centers\n They use Web protocols to access information via the Internet  and the browser to display a user interface\n The advantage of this approach is that users do not need to install separate application programs  and user data can be accessed from different computers and backed up by the service operator\n It is proving so successful that it is rivaling traditional application software\n Of course  the fact that these applications are offered for free by large providers helps\n This model is the prevalent form of cloud computing  in which computing moves off individual desktop computers and into shared clusters of servers in the Internet\n To act as applications  Web pages can no longer be static\n Dynamic content is needed\n For example  a page of the library catalog should reflect which books are currently available and which books are checked out and are thus not available\n Similarly  a useful stock market page would allow the user to interact with the page to see stock prices over different periods of time and compute profits and losses\n As these examples suggest  dynamic content can be generated by programs running on the server or in the browser (or in both places)\n In this tion  we will examine each of these two cases in turn\n The general situation is as shown in Fig\n  -  \n For example  consider a map service that lets the user enter a street address and presents a corresponding map of the location\n Given a request for a location  the Web server must use a program to create a page that shows the map for the location from a database of streets and other geographic information\n This action is shown as steps  through  \n The request (step   THE WORLD WIDE WEB  ) causes a program to run on the server\n The program consults a database to generate the appropriate page (step  ) and returns it to the browser (step  )\n  Program Program Web browser Web server  Web page  Program DB Figure  -  \n Dynamic pages\n There is more to dynamic content  however\n The page that is returned may itself contain programs that run in the browser\n In our map example  the program would let the user find routes and explore nearby areas at different levels of detail\n It would update the page  zooming in or out as directed by the user (step  )\n To handle some interactions  the program may need more data from the server\n In this case  the program will send a request to the server (step  ) that will retrieve more information from the database (step  ) and return a response (step  )\n The program will then continue updating the page (step  )\n The requests and responses happen in the background; the user may not even be aware of them because the page URL and title typically do not change\n By including client-side programs  the page can present a more responsive interface than with server-side programs alone\n Server-Side Dynamic Web Page Generation Let us look at the case of server-side content generation in more detail\n A simple situation in which server-side processing is necessary is the use of forms\n Consider the user filling out the AWI order form of Fig\n  -  (b) and clicking the Submit order button\n When the user clicks  a request is sent to the server at the URL specified with the form (a POST to http:// /cgi-bin/  in this case) along with the contents of the form as filled in by the user\n These data must be given to a program or script to process\n Thus  the URL identifies the program to run; the data are provided to the program as input\n In this case  processing would involve entering the order in AWI’s internal system  updating customer records  and charging the credit card\n The page returned by this request will depend on what happens during the processing\n It is not fixed like a static page\n If the order succeeds  the page returned might give the expected shipping date\n If it is unsuccessful  the returned page might say that widgets requested are out of stock or the credit card was not valid for some reason\n THE APPLICATION LAYER  \n  Exactly how the server runs a program instead of retrieving a file depends on the design of the Web server\n It is not specified by the Web protocols themselves\n This is because the interface can be proprietary and the browser does not need to know the details\n As far as the browser is concerned  it is simply making a request and fetching a page\n Nonetheless  standard APIs have been developed for Web servers to invoke programs\n The existence of these interfaces makes it easier for developers to extend different servers with Web applications\n We will briefly look at two APIs to give you a sense of what they entail\n The first API is a method for handling dynamic page requests that has been available since the beginning of the Web\n It is called the CGI (Common Gateway Interface) and is defined in RFC \n CGI provides an interface to allow Web servers to talk to back-end programs and scripts that can accept input ( \n  from forms) and generate HTML pages in response\n These programs may be written in whatever language is convenient for the developer  usually a scripting language for ease of development\n Pick Python  Ruby  Perl or your favorite language\n By convention  programs invoked via CGI live in a directory called cgi-bin  which is visible in the URL\n The server maps a request to this directory to a program name and executes that program as a separate process\n It provides any data sent with the request as input to the program\n The output of the program gives a Web page that is returned to the browser\n In our example  the program   is invoked with input from the form encoded as shown in Fig\n  -  \n It will parse the parameters and process the order\n A useful convention is that the program will return the HTML for the order form if no form input is provided\n In this way  the program will be sure to know the representation of the form\n The ond API we will look at is quite different\n The approach here is to embed little scripts inside HTML pages and have them be executed by the server itself to generate the page\n A popular language for writing these scripts is PHP (PHP: Hypertext Preprocessor)\n To use it  the server has to understand PHP  just as a browser has to understand CSS to interpret Web pages with style sheets\n Usually  servers identify Web pages containing PHP from the file extension php rather than html or htm\n PHP is simpler to use than CGI\n As an example of how it works with forms  see the example in Fig\n  -  (a)\n The top part of this figure contains a normal HTML page with a simple form in it\n This time  the <form> tag specifies that action\n php is to be invoked to handle the parameters when the user submits the form\n The page displays two text boxes  one with a request for a name and one with a request for an age\n After the two boxes have been filled in and the form submitted  the server parses the Fig\n  -  -type string sent back  putting the name in the name variable and the age in the age variable\n It then starts to process the action\n php file  shown in Fig\n  -  (b)  as a reply\n During the processing of this file    THE WORLD WIDE WEB the PHP commands are executed\n If the user filled in ‘‘Barbara’’ and ‘‘  ’’ in the boxes  the HTML file sent back will be the one given in Fig\n  -  (c)\n Thus  handling forms becomes extremely simple using PHP\n <html> <body> <form action=" " method="post"> <p> Please enter your name: <input type="text" name="name"> </p> <p> Please enter your age: <input type="text" name="age"> </p> <input type="submit"> </form> </body> </html> (a) <html> <body> <h > Reply: </h > Hello <?php echo $name; ?>\n Prediction: next year you will be <?php echo $age +  ; ?> </body> </html> (b) <html> <body> <h > Reply: </h > Hello Barbara\n Prediction: next year you will be   </body> </html> (c) Figure  -  \n (a) A Web page containing a form\n (b) A PHP script for handling the output of the form\n (c) Output from the PHP script when the inputs are ‘‘Barbara’’ and ‘‘  ’’  respectively\n Although PHP is easy to use  it is actually a powerful programming language for interfacing the Web and a server database\n It has variables  strings  arrays  and most of the control structures found in C  but much more powerful I/O than just printf\n PHP is open source code  freely available  and widely used\n It was designed specifically to work well with Apache  which is also open source and is the world’s most widely used Web server\n For more information about PHP  see Valade (   )\n We have now seen two different ways to generate dynamic HTML pages: CGI scripts and embedded PHP\n There are several others to choose from\n JSP (JavaServer Pages) is similar to PHP  except that the dynamic part is written in THE APPLICATION LAYER  \n  the Java programming language instead of in PHP\n Pages using this technique have the file extension \n   (Active Server Pages ) is Microsoft’s version of PHP and JavaServer Pages\n It uses programs written in Microsoft’s proprietary  networked application framework for generating the dynamic content\n Pages using this technique have the extension \n The choice among these three techniques usually has more to do with politics (open source vs\n Microsoft) than with technology  since the three languages are roughly comparable\n Client-Side Dynamic Web Page Generation PHP and CGI scripts solve the problem of handling input and interactions with databases on the server\n They can all accept incoming information from forms  look up information in one or more databases  and generate HTML pages with the results\n What none of them can do is respond to mouse movements or interact with users directly\n For this purpose  it is necessary to have scripts embedded in HTML pages that are executed on the client machine rather than the server machine\n Starting with HTML  \n  such scripts are permitted using the tag <script>\n The technologies used to produce these interactive Web pages are broadly referred to as dynamic HTML The most popular scripting language for the client side is JavaScript  so we will now take a quick look at it\n Despite the similarity in names  JavaScript has almost nothing to do with the Java programming language\n Like other scripting languages  it is a very high-level language\n For example  in a single line of JavaScript it is possible to pop up a dialog box  wait for text input  and store the resulting string in a variable\n High-level features like this make JavaScript ideal for designing interactive Web pages\n On the other hand  the fact that it is mutating faster than a fruit fly trapped in an X-ray machine makes it extremely difficult to write JavaScript programs that work on all platforms  but maybe some day it will stabilize\n As an example of a program in JavaScript  consider that of Fig\n  -  \n Like that of Fig\n  -   it displays a form asking for a name and age  and then predicts how old the person will be next year\n The body is almost the same as the PHP example  the main difference being the declaration of the Submit button and the assignment statement in it\n This assignment statement tells the browser to invoke the response script on a button click and pass it the form as a parameter\n What is completely new here is the declaration of the JavaScript function response in the head of the HTML file  an area normally reserved for titles  background colors  and so on\n This function extracts the value of the name field from the form and stores it in the variable person as a string\n It also extracts the value of the age field  converts it to an integer by using the eval function  adds  to it  and stores the result in years\n Then it opens a document for output  does four   THE WORLD WIDE WEB <html> <head> <script language="javascript" type="text/javascript"> function response(test form) { var person = test  ; var years = eval(test  ) +  ;  ();  ("<html> <body>");  ("Hello " + person + "\n<br>");  ("Prediction: next year you will be " + years + "\n");  ("</body> </html>");  (); } </script> </head> <body> <form> Please enter your name: <input type="text" name="name"> <p> Please enter your age: <input type="text" name="age"> <p> <input type="button" value="submit" onclick="response( )"> </form> </body> </html> Figure  -  \n Use of JavaScript for processing a form\n writes to it using the writeln method  and closes the document\n The document is an HTML file  as can be seen from the various HTML tags in it\n The browser then displays the document on the screen\n It is very important to understand that while PHP and JavaScript look similar in that they both embed code in HTML files  they are processed totally differently\n In the PHP example of Fig\n  -   after the user has clicked on the submit button  the browser collects the information into a long string and sends it off to the server as a request for a PHP page\n The server loads the PHP file and executes the PHP script that is embedded in to produce a new HTML page\n That page is sent back to the browser for display\n The browser cannot even be sure that it was produced by a program\n This processing is shown as steps  to  in Fig\n  -  (a)\n In the JavaScript example of Fig\n  -   when the submit button is clicked the browser interprets a JavaScript function contained on the page\n All the work is done locally  inside the browser\n There is no contact with the server\n This processing is shown as steps  and  in Fig\n  -  (b)\n As a consequence  the result is displayed virtually instantaneously  whereas with PHP there can be a delay of several onds before the resulting HTML arrives at the client\n THE APPLICATION LAYER  \n  Server (a) PHP module Browser User    Server (b) Browser User JavaScript Figure  -  \n (a) Server-side scripting with PHP\n (b) Client-side scripting with JavaScript\n This difference does not mean that JavaScript is better than PHP\n Their uses are completely different\n PHP (and  by implication  JSP and ASP) is used when interaction with a database on the server is needed\n JavaScript (and other clientside languages we will mention  such as VBScript) is used when the interaction is with the user at the client computer\n It is certainly possible to combine them  as we will see shortly\n JavaScript is not the only way to make Web pages highly interactive\n An alternative on Windows platforms is VBScript  which is based on Visual Basic\n Another popular method across platforms is the use of applets\n These are small Java programs that have been compiled into machine instructions for a virtual computer called the JVM (Java Virtual Machine)\n Applets can be embedded in HTML pages (between <applet> and </applet>) and interpreted by JVM-capable browsers\n Because Java applets are interpreted rather than directly executed  the Java interpreter can prevent them from doing Bad Things\n At least in theory\n In practice  applet writers have found a nearly endless stream of bugs in the Java I/O libraries to exploit\n Microsoft’s answer to Sun’s Java applets was allowing Web pages to hold ActiveX controls  which are programs compiled to x  machine language and executed on the bare hardware\n This feature makes them vastly faster and more flexible than interpreted Java applets because they can do anything a program can do\n When Internet Explorer sees an ActiveX control in a Web page  it downloads it  verifies its identity  and executes it\n However  downloading and running foreign programs raises enormous urity issues  which we will discuss in   Since nearly all browsers can interpret both Java programs and JavaScript  a designer who wants to make a highly interactive Web page has a choice of at least two techniques  and if portability to multiple platforms is not an issue  ActiveX in addition\n As a general rule  JavaScript programs are easier to write  Java applets execute faster  and ActiveX controls run fastest of all\n Also  since all browsers implement exactly the same JVM but no two browsers implement the same version of JavaScript  Java applets are more portable than JavaScript programs\n For more information about JavaScript  there are many books  each with many (often with more than ) pages\n See  for example  Flanagan (   )\n   THE WORLD WIDE WEB AJAX—Asynchronous JavaScript and XML Compelling Web applications need responsive user interfaces and seamless access to data stored on remote Web servers\n Scripting on the client ( \n  with JavaScript) and the server ( \n  with PHP) are basic technologies that provide pieces of the solution\n These technologies are commonly used with several other key technologies in a combination called AJAX (Asynchronous JAvascript and Xml)\n Many full-featured Web applications  such as Google’s Gmail  Maps  and Docs  are written with AJAX\n AJAX is somewhat confusing because it is not a language\n It is a set of technologies that work together to enable Web applications that are every bit as responsive and powerful as traditional desktop applications\n The technologies are:  \n HTML and CSS to present information as pages DOM (Document Object Model) to change parts of pages while they are viewed XML (eXtensible Markup Language) to let programs exchange application data with the server An asynchronous way for programs to send and retrieve XML data JavaScript as a language to bind all this functionality together\n As this is quite a collection  we will go through each piece to see what it contributes\n We have already seen HTML and CSS\n They are standards for describing content and how it should be displayed\n Any program that can produce HTML and CSS can use a Web browser as a display engine\n DOM (Document Object Model) is a representation of an HTML page that is accessible to programs\n This representation is structured as a tree that reflects the structure of the HTML elements\n For instance  the DOM tree of the HTML in Fig\n  -  (a) is given in Fig\n  -  \n At the root is an html element that represents the entire HTML block\n This element is the parent of the body element  which is in turn parent to a form element\n The form has two attributes that are drawn to the right-hand side  one for the form method (a POST ) and one for the form action (the URL to request)\n This element has three children  reflecting the two paragraph tags and one input tag that are contained within the form\n At the bottom of the tree are leaves that contain either elements or literals  such as text strings\n The significance of the DOM model is that it provides programs with a straightforward way to change parts of the page\n There is no need to rewrite the entire page\n Only the node that contains the change needs to be replaced\n When this change is made  the browser will correspondingly update the display\n For example  if an image on part of the page is changed in DOM  the browser will update that image without changing the other parts of the page\n We have already seen DOM in action when the JavaScript example of Fig\n  -  added lines to the THE APPLICATION LAYER  \n  html body Attributes to the right form action = “ ” method = “post” p p “Please enter your name:” type = “submit” input input type = “txt” name = “age” Child elements below Elements “Please enter your age:” input type = “txt” name = “age” Figure  -  \n The DOM tree for the HTML in Fig\n  -  (a)\n document element to cause new lines of text to appear at the bottom of the browser window\n The DOM is a powerful method for producing pages that can evolve\n The third technology  XML (eXtensible Markup Language)  is a language for specifying structured content\n HTML mixes content with formatting because it is concerned with the presentation of information\n However  as Web applications become more common  there is an increasing need to separate structured content from its presentation\n For example  consider a program that searches the Web for the best price for some book\n It needs to analyze many Web pages looking for the item’s title and price\n With Web pages in HTML  it is very difficult for a program to figure out where the title is and where the price is\n For this reason  the W C developed XML (Bray et al\n  ) to allow Web content to be structured for automated processing\n Unlike HTML  there are no defined tags for XML\n Each user can define her own tags\n A simple example of an XML document is given in Fig\n  -  \n It defines a structure called book list  which is a list of books\n Each book has three fields  the title  author  and year of publication\n These structures are extremely simple\n It is permitted to have structures with repeated fields ( \n  multiple authors)  optional fields ( \n  URL of the audio book)  and alternative fields ( \n  URL of a bookstore if it is in print or URL of an auction site if it is out of print)\n In this example  each of the three fields is an indivisible entity  but it is also permitted to further subdivide the fields\n For example  the author field could have been done as follows to give finer-grained control over searching and formatting: <author> <first name> George </first name> <last name> Zipf </last name> </author> Each field can be subdivided into subfields and subsubfields  arbitrarily deeply\n   THE WORLD WIDE WEB <?xml version=" \n " ?> <book list> <book> <title> Human Behavior and the Principle of Least Effort </title> <author> George Zipf </author> <year>  </year> </book> <book> <title> The Mathematical Theory of Communication </title> <author> Claude E\n Shannon </author> <author> Warren Weaver </author> <year>  </year> </book> <book> <title> Nineteen Eighty-Four </title> <author> George Orwell </author> <year>  </year> </book> </book list> Figure  -  \n A simple XML document\n All the file of Fig\n  -  does is define a book list containing three books\n It is well suited for transporting information between programs running in browsers and servers  but it says nothing about how to display the document as a Web page\n To do that  a program that consumes the information and judges  to be a fine year for books might output HTML in which the titles are marked up as italic text\n Alternatively  a language called XSLT (eXtensible Stylesheet Language Transformations)  can be used to define how XML should be transformed into HTML\n XSLT is like CSS  but much more powerful\n We will spare you the details\n The other advantage of expressing data in XML  instead of HTML  is that it is easier for programs to analyze\n HTML was originally written manually (and often is still) so a lot of it is a bit sloppy\n Sometimes the closing tags  like </p>  are left out\n Other tags do not have a matching closing tag  like <br>\n Still other tags may be nested improperly  and the case of tag and attribute names can vary\n Most browsers do their best to work out what was probably intended\n XML is stricter and cleaner in its definition\n Tag names and attributes are always lowercase  tags must always be closed in the reverse of the order that they were opened (or indicate clearly if they are an empty tag with no corresponding close)  and attribute values must be enclosed in quotation marks\n This precision makes parsing easier and unambiguous\n HTML is even being defined in terms of XML\n This approach is called XHTML (eXtended HyperText Markup Language)\n Basically  it is a Very THE APPLICATION LAYER  \n  Picky version of HTML\n XHTML pages must strictly conform to the XML rules  otherwise they are not accepted by the browser\n No more shoddy Web pages and inconsistencies across browsers\n As with XML  the intent is to produce pages that are better for programs (in this case Web applications) to process\n While XHTML has been around since  it has been slow to catch on\n People who produce HTML do not see why they need XHTML  and browser support has lagged\n Now HTML  \n  is being defined so that a page can be represented as either HTML or XHTML to aid the transition\n Eventually  XHTML should replace HTML  but it will be a long time before this transition is complete\n XML has also proved popular as a language for communication between programs\n When this communication is carried by the HTTP protocol (described in the next tion) it is called a Web service\n In particular  SOAP (Simple Object Access Protocol) is a way of implementing Web services that performs RPC between programs in a language- and system-independent way\n The client just constructs the request as an XML message and sends it to the server  using the HTTP protocol\n The server sends back a reply as an XML-formatted message\n In this way  applications on heterogeneous platforms can communicate\n Getting back to AJAX  our point is simply that XML is a useful format to exchange data between programs running in the browser and the server\n However  to provide a responsive interface in the browser while sending or receiving data  it must be possible for scripts to perform asynchronous I/O that does not block the display while awaiting the response to a request\n For example  consider a map that can be scrolled in the browser\n When it is notified of the scroll action  the script on the map page may request more map data from the server if the view of the map is near the edge of the data\n The interface should not freeze while those data are fetched\n Such an interface would win no user awards\n Instead  the scrolling should continue smoothly\n When the data arrive  the script is notified so that it can use the data\n If all goes well  new map data will be fetched before it is needed\n Modern browsers have support for this model of communication\n The final piece of the puzzle is a scripting language that holds AJAX together by providing access to the above list of technologies\n In most cases  this language is JavaScript  but there are alternatives such as VBScript\n We presented a simple example of JavaScript earlier\n Do not be fooled by this simplicity\n JavaScript has many quirks  but it is a full-blown programming language  with all the power of C or Java\n It has variables  strings  arrays  objects  functions  and all the usual control structures\n It also has interfaces specific to the browser and Web pages\n JavaScript can track mouse motion over objects on the screen  which makes it easy to make a menu suddenly appear and leads to lively Web pages\n It can use DOM to access pages  manipulate HTML and XML  and perform asynchronous HTTP communication\n Before leaving the subject of dynamic pages  let us briefly summarize the technologies we have covered so far by relating them on a single figure\n Complete Web pages can be generated on the fly by various scripts on the server   THE WORLD WIDE WEB machine\n The scripts can be written in server extension languages like PHP  JSP  or    or run as separate CGI processes and thus be written in any language\n These options are shown in Fig\n  -  \n Server machine CGI script Helper application Client machine Web browser process PHP ASP JSP Java Script Plug-ins interpreter HTML / CSS / XML interpreter Java virtual machine VB Script interpreter XML HTML/CSS etc\n Web browser process Figure  -  \n Various technologies used to generate dynamic pages\n Once these Web pages are received by the browser  they are treated as normal pages in HTML  CSS and other MIME types and just displayed\n Plug-ins that run in the browser and helper applications that run outside of the browser can be installed to extend the MIME types that are supported by the browser\n Dynamic content generation is also possible on the client side\n The programs that are embedded in Web pages can be written in JavaScript  VBScript  Java  and other languages\n These programs can perform arbitrary computations and update the display\n With AJAX  programs in Web pages can asynchronously exchange XML and other kinds of data with the server\n This model supports rich Web applications that look just like traditional applications  except that they run inside the browser and access information that is stored at servers on the Internet\n    HTTP—The HyperText Transfer Protocol Now that we have an understanding of Web content and applications  it is time to look at the protocol that is used to transport all this information between Web servers and clients\n It is HTTP (HyperText Transfer Protocol)  as specified in RFC \n HTTP is a simple request-response protocol that normally runs over TCP\n It specifies what messages clients may send to servers and what responses they get back in return\n The request and response headers are given in ASCII  just like in SMTP\n The contents are given in a MIME-like format  also like in SMTP\n This simple model was partly responsible for the early success of the Web because it made development and deployment straightforward\n In this tion  we will look at the more important properties of HTTP as it is used nowadays\n However  before getting into the details we will note that the way THE APPLICATION LAYER  \n  it is used in the Internet is evolving\n HTTP is an application layer protocol because it runs on top of TCP and is closely associated with the Web\n That is why we are covering it in this  ter\n However  in another sense HTTP is becoming more like a transport protocol that provides a way for processes to communicate content across the boundaries of different networks\n These processes do not have to be a Web browser and Web server\n A media player could use HTTP to talk to a server and request album information\n Antivirus software could use HTTP to download the latest updates\n Developers could use HTTP to fetch project files\n Consumer electronics products like digital photo frames often use an embedded HTTP server as an interface to the outside world\n Machine-to-machine communication increasingly runs over HTTP\n For example  an airline server might use SOAP (an XML RPC over HTTP) to contact a car rental server and make a car reservation  all as part of a vacation package\n These trends are likely to continue  along with the expanding use of HTTP\n Connections The usual way for a browser to contact a server is to establish a TCP connection to port   on the server’s machine  although this procedure is not formally required\n The value of using TCP is that neither browsers nor servers have to worry about how to handle long messages  reliability  or congestion control\n All of these matters are handled by the TCP implementation\n Early in the Web  with HTTP  \n  after the connection was established a single request was sent over and a single response was sent back\n Then the TCP connection was released\n In a world in which the typical Web page consisted entirely of HTML text  this method was adequate\n Quickly  the average Web page grew to contain large numbers of embedded links for content such as icons and other eye candy\n Establishing a separate TCP connection to transport each single icon became a very expensive way to operate\n This observation led to HTTP  \n  which supports persistent connections\n With them  it is possible to establish a TCP connection  send a request and get a response  and then send additional requests and get additional responses\n This strategy is also called connection reuse\n By amortizing the TCP setup  startup  and release costs over multiple requests  the relative overhead due to TCP is reduced per request\n It is also possible to pipeline requests  that is  send request  before the response to request  has arrived\n The performance difference between these three cases is shown in Fig\n  -  \n Part (a) shows three requests  one after the other and each in a separate connection\n Let us suppose that this represents a Web page with two embedded images on the same server\n The URLs of the images are determined as the main page is fetched  so they are fetched after the main page\n Nowadays  a typical page has around   other objects that must be fetched to present it  but that would make our figure far too big so we will use only two embedded objects\n   THE WORLD WIDE WEB (a) (b) (c) Pipelined requests Connection setup HTTP Response HTTP Request Connection setup Connection setup Time Connection setup Connection setup Figure  -  \n HTTP with (a) multiple connections and sequential requests\n (b) A persistent connection and sequential requests\n (c) A persistent connection and pipelined requests\n In Fig\n  -  (b)  the page is fetched with a persistent connection\n That is  the TCP connection is opened at the beginning  then the same three requests are sent  one after the other as before  and only then is the connection closed\n Observe that the fetch completes more quickly\n There are two reasons for the speedup\n First  time is not wasted setting up additional connections\n Each TCP connection requires at least one round-trip time to establish\n ond  the transfer of the same images proceeds more quickly\n Why is this? It is because of TCP congestion control\n At the start of a connection  TCP uses the slow-start procedure to increase the throughput until it learns the behavior of the network path\n The consequence of this warmup period is that multiple short TCP connections take disproportionately longer to transfer information than one longer TCP connection\n Finally  in Fig\n  -  (c)  there is one persistent connection and the requests are pipelined\n Specifically  the ond and third requests are sent in rapid succession as soon as enough of the main page has been retrieved to identify that the images must be fetched\n The responses for these requests follow eventually\n This method cuts down the time that the server is idle  so it further improves performance\n Persistent connections do not come for free  however\n A new issue that they raise is when to close the connection\n A connection to a server should stay open while the page loads\n What then? There is a good chance that the user will click on a link that requests another page from the server\n If the connection remains open  the next request can be sent immediately\n However  there is no guarantee that the client will make another request of the server any time soon\n In practice  THE APPLICATION LAYER  \n  clients and servers usually keep persistent connections open until they have been idle for a short time ( \n onds) or they have a large number of open connections and need to close some\n The observant reader may have noticed that there is one combination that we have left out so far\n It is also possible to send one request per TCP connection  but run multiple TCP connections in parallel\n This parallel connection method was widely used by browsers before persistent connections\n It has the same disadvantage as sequential connections—extra overhead—but much better performance\n This is because setting up and ramping up the connections in parallel hides some of the latency\n In our example  connections for both of the embedded images could be set up at the same time\n However  running many TCP connections to the same server is discouraged\n The reason is that TCP performs congestion control for each connection independently\n As a consequence  the connections compete against each other  causing added packet loss  and in aggregate are more aggressive users of the network than an individual connection\n Persistent connections are superior and used in preference to parallel connections because they avoid overhead and do not suffer from congestion problems\n Methods Although HTTP was designed for use in the Web  it was intentionally made more general than necessary with an eye to future object-oriented uses\n For this reason  operations  called methods  other than just requesting a Web page are supported\n This generality is what permitted SOAP to come into existence\n Each request consists of one or more lines of ASCII text  with the first word on the first line being the name of the method requested\n The built-in methods are listed in Fig\n  -  \n The names are case sensitive  so GET is allowed but not get\n Method Description GET Read a Web page HEAD Read a Web page’s header POST Append to a Web page PUT Store a Web page DELETE Remove the Web page TRACE Echo the incoming request CONNECT Connect through a proxy OPTIONS Query options for a page Figure  -  \n The built-in HTTP request methods\n The GET method requests the server to send the page\n (When we say ‘‘page’’ we mean ‘‘object’’ in the most general case  but thinking of a page as the contents   THE WORLD WIDE WEB of a file is sufficient to understand the concepts\n) The page is suitably encoded in MIME\n The vast majority of requests to Web servers are GETs\n The usual form of GET is GET filename HTTP/ \n  where filename names the page to be fetched and  \n  is the protocol version\n The HEAD method just asks for the message header  without the actual page\n This method can be used to collect information for indexing purposes  or just to test a URL for validity\n The POST method is used when forms are submitted\n Both it and GET are also used for SOAP Web services\n Like GET  it bears a URL  but instead of simply retrieving a page it uploads data to the server ( \n  the contents of the form or RPC parameters)\n The server then does something with the data that depends on the URL  conceptually appending the data to the object\n The effect might be to purchase an item  for example  or to call a procedure\n Finally  the method returns a page indicating the result\n The remaining methods are not used much for browsing the Web\n The PUT method is the reverse of GET: instead of reading the page  it writes the page\n This method makes it possible to build a collection of Web pages on a remote server\n The body of the request contains the page\n It may be encoded using MIME  in which case the lines following the PUT might include authentication headers  to prove that the caller indeed has permission to perform the requested operation\n DELETE does what you might expect: it removes the page  or at least it indicates that the Web server has agreed to remove the page\n As with PUT  authentication and permission play a major role here\n The TRACE method is for debugging\n It instructs the server to send back the request\n This method is useful when requests are not being processed correctly and the client wants to know what request the server actually got\n The CONNECT method lets a user make a connection to a Web server through an intermediate device  such as a Web cache\n The OPTIONS method provides a way for the client to query the server for a page and obtain the methods and headers that can be used with that page\n Every request gets a response consisting of a status line  and possibly additional information ( \n  all or part of a Web page)\n The status line contains a three-digit status code telling whether the request was satisfied and  if not  why not\n The first digit is used to divide the responses into five major groups  as shown in Fig\n  -  \n The  xx codes are rarely used in practice\n The  xx codes mean that the request was handled successfully and the content (if any) is being returned\n The  xx codes tell the client to look elsewhere  either using a different URL or in its own cache (discussed later)\n The  xx codes mean the request failed due to a client error such an invalid request or a nonexistent page\n Finally  the  xx errors mean the server itself has an internal problem  either due to an error in its code or to a temporary overload\n THE APPLICATION LAYER  \n  Code Meaning Examples  xx Information = server agrees to handle client’s request  xx Success = request succeeded; = no content present  xx Redirection = page moved; = cached page still valid  xx Client error = forbidden page; = page not found  xx Server error = internal server error; = try again later Figure  -  \n The status code response groups\n Message Headers The request line ( \n  the line with the GET method) may be followed by additional lines with more information\n They are called request headers\n This information can be compared to the parameters of a procedure call\n Responses may also have response headers\n Some headers can be used in either direction\n A selection of the more important ones is given in Fig\n  -  \n This list is not short  so as you might imagine there is often a variety of headers on each request and response\n The User-Agent header allows the client to inform the server about its browser implementation ( \n  Mozilla/ \n  and Chrome/   \n  )\n This information is useful to let servers tailor their responses to the browser  since different browsers can have widely varying capabilities and behaviors\n The four Accept headers tell the server what the client is willing to accept in the event that it has a limited repertoire of what is acceptable\n The first header specifies the MIME types that are welcome ( \n  text/html)\n The ond gives the character set ( \n  ISO-   -  or Unicode- - )\n The third deals with compression methods ( \n  gzip)\n The fourth indicates a natural language ( \n  Spanish)\n If the server has a choice of pages  it can use this information to supply the one the client is looking for\n If it is unable to satisfy the request  an error code is returned and the request fails\n The If-Modified-Since and If-None-Match headers are used with caching\n They let the client ask for a page to be sent only if the cached copy is no longer valid\n We will describe caching shortly\n The Host header names the server\n It is taken from the URL\n This header is mandatory\n It is used because some IP addresses may serve multiple DNS names and the server needs some way to tell which host to hand the request to\n The Authorization header is needed for pages that are protected\n In this case  the client may have to prove it has a right to see the page requested\n This header is used for that case\n The client uses the misspelled Referer header to give the URL that referred to the URL that is now requested\n Most often this is the URL of the previous page\n   THE WORLD WIDE WEB Header Type Contents User-Agent Request Information about the browser and its platform Accept Request The type of pages the client can handle Accept-Charset Request The character sets that are acceptable to the client Accept-Encoding Request The page encodings the client can handle Accept-Language Request The natural languages the client can handle If-Modified-Since Request Time and date to check freshness If-None-Match Request Previously sent tags to check freshness Host Request The server’s DNS name Authorization Request A list of the client’s credentials Referer Request The previous URL from which the request came Cookie Request Previously set cookie sent back to the server Set-Cookie Response Cookie for the client to store Server Response Information about the server Content-Encoding Response How the content is encoded ( \n  gzip) Content-Language Response The natural language used in the page Content-Length Response The page’s length in bytes Content-Type Response The page’s MIME type Content-Range Response Identifies a portion of the page’s content Last-Modified Response Time and date the page was last changed Expires Response Time and date when the page stops being valid Location Response Tells the client where to send its request Accept-Ranges Response Indicates the server will accept byte range requests Date Both Date and time the message was sent Range Both Identifies a portion of a page Cache-Control Both Directives for how to treat caches ETag Both Tag for the contents of the page Upgrade Both The protocol the sender wants to switch to Figure  -  \n Some HTTP message headers\n This header is particularly useful for tracking Web browsing  as it tells servers how a client arrived at the page\n Although cookies are dealt with in RFC  rather than RFC  they also have headers\n The Set-Cookie header is how servers send cookies to clients\n The client is expected to save the cookie and return it on subsequent requests to the server by using the Cookie header\n (Note that there is a more recent specification for cookies with newer headers  RFC  but this has largely been rejected by industry and is not widely implemented\n) THE APPLICATION LAYER  \n  Many other headers are used in responses\n The Server header allows the server to identify its software build if it wishes\n The next five headers  all starting with Content-  allow the server to describe properties of the page it is sending\n The Last-Modified header tells when the page was last modified  and the Expires header tells for how long the page will remain valid\n Both of these headers play an important role in page caching\n The Location header is used by the server to inform the client that it should try a different URL\n This can be used if the page has moved or to allow multiple URLs to refer to the same page (possibly on different servers)\n It is also used for companies that have a main Web page in the com domain but redirect clients to a national or regional page based on their IP addresses or preferred language\n If a page is very large  a small client may not want it all at once\n Some servers will accept requests for byte ranges  so the page can be fetched in multiple small units\n The Accept-Ranges header announces the server’s willingness to handle this type of partial page request\n Now we come to headers that can be used in both directions\n The Date header can be used in both directions and contains the time and date the message was sent  while the Range header tells the byte range of the page that is provided by the response\n The ETag header gives a short tag that serves as a name for the content of the page\n It is used for caching\n The Cache-Control header gives other explicit instructions about how to cache (or  more usually  how not to cache) pages\n Finally  the Upgrade header is used for switching to a new communication protocol  such as a future HTTP protocol or a ure transport\n It allows the client to announce what it can support and the server to assert what it is using\n Caching People often return to Web pages that they have viewed before  and related Web pages often have the same embedded resources\n Some examples are the images that are used for navigation across the site  as well as common style sheets and scripts\n It would be very wasteful to fetch all of these resources for these pages each time they are displayed because the browser already has a copy\n Squirreling away pages that are fetched for subsequent use is called caching\n The advantage is that when a cached page can be reused  it is not necessary to repeat the transfer\n HTTP has built-in support to help clients identify when they can safely reuse pages\n This support improves performance by reducing both network traffic and latency\n The trade-off is that the browser must now store pages  but this is nearly always a worthwhile trade-off because local storage is inexpensive\n The pages are usually kept on disk so that they can be used when the browser is run at a later date\n The difficult issue with HTTP caching is how to determine that a previously cached copy of a page is the same as the page would be if it was fetched again\n   THE WORLD WIDE WEB This determination cannot be made solely from the URL\n For example  the URL may give a page that displays the latest news item\n The contents of this page will be updated frequently even though the URL stays the same\n Alternatively  the contents of the page may be a list of the gods from Greek and Roman mythology\n This page should change somewhat less rapidly\n HTTP uses two strategies to tackle this problem\n They are shown in Fig\n  -  as forms of processing between the request (step  ) and the response (step  )\n The first strategy is page validation (step  )\n The cache is consulted  and if it has a copy of a page for the requested URL that is known to be fresh ( \n  still valid)  there is no need to fetch it anew from the server\n Instead  the cached page can be returned directly\n The Expires header returned when the cached page was originally fetched and the current date and time can be used to make this determination\n  a: Not modified Web browser Cache Web server  : Request  : Check expiry  : Conditional GET  b: Response  : Response Program Figure  -  \n HTTP caching\n However  not all pages come with a convenient Expires header that tells when the page must be fetched again\n After all  making predictions is hard—especially about the future\n In this case  the browser may use heuristics\n For example  if the page has not been modified in the past year (as told by the Last-Modified header) it is a fairly safe bet that it will not change in the next hour\n There is no guarantee  however  and this may be a bad bet\n For example  the stock market might have closed for the day so that the page will not change for hours  but it will change rapidly once the next trading session starts\n Thus  the cacheability of a page may vary wildly over time\n For this reason  heuristics should be used with care  though they often work well in practice\n Finding pages that have not expired is the most beneficial use of caching because it means that the server does not need to be contacted at all\n Unfortunately  it does not always work\n Servers must use the Expires header conservatively  since they may be unsure when a page will be updated\n Thus  the cached copies may still be fresh  but the client does not know\n The ond strategy is used in this case\n It is to ask the server if the cached copy is still valid\n This request is a conditional GET  and it is shown in Fig\n  -  as step  \n If the server knows that the cached copy is still valid  it can send a short reply to say so (step  a)\n Otherwise  it must send the full response (step  b)\n THE APPLICATION LAYER  \n  More header fields are used to let the server check whether a cached copy is still valid\n The client has the time a cached page was last updated from the Last- Modified header\n It can send this time to the server using the If-Modified-Since header to ask for the page only if it has been changed in the meantime\n Alternatively  the server may return an ETag header with a page\n This header gives a tag that is a short name for the content of the page  like a checksum but better\n (It can be a cryptographic hash  which we will describe in  ) The client can validate cached copies by sending the server an If-None-Match header listing the tags of the cached copies\n If any of the tags match the content that the server would respond with  the corresponding cached copy may be used\n This method can be used when it is not convenient or useful to determine freshness\n For example  a server may return different content for the same URL depending on what languages and MIME types are preferred\n In this case  the modification date alone will not help the server to determine if the cached page is fresh\n Finally  note that both of these caching strategies are overridden by the directives carried in the Cache-Control header\n These directives can be used to restrict caching ( \n  no-cache) when it is not appropriate\n An example is a dynamic page that will be different the next time it is fetched\n Pages that require authorization are also not cached\n There is much more to caching  but we only have the space to make two important points\n First  caching can be performed at other places besides in the browser\n In the general case  HTTP requests can be routed through a series of caches\n The use of a cache external to the browser is called proxy caching\n Each added level of caching can help to reduce requests further up the chain\n It is common for organizations such as ISPs and companies to run proxy caches to gain the benefits of caching pages across different users\n We will discuss proxy caching with the broader topic of content distribution in   at the end of this  ter\n ond  caches provide an important boost to performance  but not as much as one might hope\n The reason is that  while there are certainly popular documents on the Web  there are also a great many unpopular documents that people fetch  many of which are also very long ( \n  videos)\n The ‘‘long tail’’ of unpopular documents take up space in caches  and the number of requests that can be handled from the cache grows only slowly with the size of the cache\n Web caches are always likely to be able to handle less than half of the requests\n See Breslau et al\n (   ) for more information\n Experimenting with HTTP Because HTTP is an ASCII protocol  it is quite easy for a person at a terminal (as opposed to a browser) to directly talk to Web servers\n All that is needed is a TCP connection to port   on the server\n Readers are encouraged to experiment with the following command sequence\n It will work in most UNIX shells and the command window on Windows (once the telnet program is enabled)\n   THE WORLD WIDE WEB telnet     GET /  HTTP/ \n  Host:   This sequence of commands starts up a telnet ( \n  TCP) connection to port   on IETF’s Web server   \n Then comes the GET command naming the path of the URL and the protocol\n Try servers and URLs of your choosing\n The next line is the mandatory Host header\n A blank line following the last header is mandatory\n It tells the server that there are no more request headers\n The server will then send the response\n Depending on the server and the URL  many different kinds of headers and pages can be observed\n    The Mobile Web The Web is used from most every type of computer  and that includes mobile phones\n Browsing the Web over a wireless network while mobile can be very useful\n It also presents technical problems because much Web content was designed for flashy presentations on desktop computers with broadband connectivity\n In this tion we will describe how Web access from mobile devices  or the mobile Web  is being developed\n Compared to desktop computers at work or at home  mobile phones present several difficulties for Web browsing:  \n Relatively small screens preclude large pages and large images Limited input capabilities make it tedious to enter URLs or other lengthy input Network bandwidth is limited over wireless links  particularly on cellular ( G) networks  where it is often expensive too Connectivity may be intermittent Computing power is limited  for reasons of battery life  size  heat dissipation  and cost\n These difficulties mean that simply using desktop content for the mobile Web is likely to deliver a frustrating user experience\n Early approaches to the mobile Web devised a new protocol stack tailored to wireless devices with limited capabilities\n WAP (Wireless Application Protocol) is the most well-known example of this strategy\n The WAP effort was started in  by major mobile phone vendors that included Nokia  Ericsson  and Motorola\n However  something unexpected happened along the way\n Over the next decade  network bandwidth and device capabilities grew tremendously with the deployment of  G data services and mobile phones with larger color displays  THE APPLICATION LAYER  \n  faster processors  and   \n  wireless capabilities\n All of a sudden  it was possible for mobiles to run simple Web browsers\n There is still a gap between these mobiles and desktops that will never close  but many of the technology problems that gave impetus to a separate protocol stack have faded\n The approach that is increasingly used is to run the same Web protocols for mobiles and desktops  and to have Web sites deliver mobile-friendly content when the user happens to be on a mobile device\n Web servers are able to detect whether to return desktop or mobile versions of Web pages by looking at the request headers\n The User-Agent header is especially useful in this regard because it identifies the browser software\n Thus  when a Web server receives a request  it may look at the headers and return a page with small images  less text  and simpler navigation to an iPhone and a full-featured page to a user on a laptop\n W C is encouraging this approach in several ways\n One way is to standardize best practices for mobile Web content\n A list of   such best practices is provided in the first specification (Rabin and McCathieNevile  )\n Most of these practices take sensible steps to reduce the size of pages  including by the use of compression  since the costs of communication are higher than those of computation  and by maximizing the effectiveness of caching\n This approach encourages sites  especially large sites  to create mobile Web versions of their content because that is all that is required to capture mobile Web users\n To help those users along  there is also a logo to indicate pages that can be viewed (well) on the mobile Web\n Another useful tool is a stripped-down version of HTML called XHTML Basic\n This language is a subset of XHTML that is intended for use by mobile phones  televisions  PDAs  vending machines  pagers  cars  game machines  and even watches\n For this reason  it does not support style sheets  scripts  or frames  but most of the standard tags are there\n They are grouped into   modules\n Some are required; some are optional\n All are defined in XML\n The modules and some example tags are listed in Fig\n  -  \n However  not all pages will be designed to work well on the mobile Web\n Thus  a complementary approach is the use of content transformation or transcoding\n In this approach  a computer that sits between the mobile and the server takes requests from the mobile  fetches content from the server  and transforms it to mobile Web content\n A simple transformation is to reduce the size of large images by reformatting them at a lower resolution\n Many other small but useful transformations are possible\n Transcoding has been used with some success since the early days of the mobile Web\n See  for example  Fox et al\n (   )\n However  when both approaches are used there is a tension between the mobile content decisions that are made by the server and by the transcoder\n For instance  a Web site may select a particular combination of image and text for a mobile Web user  only to have a transcoder change the format of the image\n Our discussion so far has been about content  not protocols  as it is the content that is the biggest problem in realizing the mobile Web\n However  we will briefly mention the issue of protocols\n The HTTP  TCP  and IP protocols used by the   THE WORLD WIDE WEB Module Req\n? Function Example tags Structure Yes Doc\n structure body  head  html  title Text Yes Information br  code  dfn  em  hn  kbd  p  strong Hypertext Yes Hyperlinks a List Yes Itemized lists dl  dt  dd  ol  ul  li Forms No Fill-in forms form  input  label  option  textarea Tables No Rectangular tables caption  table  td  th  tr Image No Pictures img Object No Applets  maps  etc\n object  param Meta-information No Extra info meta Link No Similar to <a> link Base No URL starting point base Figure  -  \n The XHTML Basic modules and tags\n Web may consume a significant amount of bandwidth on protocol overheads such as headers\n To tackle this problem  WAP and other solutions defined special-purpose protocols\n This turns out to be largely unecessary\n Header compression technologies  such as ROHC (RObust Header Compression) described in  \n   can reduce the overheads of these protocols\n In this way  it is possible to have one set of protocols (HTTP  TCP  IP) and use them over either high- or low- bandwidth links\n Use over the low-bandwidth links simply requires that header compression be turned on\n    Web Search To finish our description of the Web  we will discuss what is arguably the most successful Web application: search\n In  Sergey Brin and Larry Page  then graduate students at Stanford  formed a startup called Google to build a better Web search engine\n They were armed with the then-radical idea that a search algorithm that counted how many times each page was pointed to by other pages was a better measure of its importance than how many times it contained the key words being sought\n For instance  many pages link to the main Cisco page  which makes this page more important to a user searching for ‘‘Cisco’’ than a page outside of the company that happens to use the word ‘‘Cisco’’ many times\n They were right\n It did prove possible to build a better search engine  and people flocked to it\n Backed by venture capital  Google grew tremendously\n It became a public company in  with a market capitalization of $  billion\n By  it was estimated to run more than one million servers in data centers throughout the world\n THE APPLICATION LAYER  \n  In one sense  search is simply another Web application  albeit one of the most mature Web applications because it has been under development since the early days of the Web\n However  Web search has proved indispensible in everyday usage\n Over one billion Web searches are estimated to be done each day\n People looking for all manner of information use search as a starting point\n For example  to find out where to buy Vegemite in Seattle  there is no obvious Web site to use as a starting point\n But chances are that a search engine knows of a page with the desired information and can quickly direct you to the answer\n To perform a Web search in the traditional manner  the user directs her browser to the URL of a Web search site\n The major search sites include Google  Yahoo!  and Bing\n Next  the user submits search terms using a form\n This act causes the search engine to perform a query on its database for relevant pages or images  or whatever kind of resource is being searched for  and return the result as a dynamic page\n The user can then follow links to the pages that have been found\n Web search is an interesting topic for discussion because it has implications for the design and use of networks\n First  there is the question of how Web search finds pages\n The Web search engine must have a database of pages to run a query\n Each HTML page may contain links to other pages  and everything interesting (or at least searchable) is linked somewhere\n This means that it is theoretically possible to start with a handful of pages and find all other pages on the Web by doing a traversal of all pages and links\n This process is called Web crawling\n All Web search engines use Web crawlers\n One issue with crawling is the kind of pages that it can find\n Fetching static documents and following links is easy\n However  many Web pages contain programs that display different pages depending on user interaction\n An example is an online catalog for a store\n The catalog may contain dynamic pages created from a product database and queries for different products\n This kind of content is different from static pages that are easy to traverse\n How do Web crawlers find these dynamic pages? The answer is that  for the most part  they do not\n This kind of hidden content is called the deep Web\n How to search the deep Web is an open problem that researchers are now tackling\n See  for example  madhavan et al\n (   )\n There are also conventions by which sites make a page (known as  ) to tell crawlers what parts of the sites should or should not be visited\n A ond consideration is how to process all of the crawled data\n To let indexing algorithms be run over the mass of data  the pages must be stored\n Estimates vary  but the main search engines are thought to have an index of tens of billions of pages taken from the visible part of the Web\n The average page size is estimated at KB\n These figures mean that a crawled copy of the Web takes on the order of   petabytes or  ×  bytes to store\n While this is a truly huge number  it is also an amount of data that can comfortably be stored and processed in Internet data centers (Chang et al\n  )\n For example  if disk storage costs $  /TB  then  × TB costs $    which is not exactly a huge amount for companies the size of Google  Microsoft  and Yahoo!\n And while the Web is   THE WORLD WIDE WEB expanding  disk costs are dropping dramatically  so storing the entire Web may continue to be feasible for large companies for the foreseeable future\n Making sense of this data is another matter\n You can appreciate how XML can help programs extract the structure of the data easily  while ad hoc formats will lead to much guesswork\n There is also the issue of conversion between formats  and even translation between languages\n But even knowing the structure of data is only part of the problem\n The hard bit is to understand what it means\n This is where much value can be unlocked  starting with more relevant result pages for search queries\n The ultimate goal is to be able to answer questions  for example  where to buy a cheap but decent toaster oven in your city\n A third aspect of Web search is that it has come to provide a higher level of naming\n There is no need to remember a long URL if it is just as reliable (or perhaps more) to search for a Web page by a person’s name  assuming that you are better at remembering names than URLs\n This strategy is increasingly successful\n In the same way that DNS names relegated IP addresses to computers  Web search is relegating URLs to computers\n Also in favor of search is that it corrects spelling and typing errors  whereas if you type in a URL wrong  you get the wrong page\n Finally  Web search shows us something that has little to do with network design but much to do with the growth of some Internet services: there is much money in advertising\n Advertising is the economic engine that has driven the growth of Web search\n The main change from print advertising is the ability to target advertisements depending on what people are searching for  to increase the relevance of the advertisements\n Variations on an auction mechanism are used to match the search query to the most valuable advertisement (Edelman et al\n  )\n This new model has given rise to new problems  of course  such as click fraud  in which programs imitate users and click on advertisements to cause payments that have not been fairly earned  STREAMING AUDIO AND VIDEO Web applications and the mobile Web are not the only exciting developments in the use of networks\n For many people  audio and video are the holy grail of networking\n When the word ‘‘multimedia’’ is mentioned  both the propellerheads and the suits begin salivating as if on cue\n The former see immense technical challenges in providing voice over IP and video-on-demand to every computer\n The latter see equally immense profits in it\n While the idea of sending audio and video over the Internet has been around since the s at least  it is only since roughly  that real-time audio and real-time video traffic has grown with a vengeance\n Real-time traffic is different from Web traffic in that it must be played out at some predetermined rate to be useful\n After all  watching a video in slow motion with fits and starts is not most THE APPLICATION LAYER  \n  people’s idea of fun\n In contrast  the Web can have short interruptions  and page loads can take more or less time  within limits  without it being a major problem\n Two things happened to enable this growth\n First  computers have became much more powerful and are equipped with microphones and cameras so that they can input  process  and output audio and video data with ease\n ond  a flood of Internet bandwidth has come to be available\n Long-haul links in the core of the Internet run at many gigabits/  and broadband and   \n  wireless reaches users at the edge of the Internet\n These developments allow ISPs to carry tremendous levels of traffic across their backbones and mean that ordinary users can connect to the Internet   – times faster than with a  -kbps telephone modem\n The flood of bandwidth caused audio and video traffic to grow  but for different reasons\n Telephone calls take up relatively little bandwidth (in principle   kbps but less when compressed) yet telephone service has traditionally been expensive\n Companies saw an opportunity to carry voice traffic over the Internet using existing bandwidth to cut down on their telephone bills\n Startups such as Skype saw a way to let customers make free telephone calls using their Internet connections\n Upstart telephone companies saw a cheap way to carry traditional voice calls using IP networking equipment\n The result was an explosion of voice data carried over Internet networks that is called voice over IP or Internet telephony\n Unlike audio  video takes up a large amount of bandwidth\n Reasonable quality Internet video is encoded with compression at rates of around  Mbps  and a typical DVD movie is  GB of data\n Before broadband Internet access  sending movies over the network was prohibitive\n Not so any more\n With the spread of broadband  it became possible for the first time for users to watch decent  streamed video at home\n People love to do it\n Around a quarter of the Internet users on any given day are estimated to visit YouTube  the popular video sharing site\n The movie rental business has shifted to online downloads\n And the sheer size of videos has changed the overall makeup of Internet traffic\n The majority of Internet traffic is already video  and it is estimated that  % of Internet traffic will be video within a few years (Cisco  )\n Given that there is enough bandwidth to carry audio and video  the key issue for designing streaming and conferencing applications is network delay\n Audio and video need real-time presentation  meaning that they must be played out at a predetermined rate to be useful\n Long delays mean that calls that should be interactive no longer are\n This problem is clear if you have ever talked on a satellite phone  where the delay of up to half a ond is quite distracting\n For playing music and movies over the network  the absolute delay does not matter  because it only affects when the media starts to play\n But the variation in delay  called jitter  still matters\n It must be masked by the player or the audio will sound unintelligible and the video will look jerky\n In this tion  we will discuss some strategies to handle the delay problem  as well as protocols for setting up audio and video sessions\n After an introduction to   STREAMING AUDIO AND VIDEO digital audio and video  our presentation is broken into three cases for which different designs are used\n The first and easiest case to handle is streaming stored media  like watching a video on YouTube\n The next case in terms of difficulty is streaming live media\n Two examples are Internet radio and IPTV  in which radio and television stations broadcast to many users live on the Internet\n The last and most difficult case is a call as might be made with Skype  or more generally an interactive audio and video conference\n As an aside  the term multimedia is often used in the context of the Internet to mean video and audio\n Literally  multimedia is just two or more media\n That definition makes this book a multimedia presentation  as it contains text and graphics (the figures)\n However  that is probably not what you had in mind  so we use the term ‘‘multimedia’’ to imply two or more continuous media  that is  media that have to be played during some well-defined time interval\n The two media are normally video with audio  that is  moving pictures with sound\n Many people also refer to pure audio  such as Internet telephony or Internet radio  as multimedia as well  which it is clearly not\n Actually  a better term for all these cases is streaming media\n Nonetheless  we will follow the herd and consider real-time audio to be multimedia as well\n    Digital Audio An audio (sound) wave is a one-dimensional acoustic (pressure) wave\n When an acoustic wave enters the ear  the eardrum vibrates  causing the tiny bones of the inner ear to vibrate along with it  sending nerve pulses to the brain\n These pulses are perceived as sound by the listener\n In a similar way  when an acoustic wave strikes a microphone  the microphone generates an electrical signal  representing the sound amplitude as a function of time\n The frequency range of the human ear runs from   Hz to   Hz\n Some animals  notably dogs  can hear higher frequencies\n The ear hears loudness logarithmically  so the ratio of two sounds with power A and B is conventionally expressed in dB (decibels) as the quantity   log  (A /B)\n If we define the lower limit of audibility (a sound pressure of about   μPascals) for a  -kHz sine wave as  dB  an ordinary conversation is about   dB and the pain threshold is about dB\n The dynamic range is a factor of more than  million\n The ear is surprisingly sensitive to sound variations lasting only a few millionds\n The eye  in contrast  does not notice changes in light level that last only a few millionds\n The result of this observation is that jitter of only a few millionds during the playout of multimedia affects the perceived sound quality much more than it affects the perceived image quality\n Digital audio is a digital representation of an audio wave that can be used to recreate it\n Audio waves can be converted to digital form by an ADC (Analogto- Digital Converter)\n An ADC takes an electrical voltage as input and generates a binary number as output\n In Fig\n  -  (a) we see an example of a sine wave\n THE APPLICATION LAYER  \n  To represent this signal digitally  we can sample it every ΔT onds  as shown by the bar heights in Fig\n  -  (b)\n If a sound wave is not a pure sine wave but a linear superposition of sine waves where the highest frequency component present is f  the Nyquist theorem (see  \n  ) states that it is sufficient to make samples at a frequency  f\n Sampling more often is of no value since the higher frequencies that such sampling could detect are not present   \n   \n   \n – \n  – \n  – \n  – \n  T T T T T (a) (b) (c) T Figure  -  \n (a) A sine wave\n (b) Sampling the sine wave\n (c) Quantizing the samples to  bits\n The reverse process takes digital values and produces an analog electrical voltage\n It is done by a DAC (Digital-to-Analog Converter)\n A loudspeaker can then convert the analog voltage to acoustic waves so that people can hear sounds\n Digital samples are never exact\n The samples of Fig\n  -  (c) allow only nine values  from − \n  to + \n  in steps of   An  -bit sample would allow distinct values\n A  -bit sample would allow   distinct values\n The error introduced by the finite number of bits per sample is called the quantization noise\n If it is too large  the ear detects it\n Two well-known examples where sampled sound is used are the telephone and audio compact discs\n Pulse code modulation  as used within the telephone system  uses  -bit samples made  times per ond\n The scale is nonlinear to minimize perceived distortion  and with only  samples/  frequencies above  kHz are lost\n In North America and Japan  the μ-law encoding is used\n In Europe and internationally  the A-law encoding is used\n Each encoding gives a data rate of   bps\n Audio CDs are digital with a sampling rate of   samples/  enough to capture frequencies up to   Hz  which is good enough for people but bad for canine music lovers\n The samples are   bits each and are linear over the range of amplitudes\n Note that  -bit samples allow only   distinct values  even though the dynamic range of the ear is more than  million\n Thus  even though CD-quality audio is much better than telephone-quality audio  using only   bits per sample introduces noticeable quantization noise (although the full dynamic range is not covered—CDs are not supposed to hurt)\n Some fanatic audiophiles   STREAMING AUDIO AND VIDEO still prefer  -RPM LP records to CDs because records do not have a Nyquist frequency cutoff at   kHz and have no quantization noise\n (But they do have scratches unless handled very carefully) With   samples/ of   bits each  uncompressed CD-quality audio needs a bandwidth of   \n  kbps for monaural and  \n   Mbps for stereo\n Audio Compression Audio is often compressed to reduce bandwidth needs and transfer times  even though audio data rates are much lower than video data rates\n All compression systems require two algorithms: one for compressing the data at the source  and another for decompressing it at the destination\n In the literature  these algorithms are referred to as the encoding and decoding algorithms  respectively\n We will use this terminology too\n Compression algorithms exhibit certain asymmetries that are important to understand\n Even though we are considering audio first  these asymmetries hold for video as well\n For many applications  a multimedia document will only be encoded once (when it is stored on the multimedia server) but will be decoded thousands of times (when it is played back by customers)\n This asymmetry means that it is acceptable for the encoding algorithm to be slow and require expensive hardware provided that the decoding algorithm is fast and does not require expensive hardware\n The operator of a popular audio (or video) server might be quite willing to buy a cluster of computers to encode its entire library  but requiring customers to do the same to listen to music or watch movies is not likely to be a big success\n Many practical compression systems go to great lengths to make decoding fast and simple  even at the price of making encoding slow and complicated\n On the other hand  for live audio and video  such as a voice-over-IP calls  slow encoding is unacceptable\n Encoding must happen on the fly  in real time\n Consequently  real-time multimedia uses different algorithms or parameters than stored audio or videos on disk  often with appreciably less compression\n A ond asymmetry is that the encode/decode process need not be invertible\n That is  when compressing a data file  transmitting it  and then decompressing it  the user expects to get the original back  accurate down to the last bit\n With multimedia  this requirement does not exist\n It is usually acceptable to have the audio (or video) signal after encoding and then decoding be slightly different from the original as long as it sounds (or looks) the same\n When the decoded output is not exactly equal to the original input  the system is said to be lossy\n If the input and output are identical  the system is lossless\n Lossy systems are important because accepting a small amount of information loss normally means a huge payoff in terms of the compression ratio possible\n Historically  long-haul bandwidth in the telephone network was very expensive  so there is a substantial body of work on vocoders (short for ‘‘voice coders’’) that compress audio for the special case of speech\n Human speech tends to be in THE APPLICATION LAYER  \n  the   -Hz to -Hz range and is produced by a mechanical process that depends on the speaker’s vocal tract  tongue  and jaw\n Some vocoders make use of models of the vocal system to reduce speech to a few parameters ( \n  the sizes and shapes of various cavities) and a data rate of as little as  \n  kbps\n How these vocoders work is beyond the scope of this book  however\n We will concentrate on audio as sent over the Internet  which is typically closer to CD-quality\n It is also desirable to reduce the data rates for this kind of audio\n At  \n   Mbps  stereo audio would tie up many broadband links  leaving less room for video and other Web traffic\n Its data rate with compression can be reduced by an order of magnitude with little to no perceived loss of quality\n Compression and decompression require signal processing\n Fortunately  digitized sound and movies can be easily processed by computers in software\n In fact  dozens of programs exist to let users record  display  edit  mix  and store media from multiple sources\n This has led to large amounts of music and movies being available on the Internet—not all of it legal—which has resulted in numerous lawsuits from the artists and copyright owners\n Many audio compression algorithms have been developed\n Probably the most popular formats are MP  (MPEG audio layer  ) and AAC (Advanced Audio Coding) as carried in MP  (MPEG- ) files\n To avoid confusion  note that MPEG provides audio and video compression\n MP  refers to the audio compression portion (part  ) of the MPEG-  standard  not the third version of MPEG\n In fact  no third version of MPEG was released  only MPEG-  MPEG-  and MPEG- \n AAC is the successor to MP  and the default audio encoding used in MPEG- \n MPEG-  allows both MP  and AAC audio\n Is that clear now? The nice thing about standards is that there are so many to choose from\n And if you do not like any of them  just wait a year or two\n Audio compression can be done in two ways\n In waveform coding  the signal is transformed mathematically by a Fourier transform into its frequency components\n In  \n   we showed an example function of time and its Fourier amplitudes in Fig\n  - (a)\n The amplitude of each component is then encoded in a minimal way\n The goal is to reproduce the waveform fairly accurately at the other end in as few bits as possible\n The other way  perceptual coding  exploits certain flaws in the human auditory system to encode a signal in such a way that it sounds the same to a human listener  even if it looks quite different on an oscilloscope\n Perceptual coding is based on the science of psychoacoustics—how people perceive sound\n Both MP  and AAC are based on perceptual coding\n The key property of perceptual coding is that some sounds can mask other sounds\n Imagine you are broadcasting a live flute concert on a warm summer day\n Then all of a sudden  out of the blue  a crew of workmen nearby turn on their jackhammers and start tearing up the street\n No one can hear the flute any more\n Its sounds have been masked by the jackhammers\n For transmission purposes  it is now sufficient to encode just the frequency band used by the jackhammers   STREAMING AUDIO AND VIDEO because the listeners cannot hear the flute anyway\n This is called frequency masking—the ability of a loud sound in one frequency band to hide a softer sound in another frequency band that would have been audible in the absence of the loud sound\n In fact  even after the jackhammers stop  the flute will be inaudible for a short period of time because the ear turns down its gain when they start and it takes a finite time to turn it up again\n This effect is called temporal masking\n To make these effects more quantitative  imagine experiment  \n A person in a quiet room puts on headphones connected to a computer’s sound card\n The computer generates a pure sine wave at Hz at low  but gradually increasing  power\n The subject is instructed to strike a key when she hears the tone\n The computer records the current power level and then repeats the experiment at Hz  Hz  and all the other frequencies up to the limit of human hearing\n When averaged over many people  a log-log graph of how much power it takes for a tone to be audible looks like that of Fig\n  -  (a)\n A direct consequence of this curve is that it is never necessary to encode any frequencies whose power falls below the threshold of audibility\n For example  if the power at Hz were   dB in Fig\n  -  (a)  it could be omitted from the output with no perceptible loss of quality because   dB at Hz falls below the level of audibility\n Masking signal at Hz Threshold of audibility    \n   Frequency (kHz) Power (dB)       Frequency (kHz) (a) (b) Masked signal Threshold of audibility Power (dB)      \n    Figure  -  \n (a) The threshold of audibility as a function of frequency\n (b) The masking effect\n Now consider experiment  \n The computer runs experiment  again  but this time with a constant-amplitude sine wave at  say  Hz superimposed on the test frequency\n What we discover is that the threshold of audibility for frequencies near Hz is raised  as shown in Fig\n  -  (b)\n The consequence of this new observation is that by keeping track of which signals are being masked by more powerful signals in nearby frequency bands  we can omit more and more frequencies in the encoded signal  saving bits\n In Fig\n  - the   -Hz signal can be completely omitted from the output and no one will be able to hear the difference\n Even after a powerful signal stops in some frequency band  knowledge of its temporal masking properties allows us to continue to omit the masked frequencies for some time interval as the ear recovers\n The THE APPLICATION LAYER  \n  essence of MP  and AAC is to Fourier-transform the sound to get the power at each frequency and then transmit only the unmasked frequencies  encoding these in as few bits as possible\n With this information as background  we can now see how the encoding is done\n The audio compression is done by sampling the waveform at a rate from  to   kHz for AAC  often at  \n  kHz  to mimic CD sound\n Sampling can be done on one (mono) or two (stereo) channels\n Next  the output bit rate is chosen\n MP  can compress a stereo rock ’n roll CD down to   kbps with little perceptible loss in quality  even for rock ’n roll fans with no hearing loss\n For a piano concert  AAC with at least kbps is needed\n The difference is because the signalto- noise ratio for rock ’n roll is much higher than for a piano concert (in an engineering sense  anyway)\n It is also possible to choose lower output rates and accept some loss in quality\n The samples are processed in small batches\n Each batch is passed through a bank of digital filters to get frequency bands\n The frequency information is fed into a psychoacoustic model to determine the masked frequencies\n Then the available bit budget is divided among the bands  with more bits allocated to the bands with the most unmasked spectral power  fewer bits allocated to unmasked bands with less spectral power  and no bits allocated to masked bands\n Finally  the bits are encoded using Huffman encoding  which assigns short codes to numbers that appear frequently and long codes to those that occur infrequently\n There are many more details for the curious reader\n For more information  see Brandenburg (   )\n    Digital Video Now that we know all about the ear  it is time to move on to the eye\n (No  this tion is not followed by one on the nose\n) The human eye has the property that when an image appears on the retina  the image is retained for some number of millionds before decaying\n If a sequence of images is drawn at   images/  the eye does not notice that it is looking at discrete images\n All video systems exploit this principle to produce moving pictures\n The simplest digital representation of video is a sequence of frames  each consisting of a rectangular grid of picture elements  or pixels\n Each pixel can be a single bit  to represent either black or white\n However  the quality of such a system is awful\n Try using your favorite image editor to convert the pixels of a color image to black and white (and not shades of gray)\n The next step up is to use  bits per pixel to represent gray levels\n This scheme gives high-quality ‘‘black-and-white’’ video\n For color video  many systems use  bits for each of the red  green and blue (RGB) primary color components\n This representation is possible because any color can be constructed from a linear superposition of red  green  and blue with the appropriate intensities\n With   STREAMING AUDIO AND VIDEO   bits per pixel  there are about   million colors  which is more than the human eye can distinguish\n On color LCD computer monitors and televisions  each discrete pixel is made up of closely spaced red  green and blue subpixels\n Frames are displayed by setting the intensity of the subpixels  and the eye blends the color components\n Common frame rates are   frames/ (inherited from  mm motion-picture film) frames/ (inherited from NTSC  \n televisions)  and   frames/ (inherited from the PAL television system used in nearly all the rest of the world)\n (For the truly picky  NTSC color television runs at  \n  frames/\n The original black-and-white system ran at   frames/  but when color was introduced  the engineers needed a bit of extra bandwidth for signaling so they reduced the frame rate to   NTSC videos intended for computers really use  \n) PAL was invented after NTSC and really uses  \n   frames/\n To make this story complete  a third system  AM  is used in France  Francophone Africa  and Eastern Europe\n It was first introduced into Eastern Europe by then Communist East Germany so the East German people could not watch West German (PAL) television lest they get Bad Ideas\n But many of these countries are switching to PAL\n Technology and politics at their best\n Actually  for broadcast television frames/ is not quite good enough for smooth motion so the images are split into two fields  one with the odd-numbered scan lines and one with the even-numbered scan lines\n The two (half-resolution) fields are broadcast sequentially  giving almost   (NTSC) or exactly   (PAL) fields/  a system known as interlacing\n Videos intended for viewing on a computer are progressive  that is  do not use interlacing because computer monitors have buffers on their graphics cards  making it possible for the CPU to put a new image in the buffer   times/ but have the graphics card redraw the screen   or even times/ to eliminate flicker\n Analog television sets do not have a frame buffer the way computers do\n When an interlaced video with rapid movement is displayed on a computer  short horizontal lines will be visible near sharp edges  an effect known as combing\n The frame sizes used for video sent over the Internet vary widely for the simple reason that larger frames require more bandwidth  which may not always be available\n Low-resolution video might be by pixels  and ‘‘full-screen’’ video is by pixels\n These dimensions approximate those of early computer monitors and NTSC television  respectively\n The aspect ratio  or width to height ratio  of  :  is the same as a standard television\n HDTV (High-Definition TeleVision) videos can be downloaded with  by pixels\n These ‘‘widescreen’’ images have an aspect ratio of  :  to more closely match the  :  aspect ratio of film\n For comparison  standard DVD video is usually by pixels  and video on Blu-ray discs is usually HDTV at  by pixels\n On the Internet  the number of pixels is only part of the story  as media players can present the same image at different sizes\n Video is just another window on a computer screen that can be blown up or shrunk down\n The role of more THE APPLICATION LAYER  \n  pixels is to increase the quality of the image  so that it does not look blurry when it is expanded\n However  many monitors can show images (and hence videos) with even more pixels than even HDTV\n Video Compression It should be obvious from our discussion of digital video that compression is critical for sending video over the Internet\n Even a standard-quality video with by pixel frames bits of color information per pixel  and   frames/ takes over Mbps\n This far exceeds the bandwidth by which most company offices are connected to the Internet  let alone home users  and this is for a single video stream\n Since transmitting uncompressed video is completely out of the question  at least over wide area networks  the only hope is that massive compression is possible\n Fortunately  a large body of research over the past few decades has led to many compression techniques and algorithms that make video transmission feasible\n Many formats are used for video that is sent over the Internet  some proprietary and some standard\n The most popular encoding is MPEG in its various forms\n It is an open standard found in files with mpg and mp  extensions  as well as in other container formats\n In this tion  we will look at MPEG to study how video compression is accomplished\n To begin  we will look at the compression of still images with JPEG\n A video is just a sequence of images (plus sound)\n One way to compress video is to encode each image in succession\n To a first approximation  MPEG is just the JPEG encoding of each frame  plus some extra features for removing the redundancy across frames\n The JPEG Standard The JPEG (Joint Photographic Experts Group) standard for compressing continuous-tone still pictures ( \n  photographs) was developed by photographic experts working under the joint auspices of ITU  ISO  and IEC  another standards body\n It is widely used (look for files with the extension jpg) and often provides compression ratios of  :  or better for natural images\n JPEG is defined in International Standard  \n Really  it is more like a shopping list than a single algorithm  but of the four modes that are defined only the lossy sequential mode is relevant to our discussion\n Furthermore  we will concentrate on the way JPEG is normally used to encode  -bit RGB video images and will leave out some of the options and details for the sake of simplicity\n The algorithm is illustrated in Fig\n  -  \n Step  is block preparation\n For the sake of specificity  let us assume that the JPEG input is a × RGB image with   bits/pixel  as shown in Fig\n  -  (a)\n RGB is not the best color model to use for compression\n The eye is much more sensitive to the luminance  or brightness  of video signals than the chrominance  or color  of video signals\n Thus  we   STREAMING AUDIO AND VIDEO first compute the luminance  Y  and the two chrominances  Cb and Cr  from the R  G  and B components\n The following formulas are used for  -bit values that range from  to   : Y =   +  \n  R +  \n  G +  \n  B Cb = +  \n  R −  \n  G −  \n  B Cr = +  \n  R −  \n  G +  \n  B Block preparation Discrete cosine transform Quantization Differential quantization Runlength encoding Statistical output encoding Input Output Figure  -  \n Steps in JPEG lossy sequential encoding\n Separate matrices are constructed for Y  Cb  and Cr\n Next  square blocks of four pixels are averaged in the Cb and Cr matrices to reduce them to ×   \n This reduction is lossy  but the eye barely notices it since the eye responds to luminance more than to chrominance\n Nevertheless  it compresses the total amount of data by a factor of two\n Now is subtracted from each element of all three matrices to put  in the middle of the range\n Finally  each matrix is divided up into  ×  blocks\n The Y matrix has  blocks; the other two have  blocks each  as shown in Fig\n  -  (b)\n    (a) (b) Cr RGB Y Cb     Block Block  -Bit pixel  -Bit pixel Figure  -  \n (a) RGB input data\n (b) After block preparation\n Step  of JPEG encoding is to apply a DCT (Discrete Cosine Transformation) to each of the  blocks separately\n The output of each DCT is an  ×  matrix of DCT coefficients\n DCT element (   ) is the average value of the block\n The other elements tell how much spectral power is present at each spatial frequency\n Normally  these elements decay rapidly with distance from the origin  (   )  as suggested by Fig\n  -  \n Once the DCT is complete  JPEG encoding moves on to step   called quantization  in which the less important DCT coefficients are wiped out\n This (lossy) THE APPLICATION LAYER  \n  Y/Cb/Cr Amplitude DCT x Fx y Fy (a) (b) Figure  -  \n (a) One block of the Y matrix\n (b) The DCT coefficients\n transformation is done by dividing each of the coefficients in the  ×  DCT matrix by a weight taken from a table\n If all the weights are   the transformation does nothing\n However  if the weights increase sharply from the origin  higher spatial frequencies are dropped quickly\n An example of this step is given in Fig\n  -  \n Here we see the initial DCT matrix  the quantization table  and the result obtained by dividing each DCT element by the corresponding quantization table element\n The values in the quantization table are not part of the JPEG standard\n Each application must supply its own  allowing it to control the loss-compression trade-off\n                    DCT coefficients Quantization table Quantized coefficients                                          Figure  -  \n Computation of the quantized DCT coefficients\n Step  reduces the (   ) value of each block (the one in the upper-left corner) by replacing it with the amount it differs from the corresponding element in the previous block\n Since these elements are the averages of their respective blocks  they should change slowly  so taking the differential values should reduce most of them to small values\n No differentials are computed from the other values\n   STREAMING AUDIO AND VIDEO Step  linearizes the   elements and applies run-length encoding to the list\n Scanning the block from left to right and then top to bottom will not concentrate the zeros together  so a zigzag scanning pattern is used  as shown in Fig\n  -  \n In this example  the zigzag pattern produces   conutive  s at the end of the matrix\n This string can be reduced to a single count saying there are   zeros  a technique known as run-length encoding\n                     Figure  -  \n The order in which the quantized values are transmitted\n Now we have a list of numbers that represent the image (in transform space)\n Step  Huffman-encodes the numbers for storage or transmission  assigning common numbers shorter codes than uncommon ones\n JPEG may seem complicated  but that is because it is complicated\n Still  the benefits of up to  :  compression are worth it\n Decoding a JPEG image requires running the algorithm backward\n JPEG is roughly symmetric: decoding takes as long as encoding\n This property is not true of all compression algorithms  as we shall now see\n The MPEG Standard Finally  we come to the heart of the matter: the MPEG (Motion Picture Experts Group) standards\n Though there are many proprietary algorithms  these standards define the main algorithms used to compress videos\n They have been international standards since \n Because movies contain both images and sound  MPEG can compress both audio and video\n We have already examined audio compression and still image compression  so let us now examine video compression\n The MPEG-  standard (which includes MP  audio) was first published in  and is still widely used\n Its goal was to produce video-recorder-quality output that was compressed  :  to rates of around  Mbps\n This video is suitable for THE APPLICATION LAYER  \n  broad Internet use on Web sites\n Do not worry if you do not remember video recorders—MPEG-  was also used for storing movies on CDs when they existed\n If you do not know what CDs are  we will have to move on to MPEG- \n The MPEG-  standard  released in  was designed for compressing broadcast-quality video\n It is very common now  as it is used as the basis for video encoded on DVDs (which inevitably finds its way onto the Internet) and for digital broadcast television (as DVB)\n DVD quality video is typically encoded at rates of  –  Mbps\n The MPEG-  standard has two video formats\n The first format  released in  encodes video with an object-based representation\n This allows for the mixing of natural and synthetic images and other kinds of media  for example  a weatherperson standing in front of a weather map\n With this structure  it is easy to let programs interact with movie data\n The ond format  released in  is known as H\n   or AVC (Advanced Video Coding)\n Its goal is to encode video at half the rate of earlier encoders for the same quality level  all the better to support the transmission of video over networks\n This encoder is used for HDTV on most Blu-ray discs\n The details of all these standards are many and varied\n The later standards also have many more features and encoding options than the earlier standards\n However  we will not go into the details\n For the most part  the gains in video compression over time have come from numerous small improvements  rather than fundamental shifts in how video is compressed\n Thus  we will sketch the overall concepts\n MPEG compresses both audio and video\n Since the audio and video encoders work independently  there is an issue of how the two streams get synchronized at the receiver\n The solution is to have a single clock that outputs timestamps of the current time to both encoders\n These timestamps are included in the encoded output and propagated all the way to the receiver  which can use them to synchronize the audio and video streams\n MPEG video compression takes advantage of two kinds of redundancies that exist in movies: spatial and temporal\n Spatial redundancy can be utilized by simply coding each frame separately with JPEG\n This approach is occasionally used  especially when random access to each frame is needed  as in editing video productions\n In this mode  JPEG levels of compression are achieved\n Additional compression can be achieved by taking advantage of the fact that conutive frames are often almost identical\n This effect is smaller than it might first appear since many movie directors cut between scenes every  or  onds (time a movie fragment and count the scenes)\n Nevertheless  runs of   or more highly similar frames offer the potential of a major reduction over simply encoding each frame separately with JPEG\n For scenes in which the camera and background are stationary and one or two actors are moving around slowly  nearly all the pixels will be identical from frame to frame\n Here  just subtracting each frame from the previous one and running   STREAMING AUDIO AND VIDEO JPEG on the difference would do fine\n However  for scenes where the camera is panning or zooming  this technique fails badly\n What is needed is some way to compensate for this motion\n This is precisely what MPEG does; it is the main difference between MPEG and JPEG\n MPEG output consists of three kinds of frames:  \n I- (Intracoded) frames: self-contained compressed still pictures P- (Predictive) frames: block-by-block difference with the previous frames B- (Bidirectional) frames: block-by-block differences between previous and future frames\n I-frames are just still pictures\n They can be coded with JPEG or something similar\n It is valuable to have I-frames appear in the output stream periodically ( \n  once or twice per ond) for three reasons\n First  MPEG can be used for a multicast transmission  with viewers tuning in at will\n If all frames depended on their predecessors going back to the first frame  anybody who missed the first frame could never decode any subsequent frames\n ond  if any frame were received in error  no further decoding would be possible: everything from then on would be unintelligble junk\n Third  without I-frames  while doing a fast forward or rewind the decoder would have to calculate every frame passed over so it would know the full value of the one it stopped on\n P-frames  in contrast  code interframe differences\n They are based on the idea of macroblocks  which cover  for example ×   pixels in luminance space and  ×  pixels in chrominance space\n A macroblock is encoded by searching the previous frame for it or something only slightly different from it\n An example of where P-frames would be useful is given in Fig\n  -  \n Here we see three conutive frames that have the same background  but differ in the position of one person\n The macroblocks containing the background scene will match exactly  but the macroblocks containing the person will be offset in position by some unknown amount and will have to be tracked down\n Figure  -  \n Three conutive frames\n The MPEG standards do not specify how to search  how far to search  or how good a match has to be in order to count\n This is up to each implementation\n For THE APPLICATION LAYER  \n  example  an implementation might search for a macroblock at the current position in the previous frame  and all other positions offset ±Δx in the x direction and ±Δy in the y direction\n For each position  the number of matches in the luminance matrix could be computed\n The position with the highest score would be declared the winner  provided it was above some predefined threshold\n Otherwise  the macroblock would be said to be missing\n Much more sophisticated algorithms are also possible  of course\n If a macroblock is found  it is encoded by taking the difference between its current value and the one in the previous frame (for luminance and both chrominances)\n These difference matrices are then subjected to the discrete cosine transformation  quantization  run-length encoding  and Huffman encoding  as usual\n The value for the macroblock in the output stream is then the motion vector (how far the macroblock moved from its previous position in each direction)  followed by the encoding of its difference\n If the macroblock is not located in the previous frame  the current value is encoded  just as in an I-frame\n Clearly  this algorithm is highly asymmetric\n An implementation is free to try every plausible position in the previous frame if it wants to  in a desperate attempt to locate every last macroblock  no matter where it has moved to\n This approach will minimize the encoded MPEG stream at the expense of very slow encoding\n This approach might be fine for a one-time encoding of a film library but would be terrible for real-time videoconferencing\n Similarly  each implementation is free to decide what constitutes a ‘‘found’’ macroblock\n This freedom allows implementers to compete on the quality and speed of their algorithms  but always produce compliant MPEG output\n So far  decoding MPEG is straightforward\n Decoding I-frames is similar to decoding JPEG images\n Decoding P-frames requires the decoder to buffer the previous frames so it can build up the new one in a separate buffer based on fully encoded macroblocks and macroblocks containing differences from the previous frames\n The new frame is assembled macroblock by macroblock\n B-frames are similar to P-frames  except that they allow the reference macroblock to be in either previous frames or succeeding frames\n This additional freedom allows for improved motion compensation\n It is useful  for example  when objects pass in front of  or behind  other objects\n To do B-frame encoding  the encoder needs to hold a sequence of frames in memory at once: past frames  the current frame being encoded  and future frames\n Decoding is similarly more complicated and adds some delay\n This is because a given B-frame cannot be decoded until the successive frames on which it depends are decoded\n Thus  although Bframes give the best compression  they are not always used due to their greater complexity and buffering requirements\n The MPEG standards contain many enhancements to these techniques to achieve excellent levels of compression\n AVC can be used to compress video at ratios in excess of  :  which reduces network bandwidth requirements by the same factor\n For more information on AVC  see Sullivan and Wiegand (   )\n   STREAMING AUDIO AND VIDEO    Streaming Stored Media Let us now move on to network applications\n Our first case is streaming media that is already stored in files\n The most common example of this is watching videos over the Internet\n This is one form of VoD (Video on Demand)\n Other forms of video on demand use a provider network that is separate from the Internet to deliver the movies ( \n  the cable network)\n In the next tion  we will look at streaming live media  for example  broadcast IPTV and Internet radio\n Then we will look at the third case of real-time conferencing\n An example is a voice-over-IP call or video conference with Skype\n These three cases place increasingly stringent requirements on how we can deliver the audio and video over the network because we must pay increasing attention to delay and jitter\n The Internet is full of music and video sites that stream stored media files\n Actually  the easiest way to handle stored media is not to stream it\n Imagine you want to create an online movie rental site to compete with Apple’s iTunes\n A regular Web site will let users download and then watch videos (after they pay  of course)\n The sequence of steps is shown in Fig\n  -  \n We will spell them out to contrast them with the next example\n  : Save media  : Media response (HTTP)  : Media request (HTTP) Browser Client Media player Web server Server  : Play media Disk Disk Figure  -  \n Playing media over the Web via simple downloads\n The browser goes into action when the user clicks on a movie\n In step   it sends an HTTP request for the movie to the Web server to which the movie is linked\n In step   the server fetches the movie (which is just a file in MP  or some other format) and sends it back to the browser\n Using the MIME type  for example  video/mp  the browser looks up how it is supposed to display the file\n In this case  it is with a media player that is shown as a helper application  though it could also be a plug-in\n The browser saves the entire movie to a scratch file on disk in step  \n It then starts the media player  passing it the name of the scratch file\n Finally  in step  the media player starts reading the file and playing the movie\n In principle  this approach is completely correct\n It will play the movie\n There is no real-time network issue to address either because the download is simply a THE APPLICATION LAYER  \n  file download\n The only trouble is that the entire video must be transmitted over the network before the movie starts\n Most customers do not want to wait an hour for their ‘‘video on demand\n’’ This model can be problematic even for audio\n Imagine previewing a song before purchasing an album\n If the song is  MB  which is a typical size for an MP  song  and the broadband connectivity is  Mbps  the user will be greeted by half a minute of silence before the preview starts\n This model is unlikely to sell many albums\n To get around this problem without changing how the browser works  sites can use the design shown in Fig\n  -  \n The page linked to the movie is not the actual movie file\n Instead  it is what is called a metafile  a very short file just naming the movie (and possibly having other key descriptors)\n A simple metafile might be only one line of ASCII text and look like this: rtsp://joes-movie-server/movie-     The browser gets the page as usual  now a one-line file  in steps  and  \n Then it starts the media player and hands it the one-line file in step   all as usual\n The media player reads the metafile and sees the URL of where to get the movie\n It contacts joes-video-server and asks for the movie in step  \n The movie is then streamed back to the media player in step  \n The advantage of this arrangement is that the media player starts quickly  after only a very short metafile is downloaded\n Once this happens  the browser is not in the loop any more\n The media is sent directly to the media player  which can start showing the movie before the entire file has been downloaded\n  : Media request (RTSP)  : Metafile response (HTTP)  : Metafile request (HTTP) Browser Client Media player Web server Server Media server Server  : Handoff metafile  : Media response (via TCP or UDP) Disk Figure  -  \n Streaming media using the Web and a media server\n We have shown two servers in Fig\n  -  because the server named in the metafile is often not the same as the Web server\n In fact  it is generally not even   STREAMING AUDIO AND VIDEO an HTTP server  but a specialized media server\n In this example  the media server uses RTSP (Real Time Streaming Protocol)  as indicated by the scheme name rtsp\n The media player has four major jobs to do:  \n Manage the user interface Handle transmission errors Decompress the content Eliminate jitter\n Most media players nowadays have a glitzy user interface  sometimes simulating a stereo unit  with buttons  knobs  sliders  and visual displays\n Often there are interchangeable front panels  called skins  that the user can drop onto the player\n The media player has to manage all this and interact with the user\n The other jobs are related and depend on the network protocols\n We will go through each one in turn  starting with handling transmission errors\n Dealing with errors depends on whether a TCP-based transport like HTTP is used to transport the media  or a UDP-based transport like RTP is used\n Both are used in practice\n If a TCP-based transport is being used then there are no errors for the media player to correct because TCP already provides reliability by using retransmissions\n This is an easy way to handle errors  at least for the media player  but it does complicate the removal of jitter in a later step\n Alternatively  a UDP-based transport like RTP can be used to move the data\n We studied it in   With these protocols  there are no retransmissions\n Thus  packet loss due to congestion or transmission errors will mean that some of the media does not arrive\n It is up to the media player to deal with this problem\n Let us understand the difficulty we are up against\n The loss is a problem because customers do not like large gaps in their songs or movies\n However  it is not as much of a problem as loss in a regular file transfer because the loss of a small amount of media need not degrade the presentation for the user\n For video  the user is unlikely to notice if there are occasionally   new frames in some ond instead of   new frames\n For audio  short gaps in the playout can be masked with sounds close in time\n The user is unlikely to detect this substitution unless they are paying very close attention\n The key to the above reasoning  however  is that the gaps are very short\n Network congestion or a transmission error will generally cause an entire packet to be lost  and packets are often lost in small bursts\n Two strategies can be used to reduce the impact of packet loss on the media that is lost: FEC and interleaving\n We will describe each in turn\n FEC (Forward Error Correction) is simply the error-correcting coding that we studied in  \n  applied at the application level\n Parity across packets provides an example (Shacham and McKenny  )\n For every four data packets THE APPLICATION LAYER  \n  that are sent  a fifth parity packet can be constructed and sent\n This is shown in Fig\n  -  with packets A  B  C  and D\n The parity packet  P  contains redundant bits that are the parity or exclusive-OR sums of the bits in each of the four data packets\n Hopefully  all of the packets will arrive for most groups of five packets\n When this happens  the parity packet is simply discarded at the receiver\n Or  if only the parity packet is lost  no harm is done\n Lost packet Construct parity: Client Media player Media server Server Repair loss: Parity packet B = P A + + C + D A B C D P P = A B + + C + D Disk Figure  -  \n Using a parity packet to repair loss\n Occasionally  however  a data packet may be lost during transmission  as B is in Fig\n  -  \n The media player receives only three data packets  A  C  and D  plus the parity packet  P\n By design  the bits in the missing data packet can be reconstructed from the parity bits\n To be specific  using ‘‘+’’ to represent exclusive-OR or modulo  addition  B can be reconstructed as B = P + A + C + D by the properties of exclusive-OR ( \n  X + Y + Y = X)\n FEC can reduce the level of loss seen by the media player by repairing some of the packet losses  but it only works up to a certain level\n If two packets in a group of five are lost  there is nothing we can do to recover the data\n The other property to note about FEC is the cost that we have paid to gain this protection\n Every four packets have become five packets  so the bandwidth requirements for the media are  % larger\n The latency of decoding has increased too  as we may need to wait until the parity packet has arrived before we can reconstruct a data packet that came before it\n There is also one clever trick in the technique above\n In  \n   we described parity as providing error detection\n Here we are providing error-correction\n How can it do both? The answer is that in this case it is known which packet was lost\n The lost data is called an erasure\n In  \n   when we considered a frame that was received with some bits in error  we did not know which bit was errored\n This case is harder to deal with than erasures\n Thus  with erasures parity can provide error correction  and without erasures parity can only provide error detection\n We will see another unexpected benefit of parity soon  when we get to multicast scenarios\n The ond strategy is called interleaving\n This approach is based on mixing up or interleaving the order of the media before transmission and unmixing or   STREAMING AUDIO AND VIDEO deinterleaving it on reception\n That way  if a packet (or burst of packets) is lost  the loss will be spread out over time by the unmixing\n It will not result in a single  large gap when the media is played out\n For example  a packet might contain stereo samples  each containing a pair of  -bit numbers  normally good for  m of music\n If the samples were sent in order  a lost packet would represent a  m gap in the music\n Instead  the samples are transmitted as shown in Fig\n  -  \n All the even samples for a  -m interval are sent in one packet  followed by all the odd samples in the next one\n The loss of packet  now does not represent a  -m gap in the music  but the loss of every other sample for   m\n This loss can be handled easily by having the media player interpolate using the previous and succeeding samples\n The result is lower temporal resolution for   m  but not a noticeable time gap in the media\n Even time sample Legend Odd time sample  (b) Packet (a)  Time (m)   Lost This packet contains even time samples  This packet contains odd time samples Figure  -  \n When packets carry alternate samples  the loss of a packet reduces the temporal resolution rather than creating a gap in time\n This interleaving scheme above only works with uncompressed sampling\n However  interleaving (over short periods of time  not individual samples) can also be applied after compression as long as there is a way to find sample boundaries in the compressed stream\n RFC  gives a scheme that works with compressed audio\n Interleaving is an attractive technique when it can be used because it needs no additional bandwidth  unlike FEC\n However  interleaving adds to the latency  just like FEC  because of the need to wait for a group of packets to arrive (so they can be de-interleaved)\n The media player’s third job is decompressing the content\n Although this task is computationally intensive  it is fairly straightforward\n The thorny issue is how to decode media if the network protocol does not correct transmission errors\n In many compression schemes  later data cannot be decompressed until the earlier data has been decompressed  because the later data is encoded relative to the earlier data\n For a UDP-based transport  there can be packet loss\n Thus  the encoding THE APPLICATION LAYER  \n  process must be designed to permit decoding despite packet loss\n This requirement is why MPEG uses I-  P- and B-frames\n Each I-frame can be decoded independently of the other frames to recover from the loss of any earlier frames\n The fourth job is to eliminate jitter  the bane of all real-time systems\n The general solution that we described in \n    is to use a playout buffer\n All streaming systems start by buffering  –   worth of media before starting to play  as shown in Fig\n  -  \n Playing drains media regularly from the buffer so that the audio is clear and the video is smooth\n The startup delay gives the buffer a chance to fill to the low-water mark\n The idea is that data should now arrive regularly enough that the buffer is never completely emptied\n If that were to happen  the media playout would stall\n The value of buffering is that if the data are sometimes slow to arrive due to congestion  the buffered media will allow the playout to continue normally until new media arrive and the buffer is replenished\n Buffer Lowwater mark Highwater mark Media player Media server Client machine Server machine Figure  -  \n The media player buffers input from the media server and plays from the buffer rather than directly from the network\n How much buffering is needed  and how fast the media server sends media to fill up the buffer  depend on the network protocols\n There are many possibilities\n The largest factor in the design is whether a UDP-based transport or a TCP-based transport is used\n Suppose that a UDP-based transport like RTP is used\n Further suppose that there is ample bandwidth to send packets from the media server to the media player with little loss  and little other traffic in the network\n In this case  packets can be sent at the exact rate that the media is being played\n Each packet will transit the network and  after a propagation delay  arrive at about the right time for the media player to present the media\n Very little buffering is needed  as there is no variability in delay\n If interleaving or FEC is used  more buffering is needed for at least the group of packets over which the interleaving or FEC is performed\n However  this adds only a small amount of buffering\n Unfortunately  this scenario is unrealistic in two respects\n First  bandwidth varies over network paths  so it is usually not clear to the media server whether there will be sufficient bandwidth before it tries to stream the media\n A simple solution is to encode media at multiple resolutions and let each user choose a   STREAMING AUDIO AND VIDEO resolution that is supported by his Internet connectivity\n Often there are just two levels: high quality  say  encoded at  \n  Mbps or better  and low quality  say encoded at kbps or less\n ond  there will be some jitter  or variation in how long it takes media samples to cross the network\n This jitter comes from two sources\n There is often an appreciable amount of competing traffic in the network—some of which can come from multitasking users themselves browsing the Web while ostensibly watching a streamed movie)\n This traffic will cause fluctuations in when the media arrives\n Moreover  we care about the arrival of video frames and audio samples  not packets\n With compression  video frames in particular may be larger or smaller depending on their content\n An action sequence will typically take more bits to encode than a placid landscape\n If the network bandwidth is constant  the rate of media delivery versus time will vary\n The more jitter  or variation in delay  from these sources  the larger the low-water mark of the buffer needs to be to avoid underrun\n Now suppose that a TCP-based transport like HTTP is used to send the media\n By performing retransmissions and waiting to deliver packets until they are in order  TCP will increase the jitter that is observed by the media player  perhaps significantly\n The result is that a larger buffer and higher low-water mark are needed\n However  there is an advantage\n TCP will send data as fast as the network will carry it\n Sometimes media may be delayed if loss must be repaired\n But much of the time  the network will be able to deliver media faster than the player consumes it\n In these periods  the buffer will fill and prevent future underruns\n If the network is significantly faster than the average media rate  as is often the case  the buffer will fill rapidly after startup such that emptying it will soon cease to be a concern\n With TCP  or with UDP and a transmission rate that exceeds the playout rate  a question is how far ahead of the playout point the media player and media server are willing to proceed\n Often they are willing to download the entire file\n However  proceeding far ahead of the playout point performs work that is not yet needed  may require significant storage  and is not necessary to avoid buffer underruns\n When it is not wanted  the solution is for the media player to define a high-water mark in the buffer\n Basically  the server just pumps out data until the buffer is filled to the high-water mark\n Then the media player tells it to pause\n Since data will continue to pour in until the server has gotten the pause request  the distance between the high-water mark and the end of the buffer has to be greater than the bandwidth-delay product of the network\n After the server has stopped  the buffer will begin to empty\n When it hits the low-water mark  the media player tells the media server to start again\n To avoid underrun  the low-water mark must also take the bandwidth-delay product of the network into account when asking the media server to resume sending the media\n To start and stop the flow of media  the media player needs a remote control for it\n This is what RTSP provides\n It is defined in RFC  and provides the THE APPLICATION LAYER  \n  mechanism for the player to control the server\n As well as starting and stopping the stream  it can seek back or forward to a position  play specified intervals  and play at fast or slow speeds\n It does not provide for the data stream  though  which is usually RTP over UDP or RTP over HTTP over TCP\n The main commands provided by RTSP are listed in Fig\n  -  \n They have a simple text format  like HTTP messages  and are usually carried over TCP\n RTSP can run over UDP too  since each command is acknowledged (and so can be resent if it is not acknowledged)\n Command Server action DESCRIBE List media parameters SETUP Establish a logical channel between the player and the server PLAY Start sending data to the client RECORD Start accepting data from the client PAUSE Temporarily stop sending data TEARDOWN Release the logical channel Figure  -  \n RTSP commands from the player to the server\n Even though TCP would seem a poor fit to real-time traffic  it is often used in practice\n The main reason is that it is able to pass through firewalls more easily than UDP  especially when run over the HTTP port\n Most administrators configure firewalls to protect their networks from unwelcome visitors\n They almost always allow TCP connections from remote port   to pass through for HTTP and Web traffic\n Blocking that port quickly leads to unhappy campers\n However  most other ports are blocked  including for RSTP and RTP  which use ports and  amongst others\n Thus  the easiest way to get streaming media through the firewall is for the Web site to pretend it is an HTTP server sending a regular HTTP response  at least to the firewall\n There are some other advantages of TCP  too\n Because it provides reliability  TCP gives the client a complete copy of the media\n This makes it easy for a user to rewind to a previously viewed playout point without concern for lost data\n Finally  TCP will buffer as much of the media as possible as quickly as possible\n When buffer space is cheap (which it is when the disk is used for storage)  the media player can download the media while the user watches\n Once the download is complete  the user can watch uninterrupted  even if he loses connectivity\n This property is helpful for mobiles because connectivity can change rapidly with motion\n The disadvantage of TCP is the added startup latency (because of TCP startup) and also a higher low-water mark\n However  this is rarely much of a penalty as long as the network bandwidth exceeds the media rate by a large factor\n   STREAMING AUDIO AND VIDEO    Streaming Live Media It is not only recorded videos that are tremendously popular on the Web\n Live media streaming is very popular too\n Once it became possible to stream audio and video over the Internet  commercial radio and TV stations got the idea of broadcasting their content over the Internet as well as over the air\n Not so long after that  college stations started putting their signals out over the Internet\n Then college students started their own Internet broadcasts\n Today  people and companies of all sizes stream live audio and video\n The area is a hotbed of innovation as the technologies and standards evolve\n Live streaming is used for an online presence by major television stations\n This is called IPTV (IP TeleVision)\n It is also used to broadcast radio stations like the BBC\n This is called Internet radio\n Both IPTV and Internet radio reach audiences worldwide for events ranging from fashion shows to World Cup soccer and test matches live from the Melbourne Cricket Ground\n Live streaming over IP is used as a technology by cable providers to build their own broadcast systems\n And it is widely used by low-budget operations from adult sites to zoos\n With current technology  virtually anyone can start live streaming quickly and with little expense\n One approach to live streaming is to record programs to disk\n Viewers can connect to the server’s archives  pull up any program  and download it for listening\n A podcast is an episode retrieved in this manner\n For scheduled events  it is also possible to store content just after it is broadcast live  so the archive is only running  say  half an hour or less behind the live feed\n In fact  this approach is exactly the same as that used for the streaming media we just discussed\n It is easy to do  all the techniques we have discussed work for it  and viewers can pick and choose among all the programs in the archive\n A different approach is to broadcast live over the Internet\n Viewers tune in to an ongoing media stream  just like turning on the television\n However  media players provide the added features of letting the user pause or rewind the playout\n The live media will continue to be streamed and will be buffered by the player until the user is ready for it\n From the browser’s point of view  it looks exactly like the case of streaming stored media\n It does not matter to the player whether the content comes from a file or is being sent live  and usually the player will not be able to tell (except that it is not possible to skip forward with a live stream)\n Given the similarity of mechanism  much of our previous discussion applies  but there are also some key differences\n Importantly  there is still the need for buffering at the client side to smooth out jitter\n In fact  a larger amount of buffering is often needed for live streaming (independent of the consideration that the user may pause playback)\n When streaming from a file  the media can be pushed out at a rate that is greater than the playback rate\n This will build up a buffer quickly to compensate for network jitter (and the player will stop the stream if it does not want to buffer more data)\n In contrast  live media streaming is always transmitted at precisely the rate it is THE APPLICATION LAYER  \n  generated  which is the same as the rate at which it is played back\n It cannot be sent faster than this\n As a consequence  the buffer must be large enough to handle the full range of network jitter\n In practice  a  –  ond startup delay is usually adequate  so this is not a large problem\n The other important difference is that live streaming events usually have hundreds or thousands of simultaneous viewers of the same content\n Under these circumstances  the natural solution for live streaming is to use multicasting\n This is not the case for streaming stored media because the users typically stream different content at any given time\n Streaming to many users then consists of many individual streaming sessions that happen to occur at the same time\n A multicast streaming scheme works as follows\n The server sends each media packet once using IP multicast to a group address\n The network delivers a copy of the packet to each member of the group\n All of the clients who want to receive the stream have joined the group\n The clients do this using IGMP  rather than sending an RTSP message to the media server\n This is because the media server is already sending the live stream (except before the first user joins)\n What is needed is to arrange for the stream to be received locally\n Since multicast is a one-to-many delivery service  the media is carried in RTP packets over a UDP transport\n TCP only operates between a single sender and a single receiver\n Since UDP does not provide reliability  some packets may be lost\n To reduce the level of media loss to an acceptable level  we can use FEC and interleaving  as before\n In the case of FEC  there is a beneficial interaction with multicast that is shown in the parity example of Fig\n  -  \n When the packets are multicast  different clients may lose different packets\n For example  client  has lost packet B  client  lost the parity packet P  client  lost D  and client  did not lose any packets\n However  even though three different packets are lost across the clients  each client can recover all of the data packets in this example\n All that is required is that each client lose no more than one packet  whichever one it may be  so that the missing packet can be recovered by a parity computation\n Nonnenmacher et al\n (   ) describe how this idea can be used to boost reliability\n For a server with a large number of clients  multicast of media in RTP and UDP packets is clearly the most efficient way to operate\n Otherwise  the server must transmit N streams when it has N clients  which will require a very large amount of network bandwidth at the server for large streaming events\n It may surprise you to learn that the Internet does not work like this in practice\n What usually happens is that each user establishes a separate TCP connection to the server  and the media is streamed over that connection\n To the client  this is the same as streaming stored media\n And as with streaming stored media  there are several reasons for this seemingly poor choice\n The first reason is that IP multicast is not broadly available on the Internet\n Some ISPs and networks support it internally  but it is usually not available across network boundaries as is needed for wide-area streaming\n The other reasons are   STREAMING AUDIO AND VIDEO Different packets lost Client  Server P D C B A Multicast Parity packet RTP/UDP data packet Client  Client  Client  P D C B A P D C B A P D C B A P D C B A Figure  -  \n Multicast streaming media with a parity packet\n the same advantages of TCP over UDP as discussed earlier\n Streaming with TCP will reach nearly all clients on the Internet  particularly when disguised as HTTP to pass through firewalls  and reliable media delivery allows users to rewind easily\n There is one important case in which UDP and multicast can be used for streaming  however: within a provider network\n For example  a cable company might decide to broadcast TV channels to customer set-top boxes using IP technology instead of traditional video broadcasts\n The use of IP to distribute broadcast video is broadly called IPTV  as discussed above\n Since the cable company has complete control of its own network  it can engineer it to support IP multicast and have sufficient bandwidth for UDP-based distribution\n All of this is invisible to the customer  as the IP technology exists within the walled garden of the provider\n It looks just like cable TV in terms of service  but it is IP underneath  with the set-top box being a computer running UDP and the TV set being simply a monitor attached to the computer\n Back to the Internet case  the disadvantage of live streaming over TCP is that the server must send a separate copy of the media for each client\n This is feasible for a moderate number of clients  especially for audio\n The trick is to place the server at a location with good Internet connectivity so that there is sufficient bandwidth\n Usually this means renting a server in a data center from a hosting provider  not using a server at home with only broadband Internet connectivity\n There is a very competitive hosting market  so this need not be expensive\n In fact  it is easy for anybody  even a student  to set up and operate a streaming media server such as an Internet radio station\n The main components of this THE APPLICATION LAYER  \n  station are illustrated in Fig\n  -  \n The basis of the station is an ordinary PC with a decent sound card and microphone\n Popular software is used to capture audio and encode it in various formats  for example  MP  and media players are used to listen to the audio as usual\n Student’s PC Microphone Media Audio player capture plug-in Codec plug-in TCP connections to listeners Media server Internet Figure  -  \n A student radio station\n The audio stream captured on the PC is then fed over the Internet to a media server with good network connectivity  either as podcasts for stored file streaming or for live streaming\n The server handles the task of distributing the media via large numbers of TCP connections\n It also presents a front-end Web site with pages about the station and links to the content that is available for streaming\n There are commercial software packages for managing all the pieces  as well as open source packages such as icecast\n However  for a very large number of clients  it becomes infeasible to use TCP to send media to each client from a single server\n There is simply not enough bandwidth to the one server\n For large streaming sites  the streaming is done using a set of servers that are geographically spread out  so that a client can connect to the nearest server\n This is a content distribution network that we will study at the end of the  ter\n    Real-Time Conferencing Once upon a time  voice calls were carried over the public switched telephone network  and network traffic was primarily voice traffic  with a little bit of data traffic here and there\n Then came the Internet  and the Web\n The data traffic grew and grew  until by  there was as much data traffic as voice traffic (since voice is now digitized  both can be measured in bits)\n By  the volume of data traffic was an order of magnitude more than the volume of voice traffic and still growing exponentially  with voice traffic staying almost flat\n The consequence of this growth has been to flip the telephone network on its head\n Voice traffic is now carried using Internet technologies  and represents only   STREAMING AUDIO AND VIDEO a tiny fraction of the network bandwidth\n This disruptive technology is known as voice over IP  and also as Internet telephony\n Voice-over-IP is used in several forms that are driven by strong economic factors\n (English translation: it saves money so people use it\n) One form is to have what look like regular (old-fashioned?) telephones that plug into the Ethernet and send calls over the network\n Pehr Anderson was an undergraduate student at  \n when he and his friends prototyped this design for a class project\n They got a ‘‘B’’ grade\n Not content  he started a company called NBX in  pioneered this kind of voice over IP  and sold it to  Com for $  million three years later\n Companies love this approach because it lets them do away with separate telephone lines and make do with the networks that they have already\n Another approach is to use IP technology to build a long-distance telephone network\n In countries such as the  \n  this network can be accessed for competitive long-distance service by dialing a special prefix\n Voice samples are put into packets that are injected into the network and pulled out of the packets when they leave it\n Since IP equipment is much cheaper than telecommunications equipment this leads to cheaper services\n As an aside  the difference in price is not entirely technical\n For many decades  telephone service was a regulated monopoly that guaranteed the phone companies a fixed percentage profit over their costs\n Not surprisingly  this led them to run up costs  for example  by having lots and lots of redundant hardware  justified in the name of better reliability (the telephone system was only allowed to be down for a total of  hours every   years  or  min/year on average)\n This effect was often referred to as the ‘‘gold-plated telephone pole syndrome\n’’ Since deregulation  the effect has decreased  of course  but legacy equipment still exists\n The IT industry never had any history operating like this  so it has always been lean and mean\n However  we will concentrate on the form of voice over IP that is likely the most visible to users: using one computer to call another computer\n This form became commonplace as PCs began shipping with microphones  speakers  cameras  and CPUs fast enough to process media  and people started connecting to the Internet from home at broadband rates\n A well-known example is the Skype software that was released starting in \n Skype and other companies also provide gateways to make it easy to call regular telephone numbers as well as computers with IP addresses\n As network bandwidth increased  video calls joined voice calls\n Initially  video calls were in the domain of companies\n Videoconferencing systems were designed to exchange video between two or more locations enabling executives at different locations to see each other while they held their meetings\n However  with good broadband Internet connectivity and video compression software  home users can also videoconference\n Tools such as Skype that started as audio-only now routinely include video with the calls so that friends and family across the world can see as well as hear each other\n THE APPLICATION LAYER  \n  From our point of view  Internet voice or video calls are also a media streaming problem  but one that is much more constrained than streaming a stored file or a live event\n The added constraint is the low latency that is needed for a two-way conversation\n The telephone network allows a one-way latency of up to m for acceptable usage  after which delay begins to be perceived as annoying by the participants\n (International calls may have a latency of up to m  by which point they are far from a positive user experience\n) This low latency is difficult to achieve\n Certainly  buffering  –  onds of media is not going to work (as it would for broadcasting a live sports event)\n Instead  video and voice-over-IP systems must be engineered with a variety of techniques to minimize latency\n This goal means starting with UDP as the clear choice rather than TCP  because TCP retransmissions introduce at least one round-trip worth of delay\n Some forms of latency cannot be reduced  however  even with UDP\n For example  the distance between Seattle and Amsterdam is close to  km\n The speed-of-light propagation delay for this distance in optical fiber is   m\n Good luck beating that\n In practice  the propagation delay through the network will be longer because it will cover a larger distance (the bits do not follow a great circle route) and have transmission delays as each IP router stores and forwards a packet\n This fixed delay eats into the acceptable delay budget\n Another source of latency is related to packet size\n Normally  large packets are the best way to use network bandwidth because they are more efficient\n However  at an audio sampling rate of   kbps  a  -KB packet would take m to fill (and even longer if the samples are compressed)\n This delay would consume most of the overall delay budget\n In addition  if the  -KB packet is sent over a broadband access link that runs at just  Mbps  it will take  m to transmit\n Then add another  m for the packet to go over the broadband link at the other end\n Clearly  large packets will not work\n Instead  voice-over-IP systems use short packets to reduce latency at the cost of bandwidth efficiency\n They batch audio samples in smaller units  commonly   m\n At   kbps  this is bytes of data  less with compression\n However  by definition the delay from this packetization will be   m\n The transmission delay will be smaller as well because the packet is shorter\n In our example  it would reduce to around  m\n By using short packets  the minimum one-way delay for a Seattle-to-Amsterdam packet has been reduced from an unacceptable m (  + +  ) to an acceptable   m (  +   +  )\n We have not even talked about the software overhead  but it  too  will eat up some of the delay budget\n This is especially true for video  since compression is usually needed to fit video into the available bandwidth\n Unlike streaming from a stored file  there is no time to have a computationally intensive encoder for high levels of compression\n The encoder and the decoder must both run quickly\n Buffering is still needed to play out the media samples on time (to avoid unintelligible audio or jerky video)  but the amount of buffering must be kept very small since the time remaining in our delay budget is measured in millionds\n   STREAMING AUDIO AND VIDEO When a packet takes too long to arrive  the player will skip over the missing samples  perhaps playing ambient noise or repeating a frame to mask the loss to the user\n There is a trade-off between the size of the buffer used to handle jitter and the amount of media that is lost\n A smaller buffer reduces latency but results in more loss due to jitter\n Eventually  as the size of the buffer shrinks  the loss will become noticeable to the user\n Observant readers may have noticed that we have said nothing about the network layer protocols so far in this tion\n The network can reduce latency  or at least jitter  by using quality of service mechanisms\n The reason that this issue has not come up before is that streaming is able to operate with substantial latency  even in the live streaming case\n If latency is not a major concern  a buffer at the end host is sufficient to handle the problem of jitter\n However  for real-time conferencing  it is usually important to have the network reduce delay and jitter to help meet the delay budget\n The only time that it is not important is when there is so much network bandwidth that everyone gets good service\n In  \n   we described two quality of service mechanisms that help with this goal\n One mechanism is DS (Differentiated Services)  in which packets are marked as belonging to different classes that receive different handling within the network\n The appropriate marking for voice-over-IP packets is low delay\n In practice  systems set the DS codepoint to the well-known value for the Expedited Forwarding class with Low Delay type of service\n This is especially useful over broadband access links  as these links tend to be congested when Web traffic or other traffic competes for use of the link\n Given a stable network path  delay and jitter are increased by congestion\n Every  -KB packet takes  m to send over a  -Mbps link  and a voice-over-IP packet will incur these delays if it is sitting in a queue behind Web traffic\n However  with a low delay marking the voice-over-IP packets will jump to the head of the queue  bypassing the Web packets and lowering their delay\n The ond mechanism that can reduce delay is to make sure that there is sufficient bandwidth\n If the available bandwidth varies or the transmission rate fluctuates (as with compressed video) and there is sometimes not sufficient bandwidth  queues will build up and add to the delay\n This will occur even with DS\n To ensure sufficient bandwidth  a reservation can be made with the network\n This capability is provided by integrated services\n Unfortunately  it is not widely deployed\n Instead  networks are engineered for an expected traffic level or network customers are provided with service-level agreements for a given traffic level\n Applications must operate below this level to avoid causing congestion and introducing unnecessary delays\n For casual videoconferencing at home  the user may choose a video quality as a proxy for bandwidth needs  or the software may test the network path and select an appropriate quality automatically\n Any of the above factors can cause the latency to become unacceptable  so real-time conferencing requires that attention be paid to all of them\n For an overview of voice over IP and analysis of these factors  see Goode (   )\n THE APPLICATION LAYER  \n  Now that we have discussed the problem of latency in the media streaming path  we will move on to the other main problem that conferencing systems must address\n This problem is how to set up and tear down calls\n We will look at two protocols that are widely used for this purpose  H\n   and SIP\n Skype is another important system  but its inner workings are proprietary\n H\n   One thing that was clear to everyone before voice and video calls were made over the Internet was that if each vendor designed its own protocol stack  the system would never work\n To avoid this problem  a number of interested parties got together under ITU auspices to work out standards\n In  ITU issued recommendation H\n entitled ‘‘Visual Telephone Systems and Equipment for Local Area Networks Which Provide a Non-Guaranteed Quality of Service\n’’ Only the telephone industry would think of such a name\n It was quickly changed to ‘‘Packet- based Multimedia Communications Systems’’ in the  revision\n H\n   was the basis for the first widespread Internet conferencing systems\n It remains the most widely deployed solution  in its seventh version as of \n H\n   is more of an architectural overview of Internet telephony than a specific protocol\n It references a large number of specific protocols for speech coding  call setup  signaling  data transport  and other areas rather than specifying these things itself\n The general model is depicted in Fig\n  -  \n At the center is a gateway that connects the Internet to the telephone network\n It speaks the H\n   protocols on the Internet side and the PSTN protocols on the telephone side\n The communicating devices are called terminals\n A LAN may have a gatekeeper  which controls the end points under its jurisdiction  called a zone\n Internet Gatekeeper Telephone network Zone Terminal Gateway Figure  -  \n The H\n   architectural model for Internet telephony\n A telephone network needs a number of protocols\n To start with  there is a protocol for encoding and decoding audio and video\n Standard telephony representations of a single voice channel as   kbps of digital audio ( samples of  bits per ond) are defined in ITU recommendation G All H\n   systems   STREAMING AUDIO AND VIDEO must support G Other encodings that compress speech are permitted  but not required\n They use different compression algorithms and make different tradeoffs between quality and bandwidth\n For video  the MPEG forms of video compression that we described above are supported  including H Since multiple compression algorithms are permitted  a protocol is needed to allow the terminals to negotiate which one they are going to use\n This protocol is called H It also negotiates other aspects of the connection such as the bit rate\n RTCP is need for the control of the RTP channels\n Also required is a protocol for establishing and releasing connections  providing dial tones  making ringing sounds  and the rest of the standard telephony\n ITU Q\n   is used here\n The terminals need a protocol for talking to the gatekeeper (if present) as well\n For this purpose  H\n   is used\n The PC-to-gatekeeper channel it manages is called the RAS (Registration/Admission/Status ) channel\n This channel allows terminals to join and leave the zone  request and return bandwidth  and provide status updates  among other things\n Finally  a protocol is needed for the actual data transmission\n RTP over UDP is used for this purpose\n It is managed by RTCP  as usual\n The positioning of all these protocols is shown in Fig\n  -  \n Link layer protocol IP Audio G\n xx RTP Physical layer protocol UDP TCP Video H\n  x RTCP H\n   (RAS) Q\n   (Signaling) H\n   (Call Control) Control Figure  -  \n The H\n   protocol stack\n To see how these protocols fit together  consider the case of a PC terminal on a LAN (with a gatekeeper) calling a remote telephone\n The PC first has to discover the gatekeeper  so it broadcasts a UDP gatekeeper discovery packet to port \n When the gatekeeper responds  the PC learns the gatekeeper’s IP address\n Now the PC registers with the gatekeeper by sending it a RAS message in a UDP packet\n After it has been accepted  the PC sends the gatekeeper a RAS admission message requesting bandwidth\n Only after bandwidth has been granted may call setup begin\n The idea of requesting bandwidth in advance is to allow the gatekeeper to limit the number of calls\n It can then avoid oversubscribing the outgoing line in order to help provide the necessary quality of service\n THE APPLICATION LAYER  \n  As an aside  the telephone system does the same thing\n When you pick up the receiver  a signal is sent to the local end office\n If the office has enough spare capacity for another call  it generates a dial tone\n If not  you hear nothing\n Nowadays  the system is so overdimensioned that the dial tone is nearly always instantaneous  but in the early days of telephony  it often took a few onds\n So if your grandchildren ever ask you ‘‘Why are there dial tones?’’ now you know\n Except by then  probably telephones will no longer exist\n The PC now establishes a TCP connection to the gatekeeper to begin call setup\n Call setup uses existing telephone network protocols  which are connection oriented  so TCP is needed\n In contrast  the telephone system has nothing like RAS to allow telephones to announce their presence  so the H\n   designers were free to use either UDP or TCP for RAS  and they chose the lower-overhead UDP\n Now that it has bandwidth allocated  the PC can send a Q\n   SETUP message over the TCP connection\n This message specifies the number of the telephone being called (or the IP address and port  if a computer is being called)\n The gatekeeper responds with a Q\n   CALL PROCEEDING message to acknowledge correct receipt of the request\n The gatekeeper then forwards the SETUP message to the gateway\n The gateway  which is half computer  half telephone switch  then makes an ordinary telephone call to the desired (ordinary) telephone\n The end office to which the telephone is attached rings the called telephone and also sends back a Q\n   ALERT message to tell the calling PC that ringing has begun\n When the person at the other end picks up the telephone  the end office sends back a Q\n   CONNECT message to signal the PC that it has a connection\n Once the connection has been established  the gatekeeper is no longer in the loop  although the gateway is  of course\n Subsequent packets bypass the gatekeeper and go directly to the gateway’s IP address\n At this point  we just have a bare tube running between the two parties\n This is just a physical layer connection for moving bits  no more\n Neither side knows anything about the other one\n The H\n   protocol is now used to negotiate the parameters of the call\n It uses the H\n   control channel  which is always open\n Each side starts out by announcing its capabilities  for example  whether it can handle video (H\n   can handle video) or conference calls  which codecs it supports  etc\n Once each side knows what the other one can handle  two unidirectional data channels are set up and a codec and other parameters are assigned to each one\n Since each side may have different equipment  it is entirely possible that the codecs on the forward and reverse channels are different\n After all negotiations are complete  data flow can begin using RTP\n It is managed using RTCP  which plays a role in congestion control\n If video is present  RTCP handles the audio/video synchronization\n The various channels are shown in Fig\n  -  \n When either party hangs up  the Q\n   call signaling channel is used to tear down the connection after the call has been completed in order to free up resources no longer needed\n   STREAMING AUDIO AND VIDEO Data control channel (RTCP) Reverse data channel (RTP) Forward data channel (RTP) Call control channel (H\n  ) Call signaling channel (Q\n  ) Caller Callee Figure  -  \n Logical channels between the caller and callee during a call\n When the call is terminated  the calling PC contacts the gatekeeper again with a RAS message to release the bandwidth it has been assigned\n Alternatively  it can make another call\n We have not said anything about quality of service as part of H\n even though we have said it is an important part of making real-time conferencing a success\n The reason is that QoS falls outside the scope of H If the underlying network is capable of producing a stable  jitter-free connection from the calling PC to the gateway  the QoS on the call will be good; otherwise  it will not be\n However  any portion of the call on the telephone side will be jitter-free  because that is how the telephone network is designed\n SIP—The Session Initiation Protocol H\n   was designed by ITU\n Many people in the Internet community saw it as a typical telco product: large  complex  and inflexible\n Consequently  IETF set up a committee to design a simpler and more modular way to do voice over IP\n The major result to date is SIP (Session Initiation Protocol)\n The latest version is described in RFC  which was written in \n This protocol describes how to set up Internet telephone calls  video conferences  and other multimedia connections\n Unlike H\n which is a complete protocol suite  SIP is a single module  but it has been designed to interwork well with existing Internet applications\n For example  it defines telephone numbers as URLs  so that Web pages can contain them  allowing a click on a link to initiate a telephone call (the same way the mailto scheme allows a click on a link to bring up a program to send an email message)\n SIP can establish two-party sessions (ordinary telephone calls)  multiparty sessions (where everyone can hear and speak)  and multicast sessions (one sender  many receivers)\n The sessions may contain audio  video  or data  the latter being useful for multiplayer real-time games  for example\n SIP just handles setup  management  and termination of sessions\n Other protocols  such as RTP/RTCP  are THE APPLICATION LAYER  \n  also used for data transport\n SIP is an application-layer protocol and can run over UDP or TCP  as required\n SIP supports a variety of services  including locating the callee (who may not be at his home machine) and determining the callee’s capabilities  as well as handling the mechanics of call setup and termination\n In the simplest case  SIP sets up a session from the caller’s computer to the callee’s computer  so we will examine that case first\n Telephone numbers in SIP are represented as URLs using the sip scheme  for example  sip:ilse@  for a user named Ilse at the host specified by the DNS name  \n SIP URLs may also contain IPv  addresses  IPv  addresses  or actual telephone numbers\n The SIP protocol is a text-based protocol modeled on HTTP\n One party sends a message in ASCII text consisting of a method name on the first line  followed by additional lines containing headers for passing parameters\n Many of the headers are taken from MIME to allow SIP to interwork with existing Internet applications\n The six methods defined by the core specification are listed in Fig\n  -  \n Method Description INVITE Request initiation of a session ACK Confirm that a session has been initiated BYE Request termination of a session OPTIONS Query a host about its capabilities CANCEL Cancel a pending request REGISTER Inform a redirection server about the user’s current location Figure  -  \n SIP methods\n To establish a session  the caller either creates a TCP connection with the callee and sends an INVITE message over it or sends the INVITE message in a UDP packet\n In both cases  the headers on the ond and subsequent lines describe the structure of the message body  which contains the caller’s capabilities  media types  and formats\n If the callee accepts the call  it responds with an HTTP-type reply code (a three-digit number using the groups of Fig\n  -   for acceptance)\n Following the reply-code line  the callee also may supply information about its capabilities  media types  and formats\n Connection is done using a three-way handshake  so the caller responds with an ACK message to finish the protocol and confirm receipt of the message\n Either party may request termination of a session by sending a message with the BYE method\n When the other side acknowledges it  the session is terminated\n The OPTIONS method is used to query a machine about its own capabilities\n It is typically used before a session is initiated to find out if that machine is even capable of voice over IP or whatever type of session is being contemplated\n   STREAMING AUDIO AND VIDEO The REGISTER method relates to SIP’s ability to track down and connect to a user who is away from home\n This message is sent to a SIP location server that keeps track of who is where\n That server can later be queried to find the user’s current location\n The operation of redirection is illustrated in Fig\n  -  \n Here  the caller sends the INVITE message to a proxy server to hide the possible redirection\n The proxy then looks up where the user is and sends the INVITE message there\n It then acts as a relay for the subsequent messages in the three-way handshake\n The LOOKUP and REPLY messages are not part of SIP; any convenient protocol can be used  depending on what kind of location server is used\n  OK  OK  INVITE  LOOKUP  REPLY  INVITE  ACK  ACK Caller Callee Location server Proxy  Data Figure  -  \n Use of a proxy server and redirection with SIP\n SIP has a variety of other features that we will not describe here  including call waiting  call screening  encryption  and authentication\n It also has the ability to place calls from a computer to an ordinary telephone  if a suitable gateway between the Internet and telephone system is available\n Comparison of H\n   and SIP Both H\n   and SIP allow two-party and multiparty calls using both computers and telephones as end points\n Both support parameter negotiation  encryption  and the RTP/RTCP protocols\n A summary of their similarities and differences is given in Fig\n  -  \n Although the feature sets are similar  the two protocols differ widely in philosophy\n H\n   is a typical  heavyweight  telephone-industry standard  specifying the complete protocol stack and defining precisely what is allowed and what is forbidden\n This approach leads to very well defined protocols in each layer  easing the task of interoperability\n The price paid is a large  complex  and rigid standard that is difficult to adapt to future applications\n In contrast  SIP is a typical Internet protocol that works by exchanging short lines of ASCII text\n It is a lightweight module that interworks well with other Internet protocols but less well with existing telephone system signaling protocols\n THE APPLICATION LAYER  \n  Item H\n   SIP Designed by ITU IETF Compatibility with PSTN Yes Largely Compatibility with Internet Yes  over time Yes Architecture Monolithic Modular Completeness Full protocol stack SIP just handles setup Parameter negotiation Yes Yes Call signaling Q\n   over TCP SIP over TCP or UDP Message format Binary ASCII Media transport RTP/RTCP RTP/RTCP Multiparty calls Yes Yes Multimedia conferences Yes No Addressing URL or phone number URL Call termination Explicit or TCP release Explicit or timeout Instant messaging No Yes Encryption Yes Yes Size of standards  pages pages Implementation Large and complex Moderate  but issues Status Widespread  esp\n video Alternative  esp\n voice Figure  -  \n Comparison of H\n   and SIP\n Because the IETF model of voice over IP is highly modular  it is flexible and can be adapted to new applications easily\n The downside is that is has suffered from ongoing interoperability problems as people try to interpret what the standard means  CONTENT DELIVERY The Internet used to be all about communication  like the telephone network\n Early on  academics would communicate with remote machines  logging in over the network to perform tasks\n People have used email to communicate with each other for a long time  and now use video and voice over IP as well\n Since the Web grew up  however  the Internet has become more about content than communication\n Many people use the Web to find information  and there is a tremendous amount of peer-to-peer file sharing that is driven by access to movies  music  and programs\n The switch to content has been so pronounced that the majority of Internet bandwidth is now used to deliver stored videos\n   CONTENT DELIVERY Because the task of distributing content is different from that of communication  it places different requirements on the network\n For example  if Sally wants to talk to Jitu  she may make a voice-over-IP call to his mobile\n The communication must be with a particular computer; it will do no good to call Paul’s computer\n But if Jitu wants to watch his team’s latest cricket match  he is happy to stream video from whichever computer can provide the service\n He does not mind whether the computer is Sally’s or Paul’s  or  more likely  an unknown server in the Internet\n That is  location does not matter for content  except as it affects performance (and legality)\n The other difference is that some Web sites that provide content have become tremendously popular\n YouTube is a prime example\n It allows users to share videos of their own creation on every conceivable topic\n Many people want to do this\n The rest of us want to watch\n With all of these bandwidth-hungry videos  it is estimated that YouTube accounts for up to  % of Internet traffic today\n No single server is powerful or reliable enough to handle such a startling level of demand\n Instead  YouTube and other large content providers build their own content distribution networks\n These networks use data centers spread around the world to serve content to an extremely large number of clients with good performance and availability\n The techniques that are used for content distribution have been developed over time\n Early in the growth of the Web  its popularity was almost its undoing\n More demands for content led to servers and networks that were frequently overloaded\n Many people began to call the WWW the World Wide Wait\n In response to consumer demand  very large amounts of bandwidth were provisioned in the core of the Internet  and faster broadband connectivity was rolled out at the edge of the network\n This bandwidth was key to improving performance  but it is only part of the solution\n To reduce the endless delays  researchers also developed different architectures to use the bandwidth for distributing content\n One architecture is a CDN (Content Distribution Network)\n In it  a provider sets up a distributed collection of machines at locations inside the Internet and uses them to serve content to clients\n This is the choice of the big players\n An alternative architecture is a P P (Peer-to-Peer) network\n In it  a collection of computers pool their resources to serve content to each other  without separately provisioned servers or any central point of control\n This idea has captured people’s imagination because  by acting together  many little players can pack an enormous punch\n In this tion  we will look at the problem of distributing content on the Internet and some of the solutions that are used in practice\n After briefly discussing content popularity and Internet traffic  we will describe how to build powerful Web servers and use caching to improve performance for Web clients\n Then we will come to the two main architectures for distributing content: CDNs and P P networks\n There design and properties are quite different  as we will see\n THE APPLICATION LAYER  \n     Content and Internet Traffic To design and engineer networks that work well  we need an understanding of the traffic that they must carry\n With the shift to content  for example  servers have migrated from company offices to Internet data centers that provide large numbers of machines with excellent network connectivity\n To run even a small server nowadays  it is easier and cheaper to rent a virtual server hosted in an Internet data center than to operate a real machine in a home or office with broadband connectivity to the Internet\n Fortunately  there are only two facts about Internet traffic that is it essential to know\n The first fact is that it changes quickly  not only in the details but in the overall makeup\n Before  most traffic was traditional FTP file transfer (for moving programs and data sets between computers) and email\n Then the Web arrived and grew exponentially\n Web traffic left FTP and email traffic in the dust long before the dot com bubble of \n Starting around  P P file sharing for music and then movies took off\n By  most Internet traffic was P P traffic  leaving the Web in the dust\n Sometime in the late s  video streamed using content distribution methods by sites like YouTube began to exceed P P traffic\n By  Cisco predicts that  % of all Internet traffic will be video in one form or another (Cisco  )\n It is not always traffic volume that matters\n For instance  while voice-over-IP traffic boomed even before Skype started in  it will always be a minor blip on the chart because the bandwidth requirements of audio are two orders of magnitude lower than for video\n However  voice-over-IP traffic stresses the network in other ways because it is sensitive to latency\n As another example  online social networks have grown furiously since Facebook started in \n In  for the first time  Facebook reached more users on the Web per day than Google\n Even putting the traffic aside (and there is an awful lot of traffic)  online social networks are important because they are changing the way that people interact via the Internet\n The point we are making is that seismic shifts in Internet traffic happen quickly  and with some regularity\n What will come next? Please check back in the  th edition of this book and we will let you know\n The ond essential fact about Internet traffic is that it is highly skewed\n Many properties with which we are familiar are clustered around an average\n For instance  most adults are close to the average height\n There are some tall people and some short people  but few very tall or very short people\n For these kinds of properties  it is possible to design for a range that is not very large but nonetheless captures the majority of the population\n Internet traffic is not like this\n For a long time  it has been known that there are a small number of Web sites with massive traffic and a vast number of Web site with much smaller traffic\n This feature has become part of the language of networking\n Early papers talked about traffic in terms of packet trains  the idea   CONTENT DELIVERY being that express trains with a large number of packets would suddenly travel down a link (Jain and Routhier  )\n This was formalized as the notion of selfsimilarity  which for our purposes can be thought of as network traffic that exhibits many short and many long gaps even when viewed at different time scales (Leland et al\n  )\n Later work spoke of long traffic flows as elephants and short traffic flows as mice\n The idea is that there are only a few elephants and many mice  but the elephants matter because they are so big\n Returning to Web content  the same sort of skew is evident\n Experience with video rental stores  public libraries  and other such organizations shows that not all items are equally popular\n Experimentally  when N movies are available  the fraction of all requests for the kth most popular one is approximately C /k\n Here  C is computed to normalize the sum to   namely  C =  /(  +  /  +  /  +  /  +  /  +  \n +  /N) Thus  the most popular movie is seven times as popular as the number seven movie\n This result is known as Zipf’s law (Zipf  )\n It is named after George Zipf  a professor of linguistics at Harvard University who noted that the frequency of a word’s usage in a large body of text is inversely proportional to its rank\n For example  the  th most common word is used twice as much as the  th most common word and three times as much as the   th most common word\n A Zipf distribution is shown in Fig\n  -  (a)\n It captures the notion that there are a small number of popular items and a great many unpopular items\n To recognize distributions of this form  it is convenient to plot the data on a log scale on both axes  as shown in Fig\n  -  (b)\n The result should be a straight line\n (a)  Relative Frequency Rank   Relative Frequency Rank –   –    (b) Figure  -  \n Zipf distribution (a) On a linear scale\n (b) On a log-log scale\n When people looked at the popularity of Web pages  it also turned out to roughly follow Zipf’s law (Breslau et al\n  )\n A Zipf distribution is one example in a family of distributions known as power laws\n Power laws are evident THE APPLICATION LAYER  \n  in many human phenomena  such as the distribution of city populations and of wealth\n They have the same propensity to describe a few large players and a great many smaller players  and they too appear as a straight line on a log-log plot\n It was soon discovered that the topology of the Internet could be roughly described with power laws (Faloutsos et al\n  )\n Next  researchers began plotting every imaginable property of the Internet on a log scale  observing a straight line  and shouting: ‘‘Power law!’’ However  what matters more than a straight line on a log-log plot is what these distributions mean for the design and use of networks\n Given the many forms of content that have Zipf or power law distributions  it seems fundamental that Web sites on the Internet are Zipf-like in popularity\n This in turn means that an average site is not a useful representation\n Sites are better described as either popular or unpopular\n Both kinds of sites matter\n The popular sites obviously matter  since a few popular sites may be responsible for most of the traffic on the Internet\n Perhaps surprisingly  the unpopular sites can matter too\n This is because the total amount of traffic directed to the unpopular sites can add up to a large fraction of the overall traffic\n The reason is that there are so many unpopular sites\n The notion that  collectively  many unpopular choices can matter has been popularized by books such as The Long Tail (Anderson  a)\n Curves showing decay like that of Fig\n  -  (a) are common  but they are not all the same\n In particular  situations in which the rate of decay is proportional to how much material is left (such as with unstable radioactive atoms) exhibit exponential decay  which drops off much faster than Zipf’s Law\n The number of items  say atoms  left after time t is usually expressed as e −t /α  where the constant α determines how fast the decay is\n The difference between exponential decay and Zipf’s Law is that with exponential decay  it is safe to ignore the end of tail but with Zipf’s Law the total weight of the tail is significant and cannot be ignored\n To work effectively in this skewed world  we must be able to build both kinds of Web sites\n Unpopular sites are easy to handle\n By using DNS  many different sites may actually point to the same computer in the Internet that runs all of the sites\n On the other hand  popular sites are difficult to handle\n There is no single computer even remotely powerful enough  and using a single computer would make the site inaccessible for millions of users if it fails\n To handle these sites  we must build content distribution systems\n We will start on that quest next\n    Server Farms and Web Proxies The Web designs that we have seen so far have a single server machine talking to multiple client machines\n To build large Web sites that perform well  we can speed up processing on either the server side or the client side\n On the server side  more powerful Web servers can be built with a server farm  in which a cluster of computers acts as a single server\n On the client side  better performance can   CONTENT DELIVERY be achieved with better caching techniques\n In particular  proxy caches provide a large shared cache for a group of clients\n We will describe each of these techniques in turn\n However  note that neither technique is sufficient to build the largest Web sites\n Those popular sites require the content distribution methods that we describe in the following tions  which combine computers at many different locations\n Server Farms No matter how much bandwidth one machine has  it can only serve so many Web requests before the load is too great\n The solution in this case is to use more than one computer to make a Web server\n This leads to the server farm model of Fig\n  -  \n Front end Backend database Internet access Clients Server farm Servers Balances load across servers Figure  -  \n A server farm\n The difficulty with this seemingly simple model is that the set of computers that make up the server farm must look like a single logical Web site to clients\n If they do not  we have just set up different Web sites that run in parallel\n There are several possible solutions to make the set of servers appear to be one Web site\n All of the solutions assume that any of the servers can handle a request from any client\n To do this  each server must have a copy of the Web site\n The servers are shown as connected to a common back-end database by a dashed line for this purpose\n One solution is to use DNS to spread the requests across the servers in the server farm\n When a DNS request is made for the Web URL  the DNS server returns a rotating list of the IP addresses of the servers\n Each client tries one IP address  typically the first on the list\n The effect is that different clients contact different servers to access the same Web site  just as intended\n The DNS method is at the heart of CDNs  and we will revisit it later in this tion\n The other solutions are based on a front end that sprays incoming requests over the pool of servers in the server farm\n This happens even when the client THE APPLICATION LAYER  \n  contacts the server farm using a single destination IP address\n The front end is usually a link-layer switch or an IP router  that is  a device that handles frames or packets\n All of the solutions are based on it (or the servers) peeking at the network  transport  or application layer headers and using them in nonstandard ways\n A Web request and response are carried as a TCP connection\n To work correctly  the front end must distribute all of the packets for a request to the same server\n A simple design is for the front end to broadcast all of the incoming requests to all of the servers\n Each server answers only a fraction of the requests by prior agreement\n For example servers might look at the source IP address and reply to the request only if the last  bits of the source IP address match their configured selectors\n Other packets are discarded\n While this is wasteful of incoming bandwidth  often the responses are much longer than the request  so it is not nearly as inefficient as it sounds\n In a more general design  the front end may inspect the IP  TCP  and HTTP headers of packets and arbitrarily map them to a server\n The mapping is called a load balancing policy as the goal is to balance the workload across the servers\n The policy may be simple or complex\n A simple policy might be to use the servers one after the other in turn  or round-robin\n With this approach  the front end must remember the mapping for each request so that subsequent packets that are part of the same request will be sent to the same server\n Also  to make the site more reliable than a single server  the front end should notice when servers have failed and stop sending them requests\n Much like NAT  this general design is perilous  or at least fragile  in that we have just created a device that violates the most basic principle of layered protocols: each layer must use its own header for control purposes and may not inspect and use information from the payload for any purpose\n But people design such systems anyway and when they break in the future due to changes in higher layers  they tend to be surprised\n The front end in this case is a switch or router  but it may take action based on transport layer information or higher\n Such a box is called a middlebox because it interposes itself in the middle of a network path in which it has no business  according to the protocol stack\n In this case  the front end is best considered an internal part of a server farm that terminates all layers up to the application layer (and hence can use all of the header information for those layers)\n Nonetheless  as with NAT  this design is useful in practice\n The reason for looking at TCP headers is that it is possible to do a better job of load balancing than with IP information alone\n For example  one IP address may represent an entire company and make many requests\n It is only by looking at TCP or higherlayer information that these requests can be mapped to different servers\n The reason for looking at the HTTP headers is somewhat different\n Many Web interactions access and update databases  such as when a customer looks up her most recent purchase\n The server that fields this request will have to query the back-end database\n It is useful to direct subsequent requests from the same user to   CONTENT DELIVERY the same server  because that server has already cached information about the user\n The simplest way to cause this to happen is to use Web cookies (or other information to distinguish the user) and to inspect the HTTP headers to find the cookies\n As a final note  although we have described this design for Web sites  a server farm can be built for other kinds of servers as well\n An example is servers streaming media over UDP\n The only change that is required is for the front end to be able to load balance these requests (which will have different protocol header fields than Web requests)\n Web Proxies Web requests and responses are sent using HTTP\n In   we described how browsers can cache responses and reuse them to answer future requests\n Various header fields and rules are used by the browser to determine if a cached copy of a Web page is still fresh\n We will not repeat that material here\n Caching improves performance by shortening the response time and reducing the network load\n If the browser can determine that a cached page is fresh by itself  the page can be fetched from the cache immediately  with no network traffic at all\n However  even if the browser must ask the server for confirmation that the page is still fresh  the response time is shortened and the network load is reduced  especially for large pages  since only a small message needs to be sent\n However  the best the browser can do is to cache all of the Web pages that the user has previously visited\n From our discussion of popularity  you may recall that as well as a few popular pages that many people visit repeatedly  there are many  many unpopular pages\n In practice  this limits the effectiveness of browser caching because there are a large number of pages that are visited just once by a given user\n These pages always have to be fetched from the server\n One strategy to make caches more effective is to share the cache among multiple users\n That way  a page already fetched for one user can be returned to another user when that user makes the same request\n Without browser caching  both users would need to fetch the page from the server\n Of course  this sharing cannot be done for encrypted traffic  pages that require authentication  and uncacheable pages ( \n  current stock prices) that are returned by programs\n Dynamic pages created by programs  especially  are a growing case for which caching is not effective\n Nonetheless  there are plenty of Web pages that are visible to many users and look the same no matter which user makes the request ( \n  images)\n A Web proxy is used to share a cache among users\n A proxy is an agent that acts on behalf of someone else  such as the user\n There are many kinds of proxies\n For instance  an ARP proxy replies to ARP requests on behalf of a user who is elsewhere (and cannot reply for himself)\n A Web proxy fetches Web requests on behalf of its users\n It normally provides caching of the Web responses  and since it is shared across users it has a substantially larger cache than a browser\n THE APPLICATION LAYER  \n  When a proxy is used  the typical setup is for an organization to operate one Web proxy for all of its users\n The organization might be a company or an ISP\n Both stand to benefit by speeding up Web requests for its users and reducing its bandwidth needs\n While flat pricing  independent of usage  is common for end users  most companies and ISPs are charged according to the bandwidth that they use\n This setup is shown in Fig\n  -  \n To use the proxy  each browser is configured to make page requests to the proxy instead of to the page’s real server\n If the proxy has the page  it returns the page immediately\n If not  it fetches the page from the server  adds it to the cache for future use  and returns it to the client that requested it\n Clients Servers Browser cache Organization Proxy cache Internet Figure  -  \n A proxy cache between Web browsers and Web servers\n As well as sending Web requests to the proxy instead of the real server  clients perform their own caching using its browser cache\n The proxy is only consulted after the browser has tried to satisfy the request from its own cache\n That is  the proxy provides a ond level of caching\n Further proxies may be added to provide additional levels of caching\n Each proxy (or browser) makes requests via its upstream proxy\n Each upstream proxy caches for the downstream proxies (or browsers)\n Thus  it is possible for browsers in a company to use a company proxy  which uses an ISP proxy  which contacts Web servers directly\n However  the single level of proxy caching we have shown in Fig\n  -  is often sufficient to gain most of the potential benefits  in practice\n The problem again is the long tail of popularity\n Studies of Web traffic have shown that shared caching is especially beneficial until the number of users reaches about the size of a small company (say  people)\n As the number of people grows larger  the benefits of sharing a cache become marginal because of the unpopular requests that cannot be cached due to lack of storage space (Wolman et al\n  )\n Web proxies provide additional benefits that are often a factor in the decision to deploy them\n One benefit is to filter content\n The administrator may configure   CONTENT DELIVERY the proxy to blacklist sites or otherwise filter the requests that it makes\n For example  many administrators frown on employees watching YouTube videos (or worse yet  pornography) on company time and set their filters accordingly\n Another benefit of having proxies is privacy or anonymity  when the proxy shields the identity of the user from the server\n    Content Delivery Networks Server farms and Web proxies help to build large sites and to improve Web performance  but they are not sufficient for truly popular Web sites that must serve content on a global scale\n For these sites  a different approach is needed\n CDNs (Content Delivery Networks) turn the idea of traditional Web caching on its head\n Instead  of having clients look for a copy of the requested page in a nearby cache  it is the provider who places a copy of the page in a set of nodes at different locations and directs the client to use a nearby node as the server\n An example of the path that data follows when it is distributed by a CDN is shown in Fig\n  -  \n It is a tree\n The origin server in the CDN distributes a copy of the content to other nodes in the CDN  in Sydney  Boston  and Amsterdam  in this example\n This is shown with dashed lines\n Clients then fetch pages from the nearest node in the CDN\n This is shown with solid lines\n In this way  the clients in Sydney both fetch the page copy that is stored in Sydney; they do not both fetch the page from the origin server  which may be in Europe\n CDN origin server CDN node Sydney Boston Amsterdam Distribution to CDN nodes Page fetch Worldwide clients Figure  -  \n CDN distribution tree\n Using a tree structure has three virtues\n First  the content distribution can be scaled up to as many clients as needed by using more nodes in the CDN  and more levels in the tree when the distribution among CDN nodes becomes the bottleneck\n No matter how many clients there are  the tree structure is efficient\n The origin server is not overloaded because it talks to the many clients via the tree THE APPLICATION LAYER  \n  of CDN nodes; it does not have to answer each request for a page by itself\n ond  each client gets good performance by fetching pages from a nearby server instead of a distant server\n This is because the round-trip time for setting up a connection is shorter  TCP slow-start ramps up more quickly because of the shorter round-trip time  and the shorter network path is less likely to pass through regions of congestion in the Internet\n Finally  the total load that is placed on the network is also kept at a minimum\n If the CDN nodes are well placed  the traffic for a given page should pass over each part of the network only once\n This is important because someone pays for network bandwidth  eventually\n The idea of using a distribution tree is straightforward\n What is less simple is how to organize the clients to use this tree\n For example  proxy servers would seem to provide a solution\n Looking at Fig\n  -   if each client was configured to use the Sydney  Boston or Amsterdam CDN node as a caching Web proxy  the distribution would follow the tree\n However  this strategy falls short in practice  for three reasons\n The first reason is that the clients in a given part of the network probably belong to different organizations  so they are probably using different Web proxies\n Recall that caches are not usually shared across organizations because of the limited benefit of caching over a large number of clients  and for urity reasons too\n ond  there can be multiple CDNs  but each client uses only a single proxy cache\n Which CDN should a client use as its proxy? Finally  perhaps the most practical issue of all is that Web proxies are configured by clients\n They may or may not be configured to benefit content distribution by a CDN  and there is little that the CDN can do about it\n Another simple way to support a distribution tree with one level is to use mirroring\n In this approach  the origin server replicates content over the CDN nodes as before\n The CDN nodes in different network regions are called mirrors\n The Web pages on the origin server contain explicit links to the different mirrors  usually telling the user their location\n This design lets the user manually select a nearby mirror to use for downloading content\n A typical use of mirroring is to place a large software package on mirrors located in  for example  the East and West coasts of the  \n  Asia  and Europe\n Mirrored sites are generally completely static  and the choice of sites remains stable for months or years\n They are a tried and tested technique\n However  they depend on the user to do the distribution as the mirrors are really different Web sites  even if they are linked together\n The third approach  which overcomes the difficulties of the previous two approaches  uses DNS and is called DNS redirection\n Suppose that a client wants to fetch a page with the URL http:// / \n To fetch the page  the browser will use DNS to resolve   to an IP address\n This DNS lookup proceeds in the usual manner\n By using the DNS protocol  the browser learns the IP address of the name server for    then contacts the name server to ask it to resolve  \n Now comes the really clever bit\n The name server is run by the CDN\n Instead  of returning the same IP address for each request  it will look at the IP address of the client making the request and return   CONTENT DELIVERY different answers\n The answer will be the IP address of the CDN node that is nearest the client\n That is  if a client in Sydney asks the CDN name server to resolve    the name server will return the IP address of the Sydney CDN node  but if a client in Amsterdam makes the same request  the name server will return the IP address of the Amsterdam CDN node instead\n This strategy is perfectly legal according to the semantics of DNS\n We have previously seen that name servers may return changing lists of IP addresses\n After the name resolution  the Sydney client will fetch the page directly from the Sydney CDN node\n Further pages on the same ‘‘server’’ will be fetched directly from the Sydney CDN node as well because of DNS caching\n The overall sequence of steps is shown in Fig\n  -  \n CDN origin server  : Query DNS CDN DNS server Amsterdam CDN node Sydney CDN node  : “Contact Sydney” “Contact Amsterdam”  : Fetch page  : Distribute content Sydney clients Amsterdam clients Figure  -  \n Directing clients to nearby CDN nodes using DNS\n A complex question in the above process is what it means to find the nearest CDN node  and how to go about it\n To define nearest  it is not really geography that matters\n There are at least two factors to consider in mapping a client to a CDN node\n One factor is the network distance\n The client should have a short and high-capacity network path to the CDN node\n This situation will produce quick downloads\n CDNs use a map they have previously computed to translate between the IP address of a client and its network location\n The CDN node that is selected might be the one at the shortest distance as the crow flies  or it might not\n What matters is some combination of the length of the network path and any capacity limits along it\n The ond factor is the load that is already being carried by the CDN node\n If the CDN nodes are overloaded  they will deliver slow responses  just like the overloaded Web server that we sought to avoid in the first place\n Thus  it may be necessary to balance the load across the CDN nodes  mapping some clients to nodes that are slightly further away but more lightly loaded\n The techniques for using DNS for content distribution were pioneered by Akamai starting in  when the Web was groaning under the load of its early THE APPLICATION LAYER  \n  growth\n Akamai was the first major CDN and became the industry leader\n Probably even more clever than the idea of using DNS to connect clients to nearby nodes was the incentive structure of their business\n Companies pay Akamai to deliver their content to clients  so that they have responsive Web sites that customers like to use\n The CDN nodes must be placed at network locations with good connectivity  which initially meant inside ISP networks\n For the ISPs  there is a benefit to having a CDN node in their networks  namely that the CDN node cuts down the amount of upstream network bandwidth that they need (and must pay for)  just as with proxy caches\n In addition  the CDN node improves responsiveness for the ISP’s customers  which makes the ISP look good in their eyes  giving them a competitive advantage over ISPs that do not have a CDN node\n These benefits (at no cost to the ISP) makes installing a CDN node a no brainer for the ISP\n Thus  the content provider  the ISP  and the customers all benefit and the CDN makes money\n Since  other companies have gotten into the business  so it is now a competitive industry with multiple providers\n As this description implies  most companies do not build their own CDN\n Instead  they use the services of a CDN provider such as Akamai to actually deliver their content\n To let other companies use the service of a CDN  we need to add one last step to our picture\n After the contract is signed for a CDN to distribute content on behalf of a Web site owner  the owner gives the CDN the content\n This content is pushed to the CDN nodes\n In addition  the owner rewrites any of its Web pages that link to the content\n Instead of linking to the content on their Web site  the pages link to the content via the CDN\n As an example of how this scheme works  consider the source code for Fluffy Video’s Web page  given in Fig\n  -  (a)\n After preprocessing  it is transformed to Fig\n  -  (b) and placed on Fluffy Video’s server as  / \n When a user types in the URL   to his browser  DNS returns the IP address of Fluffy Video’s own Web site  allowing the main (HTML) page to be fetched in the normal way\n When the user clicks on any of the hyperlinks  the browser asks DNS to look up  \n This lookup contacts the CDN’s DNS server  which returns the IP address of the nearby CDN node\n The browser then sends a regular HTTP request to the CDN node  for example  for /fluffyvideo/ \n The URL identifies the page to return  starting the path with fluffyvideo so that the CDN node can separate requests for the different companies that it serves\n Finally  the video is returned and the user sees cute fluffy animals\n The strategy behind this split of content hosted by the CDN and entry pages hosted by the content owner is that it gives the content owner control while letting the CDN move the bulk of the data\n Most entry pages are tiny  being just HTML text\n These pages often link to large files  such as videos and images\n It is precisely these large files that are served by the CDN  even though the use of a CDN is completely transparent to users\n The site looks the same  but performs faster\n   CONTENT DELIVERY <html> <head> <title> Fluffy Video </title> </head> <body> <h > Fluffy Video’s Product List </h > <p> Click below for free samples\n </p> <a href=" "> Koalas Today </a> <br> <a href=" "> Funny Kangaroos </a> <br> <a href=" "> Nice Wombats </a> <br> </body> </html> (a) <html> <head> <title> Fluffy Video </title> </head> <body> <h > Fluffy Video’s Product List </h > <p> Click below for free samples\n </p> <a href="http:// /fluffyvideo/ "> Koalas Today </a> <br> <a href="http:// /fluffyvideo/ "> Funny Kangaroos </a> <br> <a href="http:// /fluffyvideo/ "> Nice Wombats </a> <br> </body> </html> (b) Figure  -  \n (a) Original Web page\n (b) Same page after linking to the CDN\n There is another advantage for sites using a shared CDN\n The future demand for a Web site can be difficult to predict\n Frequently  there are surges in demand known as flash crowds\n Such a surge may happen when the latest product is released  there is a fashion show or other event  or the company is otherwise in the news\n Even a Web site that was a previously unknown  unvisited backwater can suddenly become the focus of the Internet if it is newsworthy and linked from popular sites\n Since most sites are not prepared to handle massive increases in traffic  the result is that many of them crash when traffic surges\n Case in point\n Normally the Florida retary of State’s Web site is not a busy place  although you can look up information about Florida corporations  notaries  and cultural affairs  as well as information about voting and elections there\n For some odd reason  on Nov\n    (the date of the  \n presidential election with Bush vs\n Gore)  a whole lot of people were suddenly interested in the election results page of this site\n The site suddenly became one of the busiest Web sites in the world and naturally crashed as a result\n If it had been using a CDN  it would probably have survived\n By using a CDN  a site has access to a very large content-serving capacity\n The largest CDNs have tens of thousands of servers deployed in countries all over the world\n Since only a small number of sites will be experiencing a flash crowd THE APPLICATION LAYER  \n  at any one time (by definition)  those sites may use the CDN’s capacity to handle the load until the storm passes\n That is  the CDN can quickly scale up a site’s serving capacity\n The preceding discussion above is a simplified description of how Akamai works\n There are many more details that matter in practice\n The CDN nodes pictured in our example are normally clusters of machines\n DNS redirection is done with two levels: one to map clients to the approximate network location  and another to spread the load over nodes in that location\n Both reliability and performance are concerns\n To be able to shift a client from one machine in a cluster to another  DNS replies at the ond level are given with short TTLs so that the client will repeat the resolution after a short while\n Finally  while we have concentrated on distributing static objects like images and videos  CDNs can also support dynamic page creation  streaming media  and more\n For more information about CDNs  see Dilley et al\n (   )\n    Peer-to-Peer Networks Not everyone can set up a -node CDN at locations around the world to distribute their content\n (Actually  it is not hard to rent  virtual machines around the globe because of the well-developed and competitive hosting industry\n However  setting up a CDN only starts with getting the nodes\n) Luckily  there is an alternative for the rest of us that is simple to use and can distribute a tremendous amount of content\n It is a P P (Peer-to-Peer) network\n P P networks burst onto the scene starting in \n The first widespread application was for mass crime:   million Napster users were exchanging copyrighted songs without the copyright owners’ permission until Napster was shut down by the courts amid great controversy\n Nevertheless  peer-to-peer technology has many interesting and legal uses\n Other systems continued development  with such great interest from users that P P traffic quickly eclipsed Web traffic\n Today  BitTorrent is the most popular P P protocol\n It is used so widely to share (licensed and public domain) videos  as well as other content  that it accounts for a large fraction of all Internet traffic\n We will look at it in this tion\n The basic idea of a P P (Peer-to-Peer) file-sharing network is that many computers come together and pool their resources to form a content distribution system\n The computers are often simply home computers\n They do not need to be machines in Internet data centers\n The computers are called peers because each one can alternately act as a client to another peer  fetching its content  and as a server  providing content to other peers\n What makes peer-to-peer systems interesting is that there is no dedicated infrastructure  unlike in a CDN\n Everyone participates in the task of distributing content  and there is often no central point of control\n Many people are excited about P P technology because it is seen as empowering the little guy\n The reason is not only that it takes a large company to run a   CONTENT DELIVERY CDN  while anyone with a computer can join a P P network\n It is that P P networks have a formidable capacity to distribute content that can match the largest of Web sites\n Consider a P P network made up of N average users  each with broadband connectivity at  Mbps\n The aggregate upload capacity of the P P network  or rate at which the users can send traffic into the Internet  is N Mbps\n The download capacity  or rate at which the users can receive traffic  is also N Mbps\n Each user can upload and download at the same time  too  because they have a  -Mbps link in each direction\n It is not obvious that this should be true  but it turns out that all of the capacity can be used productively to distribute content  even for the case of sharing a single copy of a file with all the other users\n To see how this can be so  imagine that the users are organized into a binary tree  with each non-leaf user sending to two other users\n The tree will carry the single copy of the file to all the other users\n To use the upload bandwidth of as many users as possible at all times (and hence distribute the large file with low latency)  we need to pipeline the network activity of the users\n Imagine that the file is divided into  pieces\n Each user can receive a new piece from somewhere up the tree and send the previously received piece down the tree at the same time\n This way  once the pipeline is started  after a small number of pieces (equal to the depth of the tree) are sent  all non-leaf users will be busy uploading the file to other users\n Since there are approximately N/  non-leaf users  the upload bandwidth of this tree is N/  Mbps\n We can repeat this trick and create another tree that uses the other N/  Mbps of upload bandwidth by swapping the roles of leaf and non-leaf nodes\n Together  this construction uses all of the capacity\n This argument means that P P networks are self-scaling\n Their usable upload capacity grows in tandem with the download demands that can be made by their users\n They are always ‘‘large enough’’ in some sense  without the need for any dedicated infrastructure\n In contrast  the capacity of even a large Web site is fixed and will either be too large or too small\n Consider a site with only clusters  each capable of   Gbps\n This enormous capacity does not help when there are a small number of users\n The site cannot get information to N users at a rate faster than N Mbps because the limit is at the users and not the Web site\n And when there are more than one million  -Mbps users  the Web site cannot pump out data fast enough to keep all the users busy downloading\n That may seem like a large number of users  but large BitTorrent networks ( \n  Pirate Bay) claim to have more than   users\n That is more like   terabits/ in terms of our example! You should take these back-of-the-envelope numbers with a grain (or better yet  a metric ton) of salt because they oversimplify the situation\n A significant challenge for P P networks is to use bandwidth well when users can come in all shapes and sizes  and have different download and upload capacities\n Nevertheless  these numbers do indicate the enormous potential of P P\n THE APPLICATION LAYER  \n  There is another reason that P P networks are important\n CDNs and other centrally run services put the providers in a position of having a trove of personal information about many users  from browsing preferences and where people shop online  to people’s locations and email addresses\n This information can be used to provide better  more personalized service  or it can be used to intrude on people’s privacy\n The latter may happen either intentionally—say as part of a new product— or through an accidental disclosure or compromise\n With P P systems  there can be no single provider that is capable of monitoring the entire system\n This does not mean that P P systems will necessarily provide privacy  as users are trusting each other to some extent\n It only means that they can provide a different form of privacy than centrally managed systems\n P P systems are now being explored for services beyond file sharing ( \n  storage  streaming)  and time will tell whether this advantage is significant\n P P technology has followed two related paths as it has been developed\n On the more practical side  there are the systems that are used every day\n The most well known of these systems are based on the BitTorrent protocol\n On the more academic side  there has been intense interest in DHT (Distributed Hash Table) algorithms that let P P systems perform well as a whole  yet rely on no centralized components at all\n We will look at both of these technologies\n BitTorrent The BitTorrent protocol was developed by Brahm Cohen in  to let a set of peers share files quickly and easily\n There are dozens of freely available clients that speak this protocol  just as there are many browsers that speak the HTTP protocol to Web servers\n The protocol is available as an open standard at  \n In a typical peer-to-peer system  like that formed with BitTorrent  the users each have some information that may be of interest to other users\n This information may be free software  music  videos  photographs  and so on\n There are three problems that need to be solved to share content in this setting:  \n How does a peer find other peers that have the content it wants to download?  \n How is content replicated by peers to provide high-speed downloads for everyone?  \n How do peers encourage each other to upload content to others as well as download content for themselves? The first problem exists because not all peers will have all of the content  at least initially\n The approach taken in BitTorrent is for every content provider to create a content description called a torrent\n The torrent is much smaller than the   CONTENT DELIVERY content  and is used by a peer to verify the integrity of the data that it downloads from other peers\n Other users who want to download the content must first obtain the torrent  say  by finding it on a Web page advertising the content\n The torrent is just a file in a specified format that contains two key kinds of information\n One kind is the name of a tracker  which is a server that leads peers to the content of the torrent\n The other kind of information is a list of equal-sized pieces  or chunks  that make up the content\n Different chunk sizes can be used for different torrents  typically   KB to KB\n The torrent file contains the name of each chunk  given as a   -bit SHA-  hash of the chunk\n We will cover cryptographic hashes such as SHA-  in   For now  you can think of a hash as a longer and more ure checksum\n Given the size of chunks and hashes  the torrent file is at least three orders of magnitude smaller than the content  so it can be transferred quickly\n To download the content described in a torrent  a peer first contacts the tracker for the torrent\n The tracker is a server that maintains a list of all the other peers that are actively downloading and uploading the content\n This set of peers is called a swarm\n The members of the swarm contact the tracker regularly to report that they are still active  as well as when they leave the swarm\n When a new peer contacts the tracker to join the swarm  the tracker tells it about other peers in the swarm\n Getting the torrent and contacting the tracker are the first two steps for downloading content  as shown in Fig\n  -  \n Seed peer Unchoked peers Tracker Torrent Peer  : Get torrent metafile  : Get peers from tracker  : Trade chunks with peers Source of content Figure  -  \n BitTorrent\n The ond problem is how to share content in a way that gives rapid downloads\n When a swarm is first formed  some peers must have all of the chunks that make up the content\n These peers are called seeders\n Other peers that join the swarm will have no chunks; they are the peers that are downloading the content\n While a peer participates in a swarm  it simultaneously downloads chunks that it is missing from other peers  and uploads chunks that it has to other peers who THE APPLICATION LAYER  \n  need them\n This trading is shown as the last step of content distribution in Fig\n  -  \n Over time  the peer gathers more chunks until it has downloaded all of the content\n The peer can leave the swarm (and return) at any time\n Normally a peer will stay for a short period after finishes its own download\n With peers coming and going  the rate of churn in a swarm can be quite high\n For the above method to work well  each chunk should be available at many peers\n If everyone were to get the chunks in the same order  it is likely that many peers would depend on the seeders for the next chunk\n This would create a bottleneck\n Instead  peers exchange lists of the chunks they have with each other\n Then they select rare chunks that are hard to find to download\n The idea is that downloading a rare chunk will make a copy of it  which will make the chunk easier for other peers to find and download\n If all peers do this  after a short while all chunks will be widely available\n The third problem is perhaps the most interesting\n CDN nodes are set up exclusively to provide content to users\n P P nodes are not\n They are users’ computers  and the users may be more interested in getting a movie than helping other users with their downloads\n Nodes that take resources from a system without contributing in kind are called free-riders or leechers\n If there are too many of them  the system will not function well\n Earlier P P systems were known to host them (Saroiu et al\n  ) so BitTorrent sought to minimize them\n The approach taken in BitTorrent clients is to reward peers who show good upload behavior\n Each peer randomly samples the other peers  retrieving chunks from them while it uploads chunks to them\n The peer continues to trade chunks with only a small number of peers that provide the highest download performance  while also randomly trying other peers to find good partners\n Randomly trying peers also allows newcomers to obtain initial chunks that they can trade with other peers\n The peers with which a node is currently exchanging chunks are said to be unchoked\n Over time  this algorithm is intended to match peers with comparable upload and download rates with each other\n The more a peer is contributing to the other peers  the more it can expect in return\n Using a set of peers also helps to saturate a peer’s download bandwidth for high performance\n Conversely  if a peer is not uploading chunks to other peers  or is doing so very slowly  it will be cut off  or choked  sooner or later\n This strategy discourages antisocial behavior in which peers free-ride on the swarm\n The choking algorithm is sometimes described as implementing the tit-for-tat strategy that encourages cooperation in repeated interactions\n However  it does not prevent clients from gaming the system in any strong sense (Piatek et al\n  )\n Nonetheless  attention to the issue and mechanisms that make it more difficult for casual users to free-ride have likely contributed to the success of Bit- Torrent\n As you can see from our discussion  BitTorrent comes with a rich vocabulary\n There are torrents  swarms  leechers  seeders  and trackers  as well as snubbing    CONTENT DELIVERY choking  lurking  and more\n For more information see the short paper on Bit- Torrent (Cohen  ) and look on the Web starting with  \n DHTs—Distributed Hash Tables The emergence of P P file sharing networks around  sparked much interest in the research community\n The essence of P P systems is that they avoid the centrally managed structures of CDNs and other systems\n This can be a significant advantage\n Centrally managed components become a bottleneck as the system grows very large and are a single point of failure\n Central components can also be used as a point of control ( \n  to shut off the P P network)\n However  the early P P systems were only partly decentralized  or  if they were fully decentralized  they were inefficient\n The traditional form of BitTorrent that we just described uses peer-to-peer transfers and a centralized tracker for each swarm\n It is the tracker that turns out to be the hard part to decentralize in a peer-to-peer system\n The key problem is how to find out which peers have specific content that is being sought\n For example  each user might have one or more data items such as songs  photographs  programs  files  and so on that other users might want to read\n How do the other users find them? Making one index of who has what is simple  but it is centralized\n Having every peer keep its own index does not help\n True  it is distributed\n However  it requires so much work to keep the indexes of all peers up to date (as content is moved about the system) that it is not worth the effort\n The question tackled by the research community was whether it was possible to build P P indexes that were entirely distributed but performed well\n By perform well  we mean three things\n First  each node keeps only a small amount of information about other nodes\n This property means that it will not be expensive to keep the index up to date\n ond  each node can look up entries in the index quickly\n Otherwise  it is not a very useful index\n Third  each node can use the index at the same time  even as other nodes come and go\n This property means the performance of the index grows with the number of nodes\n The answer is to the question was: ‘‘Yes\n’’ Four different solutions were invented in \n They are Chord (Stoica et al\n  )  CAN (Ratnasamy et al\n  )  Pastry (Rowstron and Druschel  )  and Tapestry (Zhao et al\n  )\n Other solutions were invented soon afterwards  including Kademlia  which is used in practice (Maymounkov and Mazieres  )\n The solutions are known as DHTs (Distributed Hash Tables) because the basic functionality of an index is to map a key to a value\n This is like a hash table  and the solutions are distributed versions  of course\n DHTs do their work by imposing a regular structure on the communication between the nodes  as we will see\n This behavior is quite different than that of traditional P P networks that use whatever connections peers happen to make\n THE APPLICATION LAYER  \n  For this reason  DHTs are called structured P P networks\n Traditional P P protocols build unstructured P P networks\n The DHT solution that we will describe is Chord\n As a scenario  consider how to replace the centralized tracker traditionally used in BitTorrent with a fully-distributed tracker\n Chord can be used to solve this problem\n In this scenario  the overall index is a listing of all of the swarms that a computer may join to download content\n The key used to look up the index is the torrent description of the content\n It uniquely identifies a swarm from which content can be downloaded as the hashes of all the content chunks\n The value stored in the index for each key is the list of peers that comprise the swarm\n These peers are the computers to contact to download the content\n A person wanting to download content such as a movie has only the torrent description\n The question the DHT must answer is how  lacking a central database  does a person find out which peers (out of the millions of BitTorrent nodes) to download the movie from? A Chord DHT consists of n participating nodes\n They are nodes running Bit- Torrent in our scenario\n Each node has an IP address by which it may be contacted\n The overall index is spread across the nodes\n This implies that each node stores bits and pieces of the index for use by other nodes\n The key part of Chord is that it navigates the index using identifiers in a virtual space  not the IP addresses of nodes or the names of content like movies\n Conceptually  the identifiers are simply m-bit numbers that can be arranged in ascending order into a ring\n To turn a node address into an identifier  it is mapped to an m-bit number using a hash function  hash\n Chord uses SHA-  for hash\n This is the same hash that we mentioned when describing BitTorrent\n We will look at it when we discuss cryptography in   For now  suffice it to say that it is just a function that takes a variable-length byte string as an argument and produces a highly random   -bit number\n Thus  we can use it to convert any IP address to a   -bit number called the node identifier\n In Fig\n  -  (a)  we show the node identifier circle for m =  \n (Just ignore the arcs in the middle for the moment\n) Some of the identifiers correspond to nodes  but most do not\n In this example  the nodes with identifiers    and   correspond to actual nodes and are shaded in the figure; the rest do not exist\n Let us now define the function successor(k) as the node identifier of the first actual node following k around the circle  clockwise\n For example  successor ( ) =   successor ( ) = and successor (  ) =  \n A key is also produced by hashing a content name with hash ( \n  SHA- ) to generate a   -bit number\n In our scenario  the content name is the torrent\n Thus  in order to convert torrent (the torrent description file) to its key  we compute key = hash(torrent )\n This computation is just a local procedure call to hash\n To start a new a swarm  a node needs to insert a new key-value pair consisting of (torrent  my-IP-address) into the index\n To accomplish this  the node asks successor(hash(torrent )) to store my-IP-address\n In this way  the index is distributed over the nodes at random\n For fault tolerance  p different hash functions   CONTENT DELIVERY                    Node  's finger table   Start IP addr of successor    Node  's finger table    Start IP addr of successor    Node  's finger table    Start IP addr of successor (a) (b) Node identifier Actual node Figure  -  \n (a) A set of   node identifiers arranged in a circle\n The shaded ones correspond to actual machines\n The arcs show the fingers from nodes  and  \n The labels on the arcs are the table indices\n (b) Examples of the finger tables\n could be used to store the data at p nodes  but we will not consider the subject of fault tolerance further here\n Some time after the DHT is constructed  another node wants to find a torrent so that it can join the swarm and download content\n A node looks up torrent by first hashing it to get key  and ond using successor (key) to find the IP address of the node storing the corresponding value\n The value is the list of peers in the swarm; the node can add its IP address to the list and contact the other peers to download content with the BitTorrent protocol\n The first step is easy; the ond one is not easy\n To make it possible to find the IP address of the node corresponding to a certain key  each node is required to THE APPLICATION LAYER  \n  maintain certain administrative data structures\n One of these is the IP address of its successor node along the node identifier circle\n For example  in Fig\n  -   node  ’s successor is  and node  ’s successor is  \n Lookup can now proceed as follows\n The requesting node sends a packet to its successor containing its IP address and the key it is looking for\n The packet is propagated around the ring until it locates the successor to the node identifier being sought\n That node checks to see if it has any information matching the key  and if so  returns it directly to the requesting node  whose IP address it has\n However  linearly searching all the nodes is very inefficient in a large peerto- peer system since the mean number of nodes required per search is n/ \n To greatly speed up the search  each node also maintains what Chord calls a finger table\n The finger table has m entries  indexed by  through m −   each one pointing to a different actual node\n Each of the entries has two fields: start and the IP address of successor(start )  as shown for three example nodes in Fig\n  -  (b)\n The values of the fields for entry i at a node with identifier k are: start = k +  i (modulo  m) IP address of successor(start [i ]) Note that each node stores the IP addresses of a relatively small number of nodes and that most of these are fairly close by in terms of node identifier\n Using the finger table  the lookup of key at node k proceeds as follows\n If key falls between k and successor (k)  the node holding information about key is successor (k) and the search terminates\n Otherwise  the finger table is searched to find the entry whose start field is the closest predecessor of key\n A request is then sent directly to the IP address in that finger table entry to ask it to continue the search\n Since it is closer to key but still below it  chances are good that it will be able to return the answer with only a small number of additional queries\n In fact  since every lookup halves the remaining distance to the target  it can be shown that the average number of lookups is log n\n As a first example  consider looking up key =  at node  \n Since node  knows that  lies between it and its successor the desired node is  and the search terminates  returning node  ’s IP address\n As a ond example  consider looking up key =   at node  \n Since   does not lie between  and   the finger table is consulted\n The closest predecessor to   is   so the request is forwarded to the IP address of  ’s entry  namely  that of node  \n Node   also does not know the answer itself  so it looks for the node most closely preceding   and finds which yields the IP address of node  \n A query is then sent there\n Node   observes that   lies between it and its successor (  )  so it returns the IP address of   to the caller  which works its way back to node  \n Since nodes join and leave all the time  Chord needs a way to handle these operations\n We assume that when the system began operation it was small enough that the nodes could just exchange information directly to build the first circle and   CONTENT DELIVERY finger tables\n After that  an automated procedure is needed\n When a new node  r  wants to join  it must contact some existing node and ask it to look up the IP address of successor (r) for it\n Next  the new node then asks successor (r) for its predecessor\n The new node then asks both of these to insert r in between them in the circle\n For example  if   in Fig\n  -  wants to join  it asks any node to look up successor (  )  which is  \n Then it asks   for its predecessor (  )\n After it tells both of those about its existence uses   as its successor and   uses   as its predecessor\n In addition  node   hands over those keys in the range  –   which now belong to  \n At this point is fully inserted\n However  many finger tables are now wrong\n To correct them  every node runs a background process that periodically recomputes each finger by calling successor\n When one of these queries hits a new node  the corresponding finger entry is updated\n When a node leaves gracefully  it hands its keys over to its successor and informs its predecessor of its departure so the predecessor can link to the departing node’s successor\n When a node crashes  a problem arises because its predecessor no longer has a valid successor\n To alleviate this problem  each node keeps track not only of its direct successor but also its s direct successors  to allow it to skip over up to s −  conutive failed nodes and reconnect the circle if disaster strikes\n There has been a tremendous amount of research on DHTs since they were invented\n To give you an idea of just how much research  let us pose a question: what is the most-cited networking paper of all time? You will find it difficult to come up with a paper that is cited more than the seminal Chord paper (Stoica et al\n  )\n Despite this veritable mountain of research  applications of DHTs are only slowly beginning to emerge\n Some BitTorrent clients use DHTs to provide a fully distributed tracker of the kind that we described\n Large commercial cloud services such as Amazon’s Dynamo also incorporate DHT techniques (DeCandia et al\n  )  SUMMARY Naming in the ARPANET started out in a very simple way: an ASCII text file listed the names of all the hosts and their corresponding IP addresses\n Every night all the machines downloaded this file\n But when the ARPANET morphed into the Internet and exploded in size  a far more sophisticated and dynamic naming scheme was required\n The one used now is a hierarchical scheme called the Domain Name System\n It organizes all the machines on the Internet into a set of trees\n At the top level are the well-known generic domains  including com and edu  as well as about country domains\n DNS is implemented as a distributed database with servers all over the world\n By querying a DNS server  a process THE APPLICATION LAYER  \n  can map an Internet domain name onto the IP address used to communicate with a computer for that domain\n Email is the original killer app of the Internet\n It is still widely used by everyone from small children to grandparents\n Most email systems in the world use the mail system now defined in RFCs  and \n Messages have simple ASCII headers  and many kinds of content can be sent using MIME\n Mail is submitted to message transfer agents for delivery and retrieved from them for presentation by a variety of user agents  including Web applications\n Submitted mail is delivered using SMTP  which works by making a TCP connection from the sending message transfer agent to the receiving one\n The Web is the application that most people think of as being the Internet\n Originally  it was a system for seamlessly linking hypertext pages (written in HTML) across machines\n The pages are downloaded by making a TCP connection from the browser to a server and using HTTP\n Nowadays  much of the content on the Web is produced dynamically  either at the server ( \n  with PHP) or in the browser ( \n  with JavaScript)\n When combined with back-end databases  dynamic server pages allow Web applications such as e-commerce and search\n Dynamic browser pages are evolving into full-featured applications  such as email  that run inside the browser and use the Web protocols to communicate with remote servers\n Caching and persistent connections are widely used to enhance Web performance\n Using the Web on mobile devices can be challenging  despite the growth in the bandwidth and processing power of mobiles\n Web sites often send tailored versions of pages with smaller images and less complex navigation to devices with small displays\n The Web protocols are increasingly being used for machine-to-machine communication\n XML is preferred to HTML as a description of content that is easy for machines to process\n SOAP is an RPC mechanism that sends XML messages using HTTP\n Digital audio and video have been key drivers for the Internet since \n The majority of Internet traffic today is video\n Much of it is streamed from Web sites over a mix of protocols (including RTP/UDP and RTP/HTTP/TCP)\n Live media is streamed to many consumers\n It includes Internet radio and TV stations that broadcast all manner of events\n Audio and video are also used for real-time conferencing\n Many calls use voice over IP  rather than the traditional telephone network  and include videoconferencing\n There are a small number of tremendously popular Web sites  as well as a very large number of less popular ones\n To serve the popular sites  content distribution networks have been deployed\n CDNs use DNS to direct clients to a nearby server; the servers are placed in data centers all around the world\n Alternatively  P P networks let a collection of machines share content such as movies among themselves\n They provide a content distribution capacity that scales with the number of machines in the P P network and which can rival the largest of sites  PROBLEMS PROBLEMS  \n Many business computers have three distinct and worldwide unique identifiers\n What are they?  \n In Fig\n  -  there is no period after laserjet\n Why not?  \n Consider a situation in which a cyberterrorist makes all the DNS servers in the world crash simultaneously\n How does this change one’s ability to use the Internet?  \n DNS uses UDP instead of TCP\n If a DNS packet is lost  there is no automatic recovery\n Does this cause a problem  and if so  how is it solved?  \n John wants to have an original domain name and uses a randomized program to generate a ondary domain name for him\n He wants to register this domain name in the com generic domain\n The domain name that was generated is characters long\n Will the com registrar allow this domain name to be registered?  \n Can a machine with a single DNS name have multiple IP addresses? How could this occur?  \n The number of companies with a Web site has grown explosively in recent years\n As a result  thousands of companies are registered in the com domain  causing a heavy load on the top-level server for this domain\n Suggest a way to alleviate this problem without changing the naming scheme ( \n  without introducing new top-level domain names)\n It is permitted that your solution requires changes to the client code Some email systems support a Content Return: header field\n It specifies whether the body of a message is to be returned in the event of nondelivery\n Does this field belong to the envelope or to the header?  \n Electronic mail systems need directories so people’s email addresses can be looked up\n To build such directories  names should be broken up into standard components ( \n  first name  last name) to make searching possible\n Discuss some problems that must be solved for a worldwide standard to be acceptable A large law firm  which has many employees  provides a single email address for each employee\n Each employee’s email address is <login>@ \n However  the firm did not explicitly define the format of the login\n Thus  some employees use their first names as their login names  some use their last names  some use their initials  etc\n The firm now wishes to make a fixed format  for example:  @   that can be used for the email addresses of all its employees\n How can this be done without rocking the boat too much?  \n A binary file is  bytes long\n How long will it be if encoded using base  encoding  with a CR+LF pair inserted after every bytes sent and at the end?  \n Name five MIME types not listed in this book\n You can check your browser or the Internet for information\n PROBLEMS   Suppose that you want to send an MP  file to a friend  but your friend’s ISP limits the size of each incoming message to  MB and the MP  file is  MB\n Is there a way to handle this situation by using RFC  and MIME?  \n Suppose that John just set up an auto-forwarding mechanism on his work email address  which receives all of his business-related emails  to forward them to his personal email address  which he shares with his wife\n John’s wife was unaware of this  and activated a vacation agent on their personal account\n Because John forwarded his email  he did not set up a vacation daemon on his work machine\n What happens when an email is received at John’s work email address?  \n In any standard  such as RFC  a precise grammar of what is allowed is needed so that different implementations can interwork\n Even simple items have to be defined carefully\n The SMTP headers allow white space between the tokens\n Give two plausible alternative definitions of white space between tokens Is the vacation agent part of the user agent or the message transfer agent? Of course  it is set up using the user agent  but does the user agent actually send the replies? Explain your answer In a simple version of the Chord algorithm for peer-to-peer lookup  searches do not use the finger table\n Instead  they are linear around the circle  in either direction\n Can a node accurately predict which direction it should search in? Discuss your answer IMAP allows users to fetch and download email from a remote mailbox\n Does this mean that the internal format of mailboxes has to be standardized so any IMAP program on the client side can read the mailbox on any mail server? Discuss your answer Consider the Chord circle of Fig\n  -  \n Suppose that node   suddenly goes online\n Which of the finger tables shown in the figure are affected? how?  \n Does Webmail use POP  IMAP  or neither? If one of these  why was that one chosen? If neither  which one is it closer to in spirit?  \n When Web pages are sent out  they are prefixed by MIME headers\n Why?  \n Is it possible that when a user clicks on a link with Firefox  a particular helper is started  but clicking on the same link in Internet Explorer causes a completely different helper to be started  even though the MIME type returned in both cases is identical? Explain your answer Although it was not mentioned in the text  an alternative form for a URL is to use the IP address instead of its DNS name\n Use this information to explain why a DNS name cannot end with a digit Imagine that someone in the math department at Stanford has just written a new document including a proof that he wants to distribute by FTP for his colleagues to review\n He puts the program in the FTP directory ftp/pub/forReview/ \n What is the URL for this program likely to be?  \n In Fig\n  -     keeps track of user preferences in a cookie\n A disadvantage of this scheme is that cookies are limited to  KB  so if the preferences are  \n  PROBLEMS extensive  for example  many stocks  sports teams  types of news stories  weather for multiple cities  specials in numerous product categories  and more  the  -KB limit may be reached\n Design an alternative way to keep track of preferences that does not have this problem Sloth Bank wants to make online banking easy for its lazy customers  so after a customer signs up and is authenticated by a password  the bank returns a cookie containing a customer ID number\n In this way  the customer does not have to identify himself or type a password on future visits to the online bank\n What do you think of this idea? Will it work? Is it a good idea?  \n (a) Consider the following HTML tag: <h  title=‘‘this is the header’’> HEADER  </h > Under what conditions does the browser use the TITLE attribute  and how? (b) How does the TITLE attribute differ from the ALT attribute?  \n How do you make an image clickable in HTML? Give an example Write an HTML page that includes a link to the email address username@DomainName\n com\n What happens when a user clicks this link?  \n Write an XML page for a university registrar listing multiple students  each having a name  an address  and a GPA For each of the following applications  tell whether it would be ( ) possible and ( ) better to use a PHP script or JavaScript  and why: (a) Displaying a calendar for any requested month since September \n (b) Displaying the schedule of flights from Amsterdam to New York\n (c) Graphing a polynomial from user-supplied coefficients Write a program in JavaScript that accepts an integer greater than  and tells whether it is a prime number\n Note that JavaScript has if and while statements with the same syntax as C and Java\n The modulo operator is %\n If you need the square root of x  use   (x) An HTML page is as follows: <html> <body> <a href=" - / "> Click here for info </a> </body> </html> If the user clicks on the hyperlink  a TCP connection is opened and a series of lines is sent to the server\n List all the lines sent The If-Modified-Since header can be used to check whether a cached page is still valid\n Requests can be made for pages containing images  sound  video  and so on  as well as HTML\n Do you think the effectiveness of this technique is better or worse for JPEG images as compared to HTML? Think carefully about what ‘‘effectiveness’’ means and explain your answer On the day of a major sporting event  such as the championship game in some popular sport  many people go to the official Web site\n Is this a flash crowd in the same sense as the  Florida presidential election? Why or why not? PROBLEMS   Does it make sense for a single ISP to function as a CDN? If so  how would that work? If not  what is wrong with the idea?  \n Assume that compression is not used for audio CDs\n How many MB of data must the compact disc contain in order to be able to play two hours of music?  \n In Fig\n  -  (c)  quantization noise occurs due to the use of  -bit samples to represent nine signal values\n The first sample  at   is exact  but the next few are not\n What is the percent error for the samples at  / /   and  /  of the period?  \n Could a psychoacoustic model be used to reduce the bandwidth needed for Internet telephony? If so  what conditions  if any  would have to be met to make it work? If not  why not?  \n An audio streaming server has a one-way ‘‘distance’’ of m to a media player\n It outputs at  Mbps\n If the media player has a  -MB buffer  what can you say about the position of the low-water mark and the high-water mark?  \n Does voice over IP have the same problems with firewalls that streaming audio does? Discuss your answer What is the bit rate for transmitting uncompressed  × pixel color frames with   bits/pixel at   frames/?  \n Can a  -bit error in an MPEG frame affect more than the frame in which the error occurs? Explain your answer Consider a  -customer video server  where each customer watches three movies per month\n Two-thirds of the movies are served at   \n How many movies does the server have to transmit at once during this time period? If each movie requires  Mbps  how many OC-  connections does the server need to the network?  \n Suppose that Zipf’s law holds for accesses to a  -movie video server\n If the server holds the most popular  movies in memory and the remaining  on disk  give an expression for the fraction of all references that will be to memory\n Write a little program to evaluate this expression numerically Some cybersquatters have registered domain names that are misspellings of common corporate sites  for example   \n Make a list of at least five such domains Numerous people have registered DNS names that consist of    where word is a common word\n For each of the following categories  list five such Web sites and briefly summarize what it is ( \n    belongs to a gastroenterologist on Long Island)\n Here is the list of categories: animals  foods  household objects  and body parts\n For the last category  please stick to body parts above the waist Rewrite the server of Fig\n  -  as a true Web server using the GET command for HTTP   It should also accept the Host message\n The server should maintain a cache of files recently fetched from the disk and serve requests from the cache when possible\n  NETWORK URITY For the first few decades of their existence  computer networks were primarily used by university researchers for sending email and by corporate employees for sharing printers\n Under these conditions  urity did not get a lot of attention\n But now  as millions of ordinary citizens are using networks for banking  shopping  and filing their tax returns  and weakness after weakness has been found  network urity has become a problem of massive proportions\n In this  ter  we will study network urity from several angles  point out numerous pitfalls  and discuss many algorithms and protocols for making networks more ure\n urity is a broad topic and covers a multitude of sins\n In its simplest form  it is concerned with making sure that nosy people cannot read  or worse yet  retly modify messages intended for other recipients\n It is concerned with people trying to access remote services that they are not authorized to use\n It also deals with ways to tell whether that message purportedly from the IRS ‘‘Pay by Friday  or else’’ is really from the IRS and not from the Mafia\n urity also deals with the problems of legitimate messages being captured and replayed  and with people later trying to deny that they sent certain messages\n Most urity problems are intentionally caused by malicious people trying to gain some benefit  get attention  or harm someone\n A few of the most common perpetrators are listed in Fig\n  - \n It should be clear from this list that making a network ure involves a lot more than just keeping it free of programming errors\n It involves outsmarting often intelligent  dedicated  and sometimes wellfunded adversaries\n It should also be clear that measures that will thwart casual    NETWORK URITY  \n  attackers will have little impact on the serious ones\n Police records show that the most damaging attacks are not perpetrated by outsiders tapping a phone line but by insiders bearing a grudge\n urity systems should be designed accordingly\n Adversary Goal Student To have fun snooping on people’s email Cracker To test out someone’s urity system; steal data Sales rep To claim to represent all of Europe  not just Andorra Corporation To discover a competitor’s strategic marketing plan Ex-employee To get revenge for being fired Accountant To embezzle money from a company Stockbroker To deny a promise made to a customer by email Identity thief To steal credit card numbers for sale Government To learn an enemy’s military or industrial rets Terrorist To steal biological warfare rets Figure  - \n Some people who may cause urity problems  and why\n Network urity problems can be divided roughly into four closely intertwined areas: recy  authentication  nonrepudiation  and integrity control\n recy  also called confidentiality  has to do with keeping information out of the grubby little hands of unauthorized users\n This is what usually comes to mind when people think about network urity\n Authentication deals with determining whom you are talking to before revealing sensitive information or entering into a business deal\n Nonrepudiation deals with signatures: how do you prove that your customer really placed an electronic order for ten million left-handed doohickeys at   cents each when he later claims the price was   cents? Or maybe he claims he never placed any order\n Finally  integrity control has to do with how you can be sure that a message you received was really the one sent and not something that a malicious adversary modified in transit or concocted\n All these issues (recy  authentication  nonrepudiation  and integrity control) occur in traditional systems  too  but with some significant differences\n Integrity and recy are achieved by using registered mail and locking documents up\n Robbing the mail train is harder now than it was in Jesse James’ day\n Also  people can usually tell the difference between an original paper document and a photocopy  and it often matters to them\n As a test  make a photocopy of a valid check\n Try cashing the original check at your bank on Monday\n Now try cashing the photocopy of the check on Tuesday\n Observe the difference in the bank’s behavior\n With electronic checks  the original and the copy are indistinguishable\n It may take a while for banks to learn how to handle this\n People authenticate other people by various means  including recognizing their faces  voices  and handwriting\n Proof of signing is handled by signatures on letterhead paper  raised seals  and so on\n Tampering can usually be detected by handwriting  ink  and paper experts\n None of these options are available electronically\n Clearly  other solutions are needed\n Before getting into the solutions themselves  it is worth spending a few moments considering where in the protocol stack network urity belongs\n There is probably no one single place\n Every layer has something to contribute\n In the physical layer  wiretapping can be foiled by enclosing transmission lines (or better yet  optical fibers) in sealed tubes containing an inert gas at high pressure\n Any attempt to drill into a tube will release some gas  reducing the pressure and triggering an alarm\n Some military systems use this technique\n In the data link layer  packets on a point-to-point line can be encrypted as they leave one machine and decrypted as they enter another\n All the details can be handled in the data link layer  with higher layers oblivious to what is going on\n This solution breaks down when packets have to traverse multiple routers  however  because packets have to be decrypted at each router  leaving them vulnerable to attacks from within the router\n Also  it does not allow some sessions to be protected ( \n  those involving online purchases by credit card) and others not\n Nevertheless  link encryption  as this method is called  can be added to any network easily and is often useful\n In the network layer  firewalls can be installed to keep good packets and bad packets out\n IP urity also functions in this layer\n In the transport layer  entire connections can be encrypted end to end  that is  process to process\n For maximum urity  end-to-end urity is required\n Finally  issues such as user authentication and nonrepudiation can only be handled in the application layer\n Since urity does not fit neatly into any layer  it does not fit into any  ter of this book\n For this reason  it rates its own  ter\n While this  ter is long  technical  and essential  it is also quasi-irrelevant for the moment\n It is well documented that most urity failures at banks  for example  are due to lax urity procedures and incompetent employees  numerous implementation bugs that enable remote break-ins by unauthorized users  and socalled social engineering attacks  where customers are tricked into revealing their account details\n All of these urity problems are more prevalent than clever criminals tapping phone lines and then decoding encrypted messages\n If a person can walk into a random branch of a bank with an ATM slip he found on the street claiming to have forgotten his PIN and get a new one on the spot (in the name of good customer relations)  all the cryptography in the world will not prevent abuse\n In this respect  Ross Anderson’s (   a) book is a real eye-opener  as it documents hundreds of examples of urity failures in numerous industries  nearly all of them due to what might politely be called sloppy business practices or inattention to urity\n Nevertheless  the technical foundation on which e-commerce is built when all of these other factors are done well is cryptography\n Except for physical layer urity  nearly all network urity is based on cryptographic principles\n For this reason  we will begin our study of urity by NETWORK URITY  \n  examining cryptography in some detail\n In   we will look at some of the basic principles\n In \n  -  through \n  -  we will examine some of the fundamental algorithms and data structures used in cryptography\n Then we will examine in detail how these concepts can be used to achieve urity in networks\n We will conclude with some brief thoughts about technology and society\n Before starting  one last thought is in order: what is not covered\n We have tried to focus on networking issues  rather than operating system and application issues  although the line is often hard to draw\n For example  there is nothing here about user authentication using biometrics  password urity  buffer overflow attacks  Trojan horses  login spoofing  code injection such as cross-site scripting  viruses  worms  and the like\n All of these topics are covered at length in  \n  of Modern Operating Systems (Tanenbaum  )\n The interested reader is referred to that book for the systems aspects of urity\n Now let us begin our journey  CRYPTOGRAPHY Cryptography comes from the Greek words for ‘‘ret writing\n’’ It has a long and colorful history going back thousands of years\n In this tion  we will just sketch some of the highlights  as background information for what follows\n For a complete history of cryptography  Kahn’s (   ) book is recommended reading\n For a comprehensive treatment of modern urity and cryptographic algorithms  protocols  and applications  and related material  see Kaufman et al\n (   )\n For a more mathematical approach  see Stinson (   )\n For a less mathematical approach  see Burnett and Paine (   )\n Professionals make a distinction between ciphers and codes\n A cipher is a character-for-character or bit-for-bit transformation  without regard to the linguistic structure of the message\n In contrast  a code replaces one word with another word or symbol\n Codes are not used any more  although they have a glorious history\n The most successful code ever devised was used by the  \n armed forces during World War II in the Pacific\n They simply had Navajo Indians talking to each other using specific Navajo words for military terms  for example chay-dagahi- nail-tsaidi (literally: tortoise killer) for antitank weapon\n The Navajo language is highly tonal  exceedingly complex  and has no written form\n And not a single person in Japan knew anything about it\n In September  the San Diego Union described the code by saying ‘‘For three years  wherever the Marines landed  the Japanese got an earful of strange gurgling noises interspersed with other sounds resembling the call of a Tibetan monk and the sound of a hot water bottle being emptied\n’’ The Japanese never broke the code and many Navajo code talkers were awarded high military honors for extraordinary service and bravery\n The fact that the  \n broke the Japanese code but the Japanese never broke the Navajo code played a crucial role in the American victories in the Pacific\n   CRYPTOGRAPHY    Introduction to Cryptography Historically  four groups of people have used and contributed to the art of cryptography: the military  the diplomatic corps  diarists  and lovers\n Of these  the military has had the most important role and has shaped the field over the centuries\n Within military organizations  the messages to be encrypted have traditionally been given to poorly paid  low-level code clerks for encryption and transmission\n The sheer volume of messages prevented this work from being done by a few elite specialists\n Until the advent of computers  one of the main constraints on cryptography had been the ability of the code clerk to perform the necessary transformations  often on a battlefield with little equipment\n An additional constraint has been the difficulty in switching over quickly from one cryptographic method to another one  since this entails retraining a large number of people\n However  the danger of a code clerk being captured by the enemy has made it essential to be able to change the cryptographic method instantly if need be\n These conflicting requirements have given rise to the model of Fig\n  - \n Encryption method  E Passive intruder just listens Active intruder can alter messages Plaintext  P Plaintext  P Decryption method  D Encryption key  K Decryption key  K Ciphertext  C = EK(P) Intruder Figure  - \n The encryption model (for a symmetric-key cipher)\n The messages to be encrypted  known as the plaintext  are transformed by a function that is parameterized by a key\n The output of the encryption process  known as the ciphertext  is then transmitted  often by messenger or radio\n We assume that the enemy  or intruder  hears and accurately copies down the complete ciphertext\n However  unlike the intended recipient  he does not know what the decryption key is and so cannot decrypt the ciphertext easily\n Sometimes the intruder can not only listen to the communication channel (passive intruder) but can also record messages and play them back later  inject his own messages  or modify legitimate messages before they get to the receiver (active intruder)\n The art of NETWORK URITY  \n  breaking ciphers  known as cryptanalysis  and the art of devising them (cryptography) are collectively known as cryptology\n It will often be useful to have a notation for relating plaintext  ciphertext  and keys\n We will use C = EK(P) to mean that the encryption of the plaintext P using key K gives the ciphertext C\n Similarly  P = DK(C) represents the decryption of C to get the plaintext again\n It then follows that DK(EK(P)) = P This notation suggests that E and D are just mathematical functions  which they are\n The only tricky part is that both are functions of two parameters  and we have written one of the parameters (the key) as a subscript  rather than as an argument  to distinguish it from the message\n A fundamental rule of cryptography is that one must assume that the cryptanalyst knows the methods used for encryption and decryption\n In other words  the cryptanalyst knows how the encryption method  E  and decryption  D  of Fig\n  -  work in detail\n The amount of effort necessary to invent  test  and install a new algorithm every time the old method is compromised (or thought to be compromised) has always made it impractical to keep the encryption algorithm ret\n Thinking it is ret when it is not does more harm than good\n This is where the key enters\n The key consists of a (relatively) short string that selects one of many potential encryptions\n In contrast to the general method  which may only be changed every few years  the key can be changed as often as required\n Thus  our basic model is a stable and publicly known general method parameterized by a ret and easily changed key\n The idea that the cryptanalyst knows the algorithms and that the recy lies exclusively in the keys is called Kerckhoff’s principle  named after the Flemish military cryptographer Auguste Kerckhoff who first stated it in  (Kerckhoff  )\n Thus  we have Kerckhoff’s principle: All algorithms must be public; only the keys are ret The nonrecy of the algorithm cannot be emphasized enough\n Trying to keep the algorithm ret  known in the trade as urity by obscurity  never works\n Also  by publicizing the algorithm  the cryptographer gets free consulting from a large number of academic cryptologists eager to break the system so they can publish papers demonstrating how smart they are\n If many experts have tried to break the algorithm for a long time after its publication and no one has succeeded  it is probably pretty solid\n Since the real recy is in the key  its length is a major design issue\n Consider a simple combination lock\n The general principle is that you enter digits in sequence\n Everyone knows this  but the key is ret\n A key length of two digits means that there are possibilities\n A key length of three digits means  possibilities  and a key length of six digits means a million\n The longer the key  the higher the work factor the cryptanalyst has to deal with\n The work factor for breaking the system by exhaustive search of the key space is exponential in the   CRYPTOGRAPHY key length\n recy comes from having a strong (but public) algorithm and a long key\n To prevent your kid brother from reading your email   -bit keys will do\n For routine commercial use  at least bits should be used\n To keep major governments at bay  keys of at least bits  preferably more  are needed\n From the cryptanalyst’s point of view  the cryptanalysis problem has three principal variations\n When he has a quantity of ciphertext and no plaintext  he is confronted with the ciphertext-only problem\n The cryptograms that appear in the puzzle tion of newspapers pose this kind of problem\n When the cryptanalyst has some matched ciphertext and plaintext  the problem is called the known plaintext problem\n Finally  when the cryptanalyst has the ability to encrypt pieces of plaintext of his own choosing  we have the chosen plaintext problem\n Newspaper cryptograms could be broken trivially if the cryptanalyst were allowed to ask such questions as ‘‘What is the encryption of ABCDEFGHIJKL?’’ Novices in the cryptography business often assume that if a cipher can withstand a ciphertext-only attack  it is ure\n This assumption is very naive\n In many cases  the cryptanalyst can make a good guess at parts of the plaintext\n For example  the first thing many computers say when you call them up is ‘‘login:’’\n Equipped with some matched plaintext-ciphertext pairs  the cryptanalyst’s job becomes much easier\n To achieve urity  the cryptographer should be conservative and make sure that the system is unbreakable even if his opponent can encrypt arbitrary amounts of chosen plaintext\n Encryption methods have historically been divided into two categories: substitution ciphers and transposition ciphers\n We will now deal with each of these briefly as background information for modern cryptography\n    Substitution Ciphers In a substitution cipher  each letter or group of letters is replaced by another letter or group of letters to disguise it\n One of the oldest known ciphers is the Caesar cipher  attributed to Julius Caesar\n With this method  a becomes D  b becomes E  c becomes F   \n  and z becomes C\n For example  attack becomes DWWDFN\n In our examples  plaintext will be given in lowercase letters  and ciphertext in uppercase letters\n A slight generalization of the Caesar cipher allows the ciphertext alphabet to be shifted by k letters  instead of always three\n In this case  k becomes a key to the general method of circularly shifted alphabets\n The Caesar cipher may have fooled Pompey  but it has not fooled anyone since\n The next improvement is to have each of the symbols in the plaintext  say  the   letters for simplicity  map onto some other letter\n For example  a b c d e f g h i j k l mn o p q r s t u vwx y z QWE R T Y U I O P A S D F G H J K L Z X C V B NM plaintext: ciphertext: NETWORK URITY  \n  The general system of symbol-for-symbol substitution is called a monoalphabetic substitution cipher  with the key being the  -letter string corresponding to the full alphabet\n For the key just given  the plaintext attack would be transformed into the ciphertext QZZQEA\n At first glance this might appear to be a safe system because although the cryptanalyst knows the general system (letter-for-letter substitution)  he does not know which of the  !∼∼  ×  possible keys is in use\n In contrast with the Caesar cipher  trying all of them is not a promising approach\n Even at  n per solution  a million computer chips working in parallel would take   years to try all the keys\n Nevertheless  given a surprisingly small amount of ciphertext  the cipher can be broken easily\n The basic attack takes advantage of the statistical properties of natural languages\n In English  for example  e is the most common letter  followed by t  o  a  n  i  etc\n The most common two-letter combinations  or digrams  are th  in  er  re  and an\n The most common three-letter combinations  or trigrams  are the  ing  and  and ion\n A cryptanalyst trying to break a monoalphabetic cipher would start out by counting the relative frequencies of all letters in the ciphertext\n Then he might tentatively assign the most common one to e and the next most common one to t\n He would then look at trigrams to find a common one of the form tXe  which strongly suggests that X is h\n Similarly  if the pattern thYt occurs frequently  the Y probably stands for a\n With this information  he can look for a frequently occurring trigram of the form aZW  which is most likely and\n By making guesses at common letters  digrams  and trigrams and knowing about likely patterns of vowels and consonants  the cryptanalyst builds up a tentative plaintext  letter by letter\n Another approach is to guess a probable word or phrase\n For example  consider the following ciphertext from an accounting firm (blocked into groups of five characters): CTBMN BYCTC BTJDS QXBNS GSTJC BTSWX CTQTZ CQVUJ QJSGS TJQZZ MNQJS VLNSX VSZJU JDSTS JQUUS JUBXJ DSKSU JSNTK BGAQJ ZBGYQ TLCTZ BNYBN QJSW A likely word in a message from an accounting firm is financial\n Using our knowledge that financial has a repeated letter (i)  with four other letters between their occurrences  we look for repeated letters in the ciphertext at this spacing\n We find   hits  at positions        and  \n However  only two of these and have the next letter (corresponding to n in the plaintext) repeated in the proper place\n Of these two  only   also has the a correctly positioned  so we know that financial begins at position  \n From this point on  deducing the key is easy by using the frequency statistics for English text and looking for nearly complete words to finish off\n   CRYPTOGRAPHY    Transposition Ciphers Substitution ciphers preserve the order of the plaintext symbols but disguise them\n Transposition ciphers  in contrast  reorder the letters but do not disguise them\n Figure  -  depicts a common transposition cipher  the columnar transposition\n The cipher is keyed by a word or phrase not containing any repeated letters\n In this example  MEGABUCK is the key\n The purpose of the key is to order the columns  with column  being under the key letter closest to the start of the alphabet  and so on\n The plaintext is written horizontally  in rows  padded to fill the matrix if need be\n The ciphertext is read out by columns  starting with the column whose key letter is the lowest\n M E G A B U C K    p l e a s e t r Plaintext pleasetransferonemilliondollarsto myswissbankaccountsixtwotwo Ciphertext AFLLSKSOSELAWAIATOOSSCTCLNMOMANT ESILYNTWRNNTSOWDPAEDOBUOERIRICXB a n s f e r o n e m i l l i o n d o l l a r s t o m y s w i s s b a n k a c c o u n t s i x t w o t w o a b c d Figure  - \n A transposition cipher\n To break a transposition cipher  the cryptanalyst must first be aware that he is dealing with a transposition cipher\n By looking at the frequency of E  T  A  O  I  N  etc\n  it is easy to see if they fit the normal pattern for plaintext\n If so  the cipher is clearly a transposition cipher  because in such a cipher every letter represents itself  keeping the frequency distribution intact\n The next step is to make a guess at the number of columns\n In many cases  a probable word or phrase may be guessed at from the context\n For example  suppose that our cryptanalyst suspects that the plaintext phrase milliondollars occurs somewhere in the message\n Observe that digrams MO  IL  LL  LA  IR  and OS occur in the ciphertext as a result of this phrase wrapping around\n The ciphertext letter O follows the ciphertext letter M ( \n  they are vertically adjacent in column  ) because they are separated in the probable phrase by a distance equal to the key length\n If a key of length seven had been used  the digrams MD  IO  LL  LL  IA  OR  and NS would have occurred instead\n In fact  for each key length  a different set of digrams is produced in the ciphertext\n By hunting for the various possibilities  the cryptanalyst can often easily determine the key length\n NETWORK URITY  \n  The remaining step is to order the columns\n When the number of columns  k  is small  each of the k(k −  ) column pairs can be examined in turn to see if its digram frequencies match those for English plaintext\n The pair with the best match is assumed to be correctly positioned\n Now each of the remaining columns is tentatively tried as the successor to this pair\n The column whose digram and trigram frequencies give the best match is tentatively assumed to be correct\n The next column is found in the same way\n The entire process is continued until a potential ordering is found\n Chances are that the plaintext will be recognizable at this point ( \n  if milloin occurs  it is clear what the error is)\n Some transposition ciphers accept a fixed-length block of input and produce a fixed-length block of output\n These ciphers can be completely described by giving a list telling the order in which the characters are to be output\n For example  the cipher of Fig\n  -  can be seen as a   character block cipher\n Its output is          In other words  the fourth input character  a  is the first to be output  followed by the twelfth  f  and so on\n    One-Time Pads Constructing an unbreakable cipher is actually quite easy; the technique has been known for decades\n First choose a random bit string as the key\n Then convert the plaintext into a bit string  for example  by using its ASCII representation\n Finally  compute the XOR (eXclusive OR) of these two strings  bit by bit\n The resulting ciphertext cannot be broken because in a sufficiently large sample of ciphertext  each letter will occur equally often  as will every digram  every trigram  and so on\n This method  known as the one-time pad  is immune to all present and future attacks  no matter how much computational power the intruder has\n The reason derives from information theory: there is simply no information in the message because all possible plaintexts of the given length are equally likely\n An example of how one-time pads are used is given in Fig\n  - \n First  message   ‘‘I love you\n’’ is converted to  -bit ASCII\n Then a one-time pad  pad   is chosen and XORed with the message to get the ciphertext\n A cryptanalyst could try all possible one-time pads to see what plaintext came out for each one\n For example  the one-time pad listed as pad  in the figure could be tried  resulting in plaintext   ‘‘Elvis lives’’  which may or may not be plausible (a subject beyond the scope of this book)\n In fact  for every  -character ASCII plaintext  there is a one-time pad that generates it\n That is what we mean by saying there is no information in the ciphertext: you can get any message of the correct length out of it\n One-time pads are great in theory but have a number of disadvantages in practice\n To start with  the key cannot be memorized  so both sender and receiver must carry a written copy with them\n If either one is subject to capture  written keys are clearly undesirable\n Additionally  the total amount of data that can be transmitted is limited by the amount of key available\n If the spy strikes it rich and discovers a wealth of data  he may find himself unable to transmit them back to   CRYPTOGRAPHY Message  :              Pad  :              Ciphertext:              Pad  :              Plaintext  :              Figure  - \n The use of a one-time pad for encryption and the possibility of getting any possible plaintext from the ciphertext by the use of some other pad\n headquarters because the key has been used up\n Another problem is the sensitivity of the method to lost or inserted characters\n If the sender and receiver get out of synchronization  all data from then on will appear garbled\n With the advent of computers  the one-time pad might potentially become practical for some applications\n The source of the key could be a special DVD that contains several gigabytes of information and  if transported in a DVD movie box and prefixed by a few minutes of video  would not even be suspicious\n Of course  at gigabit network speeds  having to insert a new DVD every    could become tedious\n And the DVDs must be personally carried from the sender to the receiver before any messages can be sent  which greatly reduces their practical utility\n Quantum Cryptography Interestingly  there may be a solution to the problem of how to transmit the one-time pad over the network  and it comes from a very unlikely source: quantum mechanics\n This area is still experimental  but initial tests are promising\n If it can be perfected and be made efficient  virtually all cryptography will eventually be done using one-time pads since they are provably ure\n Below we will briefly explain how this method  quantum cryptography  works\n In particular  we will describe a protocol called BB  after its authors and publication year (Bennet and Brassard  )\n Suppose that a user  Alice  wants to establish a one-time pad with a ond user  Bob\n Alice and Bob are called principals  the main characters in our story\n For example  Bob is a banker with whom Alice would like to do business\n The names ‘‘Alice’’ and ‘‘Bob’’ have been used for the principals in virtually every paper and book on cryptography since Ron Rivest introduced them many years ago (Rivest et al\n  )\n Cryptographers love tradition\n If we were to use ‘‘Andy’’ and ‘‘Barbara’’ as the principals  no one would believe anything in this  ter\n So be it\n If Alice and Bob could establish a one-time pad  they could use it to communicate urely\n The question is: how can they establish it without previously exchanging DVDs? We can assume that Alice and Bob are at the opposite ends NETWORK URITY  \n  of an optical fiber over which they can send and receive light pulses\n However  an intrepid intruder  Trudy  can cut the fiber to splice in an active tap\n Trudy can read all the bits sent in both directions\n She can also send false messages in both directions\n The situation might seem hopeless for Alice and Bob  but quantum cryptography can shed some new light on the subject\n Quantum cryptography is based on the fact that light comes in little packets called photons  which have some peculiar properties\n Furthermore  light can be polarized by being passed through a polarizing filter  a fact well known to both sunglasses wearers and photographers\n If a beam of light ( \n  a stream of photons) is passed through a polarizing filter  all the photons emerging from it will be polarized in the direction of the filter’s axis ( \n  vertically)\n If the beam is now passed through a ond polarizing filter  the intensity of the light emerging from the ond filter is proportional to the square of the cosine of the angle between the axes\n If the two axes are perpendicular  no photons get through\n The absolute orientation of the two filters does not matter; only the angle between their axes counts\n To generate a one-time pad  Alice needs two sets of polarizing filters\n Set one consists of a vertical filter and a horizontal filter\n This choice is called a rectilinear basis\n A basis (plural: bases) is just a coordinate system\n The ond set of filters is the same  except rotated   degrees  so one filter runs from the lower left to the upper right and the other filter runs from the upper left to the lower right\n This choice is called a diagonal basis\n Thus  Alice has two bases  which she can rapidly insert into her beam at will\n In reality  Alice does not have four separate filters  but a crystal whose polarization can be switched electrically to any of the four allowed directions at great speed\n Bob has the same equipment as Alice\n The fact that Alice and Bob each have two bases available is essential to quantum cryptography\n For each basis  Alice now assigns one direction as  and the other as  \n In the example presented below  we assume she chooses vertical to be  and horizontal to be  \n Independently  she also chooses lower left to upper right as  and upper left to lower right as  \n She sends these choices to Bob as plaintext\n Now Alice picks a one-time pad  for example based on a random number generator (a complex subject all by itself)\n She transfers it bit by bit to Bob  choosing one of her two bases at random for each bit\n To send a bit  her photon gun emits one photon polarized appropriately for the basis she is using for that bit\n For example  she might choose bases of diagonal  rectilinear  rectilinear  diagonal  rectilinear  etc\n To send her one-time pad of    with these bases  she would send the photons shown in Fig\n  - (a)\n Given the one-time pad and the sequence of bases  the polarization to use for each bit is uniquely determined\n Bits sent one photon at a time are called qubits\n Bob does not know which bases to use  so he picks one at random for each arriving photon and just uses it  as shown in Fig\n  - (b)\n If he picks the correct basis  he gets the correct bit\n If he picks the incorrect basis  he gets a random bit   CRYPTOGRAPHY Trudy's pad (g) x  x  x x x ?  x ? ?  x ?    x No Yes No Yes No No No Yes Yes No Yes Yes Yes No Yes No Bit number Data Trudy's bases (f) Onetime pad (e) Correct basis? (d) What Bob gets (c) Bob's bases (b) What Alice sends (a)          Figure  - \n An example of quantum cryptography\n because if a photon hits a filter polarized at   degrees to its own polarization  it randomly jumps to the polarization of the filter or to a polarization perpendicular to the filter  with equal probability\n This property of photons is fundamental to quantum mechanics\n Thus  some of the bits are correct and some are random  but Bob does not know which are which\n Bob’s results are depicted in Fig\n  - (c)\n How does Bob find out which bases he got right and which he got wrong? He simply tells Alice which basis he used for each bit in plaintext and she tells him which are right and which are wrong in plaintext  as shown in Fig\n  - (d)\n From this information  both of them can build a bit string from the correct guesses  as shown in Fig\n  - (e)\n On the average  this bit string will be half the length of the original bit string  but since both parties know it  they can use it as a one-time pad\n All Alice has to do is transmit a bit string slightly more than twice the desired length  and she and Bob will have a one-time pad of the desired length\n Done\n But wait a minute\n We forgot Trudy\n Suppose that she is curious about what Alice has to say and cuts the fiber  inserting her own detector and transmitter\n Unfortunately for her  she does not know which basis to use for each photon either\n The best she can do is pick one at random for each photon  just as Bob does\n An example of her choices is shown in Fig\n  - (f)\n When Bob later reports (in plaintext) which bases he used and Alice tells him (in plaintext) which ones are NETWORK URITY  \n  correct  Trudy now knows when she got it right and when she got it wrong\n In Fig\n  -  she got it right for bits    and  \n But she knows from Alice’s reply in Fig\n  - (d) that only bits    and   are part of the one-time pad\n For four of these bits (    and  )  she guessed right and captured the correct bit\n For the other four (  and  )  she guessed wrong and does not know the bit transmitted\n Thus  Bob knows the one-time pad starts with  from Fig\n  - (e) but all Trudy has is  ? ?? ?  from Fig\n  - (g)\n Of course  Alice and Bob are aware that Trudy may have captured part of their one-time pad  so they would like to reduce the information Trudy has\n They can do this by performing a transformation on it\n For example  they could divide the one-time pad into blocks of  bits  square each one to form a -bit number  and use the concatenation of these -bit numbers as the one-time pad\n With her partial knowledge of the bit string transmitted  Trudy has no way to generate its square and so has nothing\n The transformation from the original one-time pad to a different one that reduces Trudy’s knowledge is called privacy amplification\n In practice  complex transformations in which every output bit depends on every input bit are used instead of squaring\n Poor Trudy\n Not only does she have no idea what the one-time pad is  but her presence is not a ret either\n After all  she must relay each received bit to Bob to trick him into thinking he is talking to Alice\n The trouble is  the best she can do is transmit the qubit she received  using the polarization she used to receive it  and about half the time she will be wrong  causing many errors in Bob’s one-time pad\n When Alice finally starts sending data  she encodes it using a heavy forwarderror- correcting code\n From Bob’s point of view  a  -bit error in the one-time pad is the same as a  -bit transmission error\n Either way  he gets the wrong bit\n If there is enough forward error correction  he can recover the original message despite all the errors  but he can easily count how many errors were corrected\n If this number is far more than the expected error rate of the equipment  he knows that Trudy has tapped the line and can act accordingly ( \n  tell Alice to switch to a radio channel  call the police  etc\n)\n If Trudy had a way to clone a photon so she had one photon to inspect and an identical photon to send to Bob  she could avoid detection  but at present no way to clone a photon perfectly is known\n And even if Trudy could clone photons  the value of quantum cryptography to establish onetime pads would not be reduced\n Although quantum cryptography has been shown to operate over distances of   km of fiber  the equipment is complex and expensive\n Still  the idea has promise\n For more information about quantum cryptography  see Mullins (   )\n    Two Fundamental Cryptographic Principles Although we will study many different cryptographic systems in the pages ahead  two principles underlying all of them are important to understand\n Pay attention\n You violate them at your peril\n   CRYPTOGRAPHY Redundancy The first principle is that all encrypted messages must contain some redundancy  that is  information not needed to understand the message\n An example may make it clear why this is needed\n Consider a mail-order company  The Couch Potato (TCP)  with   products\n Thinking they are being very efficient  TCP’s programmers decide that ordering messages should consist of a  - byte customer name followed by a  -byte data field (  byte for the quantity and  bytes for the product number)\n The last  bytes are to be encrypted using a very long key known only by the customer and TCP\n At first  this might seem ure  and in a sense it is because passive intruders cannot decrypt the messages\n Unfortunately  it also has a fatal flaw that renders it useless\n Suppose that a recently fired employee wants to punish TCP for firing her\n Just before leaving  she takes the customer list with her\n She works through the night writing a program to generate fictitious orders using real customer names\n Since she does not have the list of keys  she just puts random numbers in the last  bytes  and sends hundreds of orders off to TCP\n When these messages arrive  TCP’s computer uses the customers’ name to locate the key and decrypt the message\n Unfortunately for TCP  almost every  - byte message is valid  so the computer begins printing out shipping instructions\n While it might seem odd for a customer to order sets of children’s swings or sandboxes  for all the computer knows  the customer might be planning to open a chain of franchised playgrounds\n In this way  an active intruder (the exemployee) can cause a massive amount of trouble  even though she cannot understand the messages her computer is generating\n This problem can be solved by the addition of redundancy to all messages\n For example  if order messages are extended to   bytes  the first  of which must be zeros  this attack no longer works because the ex-employee can no longer generate a large stream of valid messages\n The moral of the story is that all messages must contain considerable redundancy so that active intruders cannot send random junk and have it be interpreted as a valid message\n However  adding redundancy makes it easier for cryptanalysts to break messages\n Suppose that the mail-order business is highly competitive  and The Couch Potato’s main competitor  The Sofa Tuber  would dearly love to know how many sandboxes TCP is selling so it taps TCP’s phone line\n In the original scheme with  -byte messages  cryptanalysis was nearly impossible because after guessing a key  the cryptanalyst had no way of telling whether it was right because almost every message was technically legal\n With the new  -byte scheme  it is easy for the cryptanalyst to tell a valid message from an invalid one\n Thus  we have Cryptographic principle  : Messages must contain some redundancy In other words  upon decrypting a message  the recipient must be able to tell whether it is valid by simply inspecting the message and perhaps performing a NETWORK URITY  \n  simple computation\n This redundancy is needed to prevent active intruders from sending garbage and tricking the receiver into decrypting the garbage and acting on the ‘‘plaintext\n’’ However  this same redundancy makes it much easier for passive intruders to break the system  so there is some tension here\n Furthermore  the redundancy should never be in the form of n  s at the start or end of a message  since running such messages through some cryptographic algorithms gives more predictable results  making the cryptanalysts’ job easier\n A CRC polynomial is much better than a run of  s since the receiver can easily verify it  but it generates more work for the cryptanalyst\n Even better is to use a cryptographic hash  a concept we will explore later\n For the moment  think of it as a better CRC\n Getting back to quantum cryptography for a moment  we can also see how redundancy plays a role there\n Due to Trudy’s interception of the photons  some bits in Bob’s one-time pad will be wrong\n Bob needs some redundancy in the incoming messages to determine that errors are present\n One very crude form of redundancy is repeating the message two times\n If the two copies are not identical  Bob knows that either the fiber is very noisy or someone is tampering with the transmission\n Of course  sending everything twice is overkill; a Hamming or Reed-Solomon code is a more efficient way to do error detection and correction\n But it should be clear that some redundancy is needed to distinguish a valid message from an invalid message  especially in the face of an active intruder\n Freshness The ond cryptographic principle is that measures must be taken to ensure that each message received can be verified as being fresh  that is  sent very recently\n This measure is needed to prevent active intruders from playing back old messages\n If no such measures were taken  our ex-employee could tap TCP’s phone line and just keep repeating previously sent valid messages\n Thus  Cryptographic principle  : Some method is needed to foil replay attacks One such measure is including in every message a timestamp valid only for  say onds\n The receiver can then just keep messages around for   onds and compare newly arrived messages to previous ones to filter out duplicates\n Messages older than   onds can be thrown out  since any replays sent more than   onds later will be rejected as too old\n Measures other than timestamps will be discussed later  SYMMETRIC-KEY ALGORITHMS Modern cryptography uses the same basic ideas as traditional cryptography (transposition and substitution)  but its emphasis is different\n Traditionally  cryptographers have used simple algorithms\n Nowadays  the reverse is true: the object   SYMMETRIC-KEY ALGORITHMS is to make the encryption algorithm so complex and involuted that even if the cryptanalyst acquires vast mounds of enciphered text of his own choosing  he will not be able to make any sense of it at all without the key\n The first class of encryption algorithms we will study in this  ter are called symmetric-key algorithms because they use the same key for encryption and decryption\n Fig\n  -  illustrates the use of a symmetric-key algorithm\n In particular  we will focus on block ciphers  which take an n-bit block of plaintext as input and transform it using the key into an n-bit block of ciphertext\n Cryptographic algorithms can be implemented in either hardware (for speed) or software (for flexibility)\n Although most of our treatment concerns the algorithms and protocols  which are independent of the actual implementation  a few words about building cryptographic hardware may be of interest\n Transpositions and substitutions can be implemented with simple electrical circuits\n Figure  -  (a) shows a device  known as a P-box (P stands for permutation)  used to effect a transposition on an  -bit input\n If the  bits are designated from top to bottom as  the output of this particular P-box is    \n By appropriate internal wiring  a P-box can be made to perform any transposition and do it at practically the speed of light since no computation is involved  just signal propagation\n This design follows Kerckhoff’s principle: the attacker knows that the general method is permuting the bits\n What he does not know is which bit goes where\n S  S  P  P  P  P  S  S  S  S  S  S  Product cipher (c) S-box Decoder:  to  Encoder:  to  (b) P-box (a) S  S  S  S  Figure  - \n Basic elements of product ciphers\n (a) P-box\n (b) S-box\n (c) Product\n Substitutions are performed by S-boxes  as shown in Fig\n  - (b)\n In this example  a  -bit plaintext is entered and a  -bit ciphertext is output\n The  -bit input selects one of the eight lines exiting from the first stage and sets it to  ; all the other lines are  \n The ond stage is a P-box\n The third stage encodes the selected input line in binary again\n With the wiring shown  if the eight octal numbers  were input one after another  the output sequence would be    \n In other words   has been replaced by  has been replaced by   etc\n Again  by appropriate wiring of the P-box inside the S-box  any substitution can be accomplished\n Furthermore  such a device can be built in hardware to achieve great speed  since encoders and decoders have only one or two (subnanoond) gate delays and the propagation time across the P-box may well be less than  pico\n NETWORK URITY  \n  The real power of these basic elements only becomes apparent when we cascade a whole series of boxes to form a product cipher  as shown in Fig\n  - (c)\n In this example input lines are transposed ( \n  permuted) by the first stage (P )\n In the ond stage  the input is broken up into four groups of  bits  each of which is substituted independently of the others (S  to S )\n This arrangement shows a method of approximating a larger S-box from multiple  smaller S-boxes\n It is useful because small S-boxes are practical for a hardware implementation ( \n  an  -bit S-box can be realized as a   -entry lookup table)  but large Sboxes become unwieldy to build ( \n  a  -bit S-box would at a minimum need =  crossed wires in its middle stage)\n Although this method is less general  it is still powerful\n By inclusion of a sufficiently large number of stages in the product cipher  the output can be made to be an exceedingly complicated function of the input\n Product ciphers that operate on k-bit inputs to produce k-bit outputs are very common\n Typically  k is   to   \n A hardware implementation usually has at least   physical stages  instead of just  as in Fig\n  - (c)\n A software implementation is programmed as a loop with at least eight iterations  each one performing S-box-type substitutions on subblocks of the  - to   -bit data block  followed by a permutation that mixes the outputs of the S-boxes\n Often there is a special initial permutation and one at the end as well\n In the literature  the iterations are called rounds\n    DES—The Data Encryption Standard In January  the  \n Government adopted a product cipher developed by IBM as its official standard for unclassified information\n This cipher  DES (Data Encryption Standard)  was widely adopted by the industry for use in urity products\n It is no longer ure in its original form  but in a modified form it is still useful\n We will now explain how DES works\n An outline of DES is shown in Fig\n  - (a)\n Plaintext is encrypted in blocks of   bits  yielding   bits of ciphertext\n The algorithm  which is parameterized by a  -bit key  has   distinct stages\n The first stage is a key-independent transposition on the  -bit plaintext\n The last stage is the exact inverse of this transposition\n The stage prior to the last one exchanges the leftmost   bits with the rightmost   bits\n The remaining   stages are functionally identical but are parameterized by different functions of the key\n The algorithm has been designed to allow decryption to be done with the same key as encryption  a property needed in any symmetric-key algorithm\n The steps are just run in the reverse order\n The operation of one of these intermediate stages is illustrated in Fig\n  - (b)\n Each stage takes two  -bit inputs and produces two  -bit outputs\n The left output is simply a copy of the right input\n The right output is the bitwise XOR of the left input and a function of the right input and the key for this stage  Ki \n Pretty much all the complexity of the algorithm lies in this function\n   SYMMETRIC-KEY ALGORITHMS (a) (b) Initial transposition Iteration   Li-  ⊕ f(Ri -  Ki)  -Bit plaintext L i-  Ri-   -Bit ciphertext   bits Li   bits Ri Iteration  Iteration -Bit key  -Bit swap Inverse transposition Figure  - \n The Data Encryption Standard\n (a) General outline\n (b) Detail of one iteration\n The circled + means exclusive OR\n The function consists of four steps  carried out in sequence\n First  a  -bit number  E  is constructed by expanding the  -bit Ri −  according to a fixed transposition and duplication rule\n ond  E and Ki are XORed together\n This output is then partitioned into eight groups of  bits each  each of which is fed into a different S-box\n Each of the   possible inputs to an S-box is mapped onto a  - bit output\n Finally  these  ×  bits are passed through a P-box\n In each of the   iterations  a different key is used\n Before the algorithm starts  a  -bit transposition is applied to the key\n Just before each iteration  the key is partitioned into two  -bit units  each of which is rotated left by a number of bits dependent on the iteration number\n Ki is derived from this rotated key by applying yet another  -bit transposition to it\n A different  -bit subset of the   bits is extracted and permuted on each round\n A technique that is sometimes used to make DES stronger is called whitening\n It consists of XORing a random  -bit key with each plaintext block before feeding it into DES and then XORing a ond  -bit key with the resulting ciphertext before transmitting it\n Whitening can easily be removed by running the NETWORK URITY  \n  reverse operations (if the receiver has the two whitening keys)\n Since this technique effectively adds more bits to the key length  it makes an exhaustive search of the key space much more time consuming\n Note that the same whitening key is used for each block ( \n  there is only one whitening key)\n DES has been enveloped in controversy since the day it was launched\n It was based on a cipher developed and patented by IBM  called Lucifer  except that IBM’s cipher used a   -bit key instead of a  -bit key\n When the  \n Federal Government wanted to standardize on one cipher for unclassified use  it ‘‘invited’’ IBM to ‘‘discuss’’ the matter with NSA  the  \n Government’s code-breaking arm  which is the world’s largest employer of mathematicians and cryptologists\n NSA is so ret that an industry joke goes: Q: What does NSA stand for? A: No Such Agency\n Actually  NSA stands for National urity Agency\n After these discussions took place  IBM reduced the key from bits to   bits and decided to keep ret the process by which DES was designed\n Many people suspected that the key length was reduced to make sure that NSA could just break DES  but no organization with a smaller budget could\n The point of the ret design was supposedly to hide a back door that could make it even easier for NSA to break DES\n When an NSA employee discreetly told IEEE to cancel a planned conference on cryptography  that did not make people any more comfortable\n NSA denied everything\n In  two Stanford cryptography researchers  Diffie and Hellman (   )  designed a machine to break DES and estimated that it could be built for   million dollars\n Given a small piece of plaintext and matched ciphertext  this machine could find the key by exhaustive search of the   -entry key space in under  day\n Nowadays  the game is up\n Such a machine exists  is for sale  and costs less than $  to make (Kumar et al\n  )\n Triple DES As early as  IBM realized that the DES key length was too short and devised a way to effectively increase it  using triple encryption (Tuchman  )\n The method chosen  which has since been incorporated in International Standard  is illustrated in Fig\n  - \n Here  two keys and three stages are used\n In the first stage  the plaintext is encrypted using DES in the usual way with K \n In the ond stage  DES is run in decryption mode  using K  as the key\n Finally  another DES encryption is done with K \n This design immediately gives rise to two questions\n First  why are only two keys used  instead of three? ond  why is EDE (Encrypt Decrypt Encrypt) used  instead of EEE (Encrypt Encrypt Encrypt)? The reason that two keys are used is that even the most paranoid of cryptographers believe that bits is   SYMMETRIC-KEY ALGORITHMS K  E K  D K  P E C K  D K  E (a) (b) K  C D P Figure  - \n (a) Triple encryption using DES\n (b) Decryption\n adequate for routine commercial applications for the time being\n (And among cryptographers  paranoia is considered a feature  not a bug\n) Going to bits would just add the unnecessary overhead of managing and transporting another key for little real gain\n The reason for encrypting  decrypting  and then encrypting again is backward compatibility with existing single-key DES systems\n Both the encryption and decryption functions are mappings between sets of  -bit numbers\n From a cryptographic point of view  the two mappings are equally strong\n By using EDE  however  instead of EEE  a computer using triple encryption can speak to one using single encryption by just setting K  = K \n This property allows triple encryption to be phased in gradually  something of no concern to academic cryptographers but of considerable importance to IBM and its customers\n    AES—The Advanced Encryption Standard As DES began approaching the end of its useful life  even with triple DES  NIST (National Institute of Standards and Technology)  the agency of the  \n Dept\n of Commerce charged with approving standards for the  \n Federal Government  decided that the government needed a new cryptographic standard for unclassified use\n NIST was keenly aware of all the controversy surrounding DES and well knew that if it just announced a new standard  everyone knowing anything about cryptography would automatically assume that NSA had built a back door into it so NSA could read everything encrypted with it\n Under these conditions  probably no one would use the standard and it would have died quietly\n So  NIST took a surprisingly different approach for a government bureaucracy: it sponsored a cryptographic bake-off (contest)\n In January  researchers from all over the world were invited to submit proposals for a new standard  to be called AES (Advanced Encryption Standard)\n The bake-off rules were:  \n The algorithm must be a symmetric block cipher The full design must be public Key lengths of  and bits must be supported\n NETWORK URITY  \n   \n Both software and hardware implementations must be possible The algorithm must be public or licensed on nondiscriminatory terms\n Fifteen serious proposals were made  and public conferences were organized in which they were presented and attendees were actively encouraged to find flaws in all of them\n In August  NIST selected five finalists  primarily on the basis of their urity  efficiency  simplicity  flexibility  and memory requirements (important for embedded systems)\n More conferences were held and more potshots taken\n In October  NIST announced that it had selected Rijndael  by Joan Daemen and Vincent Rijmen\n The name Rijndael  pronounced Rhine-doll (more or less)  is derived from the last names of the authors: Rijmen + Daemen\n In November  Rijndael became the AES  \n Government standard  published as FIPS (Federal Information Processing Standard)   \n Due to the extraordinary openness of the competition  the technical properties of Rijndael  and the fact that the winning team consisted of two young Belgian cryptographers (who were unlikely to have built in a back door just to please NSA)  Rijndael has become the world’s dominant cryptographic cipher\n AES encryption and decryption is now part of the instruction set for some microprocessors ( \n  Intel)\n Rijndael supports key lengths and block sizes from bits to bits in steps of   bits\n The key length and block length may be chosen independently\n However  AES specifies that the block size must be bits and the key length must be  or bits\n It is doubtful that anyone will ever use   -bit keys  so de facto  AES has two variants: a   -bit block with a   -bit key and a   -bit block with a   -bit key\n In our treatment of the algorithm  we will examine only the   /   case because this is likely to become the commercial norm\n A   -bit key gives a key space of  ∼∼  ×  keys\n Even if NSA manages to build a machine with  billion parallel processors  each being able to evaluate one key per picoond  it would take such a machine about  years to search the key space\n By then the sun will have burned out  so the folks then present will have to read the results by candlelight\n Rijndael From a mathematical perspective  Rijndael is based on Galois field theory  which gives it some provable urity properties\n However  it can also be viewed as C code  without getting into the mathematics\n Like DES  Rijndael uses substitution and permutations  and it also uses multiple rounds\n The number of rounds depends on the key size and block size  being   for   -bit keys with   -bit blocks and moving up to   for the largest key or the largest block\n However  unlike DES  all operations involve entire bytes  to   SYMMETRIC-KEY ALGORITHMS allow for efficient implementations in both hardware and software\n An outline of the code is given in Fig\n  - \n Note that this code is for the purpose of illustration\n Good implementations of urity code will follow additional practices  such as zeroing out sensitive memory after it has been used\n See  for example  Ferguson et al\n (   )\n #define LENGTH   /* # bytes in data block or key */ #define NROWS  /* number of rows in state */ #define NCOLS  /* number of columns in state */ #define ROUNDS   /* number of iterations */ typedef unsigned char byte; /* unsigned  -bit integer */ rijndael(byte plaintext[LENGTH]  byte ciphertext[LENGTH]  byte key[LENGTH]) { int r; /* loop index */ byte state[NROWS][NCOLS]; /* current state */ struct {byte k[NROWS][NCOLS];} rk[ROUNDS +  ]; /* round keys */ expand key(key  rk); /* construct the round keys */ copy plaintext to state(state  plaintext); /* init current state */ xor roundkey into state(state  rk[ ]); /* XOR key into state */ for (r =  ; r <= ROUNDS; r++) { substitute(state); /* apply S-box to each byte */ rotate rows(state); /* rotate row i by i bytes */ if (r < ROUNDS) mix columns(state); /* mix function */ xor roundkey into state(state  rk[r]); /* XOR key into state */ } copy state to ciphertext(ciphertext  state); /* return result */ } Figure  - \n An outline of Rijndael in C\n The function rijndael has three parameters\n They are: plaintext  an array of   bytes containing the input data; ciphertext  an array of   bytes where the enciphered output will be returned; and key  the  -byte key\n During the calculation  the current state of the data is maintained in a byte array  state  whose size is NROWS × NCOLS\n For   -bit blocks  this array is  ×  bytes\n With   bytes  the full   -bit data block can be stored\n The state array is initialized to the plaintext and modified by every step in the computation\n In some steps  byte-for-byte substitution is performed\n In others  the bytes are permuted within the array\n Other transformations are also used\n At the end  the contents of the state are returned as the ciphertext\n The code starts out by expanding the key into   arrays of the same size as the state\n They are stored in rk  which is an array of structs  each containing a state array\n One of these will be used at the start of the calculation and the other   will be used during the   rounds  one per round\n The calculation of the round NETWORK URITY  \n  keys from the encryption key is too complicated for us to get into here\n Suffice it to say that the round keys are produced by repeated rotation and XORing of various groups of key bits\n For all the details  see Daemen and Rijmen (   )\n The next step is to copy the plaintext into the state array so it can be processed during the rounds\n It is copied in column order  with the first  bytes going into column   the next  bytes going into column   and so on\n Both the columns and the rows are numbered starting at   although the rounds are numbered starting at  \n This initial setup of the   byte arrays of size  ×  is illustrated in Fig\n  -  \n state rk[ ] rk[ ] rk[ ] rk[ ] rk[ ] rk[ ] rk[ ] rk[ ] rk[ ] rk[ ] rk[  ]   -Bit plaintext   -Bit encryption key Round keys Figure  -  \n Creating the state and rk arrays\n There is one more step before the main computation begins: rk[ ] is XORed into state  byte for byte\n In other words  each of the   bytes in state is replaced by the XOR of itself and the corresponding byte in rk[ ]\n Now it is time for the main attraction\n The loop executes   iterations  one per round  transforming state on each iteration\n The contents of each round is produced in four steps\n Step  does a byte-for-byte substitution on state\n Each byte in turn is used as an index into an S-box to replace its value by the contents of that S-box entry\n This step is a straight monoalphabetic substitution cipher\n Unlike DES  which has multiple S-boxes  Rijndael has only one S-box\n Step  rotates each of the four rows to the left\n Row  is rotated  bytes ( \n  not changed)  row  is rotated  byte  row  is rotated  bytes  and row  is rotated  bytes\n This step diffuses the contents of the current data around the block  analogous to the permutations of Fig\n  - \n Step  mixes up each column independently of the other ones\n The mixing is done using matrix multiplication in which the new column is the product of the old column and a constant matrix  with the multiplication done using the finite Galois field  GF(  )\n Although this may sound complicated  an algorithm exists that allows each element of the new column to be computed using two table lookups and three XORs (Daemen and Rijmen   Appendix E)\n   SYMMETRIC-KEY ALGORITHMS Finally  step  XORs the key for this round into the state array for use in the next round\n Since every step is reversible  decryption can be done just by running the algorithm backward\n However  there is also a trick available in which decryption can be done by running the encryption algorithm using different tables\n The algorithm has been designed not only for great urity  but also for great speed\n A good software implementation on a  -GHz machine should be able to achieve an encryption rate of Mbps  which is fast enough to encrypt over MPEG-  videos in real time\n Hardware implementations are faster still\n    Cipher Modes Despite all this complexity  AES (or DES  or any block cipher for that matter) is basically a monoalphabetic substitution cipher using big characters (  -bit characters for AES and  -bit characters for DES)\n Whenever the same plaintext block goes in the front end  the same ciphertext block comes out the back end\n If you encrypt the plaintext abcdefgh times with the same DES key  you get the same ciphertext times\n An intruder can exploit this property to help subvert the cipher\n Electronic Code Book Mode To see how this monoalphabetic substitution cipher property can be used to partially defeat the cipher  we will use (triple) DES because it is easier to depict  -bit blocks than   -bit blocks  but AES has exactly the same problem\n The straightforward way to use DES to encrypt a long piece of plaintext is to break it up into conutive  -byte (  -bit) blocks and encrypt them one after another with the same key\n The last piece of plaintext is padded out to   bits  if need be\n This technique is known as ECB mode (Electronic Code Book mode) in analogy with old-fashioned code books where each plaintext word was listed  followed by its ciphertext (usually a five-digit decimal number)\n In Fig\n  -   we have the start of a computer file listing the annual bonuses a company has decided to award to its employees\n This file consists of conutive  -byte records  one per employee  in the format shown:   bytes for the name   bytes for the position  and  bytes for the bonus\n Each of the sixteen  -byte blocks (numbered from  to  ) is encrypted by (triple) DES\n Leslie just had a fight with the boss and is not expecting much of a bonus\n Kim  in contrast  is the boss’ favorite  and everyone knows this\n Leslie can get access to the file after it is encrypted but before it is sent to the bank\n Can Leslie rectify this unfair situation  given only the encrypted file? No problem at all\n All Leslie has to do is make a copy of the  th ciphertext block (which contains Kim’s bonus) and use it to replace the fourth ciphertext block (which contains Leslie’s bonus)\n Even without knowing what the  th NETWORK URITY  \n  Name Position Bonus Bytes   D a v i s  B o b b i e J a n i t o r $  C o l l i n s  K i m M a n a g e r $  B l a c k  R o b i n B o s s $  A d a m s  L e s l i e C l e r k $ Figure  -  \n The plaintext of a file encrypted as   DES blocks\n block says  Leslie can expect to have a much merrier Christmas this year\n (Copying the eighth ciphertext block is also a possibility  but is more likely to be detected; besides  Leslie is not a greedy person\n) Cipher Block Chaining Mode To thwart this type of attack  all block ciphers can be chained in various ways so that replacing a block the way Leslie did will cause the plaintext decrypted starting at the replaced block to be garbage\n One way of chaining is cipher block chaining\n In this method  shown in Fig\n  -   each plaintext block is XORed with the previous ciphertext block before being encrypted\n Consequently  the same plaintext block no longer maps onto the same ciphertext block  and the encryption is no longer a big monoalphabetic substitution cipher\n The first block is XORed with a randomly chosen IV (Initialization Vector)  which is transmitted (in plaintext) along with the ciphertext\n (a) (b) + E IV Key Key IV P  C  + E P  C  E P  C  E P  C  D C  P  D C  P  D C  P  D Decryption box Encryption box Exclusive OR C  P  + + + + + + Figure  -  \n Cipher block chaining\n (a) Encryption\n (b) Decryption\n We can see how cipher block chaining mode works by examining the example of Fig\n  -  \n We start out by computing C  = E(P  XOR IV)\n Then we compute C  = E(P  XOR C )  and so on\n Decryption also uses XOR to reverse the process  with P  = IV XOR D(C )  and so on\n Note that the encryption of block i is a   SYMMETRIC-KEY ALGORITHMS function of all the plaintext in blocks  through i −   so the same plaintext generates different ciphertext depending on where it occurs\n A transformation of the type Leslie made will result in nonsense for two blocks starting at Leslie’s bonus field\n To an astute urity officer  this peculiarity might suggest where to start the ensuing investigation\n Cipher block chaining also has the advantage that the same plaintext block will not result in the same ciphertext block  making cryptanalysis more difficult\n In fact  this is the main reason it is used\n Cipher Feedback Mode However  cipher block chaining has the disadvantage of requiring an entire  -bit block to arrive before decryption can begin\n For byte-by-byte encryption  cipher feedback mode using (triple) DES is used  as shown in Fig\n  -  \n For AES  the idea is exactly the same  only a   -bit shift register is used\n In this figure  the state of the encryption machine is shown after bytes  through  have been encrypted and sent\n When plaintext byte   arrives  as illustrated in Fig\n  -  (a)  the DES algorithm operates on the  -bit shift register to generate a  -bit ciphertext\n The leftmost byte of that ciphertext is extracted and XORed with P  \n That byte is transmitted on the transmission line\n In addition  the shift register is shifted left  bits  causing C  to fall off the left end  and C  is inserted in the position just vacated at the right end by C \n (a) Key P  C  C  C  E  -bit shift register C  C  C  C  C  C  C  C  Encryption box Select leftmost byte Exclusive OR (b) Key C  P  E  -bit shift register C  C  C  C  C  C  C  C  + Encryption box Select leftmost byte + Figure  -  \n Cipher feedback mode\n (a) Encryption\n (b) Decryption\n Note that the contents of the shift register depend on the entire previous history of the plaintext  so a pattern that repeats multiple times in the plaintext will be encrypted differently each time in the ciphertext\n As with cipher block chaining  an initialization vector is needed to start the ball rolling\n NETWORK URITY  \n  Decryption with cipher feedback mode works the same way as encryption\n In particular  the content of the shift register is encrypted  not decrypted  so the selected byte that is XORed with C  to get P  is the same one that was XORed with P  to generate C  in the first place\n As long as the two shift registers remain identical  decryption works correctly\n This is illustrated in Fig\n  -  (b)\n A problem with cipher feedback mode is that if one bit of the ciphertext is accidentally inverted during transmission  the  bytes that are decrypted while the bad byte is in the shift register will be corrupted\n Once the bad byte is pushed out of the shift register  correct plaintext will once again be generated\n Thus  the effects of a single inverted bit are relatively localized and do not ruin the rest of the message  but they do ruin as many bits as the shift register is wide\n Stream Cipher Mode Nevertheless  applications exist in which having a  -bit transmission error mess up   bits of plaintext is too large an effect\n For these applications  a fourth option  stream cipher mode  exists\n It works by encrypting an initialization vector  using a key to get an output block\n The output block is then encrypted  using the key to get a ond output block\n This block is then encrypted to get a third block  and so on\n The (arbitrarily large) sequence of output blocks  called the keystream  is treated like a one-time pad and XORed with the plaintext to get the ciphertext  as shown in Fig\n  -  (a)\n Note that the IV is used only on the first step\n After that  the output is encrypted\n Also note that the keystream is independent of the data  so it can be computed in advance  if need be  and is completely insensitive to transmission errors\n Decryption is shown in Fig\n  -  (b)\n E (a) Key Plaintext Ciphertext Keystream Encryption box IV + E (b) Key Ciphertext Plaintext Keystream Encryption box IV + Figure  -  \n A stream cipher\n (a) Encryption\n (b) Decryption\n Decryption occurs by generating the same keystream at the receiving side\n Since the keystream depends only on the IV and the key  it is not affected by transmission errors in the ciphertext\n Thus  a  -bit error in the transmitted ciphertext generates only a  -bit error in the decrypted plaintext\n   SYMMETRIC-KEY ALGORITHMS It is essential never to use the same (key  IV) pair twice with a stream cipher because doing so will generate the same keystream each time\n Using the same keystream twice exposes the ciphertext to a keystream reuse attack\n Imagine that the plaintext block  P  is encrypted with the keystream to get P  XOR K \n Later  a ond plaintext block  Q  is encrypted with the same keystream to get Q  XOR K \n An intruder who captures both of these ciphertext blocks can simply XOR them together to get P  XOR Q  which eliminates the key\n The intruder now has the XOR of the two plaintext blocks\n If one of them is known or can be guessed  the other can also be found\n In any event  the XOR of two plaintext streams can be attacked by using statistical properties of the message\n For example  for English text  the most common character in the stream will probably be the XOR of two spaces  followed by the XOR of space and the letter ‘‘e’’  etc\n In short  equipped with the XOR of two plaintexts  the cryptanalyst has an excellent chance of deducing both of them\n Counter Mode One problem that all the modes except electronic code book mode have is that random access to encrypted data is impossible\n For example  suppose a file is transmitted over a network and then stored on disk in encrypted form\n This might be a reasonable way to operate if the receiving computer is a notebook computer that might be stolen\n Storing all critical files in encrypted form greatly reduces the damage due to ret information leaking out in the event that the computer falls into the wrong hands\n However  disk files are often accessed in nonsequential order  especially files in databases\n With a file encrypted using cipher block chaining  accessing a random block requires first decrypting all the blocks ahead of it  an expensive proposition\n For this reason  yet another mode has been invented: counter mode  as illustrated in Fig\n  -  \n Here  the plaintext is not encrypted directly\n Instead  the initialization vector plus a constant is encrypted  and the resulting ciphertext is XORed with the plaintext\n By stepping the initialization vector by  for each new block  it is easy to decrypt a block anywhere in the file without first having to decrypt all of its predecessors\n Although counter mode is useful  it has a weakness that is worth pointing out\n Suppose that the same key  K  is used again in the future (with a different plaintext but the same IV) and an attacker acquires all the ciphertext from both runs\n The keystreams are the same in both cases  exposing the cipher to a keystream reuse attack of the same kind we saw with stream ciphers\n All the cryptanalyst has to do is XOR the two ciphertexts together to eliminate all the cryptographic protection and just get the XOR of the plaintexts\n This weakness does not mean counter mode is a bad idea\n It just means that both keys and initialization vectors should be chosen independently and at random\n Even if the same key is accidentally used twice  if the IV is different each time  the plaintext is safe\n NETWORK URITY  \n  Encryption box + E IV Key P  C  + E IV+  Key P  C  + E IV+  Key P  C  + E IV+  Key P  C  Figure  -  \n Encryption using counter mode\n    Other Ciphers AES (Rijndael) and DES are the best-known symmetric-key cryptographic algorithms  and the standard industry choices  if only for liability reasons\n (No one will blame you if you use AES in your product and AES is cracked  but they will certainly blame you if you use a nonstandard cipher and it is later broken\n) However  it is worth mentioning that numerous other symmetric-key ciphers have been devised\n Some of these are embedded inside various products\n A few of the more common ones are listed in Fig\n  -  \n It is possible to use combinations of these ciphers  for example  AES over Twofish  so that both ciphers need to be broken to recover the data\n Cipher Author Key length Comments DES IBM   bits Too weak to use now RC  Ronald Rivest  – bits Caution: some keys are weak RC  Ronald Rivest   –   bits Good  but patented AES (Rijndael) Daemen and Rijmen   –   bits Best choice Serpent Anderson  Biham  Knudsen   –   bits Very strong Triple DES IBM bits Good  but getting old Twofish Bruce Schneier   –   bits Very strong; widely used Figure  -  \n Some common symmetric-key cryptographic algorithms\n    Cryptanalysis Before leaving the subject of symmetric-key cryptography  it is worth at least mentioning four developments in cryptanalysis\n The first development is differential cryptanalysis (Biham and Shamir  )\n This technique can be used   SYMMETRIC-KEY ALGORITHMS to attack any block cipher\n It works by beginning with a pair of plaintext blocks differing in only a small number of bits and watching carefully what happens on each internal iteration as the encryption proceeds\n In many cases  some bit patterns are more common than others  which can lead to probabilistic attacks\n The ond development worth noting is linear cryptanalysis (Matsui  )\n It can break DES with only known plaintexts\n It works by XORing certain bits in the plaintext and ciphertext together and examining the result\n When done repeatedly  half the bits should be  s and half should be  s\n Often  however  ciphers introduce a bias in one direction or the other  and this bias  however small  can be exploited to reduce the work factor\n For the details  see Matsui’s paper\n The third development is using analysis of electrical power consumption to find ret keys\n Computers typically use around  volts to represent a  bit and  volts to represent a  bit\n Thus  processing a  takes more electrical energy than processing a  \n If a cryptographic algorithm consists of a loop in which the key bits are processed in order  an attacker who replaces the main n-GHz clock with a slow ( \n -Hz) clock and puts alligator clips on the CPU’s power and ground pins can precisely monitor the power consumed by each machine instruction\n From this data  deducing the key is surprisingly easy\n This kind of cryptanalysis can be defeated only by carefully coding the algorithm in assembly language to make sure power consumption is independent of the key and also independent of all the individual round keys\n The fourth development is timing analysis\n Cryptographic algorithms are full of if statements that test bits in the round keys\n If the then and else parts take different amounts of time  by slowing down the clock and seeing how long various steps take  it may also be possible to deduce the round keys\n Once all the round keys are known  the original key can usually be computed\n Power and timing analysis can also be employed simultaneously to make the job easier\n While power and timing analysis may seem exotic  in reality they are powerful techniques that can break any cipher not specifically designed to resist them  PUBLIC-KEY ALGORITHMS Historically  distributing the keys has always been the weakest link in most cryptosystems\n No matter how strong a cryptosystem was  if an intruder could steal the key  the system was worthless\n Cryptologists always took for granted that the encryption key and decryption key were the same (or easily derived from one another)\n But the key had to be distributed to all users of the system\n Thus  it seemed as if there was an inherent problem\n Keys had to be protected from theft  but they also had to be distributed  so they could not be locked in a bank vault\n In  two researchers at Stanford University  Diffie and Hellman (   )  proposed a radically new kind of cryptosystem  one in which the encryption and decryption keys were so different that the decryption key could not feasibly be NETWORK URITY  \n  derived from the encryption key\n In their proposal  the (keyed) encryption algorithm  E  and the (keyed) decryption algorithm  D  had to meet three requirements\n These requirements can be stated simply as follows:  \n D(E(P)) = P It is exceedingly difficult to deduce D from E E cannot be broken by a chosen plaintext attack\n The first requirement says that if we apply D to an encrypted message  E(P)  we get the original plaintext message  P  back\n Without this property  the legitimate receiver could not decrypt the ciphertext\n The ond requirement speaks for itself\n The third requirement is needed because  as we shall see in a moment  intruders may experiment with the algorithm to their hearts’ content\n Under these conditions  there is no reason that the encryption key cannot be made public\n The method works like this\n A person  say  Alice  who wants to receive ret messages  first devises two algorithms meeting the above requirements\n The encryption algorithm and Alice’s key are then made public  hence the name publickey cryptography\n Alice might put her public key on her home page on the Web  for example\n We will use the notation EA to mean the encryption algorithm parameterized by Alice’s public key\n Similarly  the (ret) decryption algorithm parameterized by Alice’s private key is DA\n Bob does the same thing  publicizing EB but keeping DB ret\n Now let us see if we can solve the problem of establishing a ure channel between Alice and Bob  who have never had any previous contact\n Both Alice’s encryption key  EA  and Bob’s encryption key  EB  are assumed to be in publicly readable files\n Now Alice takes her first message  P  computes EB(P)  and sends it to Bob\n Bob then decrypts it by applying his ret key DB [ \n  he computes DB(EB(P)) = P]\n No one else can read the encrypted message  EB(P)  because the encryption system is assumed to be strong and because it is too difficult to derive DB from the publicly known EB\n To send a reply  R  Bob transmits EA(R)\n Alice and Bob can now communicate urely\n A note on terminology is perhaps useful here\n Public-key cryptography requires each user to have two keys: a public key  used by the entire world for encrypting messages to be sent to that user  and a private key  which the user needs for decrypting messages\n We will consistently refer to these keys as the public and private keys  respectively  and distinguish them from the ret keys used for conventional symmetric-key cryptography\n    RSA The only catch is that we need to find algorithms that indeed satisfy all three requirements\n Due to the potential advantages of public-key cryptography  many researchers are hard at work  and some algorithms have already been published\n   PUBLIC-KEY ALGORITHMS One good method was discovered by a group at  \n (Rivest et al\n  )\n It is known by the initials of the three discoverers (Rivest  Shamir  Adleman): RSA\n It has survived all attempts to break it for more than   years and is considered very strong\n Much practical urity is based on it\n For this reason  Rivest  Shamir  and Adleman were given the  ACM Turing Award\n Its major disadvantage is that it requires keys of at least  bits for good urity (versus bits for symmetric-key algorithms)  which makes it quite slow\n The RSA method is based on some principles from number theory\n We will now summarize how to use the method; for details  consult the paper Choose two large primes  p and q (typically  bits) Compute n = p × q and z = (p −  ) × (q −  ) Choose a number relatively prime to z and call it d Find e such that e × d =  mod z\n With these parameters computed in advance  we are ready to begin encryption\n Divide the plaintext (regarded as a bit string) into blocks  so that each plaintext message  P  falls in the interval  ≤ P < n\n Do that by grouping the plaintext into blocks of k bits  where k is the largest integer for which  k < n is true\n To encrypt a message  P  compute C = Pe (mod n)\n To decrypt C  compute P = Cd (mod n)\n It can be proven that for all P in the specified range  the encryption and decryption functions are inverses\n To perform the encryption  you need e and n\n To perform the decryption  you need d and n\n Therefore  the public key consists of the pair (e  n) and the private key consists of (d  n)\n The urity of the method is based on the difficulty of factoring large numbers\n If the cryptanalyst could factor the (publicly known) n  he could then find p and q  and from these z\n Equipped with knowledge of z and e  d can be found using Euclid’s algorithm\n Fortunately  mathematicians have been trying to factor large numbers for at least years  and the accumulated evidence suggests that it is an exceedingly difficult problem\n According to Rivest and colleagues  factoring a   -digit number would require  years using brute force\n In both cases  they assumed the best known algorithm and a computer with a  -μ instruction time\n With a million chips running in parallel  each with an instruction time of  n  it would still take  years\n Even if computers continue to get faster by an order of magnitude per decade  it will be many years before factoring a   -digit number becomes feasible  at which time our descendants can simply choose p and q still larger\n A trivial pedagogical example of how the RSA algorithm works is given in Fig\n  -  \n For this example  we have chosen p =  and q = giving n =   and z =  \n A suitable value for d is d =   since  and   have no common factors\n With these choices  e can be found by solving the equation  e =  (mod  )  which yields e =  \n The ciphertext  C  corresponding to a plaintext message  P  is NETWORK URITY  \n  given by C = P  (mod  )\n The ciphertext is decrypted by the receiver by making use of the rule P = C  (mod  )\n The figure shows the encryption of the plaintext ‘‘SUZANNE’’ as an example\n Symbolic S U Z A N N E Symbolic S U Z A N N E Numeric Plaintext (P) Ciphertext (C) After decryption Sender's computation Receiver's computation        P       P  (mod  ) C  (mod  )     C         Figure  -  \n An example of the RSA algorithm\n Because the primes chosen for this example are so small  P must be less than so each plaintext block can contain only a single character\n The result is a monoalphabetic substitution cipher  not very impressive\n If instead we had chosen p and q ∼∼  we would have n ∼∼   so each block could be up to  bits or eight-bit characters  versus  characters for DES and   characters for AES\n It should be pointed out that using RSA as we have described is similar to using a symmetric algorithm in ECB mode—the same input block gives the same output block\n Therefore  some form of chaining is needed for data encryption\n However  in practice  most RSA-based systems use public-key cryptography primarily for distributing one-time session keys for use with some symmetric-key algorithm such as AES or triple DES\n RSA is too slow for actually encrypting large volumes of data but is widely used for key distribution\n    Other Public-Key Algorithms Although RSA is widely used  it is by no means the only public-key algorithm known\n The first public-key algorithm was the knapsack algorithm (Merkle and Hellman  )\n The idea here is that someone owns a large number of objects  each with a different weight\n The owner encodes the message by retly selecting a subset of the objects and placing them in the knapsack\n The total weight of the objects in the knapsack is made public  as is the list of all possible objects and their corresponding weights\n The list of objects in the knapsack is kept ret\n With certain additional restrictions  the problem of figuring out a possible list of objects with the given weight was thought to be computationally infeasible and formed the basis of the public-key algorithm\n   PUBLIC-KEY ALGORITHMS The algorithm’s inventor  Ralph Merkle  was quite sure that this algorithm could not be broken  so he offered a $   reward to anyone who could break it\n Adi Shamir (the ‘‘S’’ in RSA) promptly broke it and collected the reward\n Undeterred  Merkle strengthened the algorithm and offered a $ reward to anyone who could break the new one\n Ronald Rivest (the ‘‘R’’ in RSA) promptly broke the new one and collected the reward\n Merkle did not dare offer $  for the next version  so ‘‘A’’ (Leonard Adleman) was out of luck\n Nevertheless  the knapsack algorithm is not considered ure and is not used in practice any more\n Other public-key schemes are based on the difficulty of computing discrete logarithms\n Algorithms that use this principle have been invented by El Gamal (   ) and Schnorr (   )\n A few other schemes exist  such as those based on elliptic curves (Menezes and Vanstone  )  but the two major categories are those based on the difficulty of factoring large numbers and computing discrete logarithms modulo a large prime\n These problems are thought to be genuinely difficult to solve— mathematicians have been working on them for many years without any great breakthroughs  DIGITAL SIGNATURES The authenticity of many legal  financial  and other documents is determined by the presence or absence of an authorized handwritten signature\n And photocopies do not count\n For computerized message systems to replace the physical transport of paper-and-ink documents  a method must be found to allow documents to be signed in an unforgeable way\n The problem of devising a replacement for handwritten signatures is a difficult one\n Basically  what is needed is a system by which one party can send a signed message to another party in such a way that the following conditions hold:  \n The receiver can verify the claimed identity of the sender The sender cannot later repudiate the contents of the message The receiver cannot possibly have concocted the message himself\n The first requirement is needed  for example  in financial systems\n When a customer’s computer orders a bank’s computer to buy a ton of gold  the bank’s computer needs to be able to make sure that the computer giving the order really belongs to the customer whose account is to be debited\n In other words  the bank has to authenticate the customer (and the customer has to authenticate the bank)\n The ond requirement is needed to protect the bank against fraud\n Suppose that the bank buys the ton of gold  and immediately thereafter the price of gold NETWORK URITY  \n  drops sharply\n A dishonest customer might then proceed to sue the bank  claiming that he never issued any order to buy gold\n When the bank produces the message in court  the customer may deny having sent it\n The property that no party to a contract can later deny having signed it is called nonrepudiation\n The digital signature schemes that we will now study help provide it\n The third requirement is needed to protect the customer in the event that the price of gold shoots up and the bank tries to construct a signed message in which the customer asked for one bar of gold instead of one ton\n In this fraud scenario  the bank just keeps the rest of the gold for itself\n    Symmetric-Key Signatures One approach to digital signatures is to have a central authority that knows everything and whom everyone trusts  say  Big Brother (BB)\n Each user then chooses a ret key and carries it by hand to BB’s office\n Thus  only Alice and BB know Alice’s ret key  KA  and so on\n When Alice wants to send a signed plaintext message  P  to her banker  Bob  she generates KA(B  RA  t  P)  where B is Bob’s identity  RA is a random number chosen by Alice  t is a timestamp to ensure freshness  and KA(B  RA  t  P) is the message encrypted with her key  KA\n Then she sends it as depicted in Fig\n  -  \n BB sees that the message is from Alice  decrypts it  and sends a message to Bob as shown\n The message to Bob contains the plaintext of Alice’s message and also the signed message KBB(A  t  P)\n Bob now carries out Alice’s request\n A  KA (B  RA  t  P) Bob Alice BB KB (A  RA  t  P  KBB (A  t  P)) Figure  -  \n Digital signatures with Big Brother\n What happens if Alice later denies sending the message? Step  is that everyone sues everyone (at least  in the United States)\n Finally  when the case comes to court and Alice vigorously denies sending Bob the disputed message  the judge will ask Bob how he can be sure that the disputed message came from Alice and not from Trudy\n Bob first points out that BB will not accept a message from Alice unless it is encrypted with KA  so there is no possibility of Trudy sending BB a false message from Alice without BB detecting it immediately\n Bob then dramatically produces Exhibit A: KBB(A  t  P)\n Bob says that this is a message signed by BB that proves Alice sent P to Bob\n The judge then asks BB (whom everyone trusts) to decrypt Exhibit A\n When BB testifies that Bob is telling the truth  the judge decides in favor of Bob\n Case dismissed\n   DIGITAL SIGNATURES One potential problem with the signature protocol of Fig\n  -  is Trudy replaying either message\n To minimize this problem  timestamps are used throughout\n Furthermore  Bob can check all recent messages to see if RA was used in any of them\n If so  the message is discarded as a replay\n Note that based on the timestamp  Bob will reject very old messages\n To guard against instant replay attacks  Bob just checks the RA of every incoming message to see if such a message has been received from Alice in the past hour\n If not  Bob can safely assume this is a new request\n    Public-Key Signatures A structural problem with using symmetric-key cryptography for digital signatures is that everyone has to agree to trust Big Brother\n Furthermore  Big Brother gets to read all signed messages\n The most logical candidates for running the Big Brother server are the government  the banks  the accountants  and the lawyers\n Unfortunately  none of these inspire total confidence in all citizens\n Hence  it would be nice if signing documents did not require a trusted authority\n Fortunately  public-key cryptography can make an important contribution in this area\n Let us assume that the public-key encryption and decryption algorithms have the property that E(D(P)) = P  in addition  of course  to the usual property that D(E(P)) = P\n (RSA has this property  so the assumption is not unreasonable\n) Assuming that this is the case  Alice can send a signed plaintext message  P  to Bob by transmitting EB(DA(P))\n Note carefully that Alice knows her own (private) key  DA  as well as Bob’s public key  EB  so constructing this message is something Alice can do\n When Bob receives the message  he transforms it using his private key  as usual  yielding DA(P)  as shown in Fig\n  -  \n He stores this text in a safe place and then applies EA to get the original plaintext\n Bob's public key  EB Alice's private key  DA Bob's private key  DB DA(P) EB (DA(P)) DA(P) Transmission line Alice's computer Bob's computer P P Alice's public key  EA Figure  -  \n Digital signatures using public-key cryptography\n To see how the signature property works  suppose that Alice subsequently denies having sent the message P to Bob\n When the case comes up in court  Bob can produce both P and DA(P)\n The judge can easily verify that Bob indeed has a valid message encrypted by DA by simply applying EA to it\n Since Bob does not NETWORK URITY  \n  know what Alice’s private key is  the only way Bob could have acquired a message encrypted by it is if Alice did indeed send it\n While in jail for perjury and fraud  Alice will have much time to devise interesting new public-key algorithms\n Although using public-key cryptography for digital signatures is an elegant scheme  there are problems that are related to the environment in which they operate rather than to the basic algorithm\n For one thing  Bob can prove that a message was sent by Alice only as long as DA remains ret\n If Alice discloses her ret key  the argument no longer holds  because anyone could have sent the message  including Bob himself\n The problem might arise  for example  if Bob is Alice’s stockbroker\n Suppose that Alice tells Bob to buy a certain stock or bond\n Immediately thereafter  the price drops sharply\n To repudiate her message to Bob  Alice runs to the police claiming that her home was burglarized and the PC holding her key was stolen\n Depending on the laws in her state or country  she may or may not be legally liable  especially if she claims not to have discovered the break-in until getting home from work  several hours after it allegedly happened\n Another problem with the signature scheme is what happens if Alice decides to change her key\n Doing so is clearly legal  and it is probably a good idea to do so periodically\n If a court case later arises  as described above  the judge will apply the current EA to DA(P) and discover that it does not produce P\n Bob will look pretty stupid at this point\n In principle  any public-key algorithm can be used for digital signatures\n The de facto industry standard is the RSA algorithm\n Many urity products use it\n However  in  NIST proposed using a variant of the El Gamal public-key algorithm for its new Digital Signature Standard (DSS)\n El Gamal gets its urity from the difficulty of computing discrete logarithms  rather than from the difficulty of factoring large numbers\n As usual when the government tries to dictate cryptographic standards  there was an uproar\n DSS was criticized for being  \n Too ret (NSA designed the protocol for using El Gamal) Too slow (  to   times slower than RSA for checking signatures) Too new (El Gamal had not yet been thoroughly analyzed) Too inure (fixed   -bit key)\n In a subsequent revision  the fourth point was rendered moot when keys up to  bits were allowed\n Nevertheless  the first two points remain valid\n    Message Digests One criticism of signature methods is that they often couple two distinct functions: authentication and recy\n Often  authentication is needed but recy is not always needed\n Also  getting an export license is often easier if the system in   DIGITAL SIGNATURES question provides only authentication but not recy\n Below we will describe an authentication scheme that does not require encrypting the entire message\n This scheme is based on the idea of a one-way hash function that takes an arbitrarily long piece of plaintext and from it computes a fixed-length bit string\n This hash function  MD  often called a message digest  has four important properties:  \n Given P  it is easy to compute MD(P) Given MD(P)  it is effectively impossible to find P Given P  no one can find P′ such that MD(P′) = MD(P) A change to the input of even  bit produces a very different output\n To meet criterion   the hash should be at least bits long  preferably more\n To meet criterion   the hash must mangle the bits very thoroughly  not unlike the symmetric-key encryption algorithms we have seen\n Computing a message digest from a piece of plaintext is much faster than encrypting that plaintext with a public-key algorithm  so message digests can be used to speed up digital signature algorithms\n To see how this works  consider the signature protocol of Fig\n  -  again\n Instead  of signing P with KBB(A  t  P)  BB now computes the message digest by applying MD to P  yielding MD(P)\n BB then encloses KBB(A  t  MD(P)) as the fifth item in the list encrypted with KB that is sent to Bob  instead of KBB(A  t  P)\n If a dispute arises  Bob can produce both P and KBB(A  t  MD(P))\n After Big Brother has decrypted it for the judge  Bob has MD(P)  which is guaranteed to be genuine  and the alleged P\n However  since it is effectively impossible for Bob to find any other message that gives this hash  the judge will easily be convinced that Bob is telling the truth\n Using message digests in this way saves both encryption time and message transport costs\n Message digests work in public-key cryptosystems  too  as shown in Fig\n  -  \n Here  Alice first computes the message digest of her plaintext\n She then signs the message digest and sends both the signed digest and the plaintext to Bob\n If Trudy replaces P along the way  Bob will see this when he computes MD(P)\n P  DA (MD (P)) Bob Alice Figure  -  \n Digital signatures using message digests\n NETWORK URITY  \n  SHA-  and SHA-  A variety of message digest functions have been proposed\n One of the most widely used functions is SHA-  (ure Hash Algorithm  ) (NIST  )\n Like all message digests  it operates by mangling bits in a sufficiently complicated way that every output bit is affected by every input bit\n SHA-  was developed by NSA and blessed by NIST in FIPS   - \n It processes input data in   -bit blocks  and it generates a   -bit message digest\n A typical way for Alice to send a nonret but signed message to Bob is illustrated in Fig\n  -  \n Here  her plaintext message is fed into the SHA-  algorithm to get a   -bit SHA-  hash\n Alice then signs the hash with her RSA private key and sends both the plaintext message and the signed hash to Bob\n SHA-  algorithm H   -Bit SHA-  hash of M DA(H) Signed hash RSA algorithm Alice's private key  DA Sent to Bob Alice's plaintext message M (arbitrary length) Figure  -  \n Use of SHA-  and RSA for signing nonret messages\n After receiving the message  Bob computes the SHA-  hash himself and also applies Alice’s public key to the signed hash to get the original hash  H\n If the two agree  the message is considered valid\n Since there is no way for Trudy to modify the (plaintext) message while it is in transit and produce a new one that hashes to H  Bob can easily detect any changes Trudy has made to the message\n For messages whose integrity is important but whose contents are not ret  the scheme of Fig\n  -  is widely used\n For a relatively small cost in computation  it guarantees that any modifications made to the plaintext message in transit can be detected with very high probability\n Now let us briefly see how SHA-  works\n It starts out by padding the message by adding a  bit to the end  followed by as many  bits as are necessary  but at least to make the length a multiple of bits\n Then a  -bit number containing the message length before padding is ORed into the low-order   bits\n In Fig\n  -   the message is shown with padding on the right because English text and figures go from left to right ( \n  the lower right is generally perceived as the end of the figure)\n With computers  this orientation corresponds to big-endian machines such as the SPARC and the IBM and its successors  but SHA-  always pads the end of the message  no matter which endian machine is used\n   DIGITAL SIGNATURES M  H  W  M  H  W  M  H  W  H  Mn-  (a) Start of message   -Bit block  -Bit word Padding (b) (c) H  W  Figure  -  \n (a) A message padded out to a multiple of bits\n (b) The output variables\n (c) The word array\n During the computation  SHA-  maintains five  -bit variables  H  through H  where the hash accumulates\n These are shown in Fig\n  -  (b)\n They are initialized to constants specified in the standard\n Each of the blocks M  through Mn −  is now processed in turn\n For the current block  the   words are first copied into the start of an auxiliary  -word array  W  as shown in Fig\n  -  (c)\n Then the other   words in W are filled in using the formula Wi = S (Wi −  XOR Wi −  XOR Wi −  XOR Wi −  ) (  ≤ i ≤  ) where Sb(W) represents the left circular rotation of the  -bit word  W  by b bits\n Now five scratch variables  A through E  are initialized from H  through H  respectively\n The actual calculation can be expressed in pseudo-C as for (i =  ; i <  ; i++) { temp = S (A) + fi (B  C  D) + E + Wi + Ki; E = D; D = C; C = S  (B); B = A; A = temp; } where the Ki constants are defined in the standard\n The mixing functions fi are defined as fi (B C D) = (B AND C) OR (NOT B AND D) (  ≤ i ≤  ) fi (B C D) = B XOR C XOR D (  ≤ i ≤  ) fi (B C D) = (B AND C) OR (B AND D) OR (C AND D) (  ≤ i ≤  ) fi (B C D) = B XOR C XOR D (  ≤ i ≤  ) When all   iterations of the loop are completed  A through E are added to H  through H  respectively\n Now that the first   -bit block has been processed  the next one is started\n The W array is reinitialized from the new block  but H is left as it was\n When this NETWORK URITY  \n  block is finished  the next one is started  and so on  until all the   -bit message blocks have been tossed into the soup\n When the last block has been finished  the five  -bit words in the H array are output as the   -bit cryptographic hash\n The complete C code for SHA-  is given in RFC \n New versions of SHA-  have been developed that produce hashes of   and bits\n Collectively  these versions are called SHA- \n Not only are these hashes longer than SHA-  hashes  but the digest function has been changed to combat some potential weaknesses of SHA- \n SHA-  is not yet widely used  but it is likely to be in the future\n MD  For completeness  we will mention another digest that is popular\n MD  (Rivest  ) is the fifth in a series of message digests designed by Ronald Rivest\n Very briefly  the message is padded to a length of bits (modulo   )\n Then the original length of the message is appended as a  -bit integer to give a total input whose length is a multiple of bits\n Each round of the computation takes a   -bit block of input and mixes it thoroughly with a running   -bit buffer\n For good measure  the mixing uses a table constructed from the sine function\n The point of using a known function is to avoid any suspicion that the designer built in a clever back door through which only he can enter\n This process continues until all the input blocks have been consumed\n The contents of the   -bit buffer form the message digest\n After more than a decade of solid use and study  weaknesses in MD  have led to the ability to find collisions  or different messages with the same hash (Sotirov  et al\n  )\n This is the death knell for a digest function because it means that the digest cannot safely be used to represent a message\n Thus  the urity community considers MD  to be broken; it should be replaced where possible and no new systems should use it as part of their design\n Nevertheless  you may still see MD  used in existing systems\n    The Birthday Attack In the world of crypto  nothing is ever what it seems to be\n One might think that it would take on the order of  m operations to subvert an m-bit message digest\n In fact  m/  operations will often do using the birthday attack  an approach published by Yuval (   ) in his now-classic paper ‘‘How to Swindle Rabin\n’’ The idea for this attack comes from a technique that math professors often use in their probability courses\n The question is: how many students do you need in a class before the probability of having two people with the same birthday exceeds  / ? Most students expect the answer to be way over   \n In fact  probability theory says it is just  \n Without giving a rigorous analysis  intuitively  with     DIGITAL SIGNATURES people  we can form (  ×  )/  = different pairs  each of which has a probability of  /   of being a hit\n In this light  it is not really so surprising any more\n More generally  if there is some mapping between inputs and outputs with n inputs (people  messages  etc\n) and k possible outputs (birthdays  message digests  etc\n)  there are n(n −  )/  input pairs\n If n(n −  )/  > k  the chance of having at least one match is pretty good\n Thus  approximately  a match is likely for n > √k \n This result means that a  -bit message digest can probably be broken by generating about messages and looking for two with the same message digest\n Let us look at a practical example\n The Department of Computer Science at State University has one position for a tenured faculty member and two candidates  Tom and Dick\n Tom was hired two years before Dick  so he goes up for review first\n If he gets it  Dick is out of luck\n Tom knows that the department chairperson  Marilyn  thinks highly of his work  so he asks her to write him a letter of recommendation to the Dean  who will decide on Tom’s case\n Once sent  all letters become confidential\n Marilyn tells her retary  Ellen  to write the Dean a letter  outlining what she wants in it\n When it is ready  Marilyn will review it  compute and sign the  -bit digest  and send it to the Dean\n Ellen can send the letter later by email\n Unfortunately for Tom  Ellen is romantically involved with Dick and would like to do Tom in  so she writes the following letter with the   bracketed options: Dear Dean Smith  This [letter | message] is to give my [honest | frank] opinion of Prof\n Tom Wilson  who is [a candidate | up] for tenure [now | this year]\n I have [known | worked with] Prof\n Wilson for [about | almost] six years\n He is an [outstanding | excellent] researcher of great [talent | ability] known [worldwide | internationally] for his [brilliant | creative] insights into [many | a wide variety of] [difficult | challenging] problems\n He is also a [highly | greatly] [respected | admired] [teacher | educator]\n His students give his [classes | courses] [rave | spectacular] reviews\n He is [our | the Department’s] [most popular | best-loved] [teacher | instructor]\n [In addition | Additionally] Prof\n Wilson is a [gifted | effective] fund raiser\n His [grants | contracts] have brought a [large | substantial] amount of money into [the | our] Department\n [This money has | These funds have] [enabled | permitted] us to [pursue | carry out] many [special | important] programs  [such as | for example] your State  program\n Without these funds we would [be unable | not be able] to continue this program  which is so [important | essential] to both of us\n I strongly urge you to grant him tenure\n Unfortunately for Tom  as soon as Ellen finishes composing and typing in this letter  she also writes a ond one: NETWORK URITY  \n  Dear Dean Smith  This [letter | message] is to give my [honest | frank] opinion of Prof\n Tom Wilson  who is [a candidate | up] for tenure [now | this year]\n I have [known | worked with] Tom for [about | almost] six years\n He is a [poor | weak] researcher not well known in his [field | area]\n His research [hardly ever | rarely] shows [insight in | understanding of] the [key | major] problems of [the | our] day\n Furthermore  he is not a [respected | admired] [teacher | educator]\n His students give his [classes | courses] [poor | bad ] reviews\n He is [our | the Department’s] least popular [teacher | instructor]  known [mostly | primarily] within [the | our] Department for his [tendency | propensity] to [ridicule | embarrass] students [foolish | imprudent] enough to ask questions in his classes\n [In addition | Additionally] Tom is a [poor | marginal] fund raiser\n His [grants | contracts] have brought only a [meager | insignificant] amount of money into [the | our] Department\n Unless new [money is | funds are] quickly located  we may have to cancel some essential programs  such as your State  program\n Unfortunately  under these [conditions | circumstances] I cannot in good [conscience | faith] recommend him to you for [tenure | a permanent position]\n Now Ellen programs her computer to compute the message digests of each letter overnight\n Chances are  one digest of the first letter will match one digest of the ond\n If not  she can add a few more options and try again tonight\n Suppose that she finds a match\n Call the ‘‘good’’ letter A and the ‘‘bad’’ one B\n Ellen now emails letter A to Marilyn for approval\n Letter B she keeps ret  showing it to no one\n Marilyn  of course  approves it  computes her  -bit message digest  signs the digest  and emails the signed digest off to Dean Smith\n Independently  Ellen emails letter B to the Dean (not letter A  as she is supposed to)\n After getting the letter and signed message digest  the Dean runs the message digest algorithm on letter B  sees that it agrees with what Marilyn sent him  and fires Tom\n The Dean does not realize that Ellen managed to generate two letters with the same message digest and sent her a different one than the one Marilyn saw and approved\n (Optional ending: Ellen tells Dick what she did\n Dick is appalled and breaks off the affair\n Ellen is furious and confesses to Marilyn\n Marilyn calls the Dean\n Tom gets tenure after all\n) With SHA-  the birthday attack is difficult because even at the ridiculous speed of  trillion digests per ond  it would take over   years to compute all digests of two letters with   variants each  and even then a match is not guaranteed\n With a cloud of  chips working in parallel    years becomes  weeks  MANAGEMENT OF PUBLIC KEYS Public-key cryptography makes it possible for people who do not share a common key in advance to nevertheless communicate urely\n It also makes signing messages possible without the presence of a trusted third party\n Finally    MANAGEMENT OF PUBLIC KEYS signed message digests make it possible for the recipient to verify the integrity of received messages easily and urely\n However  there is one problem that we have glossed over a bit too quickly: if Alice and Bob do not know each other  how do they get each other’s public keys to start the communication process? The obvious solution—put your public key on your Web site—does not work  for the following reason\n Suppose that Alice wants to look up Bob’s public key on his Web site\n How does she do it? She starts by typing in Bob’s URL\n Her browser then looks up the DNS address of Bob’s home page and sends it a GET request  as shown in Fig\n  -  \n Unfortunately  Trudy intercepts the request and replies with a fake home page  probably a copy of Bob’s home page except for the replacement of Bob’s public key with Trudy’s public key\n When Alice now encrypts her first message with ET  Trudy decrypts it  reads it  re-encrypts it with Bob’s public key  and sends it to Bob  who is none the wiser that Trudy is reading his incoming messages\n Worse yet  Trudy could modify the messages before reencrypting them for Bob\n Clearly  some mechanism is needed to make sure that public keys can be exchanged urely EB(Message) Alice Trudy  \n GET Bob's home page  \n Fake home page with ET  \n ET(Message) Bob Figure  -  \n A way for Trudy to subvert public-key encryption\n    Certificates As a first attempt at distributing public keys urely  we could imagine a KDC key distribution center available online   hours a day to provide public keys on demand\n One of the many problems with this solution is that it is not scalable  and the key distribution center would rapidly become a bottleneck\n Also  if it ever went down  Internet urity would suddenly grind to a halt\n For these reasons  people have developed a different solution  one that does not require the key distribution center to be online all the time\n In fact  it does not have to be online at all\n Instead  what it does is certify the public keys belonging to people  companies  and other organizations\n An organization that certifies public keys is now called a CA (Certification Authority)\n As an example  suppose that Bob wants to allow Alice and other people he does not know to communicate with him urely\n He can go to the CA with his public key along with his passport or driver’s license and ask to be certified\n The CA then issues a certificate similar to the one in Fig\n  -  and signs its SHA-  NETWORK URITY  \n  hash with the CA’s private key\n Bob then pays the CA’s fee and gets a CD-ROM containing the certificate and its signed hash\n I hereby certify that the public key  A B CF E  FC s    FFA    A belongs to Robert John Smith  University Avenue Berkeley  CA  Birthday: July    Email: bob@  SHA-  hash of the above certificate signed with the CA’s private key Figure  -  \n A possible certificate and its signed hash\n The fundamental job of a certificate is to bind a public key to the name of a principal (individual  company  etc\n)\n Certificates themselves are not ret or protected\n Bob might  for example  decide to put his new certificate on his Web site  with a link on the main page saying: Click here for my public-key certificate\n The resulting click would return both the certificate and the signature block (the signed SHA-  hash of the certificate)\n Now let us run through the scenario of Fig\n  -  again\n When Trudy intercepts Alice’s request for Bob’s home page  what can she do? She can put her own certificate and signature block on the fake page  but when Alice reads the contents of the certificate she will immediately see that she is not talking to Bob because Bob’s name is not in it\n Trudy can modify Bob’s home page on the fly  replacing Bob’s public key with her own\n However  when Alice runs the SHA-  algorithm on the certificate  she will get a hash that does not agree with the one she gets when she applies the CA’s well-known public key to the signature block\n Since Trudy does not have the CA’s private key  she has no way of generating a signature block that contains the hash of the modified Web page with her public key on it\n In this way  Alice can be sure she has Bob’s public key and not Trudy’s or someone else’s\n And as we promised  this scheme does not require the CA to be online for verification  thus eliminating a potential bottleneck\n While the standard function of a certificate is to bind a public key to a principal  a certificate can also be used to bind a public key to an attribute\n For example  a certificate could say: ‘‘This public key belongs to someone over  \n’’ It could be used to prove that the owner of the private key was not a minor and thus allowed to access material not suitable for children  and so on  but without disclosing the owner’s identity\n Typically  the person holding the certificate would send it to the Web site  principal  or process that cared about age\n That site  principal  or process would then generate a random number and encrypt it with the public key in the certificate\n If the owner were able to decrypt it and send it back    MANAGEMENT OF PUBLIC KEYS that would be proof that the owner indeed had the attribute stated in the certificate\n Alternatively  the random number could be used to generate a session key for the ensuing conversation\n Another example of where a certificate might contain an attribute is in an object- oriented distributed system\n Each object normally has multiple methods\n The owner of the object could provide each customer with a certificate giving a bit map of which methods the customer is allowed to invoke and binding the bit map to a public key using a signed certificate\n Again  if the certificate holder can prove possession of the corresponding private key  he will be allowed to perform the methods in the bit map\n This approach has the property that the owner’s identity need not be known  a property useful in situations where privacy is important\n    X\n   If everybody who wanted something signed went to the CA with a different kind of certificate  managing all the different formats would soon become a problem\n To solve this problem  a standard for certificates has been devised and approved by ITU\n The standard is called X\n   and is in widespread use on the Internet\n It has gone through three versions since the initial standardization in \n We will discuss V \n X\n   has been heavily influenced by the OSI world  borrowing some of its worst features ( \n  naming and encoding)\n Surprisingly  IETF went along with X\n even though in nearly every other area  from machine addresses to transport protocols to email formats  IETF generally ignored OSI and tried to do it right\n The IETF version of X\n   is described in RFC \n At its core  X\n   is a way to describe certificates\n The primary fields in a certificate are listed in Fig\n  -  \n The descriptions given there should provide a general idea of what the fields do\n For additional information  please consult the standard itself or RFC \n For example  if Bob works in the loan department of the Money Bank  his X\n   address might be /C=US/O=MoneyBank/OU=Loan/CN=Bob/ where C is for country  O is for organization  OU is for organizational unit  and CN is for common name\n CAs and other entities are named in a similar way\n A substantial problem with X\n   names is that if Alice is trying to contact bob@  and is given a certificate with an X\n   name  it may not be obvious to her that the certificate refers to the Bob she wants\n Fortunately  starting with version   DNS names are now permitted instead of X\n   names  so this problem may eventually vanish\n Certificates are encoded using OSI ASN\n  (Abstract Syntax Notation  )  which is sort of like a struct in C  except with a extremely peculiar and verbose notation\n More information about X\n   is given by Ford and Baum (   )\n NETWORK URITY  \n  Field Meaning Version Which version of X\n   Serial number This number plus the CA’s name uniquely identifies the certificate Signature algorithm The algorithm used to sign the certificate Issuer X\n   name of the CA Validity period The starting and ending times of the validity period Subject name The entity whose key is being certified Public key The subject’s public key and the ID of the algorithm using it Issuer ID An optional ID uniquely identifying the certificate’s issuer Subject ID An optional ID uniquely identifying the certificate’s subject Extensions Many extensions have been defined Signature The certificate’s signature (signed by the CA’s private key) Figure  -  \n The basic fields of an X\n   certificate\n    Public Key Infrastructures Having a single CA to issue all the world’s certificates obviously would not work\n It would collapse under the load and be a central point of failure as well\n A possible solution might be to have multiple CAs  all run by the same organization and all using the same private key to sign certificates\n While this would solve the load and failure problems  it introduces a new problem: key leakage\n If there were dozens of servers spread around the world  all holding the CA’s private key  the chance of the private key being stolen or otherwise leaking out would be greatly increased\n Since the compromise of this key would ruin the world’s electronic urity infrastructure  having a single central CA is very risky\n In addition  which organization would operate the CA? It is hard to imagine any authority that would be accepted worldwide as legitimate and trustworthy\n In some countries  people would insist that it be a government  while in other countries they would insist that it not be a government\n For these reasons  a different way for certifying public keys has evolved\n It goes under the general name of PKI (Public Key Infrastructure)\n In this tion  we will summarize how it works in general  although there have been many proposals  so the details will probably evolve in time\n A PKI has multiple components  including users  CAs  certificates  and directories\n What the PKI does is provide a way of structuring these components and define standards for the various documents and protocols\n A particularly simple form of PKI is a hierarchy of CAs  as depicted in Fig\n  -  \n In this example we have shown three levels  but in practice there might be fewer or more\n The toplevel CA  the root  certifies ond-level CAs  which we here call RAs (Regional   MANAGEMENT OF PUBLIC KEYS Authorities) because they might cover some geographic region  such as a country or continent\n This term is not standard  though; in fact  no term is really standard for the different levels of the tree\n These in turn certify the real CAs  which issue the X\n   certificates to organizations and individuals\n When the root authorizes a new RA  it generates an X\n   certificate stating that it has approved the RA  includes the new RA’s public key in it  signs it  and hands it to the RA\n Similarly  when an RA approves a new CA  it produces and signs a certificate stating its approval and containing the CA’s public key\n CA  CA  (a) (b) CA  CA  CA  RA  RA  is approved\n Its public key is  AE   \n Root's signature RA  Root RA  is approved\n Its public key is  AE   \n Root's signature CA  is approved\n Its public key is AF  B \n RA  's signature CA  is approved\n Its public key is AF  B \n RA  's signature Figure  -  \n (a) A hierarchical PKI\n (b) A chain of certificates\n Our PKI works like this\n Suppose that Alice needs Bob’s public key in order to communicate with him  so she looks for and finds a certificate containing it  signed by CA  \n But Alice has never heard of CA  \n For all she knows  CA  might be Bob’s  -year-old daughter\n She could go to CA  and say: ‘‘Prove your legitimacy\n’’ CA  will respond with the certificate it got from RA   which contains CA  ’s public key\n Now armed with CA  ’s public key  she can verify that Bob’s certificate was indeed signed by CA  and is thus legal\n Unless RA  is Bob’s  -year-old son\n So  the next step is for her to ask RA  to prove it is legitimate\n The response to her query is a certificate signed by the root and containing RA ’s public key\n Now Alice is sure she has Bob’s public key\n But how does Alice find the root’s public key? Magic\n It is assumed that everyone knows the root’s public key\n For example  her browser might have been shipped with the root’s public key built in\n Bob is a friendly sort of guy and does not want to cause Alice a lot of work\n He knows that she is going to have to check out CA  and RA   so to save her some trouble  he collects the two needed certificates and gives her the two certificates along with his\n Now she can use her own knowledge of the root’s public key to verify the top-level certificate and the public key contained therein to verify the ond one\n Alice does not need to contact anyone to do the verification\n NETWORK URITY  \n  Because the certificates are all signed  she can easily detect any attempts to tamper with their contents\n A chain of certificates going back to the root like this is sometimes called a chain of trust or a certification path\n The technique is widely used in practice\n Of course  we still have the problem of who is going to run the root\n The solution is not to have a single root  but to have many roots  each with its own RAs and CAs\n In fact  modern browsers come preloaded with the public keys for over roots  sometimes referred to as trust anchors\n In this way  having a single worldwide trusted authority can be avoided\n But there is now the issue of how the browser vendor decides which purported trust anchors are reliable and which are sleazy\n It all comes down to the user trusting the browser vendor to make wise choices and not simply approve all trust anchors willing to pay its inclusion fee\n Most browsers allow users to inspect the root keys (usually in the form of certificates signed by the root) and delete any that seem shady\n Directories Another issue for any PKI is where certificates (and their chains back to some known trust anchor) are stored\n One possibility is to have each user store his or her own certificates\n While doing this is safe ( \n  there is no way for users to tamper with signed certificates without detection)  it is also inconvenient\n One alternative that has been proposed is to use DNS as a certificate directory\n Before contacting Bob  Alice probably has to look up his IP address using DNS  so why not have DNS return Bob’s entire certificate chain along with his IP address? Some people think this is the way to go  but others would prefer dedicated directory servers whose only job is managing X\n   certificates\n Such directories could provide lookup services by using properties of the X\n   names\n For example  in theory such a directory service could answer a query such as: ‘‘Give me a list of all people named Alice who work in sales departments anywhere in the  \n or Canada\n’’ Revocation The real world is full of certificates  too  such as passports and drivers’ licenses\n Sometimes these certificates can be revoked  for example  drivers’ licenses can be revoked for drunken driving and other driving offenses\n The same problem occurs in the digital world: the grantor of a certificate may decide to revoke it because the person or organization holding it has abused it in some way\n It can also be revoked if the subject’s private key has been exposed or  worse yet  the CA’s private key has been compromised\n Thus  a PKI needs to deal with the issue of revocation\n The possibility of revocation complicates matters\n   MANAGEMENT OF PUBLIC KEYS A first step in this direction is to have each CA periodically issue a CRL (Certificate Revocation List) giving the serial numbers of all certificates that it has revoked\n Since certificates contain expiry times  the CRL need only contain the serial numbers of certificates that have not yet expired\n Once its expiry time has passed  a certificate is automatically invalid  so no distinction is needed between those that just timed out and those that were actually revoked\n In both cases  they cannot be used any more\n Unfortunately  introducing CRLs means that a user who is about to use a certificate must now acquire the CRL to see if the certificate has been revoked\n If it has been  it should not be used\n However  even if the certificate is not on the list  it might have been revoked just after the list was published\n Thus  the only way to really be sure is to ask the CA\n And on the next use of the same certificate  the CA has to be asked again  since the certificate might have been revoked a few onds ago\n Another complication is that a revoked certificate could conceivably be reinstated  for example  if it was revoked for nonpayment of some fee that has since been paid\n Having to deal with revocation (and possibly reinstatement) eliminates one of the best properties of certificates  namely  that they can be used without having to contact a CA\n Where should CRLs be stored? A good place would be the same place the certificates themselves are stored\n One strategy is for the CA to actively push out CRLs periodically and have the directories process them by simply removing the revoked certificates\n If directories are not used for storing certificates  the CRLs can be cached at various places around the network\n Since a CRL is itself a signed document  if it is tampered with  that tampering can be easily detected\n If certificates have long lifetimes  the CRLs will be long  too\n For example  if credit cards are valid for  years  the number of revocations outstanding will be much longer than if new cards are issued every  months\n A standard way to deal with long CRLs is to issue a master list infrequently  but issue updates to it more often\n Doing this reduces the bandwidth needed for distributing the CRLs  COMMUNICATION URITY We have now finished our study of the tools of the trade\n Most of the important techniques and protocols have been covered\n The rest of the  ter is about how these techniques are applied in practice to provide network urity  plus some thoughts about the social aspects of urity at the end of the  ter\n In the following four tions  we will look at communication urity  that is  how to get the bits retly and without modification from source to destination and how to keep unwanted bits outside the door\n These are by no means the only urity issues in networking  but they are certainly among the most important ones  making this a good place to start our study\n NETWORK URITY  \n     IP IETF has known for years that urity was lacking in the Internet\n Adding it was not easy because a war broke out about where to put it\n Most urity experts believe that to be really ure  encryption and integrity checks have to be end to end ( \n  in the application layer)\n That is  the source process encrypts and/or integrity protects the data and sends them to the destination process where they are decrypted and/or verified\n Any tampering done in between these two processes  including within either operating system  can then be detected\n The trouble with this approach is that it requires changing all the applications to make them urity aware\n In this view  the next best approach is putting encryption in the transport layer or in a new layer between the application layer and the transport layer  making it still end to end but not requiring applications to be changed\n The opposite view is that users do not understand urity and will not be capable of using it correctly and nobody wants to modify existing programs in any way  so the network layer should authenticate and/or encrypt packets without the users being involved\n After years of pitched battles  this view won enough support that a network layer urity standard was defined\n In part  the argument was that having network layer encryption does not prevent urity-aware users from doing it right and it does help urity-unaware users to some extent\n The result of this war was a design called IP (IP urity)  which is described in RFCs    and  among others\n Not all users want encryption (because it is computationally expensive)\n Rather than make it optional  it was decided to require encryption all the time but permit the use of a null algorithm\n The null algorithm is described and praised for its simplicity  ease of implementation  and great speed in RFC \n The complete IP design is a framework for multiple services  algorithms  and granularities\n The reason for multiple services is that not everyone wants to pay the price for having all the services all the time  so the services are available a la carte\n The major services are recy  data integrity  and protection from replay attacks (where the intruder replays a conversation)\n All of these are based on symmetric-key cryptography because high performance is crucial\n The reason for having multiple algorithms is that an algorithm that is now thought to be ure may be broken in the future\n By making IP algorithm-independent  the framework can survive even if some particular algorithm is later broken\n The reason for having multiple granularities is to make it possible to protect a single TCP connection  all traffic between a pair of hosts  or all traffic between a pair of ure routers  among other possibilities\n One slightly surprising aspect of IP is that even though it is in the IP layer  it is connection oriented\n Actually  that is not so surprising because to have any urity  a key must be established and used for some period of time—in essence  a kind of connection by a different name\n Also  connections amortize the setup   COMMUNICATION URITY costs over many packets\n A ‘‘connection’’ in the context of IP is called an SA (urity Association)\n An SA is a simplex connection between two endpoints and has a urity identifier associated with it\n If ure traffic is needed in both directions  two urity associations are required\n urity identifiers are carried in packets traveling on these ure connections and are used to look up keys and other relevant information when a ure packet arrives\n Technically  IP has two principal parts\n The first part describes two new headers that can be added to packets to carry the urity identifier  integrity control data  and other information\n The other part  ISAKMP (Internet urity Association and Key Management Protocol)  deals with establishing keys\n ISAKMP is a framework\n The main protocol for carrying out the work is IKE (Internet Key Exchange)\n Version  of IKE as described in RFC  should be used  as the earlier version was deeply flawed  as pointed out by Perlman and Kaufman (   )\n IP can be used in either of two modes\n In transport mode  the IP header is inserted just after the IP header\n The Protocol field in the IP header is changed to indicate that an IP header follows the normal IP header (before the TCP header)\n The IP header contains urity information  primarily the SA identifier  a new sequence number  and possibly an integrity check of the payload\n In tunnel mode  the entire IP packet  header and all  is encapsulated in the body of a new IP packet with a completely new IP header\n Tunnel mode is useful when the tunnel ends at a location other than the final destination\n In some cases  the end of the tunnel is a urity gateway machine  for example  a company firewall\n This is commonly the case for a VPN (Virtual Private Network)\n In this mode  the urity gateway encapsulates and decapsulates packets as they pass through it\n By terminating the tunnel at this ure machine  the machines on the company LAN do not have to be aware of IP\n Only the urity gateway has to know about it\n Tunnel mode is also useful when a bundle of TCP connections is aggregated and handled as one encrypted stream because it prevents an intruder from seeing who is sending how many packets to whom\n Sometimes just knowing how much traffic is going where is valuable information\n For example  if during a military crisis  the amount of traffic flowing between the Pentagon and the White House were to drop sharply  but the amount of traffic between the Pentagon and some military installation deep in the Colorado Rocky Mountains were to increase by the same amount  an intruder might be able to deduce some useful information from these data\n Studying the flow patterns of packets  even if they are encrypted  is called traffic analysis\n Tunnel mode provides a way to foil it to some extent\n The disadvantage of tunnel mode is that it adds an extra IP header  thus increasing packet size substantially\n In contrast  transport mode does not affect packet size as much\n The first new header is AH (Authentication Header)\n It provides integrity checking and antireplay urity  but not recy ( \n  no data encryption)\n The NETWORK URITY  \n  use of AH in transport mode is illustrated in Fig\n  -  \n In IPv  it is interposed between the IP header (including any options) and the TCP header\n In IPv  it is just another extension header and is treated as such\n In fact  the format is close to that of a standard IPv  extension header\n The payload may have to be padded out to some particular length for the authentication algorithm  as shown\n IP header AH   Bits urity parameters index Next header Payload len (Reserved) Sequence number Authentication data (HMAC) TCP header Authenticated Payload + padding Figure  -  \n The IP authentication header in transport mode for IPv \n Let us now examine the AH header\n The Next header field is used to store the value that the IP Protocol field had before it was replaced with   to indicate that an AH header follows\n In most cases  the code for TCP ( ) will go here\n The Payload length is the number of  -bit words in the AH header minus  \n The urity parameters index is the connection identifier\n It is inserted by the sender to indicate a particular record in the receiver’s database\n This record contains the shared key used on this connection and other information about the connection\n If this protocol had been invented by ITU rather than IETF  this field would have been called Virtual circuit number\n The Sequence number field is used to number all the packets sent on an SA\n Every packet gets a unique number  even retransmissions\n In other words  the retransmission of a packet gets a different number here than the original (even though its TCP sequence number is the same)\n The purpose of this field is to detect replay attacks\n These sequence numbers may not wrap around\n If all are exhausted  a new SA must be established to continue communication\n Finally  we come to Authentication data  which is a variable-length field that contains the payload’s digital signature\n When the SA is established  the two sides negotiate which signature algorithm they are going to use\n Normally  public- key cryptography is not used here because packets must be processed extremely rapidly and all known public-key algorithms are too slow\n Since IP is based on symmetric-key cryptography and the sender and receiver negotiate a shared key before setting up an SA  the shared key is used in the signature computation\n One simple way is to compute the hash over the packet plus the shared key\n The shared key is not transmitted  of course\n A scheme like this is called an HMAC   COMMUNICATION URITY (Hashed Message Authentication Code)\n It is much faster to compute than first running SHA-  and then running RSA on the result\n The AH header does not allow encryption of the data  so it is mostly useful when integrity checking is needed but recy is not needed\n One noteworthy feature of AH is that the integrity check covers some of the fields in the IP header  namely  those that do not change as the packet moves from router to router\n The Time to live field changes on each hop  for example  so it cannot be included in the integrity check\n However  the IP source address is included in the check  making it impossible for an intruder to falsify the origin of a packet\n The alternative IP header is ESP (Encapsulating urity Payload)\n Its use for both transport mode and tunnel mode is shown in Fig\n  -  \n ESP header New IP header Old IP header TCP header Authenticated (b) Payload + padding Authentication (HMAC) ESP header IP header TCP (a) header Payload + padding Authentication (HMAC) Authenticated Encrypted Encrypted Figure  -  \n (a) ESP in transport mode\n (b) ESP in tunnel mode\n The ESP header consists of two  -bit words\n They are the urity parameters index and Sequence number fields that we saw in AH\n A third word that generally follows them (but is technically not part of the header) is the Initialization vector used for the data encryption  unless null encryption is used  in which case it is omitted\n ESP also provides for HMAC integrity checks  as does AH  but rather than being included in the header  they come after the payload  as shown in Fig\n  -  \n Putting the HMAC at the end has an advantage in a hardware implementation: the HMAC can be calculated as the bits are going out over the network interface and appended to the end\n This is why Ethernet and other LANs have their CRCs in a trailer  rather than in a header\n With AH  the packet has to be buffered and the signature computed before the packet can be sent  potentially reducing the number of packets/ that can be sent\n Given that ESP can do everything AH can do and more and is more efficient to boot  the question arises: why bother having AH at all? The answer is mostly historical\n Originally  AH handled only integrity and ESP handled only recy\n Later  integrity was added to ESP  but the people who designed AH did not want to let it die after all that work\n Their only real argument is that AH checks part of the IP header  which ESP does not  but other than that it is really a weak argument\n Another weak argument is that a product supporting AH but not ESP might NETWORK URITY  \n  have less trouble getting an export license because it cannot do encryption\n AH is likely to be phased out in the future\n    Firewalls The ability to connect any computer  anywhere  to any other computer  anywhere  is a mixed blessing\n For individuals at home  wandering around the Internet is lots of fun\n For corporate urity managers  it is a nightmare\n Most companies have large amounts of confidential information online—trade rets  product development plans  marketing strategies  financial analyses  etc\n Disclosure of this information to a competitor could have dire consequences\n In addition to the danger of information leaking out  there is also a danger of information leaking in\n In particular  viruses  worms  and other digital pests can breach urity  destroy valuable data  and waste large amounts of administrators’ time trying to clean up the mess they leave\n Often they are imported by careless employees who want to play some nifty new game\n Consequently  mechanisms are needed to keep ‘‘good’’ bits in and ‘‘bad’’ bits out\n One method is to use IP\n This approach protects data in transit between ure sites\n However  IP does nothing to keep digital pests and intruders from getting onto the company LAN\n To see how to accomplish this goal  we need to look at firewalls\n Firewalls are just a modern adaptation of that old medieval urity standby: digging a deep moat around your castle\n This design forced everyone entering or leaving the castle to pass over a single drawbridge  where they could be inspected by the I/O police\n With networks  the same trick is possible: a company can have many LANs connected in arbitrary ways  but all traffic to or from the company is forced through an electronic drawbridge (firewall)  as shown in Fig\n  -  \n No other route exists\n Internal network DeMilitarized zone External Internet Email server Web server urity perimeter Firewall Figure  -  \n A firewall protecting an internal network\n   COMMUNICATION URITY The firewall acts as a packet filter\n It inspects each and every incoming and outgoing packet\n Packets meeting some criterion described in rules formulated by the network administrator are forwarded normally\n Those that fail the test are uncermoniously dropped\n The filtering criterion is typically given as rules or tables that list sources and destinations that are acceptable  sources and destinations that are blocked  and default rules about what to do with packets coming from or going to other machines\n In the common case of a TCP/IP setting  a source or destination might consist of an IP address and a port\n Ports indicate which service is desired\n For example  TCP port   is for mail  and TCP port   is for HTTP\n Some ports can simply be blocked\n For example  a company could block incoming packets for all IP addresses combined with TCP port  \n It was once popular for the Finger service to look up people’s email addresses but is little used today\n Other ports are not so easily blocked\n The difficulty is that network administrators want urity but cannot cut off communication with the outside world\n That arrangement would be much simpler and better for urity  but there would be no end to user complaints about it\n This is where arrangements such as the DMZ (DeMilitarized Zone) shown in Fig\n  -  come in handy\n The DMZ is the part of the company network that lies outside of the urity perimeter\n Anything goes here\n By placing a machine such as a Web server in the DMZ  computers on the Internet can contact it to browse the company Web site\n Now the firewall can be configured to block incoming TCP traffic to port   so that computers on the Internet cannot use this port to attack computers on the internal network\n To allow the Web server to be managed  the firewall can have a rule to permit connections between internal machines and the Web server\n Firewalls have become much more sophisticated over time in an arms race with attackers\n Originally  firewalls applied a rule set independently for each packet  but it proved difficult to write rules that allowed useful functionality but blocked all unwanted traffic\n Stateful firewalls map packets to connections and use TCP/IP header fields to keep track of connections\n This allows for rules that  for example  allow an external Web server to send packets to an internal host  but only if the internal host first establishes a connection with the external Web server\n Such a rule is not possible with stateless designs that must either pass or drop all packets from the external Web server\n Another level of sophistication up from stateful processing is for the firewall to implement application-level gateways\n This processing involves the firewall looking inside packets  beyond even the TCP header  to see what the application is doing\n With this capability  it is possible to distinguish HTTP traffic used for Web browsing from HTTP traffic used for peer-to-peer file sharing\n Administrators can write rules to spare the company from peer-to-peer file sharing but allow Web browsing that is vital for business\n For all of these methods  outgoing traffic can be inspected as well as incoming traffic  for example  to prevent sensitive documents from being emailed outside of the company\n NETWORK URITY  \n  As the above discussion should make clear  firewalls violate the standard layering of protocols\n They are network layer devices  but they peek at the transport and applications layers to do their filtering\n This makes them fragile\n For instance  firewalls tend to rely on standard port numbering conventions to determine what kind of traffic is carried in a packet\n Standard ports are often used  but not by all computers  and not by all applications either\n Some peer-to-peer applications select ports dynamically to avoid being easily spotted (and blocked)\n Encryption with IP or other schemes hides higher-layer information from the firewall\n Finally  a firewall cannot readily talk to the computers that communicate through it to tell them what policies are being applied and why their connection is being dropped\n It must simply pretend to be a broken wire\n For all these reasons  networking purists consider firewalls to be a blemish on the architecture of the Internet\n However  the Internet can be a dangerous place if you are a computer\n Firewalls help with that problem  so they are likely to stay\n Even if the firewall is perfectly configured  plenty of urity problems still exist\n For example  if a firewall is configured to allow in packets from only specific networks ( \n  the company’s other plants)  an intruder outside the firewall can put in false source addresses to bypass this check\n If an insider wants to ship out ret documents  he can encrypt them or even photograph them and ship the photos as JPEG files  which bypasses any email filters\n And we have not even discussed the fact that  although three-quarters of all attacks come from outside the firewall  the attacks that come from inside the firewall  for example  from disgruntled employees  are typically the most damaging (Verizon  )\n A different problem with firewalls is that they provide a single perimeter of defense\n If that defense is breached  all bets are off\n For this reason  firewalls are often used in a layered defense\n For example  a firewall may guard the entrance to the internal network and each computer may also run its own firewall\n Readers who think that one urity checkpoint is enough clearly have not made an international flight on a scheduled airline recently\n In addition  there is a whole other class of attacks that firewalls cannot deal with\n The basic idea of a firewall is to prevent intruders from getting in and ret data from getting out\n Unfortunately  there are people who have nothing better to do than try to bring certain sites down\n They do this by sending legitimate packets at the target in great numbers until it collapses under the load\n For example  to cripple a Web site  an intruder can send a TCP SYN packet to establish a connection\n The site will then allocate a table slot for the connection and send a SYN + ACK packet in reply\n If the intruder does not respond  the table slot will be tied up for a few onds until it times out\n If the intruder sends thousands of connection requests  all the table slots will fill up and no legitimate connections will be able to get through\n Attacks in which the intruder’s goal is to shut down the target rather than steal data are called DoS (Denial of Service) attacks\n Usually  the request packets have false source addresses so the intruder cannot be traced easily\n DoS attacks against major Web sites are common on the Internet\n   COMMUNICATION URITY An even worse variant is one in which the intruder has already broken into hundreds of computers elsewhere in the world  and then commands all of them to attack the same target at the same time\n Not only does this approach increase the intruder’s firepower  but it also reduces his chances of detection since the packets are coming from a large number of machines belonging to unsuspecting users\n Such an attack is called a DDoS (Distributed Denial of Service) attack\n This attack is difficult to defend against\n Even if the attacked machine can quickly recognize a bogus request  it does take some time to process and discard the request  and if enough requests per ond arrive  the CPU will spend all its time dealing with them\n    Virtual Private Networks Many companies have offices and plants scattered over many cities  sometimes over multiple countries\n In the olden days  before public data networks  it was common for such companies to lease lines from the telephone company between some or all pairs of locations\n Some companies still do this\n A network built up from company computers and leased telephone lines is called a private network\n Private networks work fine and are very ure\n If the only lines available are the leased lines  no traffic can leak out of company locations and intruders have to physically wiretap the lines to break in  which is not easy to do\n The problem with private networks is that leasing a dedicated T  line between two points costs thousands of dollars a month  and T  lines are many times more expensive\n When public data networks and later the Internet appeared  many companies wanted to move their data (and possibly voice) traffic to the public network  but without giving up the urity of the private network\n This demand soon led to the invention of VPNs (Virtual Private Networks)  which are overlay networks on top of public networks but with most of the properties of private networks\n They are called ‘‘virtual’’ because they are merely an illusion  just as virtual circuits are not real circuits and virtual memory is not real memory\n One popular approach is to build VPNs directly over the Internet\n A common design is to equip each office with a firewall and create tunnels through the Internet between all pairs of offices  as illustrated in Fig\n  -  (a)\n A further advantage of using the Internet for connectivity is that the tunnels can be set up on demand to include  for example  the computer of an employee who is at home or traveling as long as the person has an Internet connection\n This flexibility is much greater then is provided with leased lines  yet from the perspective of the computers on the VPN  the topology looks just like the private network case  as shown in Fig\n  -  (b)\n When the system is brought up  each pair of firewalls has to negotiate the parameters of its SA  including the services  modes  algorithms  and keys\n If IP is used for the tunneling  it is possible to aggregate all traffic between any NETWORK URITY  \n  Home Internet Paris office London office Travel Home Travel London Paris (a) (b) Figure  -  \n (a) A virtual private network\n (b) Topology as seen from the inside\n two pairs of offices onto a single authenticated  encrypted SA  thus providing integrity control  recy  and even considerable immunity to traffic analysis\n Many firewalls have VPN capabilities built in\n Some ordinary routers can do this as well  but since firewalls are primarily in the urity business  it is natural to have the tunnels begin and end at the firewalls  providing a clear separation between the company and the Internet\n Thus  firewalls  VPNs  and IP with ESP in tunnel mode are a natural combination and widely used in practice\n Once the SAs have been established  traffic can begin flowing\n To a router within the Internet  a packet traveling along a VPN tunnel is just an ordinary packet\n The only thing unusual about it is the presence of the IP header after the IP header  but since these extra headers have no effect on the forwarding process  the routers do not care about this extra header\n Another approach that is gaining popularity is to have the ISP set up the VPN\n Using MPLS (as discussed in  \n  )  paths for the VPN traffic can be set up across the ISP network between the company offices\n These paths keep the VPN traffic separate from other Internet traffic and can be guaranteed a certain amount of bandwidth or other quality of service\n A key advantage of a VPN is that it is completely transparent to all user software\n The firewalls set up and manage the SAs\n The only person who is even aware of this setup is the system administrator who has to configure and manage the urity gateways  or the ISP administrator who has to configure the MPLS paths\n To everyone else  it is like having a leased-line private network again\n For more about VPNs  see Lewis (   )\n    Wireless urity It is surprisingly easy to design a system using VPNs and firewalls that is logically completely ure but that  in practice  leaks like a sieve\n This situation can occur if some of the machines are wireless and use radio communication  which passes right over the firewall in both directions\n The range of   \n  networks is   COMMUNICATION URITY often a few hundred meters  so anyone who wants to spy on a company can simply drive into the employee parking lot in the morning  leave an   \n  -enabled notebook computer in the car to record everything it hears  and take off for the day\n By late afternoon  the hard disk will be full of valuable goodies\n Theoretically  this leakage is not supposed to happen\n Theoretically  people are not supposed to rob banks  either\n Much of the urity problem can be traced to the manufacturers of wireless base stations (access points) trying to make their products user friendly\n Usually  if the user takes the device out of the box and plugs it into the electrical power socket  it begins operating immediately—nearly always with no urity at all  blurting rets to everyone within radio range\n If it is then plugged into an Ethernet  all the Ethernet traffic suddenly appears in the parking lot as well\n Wireless is a snooper’s dream come true: free data without having to do any work\n It therefore goes without saying that urity is even more important for wireless systems than for wired ones\n In this tion  we will look at some ways wireless networks handle urity\n Some additional information is given by Nichols and Lekkas (   )\n   \n  urity Part of the   \n  standard  originally called   \n  i  prescribes a data linklevel urity protocol for preventing a wireless node from reading or interfering with messages sent between another pair of wireless nodes\n It also goes by the trade name WPA  (WiFi Protected Access  )\n Plain WPA is an interim scheme that implements a subset of   \n  i\n It should be avoided in favor of WPA \n We will describe   \n  i shortly  but will first note that it is a replacement for WEP (Wired Equivalent Privacy)  the first generation of   \n  urity protocols\n WEP was designed by a networking standards committee  which is a completely different process than  for example  the way NIST selected the design of AES\n The results were devastating\n What was wrong with it? Pretty much everything from a urity perspective as it turns out\n For example  WEP encrypted data for confidentiality by XORing it with the output of a stream cipher\n Unfortunately  weak keying arrangements meant that the output was often reused\n This led to trivial ways to defeat it\n As another example  the integrity check was based on a  -bit CRC\n That is an efficient code for detecting transmission errors  but it is not a cryptographically strong mechanism for defeating attackers\n These and other design flaws made WEP very easy to compromise\n The first practical demonstration that WEP was broken came when Adam Stubblefield was an intern at AT&T (Stubblefield et al\n  )\n He was able to code up and test an attack outlined by Fluhrer et al\n (   ) in one week  of which most of the time was spent convincing management to buy him a WiFi card to use in his experiments\n Software to crack WEP passwords within a minute is now freely available and the use of WEP is very strongly discouraged\n While it does prevent casual NETWORK URITY  \n  access it does not provide any real form of urity\n The   \n  i group was put together in a hurry when it was clear that WEP was seriously broken\n It produced a formal standard by June \n Now we will describe   \n  i  which does provide real urity if it is set up and used properly\n There are two common scenarios in which WPA  is used\n The first is a corporate setting  in which a company has a separate authentication server that has a username and password database that can be used to determine if a wireless client is allowed to access the network\n In this setting  clients use standard protocols to authenticate themselves to the network\n The main standards are   \n X  with which the access point lets the client carry on a dialogue with the authentication server and observes the result  and EAP (Extensible Authentication Protocol) (RFC )  which tells how the client and the authentication server interact\n Actually  EAP is a framework and other standards define the protocol messages\n However  we will not delve into the many details of this exchange because they do not much matter for an overview\n The ond scenario is in a home setting in which there is no authentication server\n Instead  there is a single shared password that is used by clients to access the wireless network\n This setup is less complex than having an authentication server  which is why it is used at home and in small businesses  but it is less ure as well\n The main difference is that with an authentication server each client gets a key for encrypting traffic that is not known by the other clients\n With a single shared password  different keys are derived for each client  but all clients have the same password and can derive each others’ keys if they want to\n The keys that are used to encrypt traffic are computed as part of an authentication handshake\n The handshake happens right after the client associates with a wireless network and authenticates with an authentication server  if there is one\n At the start of the handshake  the client has either the shared network password or its password for the authentication server\n This password is used to derive a master key\n However  the master key is not used directly to encrypt packets\n It is standard cryptographic practice to derive a session key for each period of usage  to change the key for different sessions  and to expose the master key to observation as little as possible\n It is this session key that is computed in the handshake\n The session key is computed with the four-packet handshake shown in Fig\n  -  \n First  the AP (access point) sends a random number for identification\n Random numbers used just once in urity protocols like this one are called nonces  which is more-or-less a contraction of ‘‘number used once\n’’ The client also picks its own nonce\n It uses the nonces  its MAC address and that of the AP  and the master key to compute a session key  KS\n The session key is split into portions  each of which is used for different purposes  but we have omitted this detail\n Now the client has session keys  but the AP does not\n So the client sends its nonce to the AP  and the AP performs the same computation to derive the same session keys\n The nonces can be sent in the clear because the keys cannot be derived from them without extra  ret information\n The message from the client is protected   COMMUNICATION URITY with an integrity check called a MIC (Message Integrity Check) based on the session key\n The AP can check that the MIC is correct  and so the message indeed must have come from the client  after it computes the session keys\n A MIC is just another name for a message authentication code  as in an HMAC\n The term MIC is often used instead for networking protocols because of the potential for confusion with MAC (Medium Access Control) addresses\n Client NonceAP NonceC  MICS KS (KG)  MICS    Access Point (AP) Compute session keys KS from MAC addresses  nonces  and master key Distribute group key  KG Verify client has KS Verify AP has KS Acknowledge Compute session keys KS  same as the client KS (ACK)  MICS Figure  -  \n The   \n  i key setup handshake\n In the last two messages  the AP distributes a group key  KG  to the client  and the client acknowledges the message\n Receipt of these messages lets the client verify that the AP has the correct session keys  and vice versa\n The group key is used for broadcast and multicast traffic on the   \n  LAN\n Because the result of the handshake is that every client has its own encryption keys  none of these keys can be used by the AP to broadcast packets to all of the wireless clients; a separate copy would need to be sent to each client using its key\n Instead  a shared key is distributed so that broadcast traffic can be sent only once and received by all the clients\n It must be updated as clients leave and join the network\n Finally  we get to the part where the keys are actually used to provide urity\n Two protocols can be used in   \n  i to provide message confidentiality  integrity  and authentication\n Like WPA  one of the protocols  called TKIP (Temporary Key Integrity Protocol)  was an interim solution\n It was designed to improve urity on old and slow   \n  cards  so that at least some urity that is better than WEP can be rolled out as a firmware upgrade\n However  it  too  has now been broken so you are better off with the other  recommended protocol  CCMP\n What does CCMP stand for? It is short for the somewhat spectacular name Counter mode with Cipher block chaining Message authentication code Protocol\n We will just call it CCMP\n You can call it anything you want\n NETWORK URITY  \n  CCMP works in a fairly straightforward way\n It uses AES encryption with a   -bit key and block size\n The key comes from the session key\n To provide confidentiality  messages are encrypted with AES in counter mode\n Recall that we discussed cipher modes in \n   \n These modes are what prevent the same message from being encrypted to the same set of bits each time\n Counter mode mixes a counter into the encryption\n To provide integrity  the message  including header fields  is encrypted with cipher block chaining mode and the last   -bit block is kept as the MIC\n Then both the message (encrypted with counter mode) and the MIC are sent\n The client and the AP can each perform this encryption  or verify this encryption when a wireless packet is received\n For broadcast or multicast messages  the same procedure is used with the group key\n Bluetooth urity Bluetooth has a considerably shorter range than   \n   so it cannot easily be attacked from the parking lot  but urity is still an issue here\n For example  imagine that Alice’s computer is equipped with a wireless Bluetooth keyboard\n In the absence of urity  if Trudy happened to be in the adjacent office  she could read everything Alice typed in  including all her outgoing email\n She could also capture everything Alice’s computer sent to the Bluetooth printer sitting next to it ( \n  incoming email and confidential reports)\n Fortunately  Bluetooth has an elaborate urity scheme to try to foil the world’s Trudies\n We will now summarize the main features of it\n Bluetooth version  \n  and later has four urity modes  ranging from nothing at all to full data encryption and integrity control\n As with   \n   if urity is disabled (the default for older devices)  there is no urity\n Most users have urity turned off until a serious breach has occurred; then they turn it on\n In the agricultural world  this approach is known as locking the barn door after the horse has escaped\n Bluetooth provides urity in multiple layers\n In the physical layer  frequency hopping provides a tiny little bit of urity  but since any Bluetooth device that moves into a piconet has to be told the frequency hopping sequence  this sequence is obviously not a ret\n The real urity starts when the newly arrived slave asks for a channel with the master\n Before Bluetooth  \n  two devices were assumed to share a ret key set up in advance\n In some cases  both are hardwired by the manufacturer ( \n  for a headset and mobile phone sold as a unit)\n In other cases  one device ( \n  the headset) has a hardwired key and the user has to enter that key into the other device ( \n  the mobile phone) as a decimal number\n These shared keys are called passkeys\n Unfortunately  the passkeys are often hardcoded to ‘‘   ’’ or another predictable value  and in any case are four decimal digits  allowing only choices\n With simple ure pairing in Bluetooth  \n  devices pick a code from a six-digit range  which makes the passkey much less predictable but still far from ure\n   COMMUNICATION URITY To establish a channel  the slave and master each check to see if the other one knows the passkey\n If so  they negotiate whether that channel will be encrypted  integrity controlled  or both\n Then they select a random   -bit session key  some of whose bits may be public\n The point of allowing this key weakening is to comply with government restrictions in various countries designed to prevent the export or use of keys longer than the government can break\n Encryption uses a stream cipher called E ; integrity control uses SAFER+\n Both are traditional symmetric-key block ciphers\n SAFER+ was submitted to the AES bake-off but was eliminated in the first round because it was slower than the other candidates\n Bluetooth was finalized before the AES cipher was chosen; otherwise  it would most likely have used Rijndael\n The actual encryption using the stream cipher is shown in Fig\n  -   with the plaintext XORed with the keystream to generate the ciphertext\n Unfortunately  E  itself (like RC ) may have fatal weaknesses (Jakobsson and Wetzel  )\n While it was not broken at the time of this writing  its similarities to the A /  cipher  whose spectacular failure compromises all GSM telephone traffic  are cause for concern (Biryukov et al\n  )\n It sometimes amazes people (including the authors of this book)  that in the perennial cat-and-mouse game between the cryptographers and the cryptanalysts  the cryptanalysts are so often on the winning side\n Another urity issue is that Bluetooth authenticates only devices  not users  so theft of a Bluetooth device may give the thief access to the user’s financial and other accounts\n However  Bluetooth also implements urity in the upper layers  so even in the event of a breach of link-level urity  some urity may remain  especially for applications that require a PIN code to be entered manually from some kind of keyboard to complete the transaction  AUTHENTICATION PROTOCOLS Authentication is the technique by which a process verifies that its communication partner is who it is supposed to be and not an imposter\n Verifying the identity of a remote process in the face of a malicious  active intruder is surprisingly difficult and requires complex protocols based on cryptography\n In this tion  we will study some of the many authentication protocols that are used on inure computer networks\n As an aside  some people confuse authorization with authentication\n Authentication deals with the question of whether you are actually communicating with a specific process\n Authorization is concerned with what that process is permitted to do\n For example  say a client process contacts a file server and says: ‘‘I am Scott’s process and I want to delete the file  \n’’ From the file server’s point of view  two questions must be answered: NETWORK URITY  \n   \n Is this actually Scott’s process (authentication)?  \n Is Scott allowed to delete   (authorization)? Only after both of these questions have been unambiguously answered in the affirmative can the requested action take place\n The former question is really the key one\n Once the file server knows to whom it is talking  checking authorization is just a matter of looking up entries in local tables or databases\n For this reason  we will concentrate on authentication in this tion\n The general model that essentially all authentication protocols use is this\n Alice starts out by sending a message either to Bob or to a trusted KDC (Key Distribution Center)  which is expected to be honest\n Several other message exchanges follow in various directions\n As these messages are being sent  Trudy may intercept  modify  or replay them in order to trick Alice and Bob or just to gum up the works\n Nevertheless  when the protocol has been completed  Alice is sure she is talking to Bob and Bob is sure he is talking to Alice\n Furthermore  in most of the protocols  the two of them will also have established a ret session key for use in the upcoming conversation\n In practice  for performance reasons  all data traffic is encrypted using symmetric-key cryptography (typically AES or triple DES)  although public-key cryptography is widely used for the authentication protocols themselves and for establishing the session key\n The point of using a new  randomly chosen session key for each new connection is to minimize the amount of traffic that gets sent with the users’ ret keys or public keys  to reduce the amount of ciphertext an intruder can obtain  and to minimize the damage done if a process crashes and its core dump falls into the wrong hands\n Hopefully  the only key present then will be the session key\n All the permanent keys should have been carefully zeroed out after the session was established\n    Authentication Based on a Shared ret Key For our first authentication protocol  we will assume that Alice and Bob already share a ret key  KAB\n This shared key might have been agreed upon on the telephone or in person  but  in any event  not on the (inure) network\n This protocol is based on a principle found in many authentication protocols: one party sends a random number to the other  who then transforms it in a special way and returns the result\n Such protocols are called challenge-response protocols\n In this and subsequent authentication protocols  the following notation will be used: A  B are the identities of Alice and Bob\n Ri’s are the challenges  where i identifies the challenger\n Ki’s are keys  where i indicates the owner\n KS is the session key\n   AUTHENTICATION PROTOCOLS The message sequence for our first shared-key authentication protocol is illustrated in Fig\n  -  \n In message   Alice sends her identity  A  to Bob in a way that Bob understands\n Bob  of course  has no way of knowing whether this message came from Alice or from Trudy  so he chooses a challenge  a large random number  RB  and sends it back to ‘‘Alice’’ as message   in plaintext\n Alice then encrypts the message with the key she shares with Bob and sends the ciphertext  KAB(RB)  back in message  \n When Bob sees this message  he immediately knows that it came from Alice because Trudy does not know KAB and thus could not have generated it\n Furthermore  since RB was chosen randomly from a large space (say -bit random numbers)  it is very unlikely that Trudy would have seen RB and its response in an earlier session\n It is equally unlikely that she could guess the correct response to any challenge\n A Alice RB  KAB (RB) KAB (RA) Bob RA Figure  -  \n Two-way authentication using a challenge-response protocol\n At this point  Bob is sure he is talking to Alice  but Alice is not sure of anything\n For all Alice knows  Trudy might have intercepted message  and sent back RB in response\n Maybe Bob died last night\n To find out to whom she is talking  Alice picks a random number  RA  and sends it to Bob as plaintext  in message  \n When Bob responds with KAB(RA)  Alice knows she is talking to Bob\n If they wish to establish a session key now  Alice can pick one  KS  and send it to Bob encrypted with KAB\n The protocol of Fig\n  -  contains five messages\n Let us see if we can be clever and eliminate some of them\n One approach is illustrated in Fig\n  -  \n Here Alice initiates the challenge-response protocol instead of waiting for Bob to do it\n Similarly  while he is responding to Alice’s challenge  Bob sends his own\n The entire protocol can be reduced to three messages instead of five\n Is this new protocol an improvement over the original one? In one sense it is: it is shorter\n Unfortunately  it is also wrong\n Under certain circumstances  Trudy can defeat this protocol by using what is known as a reflection attack\n In particular  Trudy can break it if it is possible to open multiple sessions with Bob at once\n This situation would be true  for example  if Bob is a bank and is prepared to accept many simultaneous connections from teller machines at once\n NETWORK URITY  \n  Alice  RB  KAB (RA) KAB (RB) A  RA Bob Figure  -  \n A shortened two-way authentication protocol\n Trudy’s reflection attack is shown in Fig\n  -  \n It starts out with Trudy claiming she is Alice and sending RT\n Bob responds  as usual  with his own challenge  RB\n Now Trudy is stuck\n What can she do? She does not know KAB(RB)\n Trudy  RB  KAB (RT) KAB (RB) A  RT RB  KAB (RB) A  RB First session ond session First session Bob Figure  -  \n The reflection attack\n She can open a ond session with message   supplying the RB taken from message  as her challenge\n Bob calmly encrypts it and sends back KAB(RB) in message  \n We have shaded the messages on the ond session to make them stand out\n Now Trudy has the missing information  so she can complete the first session and abort the ond one\n Bob is now convinced that Trudy is Alice  so when she asks for her bank account balance  he gives it to her without question\n Then when she asks him to transfer it all to a ret bank account in Switzerland  he does so without a moment’s hesitation\n The moral of this story is: Designing a correct authentication protocol is much harder than it looks\n The following four general rules often help the designer avoid common pitfalls:   AUTHENTICATION PROTOCOLS  \n Have the initiator prove who she is before the responder has to\n This avoids Bob giving away valuable information before Trudy has to give any evidence of who she is Have the initiator and responder use different keys for proof  even if this means having two shared keys  KAB and K′AB Have the initiator and responder draw their challenges from different sets\n For example  the initiator must use even numbers and the responder must use odd numbers Make the protocol resistant to attacks involving a ond parallel session in which information obtained in one session is used in a different one\n If even one of these rules is violated  the protocol can frequently be broken\n Here  all four rules were violated  with disastrous consequences\n Now let us go take a closer look at Fig\n  -  \n Surely that protocol is not subject to a reflection attack? Maybe\n It is quite subtle\n Trudy was able to defeat our protocol by using a reflection attack because it was possible to open a ond session with Bob and trick him into answering his own questions\n What would happen if Alice were a general-purpose computer that also accepted multiple sessions  rather than a person at a computer? Let us take a look what Trudy can do\n To see how Trudy’s attack works  see Fig\n  -  \n Alice starts out by announcing her identity in message  \n Trudy intercepts this message and begins her own session with message   claiming to be Bob\n Again we have shaded the session  messages\n Alice responds to message  by saying in message  : ‘‘You claim to be Bob? Prove it\n’’ At this point  Trudy is stuck because she cannot prove she is Bob\n What does Trudy do now? She goes back to the first session  where it is her turn to send a challenge  and sends the RA she got in message  \n Alice kindly responds to it in message   thus supplying Trudy with the information she needs to send in message  in session  \n At this point  Trudy is basically home free because she has successfully responded to Alice’s challenge in session  \n She can now cancel session   send over any old number for the rest of session   and she will have an authenticated session with Alice in session  \n But Trudy is nasty  and she really wants to rub it in\n Instead  of sending any old number over to complete session   she waits until Alice sends message   Alice’s challenge for session  \n Of course  Trudy does not know how to respond  so she uses the reflection attack again  sending back RA  as message  \n Alice conveniently encrypts RA  in message  \n Trudy now switches back to session  and sends Alice the number she wants in message conveniently copied from what Alice sent in message  \n At this point Trudy has two fully authenticated sessions with Alice\n This attack has a somewhat different result than the attack on the three-message protocol that we saw in Fig\n  -  \n This time  Trudy has two authenticated NETWORK URITY  \n  A Alice B  KAB (RA) Trudy RA RA  KAB (RA)  RA  KAB (RA ) RA KAB (RA ) First session First session First session First session ond session ond session ond session Figure  -  \n A reflection attack on the protocol of Fig\n  -  \n connections with Alice\n In the previous example  she had one authenticated connection with Bob\n Again here  if we had applied all the general authentication protocol rules discussed earlier  this attack could have been stopped\n For a detailed discussion of these kinds of attacks and how to thwart them  see Bird et al\n (   )\n They also show how it is possible to systematically construct protocols that are provably correct\n The simplest such protocol is nevertheless a bit complicated  so we will now show a different class of protocol that also works\n The new authentication protocol is shown in Fig\n  -  (Bird et al\n  )\n It uses an HMAC of the type we saw when studying IP\n Alice starts out by sending Bob a nonce  RA  as message  \n Bob responds by selecting his own nonce  RB  and sending it back along with an HMAC\n The HMAC is formed by building a data structure consisting of Alice’s nonce  Bob’s nonce  their identities  and the shared ret key  KAB\n This data structure is then hashed into the HMAC  for example  using SHA- \n When Alice receives message   she now has RA (which she picked herself)  RB  which arrives as plaintext  the two identities  and the ret key  KAB  which she has known all along  so she can compute the HMAC herself\n If it agrees with the HMAC in the message  she knows she is talking to Bob because Trudy does not know KAB and thus cannot figure out which HMAC to send\n Alice responds to Bob with an HMAC containing just the two nonces\n Can Trudy somehow subvert this protocol? No  because she cannot force either party to encrypt or hash a value of her choice  as happened in Fig\n  -  and Fig\n  -  \n Both HMACs include values chosen by the sending party  something that Trudy cannot control\n   AUTHENTICATION PROTOCOLS Alice  RA Bob RB  HMAC(RA  RB  A  B  KAB) HMAC(RA  RB  KAB) Figure  -  \n Authentication using HMACs\n Using HMACs is not the only way to use this idea\n An alternative scheme that is often used instead of computing the HMAC over a series of items is to encrypt the items sequentially using cipher block chaining\n    Establishing a Shared Key: The Diffie-Hellman Key Exchange So far  we have assumed that Alice and Bob share a ret key\n Suppose that they do not (because so far there is no universally accepted PKI for signing and distributing certificates)\n How can they establish one? One way would be for Alice to call Bob and give him her key on the phone  but he would probably start out by saying: ‘‘How do I know you are Alice and not Trudy?’’ They could try to arrange a meeting  with each one bringing a passport  a driver’s license  and three major credit cards  but being busy people  they might not be able to find a mutually acceptable date for months\n Fortunately  incredible as it may sound  there is a way for total strangers to establish a shared ret key in broad daylight  even with Trudy carefully recording every message\n The protocol that allows strangers to establish a shared ret key is called the Diffie-Hellman key exchange (Diffie and Hellman  ) and works as follows\n Alice and Bob have to agree on two large numbers  n and g  where n is a prime  (n −  )/  is also a prime  and certain conditions apply to g\n These numbers may be public  so either one of them can just pick n and g and tell the other openly\n Now Alice picks a large (say  -bit) number  x  and keeps it ret\n Similarly  Bob picks a large ret number  y\n Alice initiates the key exchange protocol by sending Bob a message containing (n  g  gx mod n)  as shown in Fig\n  -  \n Bob responds by sending Alice a message containing gy mod n\n Now Alice raises the number Bob sent her to the xth power modulo n to get (gy mod n)x mod n\n Bob performs a similar operation to get (gx mod n)y mod n\n By the laws of modular arithmetic  both calculations yield gxy mod n\n Lo and behold  as if by magic  Alice and Bob suddenly share a ret key  gxy mod n\n NETWORK URITY  \n Alice picks x Bob picks y  gy mod n n  g  gx mod n Alice computes (gy mod n)x = gxy mod n Bob computes (gx mod n)y = gxy mod n Bob Alice mod n mod n Figure  -  \n The Diffie-Hellman key exchange\n Trudy  of course  has seen both messages\n She knows g and n from message  \n If she could compute x and y  she could figure out the ret key\n The trouble is  given only gx mod n  she cannot find x\n No practical algorithm for computing discrete logarithms modulo a very large prime number is known\n To make this example more concrete  we will use the (completely unrealistic) values of n =   and g =  \n Alice picks x =  and Bob picks y =  \n Both of these are kept ret\n Alice’s message to Bob is (    ) because   mod   is  \n Bob’s message to Alice is (  )\n Alice computes mod which is  \n Bob computes  mod which is  \n Alice and Bob have now independently determined that the ret key is now  \n To find the key  Trudy now has to solve the equation  x mod   = which can be done by exhaustive search for small numbers like this  but not when all the numbers are hundreds of bits long\n All currently known algorithms simply take far too long  even on massively parallel  lightning fast supercomputers\n Despite the elegance of the Diffie-Hellman algorithm  there is a problem: when Bob gets the triple (    )  how does he know it is from Alice and not from Trudy? There is no way he can know\n Unfortunately  Trudy can exploit this fact to deceive both Alice and Bob  as illustrated in Fig\n  -  \n Here  while Alice and Bob are choosing x and y  respectively  Trudy picks her own random number  z\n Alice sends message   intended for Bob\n Trudy intercepts it and sends message  to Bob  using the correct g and n (which are public anyway) but with her own z instead of x\n She also sends message  back to Alice\n Later Bob sends message  to Alice  which Trudy again intercepts and keeps\n Now everybody does the modular arithmetic\n Alice computes the ret key as gxz mod n  and so does Trudy (for messages to Alice)\n Bob computes gyz mod n and so does Trudy (for messages to Bob)\n Alice thinks she is talking to Bob  so she establishes a session key (with Trudy)\n So does Bob\n Every message that Alice sends on the encrypted session is captured by Trudy  stored  modified if desired  and then (optionally) passed on to Bob\n Similarly  in the other direction  Trudy sees everything and can modify all messages at will  while both Alice and Bob are under the illusion that they have a ure channel to one another\n For this   AUTHENTICATION PROTOCOLS  Alice picks x Trudy picks z  gz mod n n  g  gx mod n Trudy  Bob picks y  gy mod n n  g  gz mod n Bob Alice Figure  -  \n The man-in-the-middle attack\n reason  the attack is known as the man-in-the-middle attack\n It is also called the bucket brigade attack  because it vaguely resembles an old-time volunteer fire department passing buckets along the line from the fire truck to the fire\n    Authentication Using a Key Distribution Center Setting up a shared ret with a stranger almost worked  but not quite\n On the other hand  it probably was not worth doing in the first place (sour grapes attack)\n To talk to n people this way  you would need n keys\n For popular people  key management would become a real burden  especially if each key had to be stored on a separate plastic chip card\n A different approach is to introduce a trusted key distribution center\n In this model  each user has a single key shared with the KDC\n Authentication and session key management now go through the KDC\n The simplest known KDC authentication protocol involving two parties and a trusted KDC is depicted in Fig\n  -  \n  A  KA (B  KS) KDC  Bob Alice KB (A  KS) Figure  -  \n A first attempt at an authentication protocol using a KDC\n The idea behind this protocol is simple: Alice picks a session key  KS  and tells the KDC that she wants to talk to Bob using KS\n This message is encrypted NETWORK URITY  \n  with the ret key Alice shares (only) with the KDC  KA\n The KDC decrypts this message  extracting Bob’s identity and the session key\n It then constructs a new message containing Alice’s identity and the session key and sends this message to Bob\n This encryption is done with KB  the ret key Bob shares with the KDC\n When Bob decrypts the message  he learns that Alice wants to talk to him and which key she wants to use\n The authentication here happens for free\n The KDC knows that message  must have come from Alice  since no one else would have been able to encrypt it with Alice’s ret key\n Similarly  Bob knows that message  must have come from the KDC  whom he trusts  since no one else knows his ret key\n Unfortunately  this protocol has a serious flaw\n Trudy needs some money  so she figures out some legitimate service she can perform for Alice  makes an attractive offer  and gets the job\n After doing the work  Trudy then politely requests Alice to pay by bank transfer\n Alice then establishes a session key with her banker  Bob\n Then she sends Bob a message requesting money to be transferred to Trudy’s account\n Meanwhile  Trudy is back to her old ways  snooping on the network\n She copies both message  in Fig\n  -  and the money-transfer request that follows it\n Later  she replays both of them to Bob who thinks: ‘‘Alice must have hired Trudy again\n She clearly does good work\n’’ Bob then transfers an equal amount of money from Alice’s account to Trudy’s\n Some time after the  th message pair  Bob runs out of the office to find Trudy to offer her a big loan so she can expand her obviously successful business\n This problem is called the replay attack\n Several solutions to the replay attack are possible\n The first one is to include a timestamp in each message\n Then  if anyone receives an obsolete message  it can be discarded\n The trouble with this approach is that clocks are never exactly synchronized over a network  so there has to be some interval during which a timestamp is valid\n Trudy can replay the message during this interval and get away with it\n The ond solution is to put a nonce in each message\n Each party then has to remember all previous nonces and reject any message containing a previously used nonce\n But nonces have to be remembered forever  lest Trudy try replaying a  -year-old message\n Also  if some machine crashes and it loses its nonce list  it is again vulnerable to a replay attack\n Timestamps and nonces can be combined to limit how long nonces have to be remembered  but clearly the protocol is going to get a lot more complicated\n A more sophisticated approach to mutual authentication is to use a multiway challenge-response protocol\n A well-known example of such a protocol is the Needham-Schroeder authentication protocol (Needham and Schroeder  )  one variant of which is shown in Fig\n  -  \n The protocol begins with Alice telling the KDC that she wants to talk to Bob\n This message contains a large random number  RA  as a nonce\n The KDC sends back message  containing Alice’s random number  a session key  and a ticket   AUTHENTICATION PROTOCOLS  RA  A  B  KA (RA  B  KS  KB(A  KS)) KDC  Bob Alice KB(A  KS)  KS (RA )  KS (RA  – )  RB  KS (RB – ) Figure  -  \n The Needham-Schroeder authentication protocol\n that she can send to Bob\n The point of the random number  RA  is to assure Alice that message  is fresh  and not a replay\n Bob’s identity is also enclosed in case Trudy gets any funny ideas about replacing B in message  with her own identity so the KDC will encrypt the ticket at the end of message  with KT instead of KB\n The ticket encrypted with KB is included inside the encrypted message to prevent Trudy from replacing it with something else on the way back to Alice\n Alice now sends the ticket to Bob  along with a new random number  RA   encrypted with the session key  KS\n In message   Bob sends back KS(RA  −  ) to prove to Alice that she is talking to the real Bob\n Sending back KS(RA  ) would not have worked  since Trudy could just have stolen it from message  \n After receiving message   Alice is now convinced that she is talking to Bob and that no replays could have been used so far\n After all  she just generated RA  a few millionds ago\n The purpose of message  is to convince Bob that it is indeed Alice he is talking to  and no replays are being used here either\n By having each party both generate a challenge and respond to one  the possibility of any kind of replay attack is eliminated\n Although this protocol seems pretty solid  it does have a slight weakness\n If Trudy ever manages to obtain an old session key in plaintext  she can initiate a new session with Bob by replaying the message  that corresponds to the compromised key and convince him that she is Alice (Denning and Sacco  )\n This time she can plunder Alice’s bank account without having to perform the legitimate service even once\n Needham and Schroeder (   ) later published a protocol that corrects this problem\n In the same issue of the same journal  Otway and Rees (   ) also published a protocol that solves the problem in a shorter way\n Figure  -  shows a slightly modified Otway-Rees protocol\n In the Otway-Rees protocol  Alice starts out by generating a pair of random numbers: R  which will be used as a common identifier  and RA  which Alice will use to challenge Bob\n When Bob gets this message  he constructs a new message from the encrypted part of Alice’s message and an analogous one of his own\n NETWORK URITY  \n KA(RA  KS) KB(RB  KS) KDC  Bob Alice A  B  R  KA (A  B  R  RA) A  KA (A  B  R  RA)  B  KB (A  B  R  RB) Figure  -  \n The Otway-Rees authentication protocol (slightly simplified)\n Both the parts encrypted with KA and KB identify Alice and Bob  contain the common identifier  and contain a challenge\n The KDC checks to see if the R in both parts is the same\n It might not be if Trudy has tampered with R in message  or replaced part of message  \n If the two Rs match  the KDC believes that the request message from Bob is valid\n It then generates a session key and encrypts it twice  once for Alice and once for Bob\n Each message contains the receiver’s random number  as proof that the KDC  and not Trudy  generated the message\n At this point  both Alice and Bob are in possession of the same session key and can start communicating\n The first time they exchange data messages  each one can see that the other one has an identical copy of KS  so the authentication is then complete\n    Authentication Using Kerberos An authentication protocol used in many real systems (including Windows  and later versions) is Kerberos  which is based on a variant of Needham- Schroeder\n It is named for a multiheaded dog in Greek mythology that used to guard the entrance to Hades (presumably to keep undesirables out)\n Kerberos was designed at  \n to allow workstation users to access network resources in a ure way\n Its biggest difference from Needham-Schroeder is its assumption that all clocks are fairly well synchronized\n The protocol has gone through several iterations\n V  is the one that is widely used in industry and defined in RFC \n The earlier version  V  was finally retired after serious flaws were found (Yu et al\n  )\n V  improves on V  with many small changes to the protocol and some improved features  such as the fact that it no longer relies on the now-dated DES\n For more information  see Neuman and Ts’o (   )\n Kerberos involves three servers in addition to Alice (a client workstation):  \n Authentication Server (AS): Verifies users during login Ticket-Granting Server (TGS): Issues ‘‘proof of identity tickets\n’’  \n Bob the server: Actually does the work Alice wants performed\n   AUTHENTICATION PROTOCOLS AS is similar to a KDC in that it shares a ret password with every user\n The TGS’s job is to issue tickets that can convince the real servers that the bearer of a TGS ticket really is who he or she claims to be\n To start a session  Alice sits down at an arbitrary public workstation and types her name\n The workstation sends her name and the name of the TGS to the AS in plaintext  as shown in message  of Fig\n  -  \n What comes back is a session key and a ticket  KTGS(A  KS  t)  intended for the TGS\n The session key is encrypted using Alice’s ret key  so that only Alice can decrypt it\n Only when message  arrives does the workstation ask for Alice’s password—not before then\n The password is then used to generate KA in order to decrypt message  and obtain the session key\n At this point  the workstation overwrites Alice’s password to make sure that it is only inside the workstation for a few millionds at most\n If Trudy tries logging in as Alice  the password she types will be wrong and the workstation will detect this because the standard part of message  will be incorrect\n Alice AS TGS Bob KAB(A  t)  KB(A  B  KAB  t) A TGS KA(TGS  KS  t)  KTGS(A  KS  t) B  KS(A  t)  KTGS(A  KS  t) KS(B  KAB  t)  KB(A  B  KAB  t) KAB (t)    Figure  -  \n The operation of Kerberos V \n After she logs in  Alice may tell the workstation that she wants to contact Bob the file server\n The workstation then sends message  to the TGS asking for a ticket to use with Bob\n The key element in this request is the ticket KTGS(A  KS  t)  which is encrypted with the TGS’s ret key and used as proof that the sender really is Alice\n The TGS responds in message  by creating a session key  KAB  for Alice to use with Bob\n Two versions of it are sent back\n The first is encrypted with only KS  so Alice can read it\n The ond is another ticket  encrypted with Bob’s key  KB  so Bob can read it\n NETWORK URITY  \n  Trudy can copy message  and try to use it again  but she will be foiled by the encrypted timestamp  t  sent along with it\n Trudy cannot replace the timestamp with a more recent one  because she does not know KS  the session key Alice uses to talk to the TGS\n Even if Trudy replays message  quickly  all she will get is another copy of message   which she could not decrypt the first time and will not be able to decrypt the ond time either\n Now Alice can send KAB to Bob via the new ticket to establish a session with him (message  )\n This exchange is also timestamped\n The optional response (message  ) is proof to Alice that she is actually talking to Bob  not to Trudy\n After this series of exchanges  Alice can communicate with Bob under cover of KAB\n If she later decides she needs to talk to another server  Carol  she just repeats message  to the TGS  only now specifying C instead of B\n The TGS will promptly respond with a ticket encrypted with KC that Alice can send to Carol and that Carol will accept as proof that it came from Alice\n The point of all this work is that now Alice can access servers all over the network in a ure way and her password never has to go over the network\n In fact  it only had to be in her own workstation for a few millionds\n However  note that each server does its own authorization\n When Alice presents her ticket to Bob  this merely proves to Bob who sent it\n Precisely what Alice is allowed to do is up to Bob\n Since the Kerberos designers did not expect the entire world to trust a single authentication server  they made provision for having multiple realms  each with its own AS and TGS\n To get a ticket for a server in a distant realm  Alice would ask her own TGS for a ticket accepted by the TGS in the distant realm\n If the distant TGS has registered with the local TGS (the same way local servers do)  the local TGS will give Alice a ticket valid at the distant TGS\n She can then do business over there  such as getting tickets for servers in that realm\n Note  however  that for parties in two realms to do business  each one must trust the other’s TGS\n Otherwise  they cannot do business\n    Authentication Using Public-Key Cryptography Mutual authentication can also be done using public-key cryptography\n To start with  Alice needs to get Bob’s public key\n If a PKI exists with a directory server that hands out certificates for public keys  Alice can ask for Bob’s  as shown in Fig\n  -  as message  \n The reply  in message   is an X\n   certificate containing Bob’s public key\n When Alice verifies that the signature is correct  she sends Bob a message containing her identity and a nonce\n When Bob receives this message  he has no idea whether it came from Alice or from Trudy  but he plays along and asks the directory server for Alice’s public key (message  )  which he soon gets (message  )\n He then sends Alice message   containing Alice’s RA  his own nonce  RB  and a proposed session key  KS\n   AUTHENTICATION PROTOCOLS  EB (A  RA)  KS (RB)  EA (RA  RB  KS) Bob Alice Directory  \n Here is EB  \n Give me EA  \n Here is EA  \n Give me EB Figure  -  \n Mutual authentication using public-key cryptography\n When Alice gets message   she decrypts it using her private key\n She sees RA in it  which gives her a warm feeling inside\n The message must have come from Bob  since Trudy has no way of determining RA\n Furthermore  it must be fresh and not a replay  since she just sent Bob RA\n Alice agrees to the session by sending back message  \n When Bob sees RB encrypted with the session key he just generated  he knows Alice got message  and verified RA\n Bob is now a happy camper\n What can Trudy do to try to subvert this protocol? She can fabricate message  and trick Bob into probing Alice  but Alice will see an RA that she did not send and will not proceed further\n Trudy cannot forge message  back to Bob because she does not know RB or KS and cannot determine them without Alice’s private key\n She is out of luck  EMAIL URITY When an email message is sent between two distant sites  it will generally transit dozens of machines on the way\n Any of these can read and record the message for future use\n In practice  privacy is nonexistent  despite what many people think\n Nevertheless  many people would like to be able to send email that can be read by the intended recipient and no one else: not their boss and not even their government\n This desire has stimulated several people and groups to apply the cryptographic principles we studied earlier to email to produce ure email\n In the following tions we will study a widely used ure email system  PGP  and then briefly mention one other  S/MIME\n For additional information about ure email  see Kaufman et al\n (   ) and Schneier (   )\n NETWORK URITY  \n     PGP—Pretty Good Privacy Our first example  PGP (Pretty Good Privacy) is essentially the brainchild of one person  Phil Zimmermann (   a  b)\n Zimmermann is a privacy advocate whose motto is: ‘‘If privacy is outlawed  only outlaws will have privacy\n’’ Released in  PGP is a complete email urity package that provides privacy  authentication  digital signatures  and compression  all in an easy-to-use form\n Furthermore  the complete package  including all the source code  is distributed free of charge via the Internet\n Due to its quality  price (zero)  and easy availability on UNIX  Linux  Windows  and Mac OS platforms  it is widely used today\n PGP encrypts data by using a block cipher called IDEA (International Data Encryption Algorithm)  which uses   -bit keys\n It was devised in Switzerland at a time when DES was seen as tainted and AES had not yet been invented\n Conceptually  IDEA is similar to DES and AES: it mixes up the bits in a series of rounds  but the details of the mixing functions are different from DES and AES\n Key management uses RSA and data integrity uses MD  topics that we have already discussed\n PGP has also been embroiled in controversy since day  (Levy  )\n Because Zimmermann did nothing to stop other people from placing PGP on the Internet  where people all over the world could get it  the  \n Government claimed that Zimmermann had violated  \n laws prohibiting the export of munitions\n The  \n Government’s investigation of Zimmermann went on for  years but was eventually dropped  probably for two reasons\n First  Zimmermann did not place PGP on the Internet himself  so his lawyer claimed that he never exported anything (and then there is the little matter of whether creating a Web site constitutes export at all)\n ond  the government eventually came to realize that winning a trial meant convincing a jury that a Web site containing a downloadable privacy program was covered by the arms-trafficking law prohibiting the export of war materiel such as tanks  submarines  military aircraft  and nuclear weapons\n Years of negative publicity probably did not help much  either\n As an aside  the export rules are bizarre  to put it mildly\n The government considered putting code on a Web site to be an illegal export and harassed Zimmermann about it for  years\n On the other hand  when someone published the complete PGP source code  in C  as a book (in a large font with a checksum on each page to make scanning it in easy) and then exported the book  that was fine with the government because books are not classified as munitions\n The sword is mightier than the pen  at least for Uncle Sam\n Another problem PGP ran into involved patent infringement\n The company holding the RSA patent  RSA urity  Inc\n  alleged that PGP’s use of the RSA algorithm infringed on its patent  but that problem was settled with releases starting at   Furthermore  PGP uses another patented encryption algorithm  IDEA  whose use caused some problems at first\n   EMAIL URITY Since PGP is open source  various people and groups have modified it and produced a number of versions\n Some of these were designed to get around the munitions laws  others were focused on avoiding the use of patented algorithms  and still others wanted to turn it into a closed-source commercial product\n Although the munitions laws have now been slightly liberalized (otherwise  products using AES would not have been exportable from the  \n)  and the RSA patent expired in September  the legacy of all these problems is that several incompatible versions of PGP are in circulation  under various names\n The discussion below focuses on classic PGP  which is the oldest and simplest version\n Another popular version  Open PGP  is described in RFC \n Yet another is the GNU Privacy Guard\n PGP intentionally uses existing cryptographic algorithms rather than inventing new ones\n It is largely based on algorithms that have withstood extensive peer review and were not designed or influenced by any government agency trying to weaken them\n For people who distrust government  this property is a big plus\n PGP supports text compression  recy  and digital signatures and also provides extensive key management facilities  but  oddly enough  not email facilities\n It is like a preprocessor that takes plaintext as input and produces signed ciphertext in base  as output\n This output can then be emailed  of course\n Some PGP implementations call a user agent as the final step to actually send the message\n To see how PGP works  let us consider the example of Fig\n  -  \n Here  Alice wants to send a signed plaintext message  P  to Bob in a ure way\n Both Alice and Bob have private (DX) and public (EX) RSA keys\n Let us assume that each one knows the other’s public key; we will cover PGP key management shortly\n Alice starts out by invoking the PGP program on her computer\n PGP first hashes her message  P  using MD  and then encrypts the resulting hash using her private RSA key  DA\n When Bob eventually gets the message  he can decrypt the hash with Alice’s public key and verify that the hash is correct\n Even if someone else ( \n  Trudy) could acquire the hash at this stage and decrypt it with Alice’s known public key  the strength of MD  guarantees that it would be computationally infeasible to produce another message with the same MD  hash\n The encrypted hash and the original message are now concatenated into a single message  P  and compressed using the ZIP program  which uses the Ziv- Lempel algorithm (Ziv and Lempel  )\n Call the output of this step P \n Next  PGP prompts Alice for some random input\n Both the content and the typing speed are used to generate a   -bit IDEA message key  KM (called a session key in the PGP literature  but this is really a misnomer since there is no session)\n KM is now used to encrypt P  with IDEA in cipher feedback mode\n In addition  KM is encrypted with Bob’s public key  EB\n These two components are then concatenated and converted to base   as we discussed in the tion on MIME in   The resulting message contains only letters  digits  and the symbols +  /  and =  which means it can be put into an RFC body and be expected to arrive unmodified\n NETWORK URITY  \n  MD  RSA Zip IDEA Base   RSA ASCII text to P  the network P P  Original plaintext message from Alice Concatenation of P and the signed hash of P Concatenation of P  encrypted with IDEA and KM encrypted with EB Alice's private RSA key  DA P  compressed Bob's public RSA key  EB KM : One-time message key for IDEA : Concatenation KM Figure  -  \n PGP in operation for sending a message\n When Bob gets the message  he reverses the base  encoding and decrypts the IDEA key using his private RSA key\n Using this key  he decrypts the message to get P \n After decompressing it  Bob separates the plaintext from the encrypted hash and decrypts the hash using Alice’s public key\n If the plaintext hash agrees with his own MD  computation  he knows that P is the correct message and that it came from Alice\n It is worth noting that RSA is only used in two places here: to encrypt the   -bit MD  hash and to encrypt the   -bit IDEA key\n Although RSA is slow  it has to encrypt only bits  not a large volume of data\n Furthermore  all plaintext bits are exceedingly random  so a considerable amount of work will be required on Trudy’s part just to determine if a guessed key is correct\n The heavyduty encryption is done by IDEA  which is orders of magnitude faster than RSA\n Thus  PGP provides urity  compression  and a digital signature and does so in a much more efficient way than the scheme illustrated in Fig\n  -  \n PGP supports four RSA key lengths\n It is up to the user to select the one that is most appropriate\n The lengths are:  \n Casual (   bits): Can be broken easily today Commercial (   bits): Breakable by three-letter organizations Military ( bits): Not breakable by anyone on earth Alien ( bits): Not breakable by anyone on other planets  either\n   EMAIL URITY Since RSA is only used for two small computations  everyone should use alienstrength keys all the time\n The format of a classic PGP message is shown in Fig\n  -  \n Numerous other formats are also in use\n The message has three parts  containing the IDEA key  the signature  and the message  respectively\n The key part contains not only the key  but also a key identifier  since users are permitted to have multiple public keys\n ID of EB ID of EA Sig\n hdr MD  hash Msg hdr File name T i m e T i m e T y p e s KM Message Encrypted by EB DA Compressed  encrypted by IDEA Base  Signature part Message key part Message part Figure  -  \n A PGP message\n The signature part contains a header  which will not concern us here\n The header is followed by a timestamp  the identifier for the sender’s public key that can be used to decrypt the signature hash  some type information that identifies the algorithms used (to allow MD  and RSA  to be used when they are invented)  and the encrypted hash itself\n The message part also contains a header  the default name of the file to be used if the receiver writes the file to the disk  a message creation timestamp  and  finally  the message itself\n Key management has received a large amount of attention in PGP as it is the Achilles’ heel of all urity systems\n Key management works as follows\n Each user maintains two data structures locally: a private key ring and a public key ring\n The private key ring contains one or more personal private/public key pairs\n The reason for supporting multiple pairs per user is to permit users to change their public keys periodically or when one is thought to have been compromised  without invalidating messages currently in preparation or in transit\n Each pair has an identifier associated with it so that a message sender can tell the recipient which public key was used to encrypt it\n Message identifiers consist of the low-order   bits of the public key\n Users are themselves responsible for avoiding conflicts in their public-key identifiers\n The private keys on disk are encrypted using a special (arbitrarily long) password to protect them against sneak attacks\n The public key ring contains public keys of the user’s correspondents\n These are needed to encrypt the message keys associated with each message\n Each entry NETWORK URITY  \n  on the public key ring contains not only the public key  but also its  -bit identifier and an indication of how strongly the user trusts the key\n The problem being tackled here is the following\n Suppose that public keys are maintained on bulletin boards\n One way for Trudy to read Bob’s ret email is to attack the bulletin board and replace Bob’s public key with one of her choice\n When Alice later fetches the key allegedly belonging to Bob  Trudy can mount a bucket brigade attack on Bob\n To prevent such attacks  or at least minimize the consequences of them  Alice needs to know how much to trust the item called ‘‘Bob’s key’’ on her public key ring\n If she knows that Bob personally handed her a CD-ROM containing the key  she can set the trust value to the highest value\n It is this decentralized  user-controlled approach to public-key management that sets PGP apart from centralized PKI schemes\n Nevertheless  people do sometimes obtain public keys by querying a trusted key server\n For this reason  after X\n   was standardized  PGP supported these certificates as well as the traditional PGP public key ring mechanism\n All current versions of PGP have X\n   support\n    S/MIME IETF’s venture into email urity  called S/MIME (ure/MIME)  is described in RFCs  through \n It provides authentication  data integrity  recy  and nonrepudiation\n It also is quite flexible  supporting a variety of cryptographic algorithms\n Not surprisingly  given the name  S/MIME integrates well with MIME  allowing all kinds of messages to be protected\n A variety of new MIME headers are defined  for example  for holding digital signatures\n S/MIME does not have a rigid certificate hierarchy beginning at a single root  which had been one of the political problems that doomed an earlier system called PEM (Privacy Enhanced Mail)\n Instead  users can have multiple trust anchors\n As long as a certificate can be traced back to some trust anchor the user believes in  it is considered valid\n S/MIME uses the standard algorithms and protocols we have been examining so far  so we will not discuss it any further here\n For the details  please consult the RFCs  WEB URITY We have just studied two important areas where urity is needed: communications and email\n You can think of these as the soup and appetizer\n Now it is time for the main course: Web urity\n The Web is where most of the Trudies hang out nowadays and do their dirty work\n In the following tions  we will look at some of the problems and issues relating to Web urity\n   WEB URITY Web urity can be roughly divided into three parts\n First  how are objects and resources named urely? ond  how can ure  authenticated connections be established? Third  what happens when a Web site sends a client a piece of executable code? After looking at some threats  we will examine all these issues\n    Threats One reads about Web site urity problems in the newspaper almost weekly\n The situation is really pretty grim\n Let us look at a few examples of what has already happened\n First  the home pages of numerous organizations have been attacked and replaced by new home pages of the crackers’ choosing\n (The popular press calls people who break into computers ‘‘hackers ’’ but many programmers reserve that term for great programmers\n We prefer to call these people ‘‘crackers\n’’) Sites that have been cracked include those belonging to Yahoo!  the  \n Army  the CIA  NASA  and the New York Times\n In most cases  the crackers just put up some funny text and the sites were repaired within a few hours\n Now let us look at some much more serious cases\n Numerous sites have been brought down by denial-of-service attacks  in which the cracker floods the site with traffic  rendering it unable to respond to legitimate queries\n Often  the attack is mounted from a large number of machines that the cracker has already broken into (DDoS attacks)\n These attacks are so common that they do not even make the news any more  but they can cost the attacked sites thousands of dollars in lost business\n In  a Swedish cracker broke into Microsoft’s Hotmail Web site and created a mirror site that allowed anyone to type in the name of a Hotmail user and then read all of the person’s current and archived email\n In another case  a  -year-old Russian cracker named Maxim broke into an e-commerce Web site and stole    credit card numbers\n Then he approached the site owners and told them that if they did not pay him $    he would post all the credit card numbers to the Internet\n They did not give in to his blackmail  and he indeed posted the credit card numbers  inflicting great damage on many innocent victims\n In a different vein  a  -year-old California student emailed a press release to a news agency falsely stating that the Emulex Corporation was going to post a large quarterly loss and that the  \n was resigning immediately\n Within hours  the company’s stock dropped by  %  causing stockholders to lose over $  billion\n The perpetrator made a quarter of a million dollars by selling the stock short just before sending the announcement\n While this event was not a Web site break-in  it is clear that putting such an announcement on the home page of any big corporation would have a similar effect\n We could (unfortunately) go on like this for many more pages\n But it is now time to examine some of the technical issues related to Web urity\n For more NETWORK URITY  \n  information about urity problems of all kinds  see Anderson (   a); Stuttard and Pinto (   ); and Schneier (   )\n Searching the Internet will also turn up vast numbers of specific cases\n    ure Naming Let us start with something very basic: Alice wants to visit Bob’s Web site\n She types Bob’s URL into her browser and a few onds later  a Web page appears\n But is it Bob’s? Maybe yes and maybe no\n Trudy might be up to her old tricks again\n For example  she might be intercepting all of Alice’s outgoing packets and examining them\n When she captures an HTTP GET request headed to Bob’s Web site  she could go to Bob’s Web site herself to get the page  modify it as she wishes  and return the fake page to Alice\n Alice would be none the wiser\n Worse yet  Trudy could slash the prices at Bob’s e-store to make his goods look very attractive  thereby tricking Alice into sending her credit card number to ‘‘Bob’’ to buy some merchandise\n One disadvantage of this classic man-in-the-middle attack is that Trudy has to be in a position to intercept Alice’s outgoing traffic and forge her incoming traffic\n In practice  she has to tap either Alice’s phone line or Bob’s  since tapping the fiber backbone is fairly difficult\n While active wiretapping is certainly possible  it is a fair amount of work  and while Trudy is clever  she is also lazy\n Besides  there are easier ways to trick Alice\n DNS Spoofing One way would be for Trudy to crack the DNS system or maybe just the DNS cache at Alice’s ISP  and replace Bob’s IP address (say    \n ) with her (Trudy’s) IP address (say    \n )\n That leads to the following attack\n The way it is supposed to work is illustrated in Fig\n  -  (a)\n Here  Alice ( ) asks DNS for Bob’s IP address  ( ) gets it  ( ) asks Bob for his home page  and ( ) gets that  too\n After Trudy has modified Bob’s DNS record to contain her own IP address instead of Bob’s  we get the situation in Fig\n  -  (b)\n Here  when Alice looks up Bob’s IP address  she gets Trudy’s  so all her traffic intended for Bob goes to Trudy\n Trudy can now mount a man-in-the-middle attack without having to go to the trouble of tapping any phone lines\n Instead  she has to break into a DNS server and change one record  a much easier proposition\n How might Trudy fool DNS? It turns out to be relatively easy\n Briefly summarized  Trudy can trick the DNS server at Alice’s ISP into sending out a query to look up Bob’s address\n Unfortunately  since DNS uses UDP  the DNS server has no real way of checking who supplied the answer\n Trudy can exploit this property by forging the expected reply and thus injecting a false IP address into the DNS server’s cache\n For simplicity  we will assume that Alice’s ISP does not initially have an entry for Bob’s Web site   \n If it does  Trudy can wait until it times out and try later (or use other tricks)\n   WEB URITY  \n Give me Bob's IP address  \n   \n  (Bob's IP address)  \n GET    \n Bob's home page Bob's Web server (   \n ) DNS server Alice  (a)   \n Give me Bob's IP address  \n   \n  (Trudy's IP address)  \n GET    \n Trudy's fake of Bob's home page Trudy's Web server (   \n ) Cracked DNS server Alice  (b)  Figure  -  \n (a) Normal situation\n (b) An attack based on breaking into a DNS server and modifying Bob’s record\n Trudy starts the attack by sending a lookup request to Alice’s ISP asking for the IP address of  \n Since there is no entry for this DNS name  the cache server queries the top-level server for the com domain to get one\n However  Trudy beats the com server to the punch and sends back a false reply saying: ‘‘  is   \n  ’’ where that IP address is hers\n If her false reply gets back to Alice’s ISP first  that one will be cached and the real reply will be rejected as an unsolicited reply to a query no longer outstanding\n Tricking a DNS server into installing a false IP address is called DNS spoofing\n A cache that holds an intentionally false IP address like this is called a poisoned cache\n Actually  things are not quite that simple\n First  Alice’s ISP checks to see that the reply bears the correct IP source address of the top-level server\n But since Trudy can put anything she wants in that IP field  she can defeat that test easily since the IP addresses of the top-level servers have to be public\n ond  to allow DNS servers to tell which reply goes with which request  all requests carry a sequence number\n To spoof Alice’s ISP  Trudy has to know its current sequence number\n The easiest way to learn the current sequence number is for Trudy to register a domain herself  say  trudy-the- \n Let us assume its IP address is also    She also creates a DNS server for her newly hatched domain   -the- \n It  too  uses Trudy’s   \n  IP address  since Trudy has only one computer\n Now she has to make Alice’s ISP aware of her DNS server\n That is easy to do\n All she has to do is ask Alice’s ISP for  -the-   which will cause Alice’s ISP to find out who serves Trudy’s new domain by asking the top-level com server\n NETWORK URITY  \n  With  -the-  safely in the cache at Alice’s ISP  the real attack can start\n Trudy now queries Alice’s ISP for  -the- \n The ISP naturally sends Trudy’s DNS server a query asking for it\n This query bears the sequence number that Trudy is looking for\n Quick like a bunny  Trudy asks Alice’s ISP to look up Bob\n She immediately answers her own question by sending the ISP a forged reply  allegedly from the top-level com server  saying: ‘‘  is   \n ’’\n This forged reply carries a sequence number one higher than the one she just received\n While she is at it  she can also send a ond forgery with a sequence number two higher  and maybe a dozen more with increasing sequence numbers\n One of them is bound to match\n The rest will just be thrown out\n When Alice’s forged reply arrives  it is cached; when the real reply comes in later  it is rejected since no query is then outstanding\n Now when Alice looks up    she is told to use   \n  Trudy’s address\n Trudy has mounted a successful man-in-the-middle attack from the comfort of her own living room\n The various steps to this attack are illustrated in Fig\n  -  \n This one specific attack can be foiled by having DNS servers use random IDs in their queries rather than just counting  but it seems that every time one hole is plugged  another one turns up\n In particular  the IDs are only   bits  so working through all of them is easy when it is a computer that is doing the guessing Look up  -the-  (to force it into the ISP's cache)  \n Look up  -the-  (to get the ISP's next sequence number)  \n Request for  -the-  (Carrying the ISP's next sequence number  n)  \n Quick like a bunny  look up   (to force the ISP to query the com server in step  )  \n Legitimate query for   with seq = n+  \n Trudy's forged answer: Bob is   \n  seq = n+  \n Real answer (rejected  too late) Alice's ISP's cache DNS server for com Trudy  Figure  -  \n How Trudy spoofs Alice’s ISP\n ure DNS The real problem is that DNS was designed at a time when the Internet was a research facility for a few hundred universities  and neither Alice  nor Bob  nor Trudy was invited to the party\n urity was not an issue then; making the Internet work at all was the issue\n The environment has changed radically over the   WEB URITY years  so in  IETF set up a working group to make DNS fundamentally ure\n This (ongoing) project is known as DNS (DNS urity); its first output was presented in RFC \n Unfortunately  DNS has not been fully deployed yet  so numerous DNS servers are still vulnerable to spoofing attacks\n DNS is conceptually extremely simple\n It is based on public-key cryptography\n Every DNS zone (in the sense of Fig\n  - ) has a public/private key pair\n All information sent by a DNS server is signed with the originating zone’s private key  so the receiver can verify its authenticity\n DNS offers three fundamental services:  \n Proof of where the data originated Public key distribution Transaction and request authentication\n The main service is the first one  which verifies that the data being returned has been approved by the zone’s owner\n The ond one is useful for storing and retrieving public keys urely\n The third one is needed to guard against playback and spoofing attacks\n Note that recy is not an offered service since all the information in DNS is considered public\n Since phasing in DNS is expected to take several years  the ability for urity-aware servers to interwork with urity- ignorant servers is essential  which implies that the protocol cannot be changed\n Let us now look at some of the details\n DNS records are grouped into sets called RRSets (Resource Record Sets)  with all the records having the same name  class  and type being lumped together in a set\n An RRSet may contain multiple A records  for example  if a DNS name resolves to a primary IP address and a ondary IP address\n The RRSets are extended with several new record types (discussed below)\n Each RRSet is cryptographically hashed ( \n  using SHA- )\n The hash is signed by the zone’s private key ( \n  using RSA)\n The unit of transmission to clients is the signed RRSet\n Upon receipt of a signed RRSet  the client can verify whether it was signed by the private key of the originating zone\n If the signature agrees  the data are accepted\n Since each RRSet contains its own signature  RRSets can be cached anywhere  even at untrustworthy servers  without endangering the urity\n DNS introduces several new record types\n The first of these is the KEY record\n This records holds the public key of a zone  user  host  or other principal  the cryptographic algorithm used for signing  the protocol used for transmission  and a few other bits\n The public key is stored naked\n X\n   certificates are not used due to their bulk\n The algorithm field holds a  for MD /RSA signatures (the preferred choice)  and other values for other combinations\n The protocol field can indicate the use of IP or other urity protocols  if any\n The ond new record type is the SIG record\n It holds the signed hash according to the algorithm specified in the KEY record\n The signature applies to all the records in the RRSet  including any KEY records present  but excluding NETWORK URITY  \n  itself\n It also holds the times when the signature begins its period of validity and when it expires  as well as the signer’s name and a few other items\n The DNS design is such that a zone’s private key can be kept offline\n Once or twice a day  the contents of a zone’s database can be manually transported ( \n  on CD-ROM) to a disconnected machine on which the private key is located\n All the RRSets can be signed there and the SIG records thus produced can be conveyed back to the zone’s primary server on CD-ROM\n In this way  the private key can be stored on a CD-ROM locked in a safe except when it is inserted into the disconnected machine for signing the day’s new RRSets\n After signing is completed  all copies of the key are erased from memory and the disk and the CD-ROM are returned to the safe\n This procedure reduces electronic urity to physical urity  something people understand how to deal with\n This method of presigning RRSets greatly speeds up the process of answering queries since no cryptography has to be done on the fly\n The trade-off is that a large amount of disk space is needed to store all the keys and signatures in the DNS databases\n Some records will increase tenfold in size due to the signature\n When a client process gets a signed RRSet  it must apply the originating zone’s public key to decrypt the hash  compute the hash itself  and compare the two values\n If they agree  the data are considered valid\n However  this procedure begs the question of how the client gets the zone’s public key\n One way is to acquire it from a trusted server  using a ure connection ( \n  using IP)\n However  in practice  it is expected that clients will be preconfigured with the public keys of all the top-level domains\n If Alice now wants to visit Bob’s Web site  she can ask DNS for the RRSet of    which will contain his IP address and a KEY record containing Bob’s public key\n This RRSet will be signed by the top-level com domain  so Alice can easily verify its validity\n An example of what this RRSet might contain is shown in Fig\n  -  \n Domain name Time to live Class Type Value  \n  IN A   \n   \n  IN KEY   A B  F  CE   D\n  IN SIG    A B  F   E C\n\n Figure  -  \n An example RRSet for  \n The KEY record is Bob’s public key\n The SIG record is the top-level com server’s signed hash of the A and KEY records to verify their authenticity\n Now armed with a verified copy of Bob’s public key  Alice can ask Bob’s DNS server (run by Bob) for the IP address of  \n This RRSet will be signed by Bob’s private key  so Alice can verify the signature on the RRSet Bob returns\n If Trudy somehow manages to inject a false RRSet into any of the caches  Alice can easily detect its lack of authenticity because the SIG record contained in it will be incorrect\n   WEB URITY However  DNS also provides a cryptographic mechanism to bind a response to a specific query  to prevent the kind of spoof Trudy managed to pull off in Fig\n  -  \n This (optional) antispoofing measure adds to the response a hash of the query message signed with the respondent’s private key\n Since Trudy does not know the private key of the top-level com server  she cannot forge a response to a query Alice’s ISP sent there\n She can certainly get her response back first  but it will be rejected due to its invalid signature over the hashed query\n DNS also supports a few other record types\n For example  the CERT record can be used for storing ( \n  X\n  ) certificates\n This record has been provided because some people want to turn DNS into a PKI\n Whether this will actually happen remains to be seen\n We will stop our discussion of DNS here\n For more details  please consult RFC \n    SSL—The ure Sockets Layer ure naming is a good start  but there is much more to Web urity\n The next step is ure connections\n We will now look at how ure connections can be achieved\n Nothing involving urity is simple and this is not either\n When the Web burst into public view  it was initially used for just distributing static pages\n However  before long  some companies got the idea of using it for financial transactions  such as purchasing merchandise by credit card  online banking  and electronic stock trading\n These applications created a demand for ure connections\n In  Netscape Communications Corp\n  the then-dominant browser vendor  responded by introducing a urity package called SSL (ure Sockets Layer) to meet this demand\n This software and its protocol are now widely used  for example  by Firefox  Safari  and Internet Explorer  so it is worth examining in some detail\n SSL builds a ure connection between two sockets  including  \n Parameter negotiation between client and server Authentication of the server by the client ret communication Data integrity protection\n We have seen these items before  so there is no need to elaborate on them\n The positioning of SSL in the usual protocol stack is illustrated in Fig\n  -  \n Effectively  it is a new layer interposed between the application layer and the transport layer  accepting requests from the browser and sending them down to TCP for transmission to the server\n Once the ure connection has been established  SSL’s main job is handling compression and encryption\n When HTTP is used over SSL  it is called HTTPS (ure HTTP)  even though it is the standard HTTP protocol\n Sometimes it is available at a new port (  ) instead of port  \n NETWORK URITY  \n  As an aside  SSL is not restricted to Web browsers  but that is its most common application\n It can also provide mutual authentication\n Application (HTTP) urity (SSL) Transport (TCP) Network (IP) Data link (PPP) Physical (modem  ADSL  cable TV) Figure  -  \n Layers (and protocols) for a home user browsing with SSL\n The SSL protocol has gone through several versions\n Below we will discuss only version   which is the most widely used version\n SSL supports a variety of different options\n These options include the presence or absence of compression  the cryptographic algorithms to be used  and some matters relating to export restrictions on cryptography\n The last is mainly intended to make sure that serious cryptography is used only when both ends of the connection are in the United States\n In other cases  keys are limited to   bits  which cryptographers regard as something of a joke\n Netscape was forced to put in this restriction in order to get an export license from the  \n Government\n SSL consists of two subprotocols  one for establishing a ure connection and one for using it\n Let us start out by seeing how ure connections are established\n The connection establishment subprotocol is shown in Fig\n  -  \n It starts out with message  when Alice sends a request to Bob to establish a connection\n The request specifies the SSL version Alice has and her preferences with respect to compression and cryptographic algorithms\n It also contains a nonce  RA  to be used later\n Now it is Bob’s turn\n In message   Bob makes a choice among the various algorithms that Alice can support and sends his own nonce  RB\n Then  in message   he sends a certificate containing his public key\n If this certificate is not signed by some well-known authority  he also sends a chain of certificates that can be followed back to one\n All browsers  including Alice’s  come preloaded with about public keys  so if Bob can establish a chain anchored to one of these  Alice will be able to verify Bob’s public key\n At this point  Bob may send some other messages (such as a request for Alice’s public-key certificate)\n When Bob is done  he sends message  to tell Alice it is her turn\n Alice responds by choosing a random   -bit premaster key and sending it to Bob encrypted with his public key (message  )\n The actual session key used for encrypting data is derived from the premaster key combined with both nonces in a complex way\n After message  has been received  both Alice and Bob are able to compute the session key\n For this reason  Alice tells Bob to switch to the   WEB URITY SSL version  preferences  RA SSL version  choices  RB X\n   certificate chain Server done EB (premaster key) Change cipher Finished Change cipher Finished  Alice Bob    Figure  -  \n A simplified version of the SSL connection establishment subprotocol\n new cipher (message  ) and also that she is finished with the establishment subprotocol (message  )\n Bob then acknowledges her (messages  and  )\n However  although Alice knows who Bob is  Bob does not know who Alice is (unless Alice has a public key and a corresponding certificate for it  an unlikely situation for an individual)\n Therefore  Bob’s first message may well be a request for Alice to log in using a previously established login name and password\n The login protocol  however  is outside the scope of SSL\n Once it has been accomplished  by whatever means  data transport can begin\n As mentioned above  SSL supports multiple cryptographic algorithms\n The strongest one uses triple DES with three separate keys for encryption and SHA-  for message integrity\n This combination is relatively slow  so it is mostly used for banking and other applications in which the highest urity is required\n For ordinary e-commerce applications  RC  is used with a   -bit key for encryption and MD  is used for message authentication\n RC  takes the   -bit key as a seed and expands it to a much larger number for internal use\n Then it uses this internal number to generate a keystream\n The keystream is XORed with the plaintext to provide a classical stream cipher  as we saw in Fig\n  -  \n The export versions also use RC  with   -bit keys  but   of the bits are made public to make the cipher easy to break\n For actual transport  a ond subprotocol is used  as shown in Fig\n  -  \n Messages from the browser are first broken into units of up to   KB\n If data NETWORK URITY  \n  compression is enabled  each unit is then separately compressed\n After that  a ret key derived from the two nonces and premaster key is concatenated with the compressed text and the result is hashed with the agreed-on hashing algorithm (usually MD )\n This hash is appended to each fragment as the MAC\n The compressed fragment plus MAC is then encrypted with the agreed-on symmetric encryption algorithm (usually by XORing it with the RC  keystream)\n Finally  a fragment header is attached and the fragment is transmitted over the TCP connection\n Message authentication code Header added Encryption MAC added Compression Fragmentation Part  Part  Message from browser Figure  -  \n Data transmission using SSL\n A word of caution is in order  however\n Since it has been shown that RC  has some weak keys that can be easily cryptanalyzed  the urity of SSL using RC  is on shaky ground (Fluhrer et al\n  )\n Browsers that allow the user to choose the cipher suite should be configured to use triple DES with   -bit keys and SHA-  all the time  even though this combination is slower than RC  and MD \n Or  better yet  users should upgrade to browsers that support the successor to SSL that we describe shortly\n A problem with SSL is that the principals may not have certificates  and even if they do  they do not always verify that the keys being used match them\n In  Netscape Communications Corp\n turned SSL over to IETF for standardization\n The result was TLS (Transport Layer urity)\n It is described in RFC \n TLS was built on SSL version  \n The changes made to SSL were relatively small  but just enough that SSL version  and TLS cannot interoperate\n For example  the way the session key is derived from the premaster key and nonces was   WEB URITY changed to make the key stronger ( \n  harder to cryptanalyze)\n Because of this incompatibility  most browsers implement both protocols  with TLS falling back to SSL during negotiation if necessary\n This is referred to as SSL/TLS\n The first TLS implementation appeared in  with version  \n  defined in August \n It includes support for stronger cipher suites (notably AES)\n SSL has remained strong in the marketplace although TLS will probably gradually replace it\n    Mobile Code urity Naming and connections are two areas of concern related to Web urity\n But there are more\n In the early days  when Web pages were just static HTML files  they did not contain executable code\n Now they often contain small programs  including Java applets  ActiveX controls  and JavaScripts\n Downloading and executing such mobile code is obviously a massive urity risk  so various methods have been devised to minimize it\n We will now take a quick peek at some of the issues raised by mobile code and some approaches to dealing with it\n Java Applet urity Java applets are small Java programs compiled to a stack-oriented machine language called JVM (Java Virtual Machine)\n They can be placed on a Web page for downloading along with the page\n After the page is loaded  the applets are inserted into a JVM interpreter inside the browser  as illustrated in Fig\n  -  \n Untrusted applet Trusted applet Web browser Sandbox Interpreter Virtual address space  xFFFFFFFF  Figure  -  \n Applets can be interpreted by a Web browser\n The advantage of running interpreted code over compiled code is that every instruction is examined by the interpreter before being executed\n This gives the interpreter the opportunity to check whether the instruction’s address is valid\n In addition  system calls are also caught and interpreted\n How these calls are handled is a matter of the urity policy\n For example  if an applet is trusted ( \n  it NETWORK URITY  \n  came from the local disk)  its system calls could be carried out without question\n However  if an applet is not trusted ( \n  it came in over the Internet)  it could be encapsulated in what is called a sandbox to restrict its behavior and trap its attempts to use system resources\n When an applet tries to use a system resource  its call is passed to a urity monitor for approval\n The monitor examines the call in light of the local urity policy and then makes a decision to allow or reject it\n In this way  it is possible to give applets access to some resources but not all\n Unfortunately  the reality is that the urity model works badly and that bugs in it crop up all the time\n ActiveX ActiveX controls are x  binary programs that can be embedded in Web pages\n When one of them is encountered  a check is made to see if it should be executed  and it if passes the test  it is executed\n It is not interpreted or sandboxed in any way  so it has as much power as any other user program and can potentially do great harm\n Thus  all the urity is in the decision whether to run the ActiveX control\n In retrospect  the whole idea is a gigantic urity hole\n The method that Microsoft chose for making this decision is based on the idea of code signing\n Each ActiveX control is accompanied by a digital signature—a hash of the code that is signed by its creator using public-key cryptography\n When an ActiveX control shows up  the browser first verifies the signature to make sure it has not been tampered with in transit\n If the signature is correct  the browser then checks its internal tables to see if the program’s creator is trusted or there is a chain of trust back to a trusted creator\n If the creator is trusted  the program is executed; otherwise  it is not\n The Microsoft system for verifying ActiveX controls is called Authenticode\n It is useful to contrast the Java and ActiveX approaches\n With the Java approach  no attempt is made to determine who wrote the applet\n Instead  a run-time interpreter makes sure it does not do things the machine owner has said applets may not do\n In contrast  with code signing  there is no attempt to monitor the mobile code’s run-time behavior\n If it came from a trusted source and has not been modified in transit  it just runs\n No attempt is made to see whether the code is malicious or not\n If the original programmer intended the code to format the hard disk and then erase the flash ROM so the computer can never again be booted  and if the programmer has been certified as trusted  the code will be run and destroy the computer (unless ActiveX controls have been disabled in the browser)\n Many people feel that trusting an unknown software company is scary\n To demonstrate the problem  a programmer in Seattle formed a software company and got it certified as trustworthy  which is easy to do\n He then wrote an ActiveX control that did a clean shutdown of the machine and distributed his ActiveX control widely\n It shut down many machines  but they could just be rebooted  so no   WEB URITY harm was done\n He was just trying to expose the problem to the world\n The official response was to revoke the certificate for this specific ActiveX control  which ended a short episode of acute embarrassment  but the underlying problem is still there for an evil programmer to exploit (Garfinkel with Spafford  )\n Since there is no way to police the thousands of software companies that might write mobile code  the technique of code signing is a disaster waiting to happen\n JavaScript JavaScript does not have any formal urity model  but it does have a long history of leaky implementations\n Each vendor handles urity in a different way\n For example  Netscape Navigator version  used something akin to the Java model  but by version  that had been abandoned for a code-signing model\n The fundamental problem is that letting foreign code run on your machine is asking for trouble\n From a urity standpoint  it is like inviting a burglar into your house and then trying to watch him carefully so he cannot escape from the kitchen into the living room\n If something unexpected happens and you are distracted for a moment  bad things can happen\n The tension here is that mobile code allows flashy graphics and fast interaction  and many Web site designers think that this is much more important than urity  especially when it is somebody else’s machine at risk\n Browser Extensions As well as extending Web pages with code  there is a booming marketplace in browser extensions  add-ons  and plug-ins\n They are computer programs that extend the functionality of Web browsers\n Plug-ins often provide the capability to interpret or display a certain type of content  such as PDFs or Flash animations\n Extensions and add-ons provide new browser features  such as better password management  or ways to interact with pages by  for example  marking them up or enabling easy shopping for related items\n Installing an extension  add-on  or plug-in is as simple as coming across something you want when browsing and following the link to install the program\n This action will cause code to be downloaded across the Internet and installed into the browser\n All of these programs are written to frameworks that differ depending on the browser that is being enhanced\n However  to a first approximation  they become part of the trusted computing base of the browser\n That is  if the code that is installed is buggy  the entire browser can be compromised\n There are two other obvious failure modes as well\n The first is that the program may behave maliciously  for example  by gathering personal information and sending it to a remote server\n For all the browser knows  the user installed the extension for precisely this purpose\n The ond problem is that plug-ins give the browser the ability to interpret new types of content\n Often this content is a full NETWORK URITY  \n  blown programming language itself\n PDF and Flash are good examples\n When users view pages with PDF and Flash content  the plug-ins in their browser are executing the PDF and Flash code\n That code had better be safe; often there are vulnerabilities that it can exploit\n For all of these reasons  add-ons and plug-ins should only be installed as needed and only from trusted vendors\n Viruses Viruses are another form of mobile code\n Only  unlike the examples above  viruses are not invited in at all\n The difference between a virus and ordinary mobile code is that viruses are written to reproduce themselves\n When a virus arrives  either via a Web page  an email attachment  or some other way  it usually starts out by infecting executable programs on the disk\n When one of these programs is run  control is transferred to the virus  which usually tries to spread itself to other machines  for example  by emailing copies of itself to everyone in the victim’s email address book\n Some viruses infect the boot tor of the hard disk  so when the machine is booted  the virus gets to run\n Viruses have become a huge problem on the Internet and have caused billions of dollars’ worth of damage\n There is no obvious solution\n Perhaps a whole new generation of operating systems based on ure microkernels and tight compartmentalization of users  processes  and resources might help  SOCIAL ISSUES The Internet and its urity technology is an area where social issues  public policy  and technology meet head on  often with huge consequences\n Below we will just briefly examine three areas: privacy  freedom of speech  and copyright\n Needless to say  we can only scratch the surface\n For additional reading  see Anderson (   a)  Garfinkel with Spafford (   )  and Schneier (   )\n The Internet is also full of material\n Just type words such as ‘‘privacy ’’ ‘‘censorship ’’ and ‘‘copyright’’ into any search engine\n Also  see this book’s Web site for some links\n It is at http:// /tanenbaum  \n  Privacy Do people have a right to privacy? Good question\n The Fourth Amendment to the  \n Constitution prohibits the government from searching people’s houses  papers  and effects without good reason  and goes on to restrict the circumstances under which search warrants shall be issued\n Thus  privacy has been on the public agenda for over years  at least in the  \n What has changed in the past decade is both the ease with which governments can spy on their citizens and the ease with which the citizens can prevent such   SOCIAL ISSUES spying\n In the  th century  for the government to search a citizen’s papers  it had to send out a policeman on a horse to go to the citizen’s farm demanding to see certain documents\n It was a cumbersome procedure\n Nowadays  telephone companies and Internet providers readily provide wiretaps when presented with search warrants\n It makes life much easier for the policeman and there is no danger of falling off a horse\n Cryptography changes all that\n Anybody who goes to the trouble of downloading and installing PGP and who uses a well-guarded alien-strength key can be fairly sure that nobody in the known universe can read his email  search warrant or no search warrant\n Governments well understand this and do not like it\n Real privacy means it is much harder for them to spy on criminals of all stripes  but it is also much harder to spy on journalists and political opponents\n Consequently  some governments restrict or forbid the use or export of cryptography\n In France  for example  prior to  all cryptography was banned unless the government was given the keys\n France was not alone\n In April  the  \n Government announced its intention to make a hardware cryptoprocessor  the clipper chip  the standard for all networked communication\n It was said that this would guarantee citizens’ privacy\n It also mentioned that the chip provided the government with the ability to decrypt all traffic via a scheme called key escrow  which allowed the government access to all the keys\n However  the government promised only to snoop when it had a valid search warrant\n Needless to say  a huge furor ensued  with privacy advocates denouncing the whole plan and law enforcement officials praising it\n Eventually  the government backed down and dropped the idea\n A large amount of information about electronic privacy is available at the Electronic Frontier Foundation’s Web site   \n Anonymous Remailers PGP  SSL  and other technologies make it possible for two parties to establish ure  authenticated communication  free from third-party surveillance and interference\n However  sometimes privacy is best served by not having authentication  in fact  by making communication anonymous\n The anonymity may be desired for point-to-point messages  newsgroups  or both\n Let us consider some examples\n First  political dissidents living under authoritarian regimes often wish to communicate anonymously to escape being jailed or killed\n ond  wrongdoing in many corporate  educational  governmental  and other organizations has often been exposed by whistleblowers  who frequently prefer to remain anonymous to avoid retribution\n Third  people with unpopular social  political  or religious views may wish to communicate with each other via email or newsgroups without exposing themselves\n Fourth  people may wish to discuss alcoholism  mental illness  sexual harassment  child abuse  or being a NETWORK URITY  \n  member of a peruted minority in a newsgroup without having to go public\n Numerous other examples exist  of course\n Let us consider a specific example\n In the s  some critics of a nontraditional religious group posted their views to a USENET newsgroup via an anonymous remailer\n This server allowed users to create pseudonyms and send email to the server  which then remailed or re-posted them using the pseudonyms  so no one could tell where the messages really came from\n Some postings revealed what the religious group claimed were trade rets and copyrighted documents\n The religious group responded by telling local authorities that its trade rets had been disclosed and its copyright infringed  both of which were crimes where the server was located\n A court case followed and the server operator was compelled to turn over the mapping information that revealed the true identities of the persons who had made the postings\n (Incidentally  this was not the first time that a religious group was unhappy when someone leaked its trade rets: William Tyndale was burned at the stake in  for translating the Bible into English)\n A substantial segment of the Internet community was completely outraged by this breach of confidentiality\n The conclusion that everyone drew is that an anonymous remailer that stores a mapping between real email addresses and pseudonyms (now called a type  remailer) is not worth much\n This case stimulated various people into designing anonymous remailers that could withstand subpoena attacks\n These new remailers  often called cypherpunk remailers  work as follows\n The user produces an email message  complete with RFC headers (except From:  of course)  encrypts it with the remailer’s public key  and sends it to the remailer\n There the outer RFC headers are stripped off  the content is decrypted and the message is remailed\n The remailer has no accounts and maintains no logs  so even if the server is later confiscated  it retains no trace of messages that have passed through it\n Many users who wish anonymity chain their requests through multiple anonymous remailers  as shown in Fig\n  -  \n Here  Alice wants to send Bob a really  really  really anonymous Valentine’s Day card  so she uses three remailers\n She composes the message  M  and puts a header on it containing Bob’s email address\n Then she encrypts the whole thing with remailer  ’s public key  E  (indicated by horizontal hatching)\n To this she prepends a header with remailer  ’s email address in plaintext\n This is the message shown between remailers  and  in the figure\n Then she encrypts this message with remailer  ’s public key  E  (indicated by vertical hatching) and prepends a plaintext header containing remailer  ’s email address\n This message is shown between  and  in Fig\n  -  \n Finally  she encrypts the entire message with remailer  ’s public key  E  and prepends a plaintext header with remailer  ’s email address\n This is the message shown to the right of Alice in the figure and this is the message she actually transmits\n   SOCIAL ISSUES Alice  Bob To  To  Anonymous remailer Encrypted with E  Encrypted with E  Encrypted with E  To Bob To  M To Bob M To  To Bob M To  To  To Bob M Figure  -  \n How Alice uses three remailers to send Bob a message\n When the message hits remailer   the outer header is stripped off\n The body is decrypted and then emailed to remailer  \n Similar steps occur at the other two remailers\n Although it is extremely difficult for anyone to trace the final message back to Alice  many remailers take additional safety precautions\n For example  they may hold messages for a random time  add or remove junk at the end of a message  and reorder messages  all to make it harder for anyone to tell which message output by a remailer corresponds to which input  in order to thwart traffic analysis\n For a description of this kind of remailer  see Mazie`res and Kaashoek (   )\n Anonymity is not restricted to email\n Services also exist that allow anonymous Web surfing using the same form of layered path in which one node only knows the next node in the chain\n This method is called onion routing because each node peels off another layer of the onion to determine where to forward the packet next\n The user configures his browser to use the anonymizer service as a proxy\n Tor is a well-known example of such a system (Dingledine et al\n  )\n Henceforth  all HTTP requests go through the anonymizer network  which requests the page and sends it back\n The Web site sees an exit node of the anonymizer network as the source of the request  not the user\n As long as the anonymizer network refrains from keeping a log  after the fact no one can determine who requested which page  \n  Freedom of Speech Privacy relates to individuals wanting to restrict what other people can see about them\n A ond key social issue is freedom of speech  and its opposite  censorship  which is about governments wanting to restrict what individuals can read and publish\n With the Web containing millions and millions of pages  it has become a censor’s paradise\n Depending on the nature and ideology of the regime  banned material may include Web sites containing any of the following: NETWORK URITY  \n   \n Material inappropriate for children or teenagers Hate aimed at various ethnic  religious  sexual or other groups Information about democracy and democratic values Accounts of historical events contradicting the government’s version Manuals for picking locks  building weapons  encrypting messages  etc\n The usual response is to ban the ‘‘bad’’ sites\n Sometimes the results are unexpected\n For example  some public libraries have installed Web filters on their computers to make them child friendly by blocking pornography sites\n The filters veto sites on their blacklists but also check pages for dirty words before displaying them\n In one case in Loudoun County  Virginia  the filter blocked a patron’s search for information on breast cancer because the filter saw the word ‘‘breast\n’’ The library patron sued Loudoun County\n However  in Livermore  California  a parent sued the public library for not installing a filter after her  -year-old son was caught viewing pornography there\n What’s a library to do? It has escaped many people that the World Wide Web is a worldwide Web\n It covers the whole world\n Not all countries agree on what should be allowed on the Web\n For example  in November  a French court ordered Yahoo!  a California Corporation  to block French users from viewing auctions of Nazi memorabilia on Yahoo!’s Web site because owning such material violates French law\n Yahoo! appealed to a  \n court  which sided with it  but the issue of whose laws apply where is far from settled\n Just imagine\n What would happen if some court in Utah instructed France to block Web sites dealing with wine because they do not comply with Utah’s much stricter laws about alcohol? Suppose that China demanded that all Web sites dealing with democracy be banned as not in the interest of the State\n Do Iranian laws on religion apply to more liberal Sweden? Can Saudi Arabia block Web sites dealing with women’s rights? The whole issue is a veritable Pandora’s box\n A relevant comment from John Gilmore is: ‘‘The net interprets censorship as damage and routes around it\n’’ For a concrete implementation  consider the eternity service (Anderson  )\n Its goal is to make sure published information cannot be depublished or rewritten  as was common in the Soviet Union during Josef Stalin’s reign\n To use the eternity service  the user specifies how long the material is to be preserved  pays a fee proportional to its duration and size  and uploads it\n Thereafter  no one can remove or edit it  not even the uploader\n How could such a service be implemented? The simplest model is to use a peer-to-peer system in which stored documents would be placed on dozens of participating servers  each of which gets a fraction of the fee  and thus an incentive to join the system\n The servers should be spread over many legal jurisdictions for maximum resilience\n Lists of   randomly selected servers would be stored   SOCIAL ISSUES urely in multiple places  so that if some were compromised  others would still exist\n An authority bent on destroying the document could never be sure it had found all copies\n The system could also be made self-repairing in the sense that if it became known that some copies had been destroyed  the remaining sites would attempt to find new repositories to replace them\n The eternity service was the first proposal for a censorship-resistant system\n Since then  others have been proposed and  in some cases  implemented\n Various new features have been added  such as encryption  anonymity  and fault tolerance\n Often the files to be stored are broken up into multiple fragments  with each fragment stored on many servers\n Some of these systems are Freenet (Clarke et al\n  )  PASIS (Wylie et al\n  )  and Publius (Waldman et al\n  )\n Other work is reported by Serjantov (   )\n Increasingly  many countries are trying to regulate the export of intangibles  which often include Web sites  software  scientific papers  email  telephone helpdesks  and more\n Even the  \n  which has a centuries-long tradition of freedom of speech  is now seriously considering highly restrictive laws  that would  for example  define technical discussions between a British professor and his foreign  \n student  both located at the University of Cambridge  as regulated export needing a government license (Anderson  )\n Needless to say  many people consider such a policy to be outrageous\n Steganography In countries where censorship abounds  dissidents often try to use technology to evade it\n Cryptography allows ret messages to be sent (although possibly not lawfully)  but if the government thinks that Alice is a Bad Person  the mere fact that she is communicating with Bob may get him put in this category  too  as repressive governments understand the concept of transitive closure  even if they are short on mathematicians\n Anonymous remailers can help  but if they are banned domestically and messages to foreign ones require a government export license  they cannot help much\n But the Web can\n People who want to communicate retly often try to hide the fact that any communication at all is taking place\n The science of hiding messages is called steganography  from the Greek words for ‘‘covered writing\n’’ In fact  the ancient Greeks used it themselves\n Herodotus wrote of a general who shaved the head of a messenger  tattooed a message on his scalp  and let the hair grow back before sending him off\n Modern techniques are conceptually the same  only they have a higher bandwidth  lower latency  and do not require the services of a barber\n As a case in point  consider Fig\n  -  (a)\n This photograph  taken by one of the authors (AST) in Kenya  contains three zebras contemplating an acacia tree\n Fig\n  -  (b) appears to be the same three zebras and acacia tree  but it has an extra added attraction\n It contains the complete  unabridged text of five of NETWORK URITY  \n  Shakespeare’s plays embedded in it: Hamlet  King Lear  Macbeth  The Merchant of Venice  and Julius Caesar\n Together  these plays total over KB of text\n (a) (b) Figure  -  \n (a) Three zebras and a tree\n (b) Three zebras  a tree  and the complete text of five plays by William Shakespeare\n How does this steganographic channel work? The original color image is  × pixels\n Each pixel consists of three  -bit numbers  one each for the red  green  and blue intensity of that pixel\n The pixel’s color is formed by the linear superposition of the three colors\n The steganographic encoding method uses the low-order bit of each RGB color value as a covert channel\n Thus  each pixel has room for  bits of ret information   in the red value   in the green value  and  in the blue value\n With an image of this size  up to  × ×  bits or    bytes of ret information can be stored in it\n The full text of the five plays and a short notice add up to    bytes\n This text was first compressed to about KB using a standard compression algorithm\n The compressed output was then encrypted using IDEA and inserted into the low-order bits of each color value\n As can be seen (or actually  cannot be seen)  the existence of the information is completely invisible\n It is equally invisible in the large  full-color version of the photo\n The eye cannot easily distinguish  -bit color from  -bit color\n Viewing the two images in black and white with low resolution does not do justice to how powerful the technique is\n To get a better feel for how steganography works  we have prepared a demonstration  including the full-color highresolution image of Fig\n  -  (b) with the five plays embedded in it\n The demonstration  including tools for inserting and extracting text into images  can be found at the book’s Web site\n To use steganography for undetected communication  dissidents could create a Web site bursting with politically correct pictures  such as photographs of the Great Leader  local sports  movie  and television stars  etc\n Of course  the pictures would be riddled with steganographic messages\n If the messages were first   SOCIAL ISSUES compressed and then encrypted  even someone who suspected their presence would have immense difficulty in distinguishing the messages from white noise\n Of course  the images should be fresh scans; copying a picture from the Internet and changing some of the bits is a dead giveaway\n Images are by no means the only carrier for steganographic messages\n Audio files also work fine\n Hidden information can be carried in a voice-over-IP call by manipulating the packet delays  distorting the audio  or even in the header fields of packets (Lubacz et al\n  )\n Even the layout and ordering of tags in an HTML file can carry information\n Although we have examined steganography in the context of free speech  it has numerous other uses\n One common use is for the owners of images to encode ret messages in them stating their ownership rights\n If such an image is stolen and placed on a Web site  the lawful owner can reveal the steganographic message in court to prove whose image it is\n This technique is called watermarking\n It is discussed in Piva et al\n (   )\n For more on steganography  see Wayner (   )  \n  Copyright Privacy and censorship are just two areas where technology meets public policy\n A third one is the copyright law\n Copyright is granting to the creators of IP (Intellectual Property)  including writers  poets  artists  composers  musicians  photographers  cinematographers  choreographers  and others  the exclusive right to exploit their IP for some period of time  typically the life of the author plus   years or   years in the case of corporate ownership\n After the copyright of a work expires  it passes into the public domain and anyone can use or sell it as they wish\n The Gutenberg Project ( /pg)  for example  has placed thousands of public-domain works ( \n  by Shakespeare  Twain  and Dickens) on the Web\n In  the  \n Congress extended copyright in the  \n by another   years at the request of Hollywood  which claimed that without an extension nobody would create anything any more\n By way of contrast  patents last for only   years and people still invent things\n Copyright came to the forefront when Napster  a music-swapping service  had   million members\n Although Napster did not actually copy any music  the courts held that its holding a central database of who had which song was contributory infringement  that is  it was helping other people infringe\n While nobody seriously claims copyright is a bad idea (although many claim that the term is far too long  favoring big corporations over the public)  the next generation of music sharing is already raising major ethical issues\n For example  consider a peer-to-peer network in which people share legal files (public-domain music  home videos  religious tracts that are not trade rets  etc\n) and perhaps a few that are copyrighted\n Assume that everyone is online all the time via ADSL or cable\n Each machine has an index of what is on the hard NETWORK URITY  \n  disk  plus a list of other members\n Someone looking for a specific item can pick a random member and see if he has it\n If not  he can check out all the members in that person’s list  and all the members in their lists  and so on\n Computers are very good at this kind of work\n Having found the item  the requester just copies it\n If the work is copyrighted  chances are the requester is infringing (although for international transfers  the question of whose law applies matters because in some countries uploading is illegal but downloading is not)\n But what about the supplier? Is it a crime to keep music you have paid for and legally downloaded on your hard disk where others might find it? If you have an unlocked cabin in the country and an IP thief sneaks in carrying a notebook computer and scanner  scans a copyrighted book to the notebook’s hard disk  and sneaks out  are you guilty of the crime of failing to protect someone else’s copyright? But there is more trouble brewing on the copyright front\n There is a huge battle going on now between Hollywood and the computer industry\n The former wants stringent protection of all intellectual property but the latter does not want to be Hollywood’s policeman\n In October  Congress passed the DMCA (Digital Millennium Copyright Act)  which makes it a crime to circumvent any protection mechanism present in a copyrighted work or to tell others how to circumvent it\n Similar legislation has been enacted in the European Union\n While virtually no one thinks that pirates in the Far East should be allowed to duplicate copyrighted works  many people think that the DMCA completely shifts the balance between the copyright owner’s interest and the public interest\n A case in point: in September  a music industry consortium charged with building an unbreakable system for selling music online sponsored a contest inviting people to try to break the system (which is precisely the right thing to do with any new urity system)\n A team of urity researchers from several universities  led by Prof\n Edward Felten of Princeton  took up the challenge and broke the system\n They then wrote a paper about their findings and submitted it to a USENIX urity conference  where it underwent peer review and was accepted\n Before the paper was to be presented  Felten received a letter from the Recording Industry Association of America that threatened to sue the authors under the DMCA if they published the paper\n Their response was to file a lawsuit asking a federal court to rule on whether publishing scientific papers on urity research was still legal\n Fearing a definitive court ruling against it  the industry withdrew its threat and the court dismissed Felten’s suit\n No doubt the industry was motivated by the weakness of its case: it had invited people to try to break its system and then threatened to sue some of them for accepting its own challenge\n With the threat withdrawn  the paper was published (Craver et al\n  )\n A new confrontation is virtually certain\n Meanwhile  pirated music and movies have fueled the massive growth of peer-to-peer networks\n This has not pleased the copyright holders  who have used the DMCA to take action\n There are now automated systems that search peer-topeer networks and then fire off warnings to network operators and users who are   SOCIAL ISSUES suspected of infringing copyright\n In the United States  these warnings are known as DMCA takedown notices\n This search is an arms’ race because it is hard to reliably catch copyright infringers\n Even your printer might be mistaken for a culprit (Piatek et al\n  )\n A related issue is the extent of the fair use doctrine  which has been established by court rulings in various countries\n This doctrine says that purchasers of a copyrighted work have certain limited rights to copy the work  including the right to quote parts of it for scientific purposes  use it as teaching material in schools or colleges  and in some cases make backup copies for personal use in case the original medium fails\n The tests for what constitutes fair use include ( ) whether the use is commercial  ( ) what percentage of the whole is being copied  and ( ) the effect of the copying on sales of the work\n Since the DMCA and similar laws within the European Union prohibit circumvention of copy protection schemes  these laws also prohibit legal fair use\n In effect  the DMCA takes away historical rights from users to give content sellers more power\n A major showdown is inevitable\n Another development in the works that dwarfs even the DMCA in its shifting of the balance between copyright owners and users is trusted computing as advocated by industry bodies such as the TCG (Trusted Computing Group)  led by companies like Intel and Microsoft\n The idea is to provide support for carefully monitoring user behavior in various ways ( \n  playing pirated music) at a level below the operating system in order to prohibit unwanted behavior\n This is accomplished with a small chip  called a TPM (Trusted Platform Module)  which it is difficult to tamper with\n Most PCs sold nowadays come equipped with a TPM\n The system allows software written by content owners to manipulate PCs in ways that users cannot change\n This raises the question of who is trusted in trusted computing\n Certainly  it is not the user\n Needless to say  the social consequences of this scheme are immense\n It is nice that the industry is finally paying attention to urity  but it is lamentable that the driver is enforcing copyright law rather than dealing with viruses  crackers  intruders  and other urity issues that most people are concerned about\n In short  the lawmakers and lawyers will be busy balancing the economic interests of copyright owners with the public interest for years to come\n Cyberspace is no different from meatspace: it constantly pits one group against another  resulting in power struggles  litigation  and (hopefully) eventually some kind of resolution  at least until some new disruptive technology comes along  SUMMARY Cryptography is a tool that can be used to keep information confidential and to ensure its integrity and authenticity\n All modern cryptographic systems are based on Kerckhoff’s principle of having a publicly known algorithm and a ret NETWORK URITY  \n  key\n Many cryptographic algorithms use complex transformations involving substitutions and permutations to transform the plaintext into the ciphertext\n However  if quantum cryptography can be made practical  the use of one-time pads may provide truly unbreakable cryptosystems\n Cryptographic algorithms can be divided into symmetric-key algorithms and public-key algorithms\n Symmetric-key algorithms mangle the bits in a series of rounds parameterized by the key to turn the plaintext into the ciphertext\n AES (Rijndael) and triple DES are the most popular symmetric-key algorithms at present\n These algorithms can be used in electronic code book mode  cipher block chaining mode  stream cipher mode  counter mode  and others\n Public-key algorithms have the property that different keys are used for encryption and decryption and that the decryption key cannot be derived from the encryption key\n These properties make it possible to publish the public key\n The main public-key algorithm is RSA  which derives its strength from the fact that it is very difficult to factor large numbers\n Legal  commercial  and other documents need to be signed\n Accordingly  various schemes have been devised for digital signatures  using both symmetric-key and public-key algorithms\n Commonly  messages to be signed are hashed using algorithms such as SHA-  and then the hashes are signed rather than the original messages\n Public-key management can be done using certificates  which are documents that bind a principal to a public key\n Certificates are signed by a trusted authority or by someone (recursively) approved by a trusted authority\n The root of the chain has to be obtained in advance  but browsers generally have many root certificates built into them\n These cryptographic tools can be used to ure network traffic\n IP operates in the network layer  encrypting packet flows from host to host\n Firewalls can screen traffic going into or out of an organization  often based on the protocol and port used\n Virtual private networks can simulate an old leased-line network to provide certain desirable urity properties\n Finally  wireless networks need good urity lest everyone read all the messages  and protocols like   \n  i provide it\n When two parties establish a session  they have to authenticate each other and  if need be  establish a shared session key\n Various authentication protocols exist  including some that use a trusted third party  Diffie-Hellman  Kerberos  and public-key cryptography\n Email urity can be achieved by a combination of the techniques we have studied in this  ter\n PGP  for example  compresses messages  then encrypts them with a ret key and sends the ret key encrypted with the receiver’s public key\n In addition  it also hashes the message and sends the signed hash to verify message integrity\n Web urity is also an important topic  starting with ure naming\n DNS provides a way to prevent DNS spoofing\n Most e-commerce Web sites use   SUMMARY SSL/TLS to establish ure  authenticated sessions between the client and server\n Various techniques are used to deal with mobile code  especially sandboxing and code signing\n The Internet raises many issues in which technology interacts strongly with public policy\n Some of the areas include privacy  freedom of speech  and copyright\n PROBLEMS  \n Break the following monoalphabetic substitution cipher\n The plaintext  consisting of letters only  is an excerpt from a poem by Lewis Carroll\n mvyy bek mnyx n yvjjyr snijrh invq n muvjvdt je n idnvy jurhri n fehfevir pyeir oruvdq ki ndq uri jhrnqvdt ed zb jnvy Irr uem rntrhyb jur yeoijrhi ndq jur jkhjyri nyy nqlndpr Jurb nhr mnvjvdt ed jur iuvdtyr mvyy bek pezr ndq wevd jur qndpr mvyy bek  medj bek  mvyy bek  medj bek  mvyy bek wevd jur qndpr mvyy bek  medj bek  mvyy bek  medj bek  medj bek wevd jur qndpr  \n An affine cipher is a version of a monoalphabetic substitution cipher  in which the letters of an alphabet of size m are first map to the integers in the range  to m- \n Subsequently  the integer representing each plaintext letter is transformed to an integer representing the corresponding cipher text letter\n The encryption function for a single letter is E(x) = (ax + b) mod m  where m is the size of the alphabet and a and b are the key of the cipher  and are co-prime\n Trudy finds out that Bob generated a ciphertext using an affine cipher\n She gets a copy of the ciphertext  and finds out that the most frequent letter of the ciphertext is ’R’  and the ond most frequent letter of the ciphertext is ’K’\n Show how Trudy can break the code and retrieve the plaintext Break the following columnar transposition cipher\n The plaintext is taken from a popular computer textbook  so ‘‘computer’’ is a probable word\n The plaintext consists entirely of letters (no spaces)\n The ciphertext is broken up into blocks of five characters for readability\n aauan cvlre rurnn dltme aeepb ytust iceat npmey iicgo gorch srsoc nntii imiha oofpa gsivt tpsit lbolr otoex  \n Alice used a transposition cipher to encrypt her messages to Bob\n For added urity  she encrypted the transposition cipher key using a substitution cipher  and kept the encrypted cipher in her computer\n Trudy managed to get hold of the encrypted transposition cipher key\n Can Trudy decipher Alice’s messages to Bob? Why or why not?  \n Find a  -bit one-time pad that generates the text ‘‘Hello World’’ from the ciphertext of Fig\n  -  You are a spy  and  conveniently  have a library with an infinite number of books at your disposal\n Your operator also has such a library at his disposal\n You have agreed NETWORK URITY  \n  to use Lord of the Rings as a one-time pad\n Explain how you could use these assets to generate an infinitely long one-time pad Quantum cryptography requires having a photon gun that can  on demand  fire a single photon carrying  bit\n In this problem  calculate how many photons a bit carries on a   -Gbps fiber link\n Assume that the length of a photon is equal to its wavelength  which for purposes of this problem  is  micron\n The speed of light in fiber is   cm/n If Trudy captures and regenerates photons when quantum cryptography is in use  she will get some of them wrong and cause errors to appear in Bob’s one-time pad\n What fraction of Bob’s one-time pad bits will be in error  on average?  \n A fundamental cryptographic principle states that all messages must have redundancy\n But we also know that redundancy helps an intruder tell if a guessed key is correct\n Consider two forms of redundancy\n First  the initial n bits of the plaintext contain a known pattern\n ond  the final n bits of the message contain a hash over the message\n From a urity point of view  are these two equivalent? Discuss your answer In Fig\n  -  the P-boxes and S-boxes alternate\n Although this arrangement is esthetically pleasing  is it any more ure than first having all the P-boxes and then all the S-boxes? Discuss your answer Design an attack on DES based on the knowledge that the plaintext consists exclusively of uppercase ASCII letters  plus space  comma  period  semicolon  carriage return  and line feed\n Nothing is known about the plaintext parity bits In the text  we computed that a cipher-breaking machine with a million processors that could analyze a key in  nanoond would take  years to break the   -bit version of AES\n Let us compute how long it will take for this time to get down to  year  still along time  of course\n To achieve this goal  we need computers to be  times faster\n If Moore’s Law (computing power doubles every   months) continues to hold  how many years will it take before a parallel computer can get the cipherbreaking time down to a year?  \n AES supports a   -bit key\n How many keys does AES-   have? See if you can find some number in physics  chemistry  or astronomy of about the same size\n Use the Internet to help search for big numbers\n Draw a conclusion from your research Suppose that a message has been encrypted using DES in counter mode\n One bit of ciphertext in block Ci is accidentally transformed from a  to a  during transmission\n How much plaintext will be garbled as a result?  \n Now consider ciphertext block chaining again\n Instead of a single  bit being transformed into a  bit  an extra  bit is inserted into the ciphertext stream after block Ci \n How much plaintext will be garbled as a result?  \n Compare cipher block chaining with cipher feedback mode in terms of the number of encryption operations needed to transmit a large file\n Which one is more efficient and by how much?  \n Using the RSA public key cryptosystem  with a =   b =   \n y = z =  \n (a) If p =  and q = list five legal values for d  PROBLEMS (b) If p =   q = and d = find e\n (c) Using p =   q = and d =   find e and encrypt ‘‘hello’’ Alice and Bob use RSA public key encryption in order to communicate between them\n Trudy finds out that Alice and Bob shared one of the primes used to determine the number n of their public key pairs\n In other words  Trudy found out that na = pa × q and nb = pb × q\n How can Trudy use this information to break Alice’s code?  \n Consider the use of counter mode  as shown in Fig\n  -   but with IV =  \n Does the use of  threaten the urity of the cipher in general?  \n In Fig\n  -   we see how Alice can send Bob a signed message\n If Trudy replaces P  Bob can detect it\n But what happens if Trudy replaces both P and the signature?  \n Digital signatures have a potential weakness due to lazy users\n In e-commerce transactions  a contract might be drawn up and the user asked to sign its SHA-  hash\n If the user does not actually verify that the contract and hash correspond  the user may inadvertently sign a different contract\n Suppose that the Mafia try to exploit this weakness to make some money\n They set up a pay Web site ( \n  pornography  gambling  etc\n) and ask new customers for a credit card number\n Then they send over a contract saying that the customer wishes to use their service and pay by credit card and ask the customer to sign it  knowing that most of them will just sign without verifying that the contract and hash agree\n Show how the Mafia can buy diamonds from a legitimate Internet jeweler and charge them to unsuspecting customers A math class has   students\n Assuming that all of the students were born in the first half of the year—between January  st and June  th— what is the probability that at least two students have the same birthday? Assume that nobody was born on leap day  so there are possible birthdays After Ellen confessed to Marilyn about tricking her in the matter of Tom’s tenure  Marilyn resolved to avoid this problem by dictating the contents of future messages into a dictating machine and having her new retary just type them in\n Marilyn then planned to examine the messages on her terminal after they had been typed in to make sure they contained her exact words\n Can the new retary still use the birthday attack to falsify a message  and if so  how? Hint: She can Consider the failed attempt of Alice to get Bob’s public key in Fig\n  -  \n Suppose that Bob and Alice already share a ret key  but Alice still wants Bob’s public key\n Is there now a way to get it urely? If so  how?  \n Alice wants to communicate with Bob  using public-key cryptography\n She establishes a connection to someone she hopes is Bob\n She asks him for his public key and he sends it to her in plaintext along with an X\n   certificate signed by the root CA\n Alice already has the public key of the root CA\n What steps does Alice carry out to verify that she is talking to Bob? Assume that Bob does not care who he is talking to ( \n  Bob is some kind of public service) Suppose that a system uses PKI based on a tree-structured hierarchy of CAs\n Alice wants to communicate with Bob  and receives a certificate from Bob signed by a CA X after establishing a communication channel with Bob\n Suppose Alice has never heard of X\n What steps does Alice take to verify that she is talking to Bob? NETWORK URITY   Can IP using AH be used in transport mode if one of the machines is behind a NAT box? Explain your answer Alice wants to send a message to Bob using SHA-  hashes\n She consults with you regarding the appropriate signature algorithm to be used\n What would you suggest?  \n Give one reason why a firewall might be configured to inspect incoming traffic\n Give one reason why it might be configured to inspect outgoing traffic\n Do you think the inspections are likely to be successful?  \n Suppose an organization uses VPN to urely connect its sites over the Internet\n Jim  a user in the organization  uses the VPN to communicate with his boss  Mary\n Describe one type of communication between Jim and Mary which would not require use of encryption or other urity mechanism  and another type of communication which would require encryption or other urity mechanisms\n Explain your answer Change one message in the protocol of Fig\n  -  in a minor way to make it resistant to the reflection attack\n Explain why your change works The Diffie-Hellman key exchange is being used to establish a ret key between Alice and Bob\n Alice sends Bob (  )\n Bob responds with (  )\n Alice’s ret number  x  is and Bob’s ret number  y  is  \n Show how Alice and Bob compute the ret key Two users can establish a shared ret key using the Diffie-Hellman algorithm  even if they have never met  share no rets  and have no certificates (a) Explain how this algorithm is susceptible to a man-in-the-middle attack\n (b) How would this susceptibility change if n or g were ret?  \n In the protocol of Fig\n  -   why is A sent in plaintext along with the encrypted session key?  \n In the Needham-Schroeder protocol  Alice generates two challenges  RA and RA  \n This seems like overkill\n Would one not have done the job?  \n Suppose an organization uses Kerberos for authentication\n In terms of urity and service availability  what is the effect if AS or TGS goes down?  \n Alice is using the public-key authentication protocol of Fig\n  -  to authenticate communication with Bob\n However  when sending message   Alice forgot to encrypt RB\n Trudy now knows the value of RB\n Do Alice and Bob need to repeat the authentication procedure with new parameters in order to ensure ure communication? Explain your answer In the public-key authentication protocol of Fig\n  -   in message   RB is encrypted with KS\n Is this encryption necessary  or would it have been adequate to send it back in plaintext? Explain your answer Point-of-sale terminals that use magnetic-stripe cards and PIN codes have a fatal flaw: a malicious merchant can modify his card reader to log all the information on the card and the PIN code in order to post additional (fake) transactions in the future\n Next generation terminals will use cards with a complete CPU  keyboard  and tiny display on the card\n Devise a protocol for this system that malicious merchants cannot break  PROBLEMS  \n Is it possible to multicast a PGP message? What restrictions would apply?  \n Assuming that everyone on the Internet used PGP  could a PGP message be sent to an arbitrary Internet address and be decoded correctly by all concerned? Discuss your answer The attack shown in Fig\n  -  leaves out one step\n The step is not needed for the spoof to work  but including it might reduce potential suspicion after the fact\n What is the missing step?  \n The SSL data transport protocol involves two nonces as well as a premaster key\n What value  if any  does using the nonces have?  \n Consider an image of  × pixels\n You want to encrypt a file sized  \n  MB\n What fraction of the file can you encrypt in this image? What fraction would you be able to encrypt if you compressed the file to a quarter of its original size? Show your calculations The image of Fig\n  -  (b) contains the ASCII text of five plays by Shakespeare\n Would it be possible to hide music among the zebras instead of text? If so  how would it work and how much could you hide in this picture? If not  why not?  \n You are given a text file of size   MB  which is to be encrypted using steganography in the low-order bits of each color in an image file\n What size image would be required in order to encrypt the entire file? What size would be needed if the file were first compressed to a third of its original size? Give your answer in pixels  and show your calculations\n Assume that the images have an aspect ratio of  :  for example  ×  pixels Alice was a heavy user of a type  anonymous remailer\n She would post many messages to her favorite newsgroup     and everyone would know they all came from Alice because they all bore the same pseudonym\n Assuming that the remailer worked correctly  Trudy could not impersonate Alice\n After type  remailers were all shut down  Alice switched to a cypherpunk remailer and started a new thread in her newsgroup\n Devise a way for her to prevent Trudy from posting new messages to the newsgroup  impersonating Alice Search the Internet for an interesting case involving privacy and write a one-page report on it Search the Internet for some court case involving copyright versus fair use and write a  -page report summarizing your findings Write a program that encrypts its input by XORing it with a keystream\n Find or write as good a random number generator as you can to generate the keystream\n The program should act as a filter  taking plaintext on standard input and producing ciphertext on standard output (and vice versa)\n The program should take one parameter  the key that seeds the random number generator Write a procedure that computes the SHA-  hash of a block of data\n The procedure should have two parameters: a pointer to the input buffer and a pointer to a  -byte output buffer\n To see the exact specification of SHA-  search the Internet for FIPS   -  which is the full specification\n NETWORK URITY   Write a function that accepts a stream of ASCII characters and encrypts this input using a substitution cipher with the Cipher Block Chaining mode\n The block size should be  bytes\n The program should take plaintext from the standard input and print the ciphertext on the standard output\n For this problem  you are allowed to select any reasonable system to determine that the end of the input is reached  and/or when padding should be applied to complete the block\n You may select any output format  as long as it is unambiguous\n The program should receive two parameters:  \n A pointer to the initializing vector; and  \n A number  k  representing the substitution cipher shift  such that each ASCII character would be encrypted by the kth character ahead of it in the alphabet\n For example  if x =   then A is encoded by D  B is encoded by E etc\n Make reasonable assumptions with respect to reaching the last character in the ASCII set\n Make sure to document clearly in your code any assumptions you make about the input and encryption algorithm The purpose of this problem is to give you a better understanding as to the mechanisms of RSA\n Write a function that receives as its parameters primes p and q  calculates public and private RSA keys using these parameters  and outputs n  z  d and e as printouts to the standard output\n The function should also accept a stream of ASCII characters and encrypt this input using the calculated RSA keys\n The program should take plaintext from the standard input and print the ciphertext to the standard output\n The encryption should be carried out character-wise  that is  take each character in the input and encrypt it independently of other characters in the input\n For this problem  you are allowed to select any reasonable system to determine that the end of the input is reached\n You may select any output format  as long as it is unambiguous\n Make sure to document clearly in your code any assumptions you make about the input and encryption algorithm\n  READING LIST AND BIBLIOGRAPHY We have now finished our study of computer networks  but this is only the beginning\n Many interesting topics have not been treated in as much detail as they deserve  and others have been omitted altogether for lack of space\n In this  ter  we provide some suggestions for further reading and a bibliography  for the benefit of readers who wish to continue their study of computer networks  SUGGESTIONS FOR FURTHER READING There is an extensive literature on all aspects of computer networks\n Two journals that publish papers in this area are IEEE/ACM Transactions on Networking and IEEE Journal on Selected Areas in Communications\n The periodicals of the ACM Special Interest Groups on Data Communications (SIGCOMM) and Mobility of Systems  Users  Data  and Computing (SIGMOBILE) publish many papers of interest  especially on emerging topics\n They are Computer Communication Review and Mobile Computing and Communications Review\n IEEE also publishes three magazines—IEEE Internet Computing  IEEE Network Magazine  and IEEE Communications Magazine—that contain surveys  tutorials  and case studies on networking\n The first two emphasize architecture  standards  and software  and the last tends toward communications technology (fiber optics  satellites  and so on)\n    READING LIST AND BIBLIOGRAPHY  \n  There are a number of annual or biannual conferences that attract numerous papers on networks\n In particular  look for the SIGCOMM conference  NSDI (Symposium on Networked Systems Design and Implementation)  MobiSys (Conference on Mobile Systems  Applications  and Services)  SOSP (Symposium on Operating Systems Principles) and OSDI (Symposium on Operating Systems Design and Implementation)\n Below we list some suggestions for supplementary reading  keyed to the  ters of this book\n Many of the suggestions are books of  ters in books  with some tutorials and surveys\n Full references are in \n      Introduction and General Works Comer  The Internet Book  th ed\n Anyone looking for an easygoing introduction to the Internet should look here\n Comer describes the history  growth  technology  protocols  and services of the Internet in terms that novices can understand  but so much material is covered that the book is also of interest to more technical readers\n Computer Communication Review   th Anniversary Issue  Jan\n  For a firsthand look at how the Internet developed  this special issue collects important papers up to \n Included are papers that show the development of TCP  multicast  the DNS  Ethernet  and the overall architecture\n Crovella and Krishnamurthy  Internet Measurement How do we know how well the Internet works anyway? This question is not trivial to answer because no one is in charge of the Internet\n This book describes the techniques that have been developed to measure the operation of the Internet  from network infrastructure to applications\n IEEE Internet Computing  Jan\n–Feb\n  The first issue of IEEE Internet Computing in the new millennium did exactly what you would expect: it asked the people who helped create the Internet in the previous millennium to speculate on where it is going in the next one\n The experts are Paul Baran  Lawrence Roberts  Leonard Kleinrock  Stephen Crocker  Danny Cohen  Bob Metcalfe  Bill Gates  Bill Joy  and others\n See how well their predictions have fared over a decade later\n Kipnis  ‘‘Beating the System: Abuses of the Standards Adoption Process’’ Standards committees try to be fair and vendor neutral in their work  but unfortunately there are companies that try to abuse the system\n For example  it has happened repeatedly that a company helps develop a standard and then after it is approved  announces that the standard is based on a patent it owns and which it will license to companies that it likes and not to companies that it does not like  at   SUGGESTIONS FOR FURTHER READING prices that it alone determines\n For a look at the dark side of standardization  this article is an excellent start\n Hafner and Lyon  Where Wizards Stay Up Late Naughton  A Brief History of the Future Who invented the Internet  anyway? Many people have claimed credit\n And rightly so  since many people had a hand in it  in different ways\n There was Paul Baran  who wrote a report describing packet switching  there were the people at various universities who designed the ARPANET architecture  there were the people at BBN who programmed the first IMPs  there were Bob Kahn and Vint Cerf who invented TCP/IP  and so on\n These books tell the story of the Internet  at least up to  replete with many anecdotes\n    The Physical Layer Bellamy  Digital Telephony  rd ed\n For a look back at that other important network  the telephone network  this authoritative book contains everything you ever wanted to know and more\n Particularly interesting are the  ters on transmission and multiplexing  digital switching  fiber optics  mobile telephony  and DSL\n Hu and Li  ‘‘Satellite-Based Internet: A Tutorial’’ Internet access via satellite is different from using terrestrial lines\n Not only is there the issue of delay  but routing and switching are also different\n In this paper  the authors examine the issues related to using satellites for Internet access\n Joel  ‘‘Telecommunications and the IEEE Communications Society’’ For a compact but surprisingly comprehensive history of telecommunications  starting with the telegraph and ending with   \n   this article is the place to look\n It also covers radio  telephones  analog and digital switching  submarine cables  digital transmission  television broadcasting  satellites  cable TV  optical communications  mobile phones  packet switching  the ARPANET  and the Internet\n Palais  Fiber Optic Communication  th ed\n Books on fiber optic technology tend to be aimed at the specialist  but this one is more accessible than most\n It covers waveguides  light sources  light detectors  couplers  modulation  noise  and many other topics\n Su  The UMTS Air Interface in RF Engineering This book provides a detailed overview of one of the main  G cellular systems\n It is focused on the air interface  or wireless protocols that are used between mobiles and the network infrastructure\n READING LIST AND BIBLIOGRAPHY  \n  Want  RFID Explained Want’s book is an easy-to-read primer on how the unusual technology of the RFID physical layer works\n It covers all aspects of RFID  including its potential applications\n Some real-world examples of RFID deployments and the experience gained from them is also convered\n    The Data Link Layer Kasim  Delivering Carrier Ethernet Nowadays  Ethernet is not only a local-area technology\n The new fashion is to use Ethernet as a long-distance link for carrier-grade Ethernet\n This book brings together essays to cover the topic in depth\n Lin and Costello  Error Control Coding  nd ed\n Codes to detect and correct errors are central to reliable computer networks\n This popular textbook explains some of the most important codes  from simple linear Hamming codes to more complex low-density parity check codes\n It tries to do so with the minimum algebra necessary  but that is still a lot\n Stallings  Data and Computer Communications  th ed\n Part two covers digital data transmission and a variety of links  including error detection  error control with retransmissions  and flow control\n    The Medium Access Control Sublayer Andrews et al\n  Fundamentals of WiMAX This comprehensive book gives a definitive treatment of WiMAX technology  from the idea of broadband wireless  to the wireless techniques using OFDM and multiple antennas  through the multi-access system\n Its tutorial style gives about the most accessible treatment you will find for this heavy material\n Gast \n  Wireless Networks  nd ed\n For a readable introduction to the technology and protocols of   \n   this is a good place to start\n It begins with the MAC sublayer  then introduces material on the different physical layers and also urity\n However  the ond edition is not new enough to have much to say about   \n  n\n Perlman  Interconnections  nd ed\n For an authoritative but entertaining treatment of bridges  routers  and routing in general  Perlman’s book is the place to look\n The author designed the algorithms used in the IEEE spanning tree bridge and she is one of the world’s leading authorities on various aspects of networking\n   SUGGESTIONS FOR FURTHER READING    The Network Layer Comer  Internetworking with TCP/IP  Vol\n th ed\n Comer has written the definitive work on the TCP/IP protocol suite  now in its fifth edition\n Most of the first half deals with IP and related protocols in the network layer\n The other  ters deal primarily with the higher layers and are also worth reading\n Grayson et al\n  IP Design for Mobile Networks Traditional telephone networks and the Internet are on a collision course  with mobile phone networks being implemented with IP on the inside\n This book tells how to design a network using the IP protocols that supports mobile telephone service\n Huitema  Routing in the Internet  nd ed\n If you want to gain a deep understanding of routing protocols  this is a very good book\n Both pronounceable algorithms ( \n  RIP  and CIDR) and unpronounceable algorithms ( \n  OSPF  IGRP  and BGP) are treated in great detail\n Newer developments are not covered since this is an older book  but what is covered is explained very well\n Koodli and Perkins  Mobile Inter-networking with IPv  Two important network layer developments are presented in one volume: IPv  and Mobile IP\n Both topics are covered well  and Perkins was one of the driving forces behind Mobile IP\n Nucci and Papagiannaki  Design  Measurement and Management of Large-Scale IP Networks We talked a great deal about how networks work  but not how you would design  deploy and manage one if you were an ISP\n This book fills that gap  looking at modern methods for traffic engineering and how ISPs provide services using networks\n Perlman  Interconnections  nd ed\n In  s\n   through Perlman describes many of the issues involved in unicast and multicast routing algorithm design  both for wide area networks and networks of LANs\n But by far  the best part of the book is  \n in which the author distills her many years of experience with network protocols into an informative and fun  ter\n It is required reading for protocol designers\n Stevens  TCP/IP Illustrated  Vol\n ters  –  provide a comprehensive treatment of IP and related protocols (ARP  RARP  and ICMP)  illustrated by examples\n READING LIST AND BIBLIOGRAPHY  \n  Varghese  Network Algorithmics We have spent much time talking about how routers and other network elements interact with each other\n This book is different: it is about how routers are actually designed to forward packets at prodigious speeds\n For the inside scoop on that and related questions  this is the book to read\n The author is an authority on clever algorithms that are used in practice to implement high-speed network elements in software and hardware\n    The Transport Layer Comer  Internetworking with TCP/IP  Vol\n th ed\n As mentioned above  Comer has written the definitive work on the TCP/IP protocol suite\n The ond half of the book is about UDP and TCP\n Farrell and Cahill  Delay- and Disruption-Tolerant Networking This short book is the one to read for a deeper look at the architecture  protocols  and applications of ‘‘challenged networks’’ that must operate under harsh conditions of connectivity\n The authors have participated in the development of DTNs in the IETF DTN Research Group\n Stevens  TCP/IP Illustrated  Vol\n ters  –  provide a comprehensive treatment of TCP illustrated by examples\n    The Application Layer Berners-Lee et al\n  ‘‘The World Wide Web’’ Take a trip back in time for a perspective on the Web and where it is going by the person who invented it and some of his colleagues at CERN\n The article focuses on the Web architecture  URLs  HTTP  and HTML  as well as future directions  and compares it to other distributed information systems\n Held  A Practical Guide to Content Delivery Networks  nd ed\n This book gives a down-to-earth exposition of how CDNs work  emphasizing the practical considerations in designing and operating a CDN that performs well\n Hunter et al\n  Beginning XML  th ed\n There are many  many books on HTML  XML and Web services\n This - page book covers most of what you are likely to want to know\n It explains not only how to write XML and XHTML  but also how to develop Web services that produce and manipulate XML using Ajax  SOAP  and other techniques that are commonly used in practice\n   SUGGESTIONS FOR FURTHER READING Krishnamurthy and Rexford  Web Protocols and Practice It would be hard to find a more comprehensive book about all aspects of the Web than this one\n It covers clients  servers  proxies  and caching  as you might expect\n But there are also  ters on Web traffic and measurements as well as  ters on current research and improving the Web\n Simpson  Video Over IP  nd ed\n The author takes a broad look at how IP technology can be used to move video across networks  both on the Internet and in private networks designed to carry video\n Interestingly  this book is oriented for the video professional learning about networking  rather than the other way around\n Wittenburg  Understanding Voice Over IP Technology This book covers how voice over IP works  from carrying audio data with the IP protocols and quality-of-service issues  through to the SIP and H\n   suite of protocols\n It is necessarily detailed given the material  but accessible and broken up into digestible units\n    Network urity Anderson  urity Engineering  nd\n ed\n This book presents a wonderful mix of urity techniques couched in an understanding of how people use (and misuse) them\n It is more technical than rets and Lies  but less technical than Network urity (see below)\n After an introduction to the basic urity techniques  entire  ters are devoted to various applications  including banking  nuclear command and control  urity printing  biometrics  physical urity  electronic warfare  telecom urity  e-commerce  and copyright protection\n Ferguson et al\n  Cryptography Engineering Many books tell you how the popular cryptographic algorithms work\n This book tells you how to use cryptography—why cryptographic protocols are designed the way they are and how to put them together into a system that will meet your urity goals\n It is a fairly compact book that is essential reading for anyone designing systems that depend on cryptography\n Fridrich  Steganography in Digital Media Steganography goes back to ancient Greece  where the wax was melted off blank tablets so ret messages could be applied to the underlying wood before the wax was reapplied\n Nowadays  videos  audio  and other content on the Internet provide different carriers for ret messages\n Various modern techniques for hiding and finding information in images are discussed here\n READING LIST AND BIBLIOGRAPHY  \n  Kaufman et al\n  Network urity  nd ed\n This authoritative and witty book is the first place to look for more technical information on network urity algorithms and protocols\n ret and public key algorithms and protocols  message hashes  authentication  Kerberos  PKI  IP  SSL/TLS  and email urity are all explained carefully and at considerable length  with many examples\n  ter on urity folklore  is a real gem\n In urity  the devil is in the details\n Anyone planning to design a urity system that will actually be used will learn a lot from the real-world advice in this  ter\n Schneier  rets and Lies If you read Cryptography Engineering from cover to cover  you will know everything there is to know about cryptographic algorithms\n If you then read rets and Lies cover to cover (which can be done in a lot less time)  you will learn that cryptographic algorithms are not the whole story\n Most urity weaknesses are not due to faulty algorithms or even keys that are too short  but to flaws in the urity environment\n For a nontechnical and fascinating discussion of computer urity in the broadest sense  this book is a very good read\n Skoudis and Liston  Counter Hack Reloaded  nd ed\n The best way to stop a hacker is to think like a hacker\n This book shows how hackers see a network  and argues that urity should be a function of the entire network’s design  not an afterthought based on one specific technology\n It covers almost all common attacks  including the ‘‘social engineering’’ types that take advantage of users who are not always familiar with computer urity measures  ALPHABETICAL BIBLIOGRAPHY ABRAMSON  N\n: ‘‘Internet Access Using VSATs ’’ IEEE Commun\n Magazine  vol\n pp\n  –   July \n AHMADI  S\n: ‘‘An Overview of Next-Generation Mobile WiMAX Technology ’’ IEEE Commun\n Magazine  vol\n pp\n  –   June \n ALLMAN  M\n  and PAXSON  V\n: ‘‘On Estimating End-to-End Network Path Properties ’’ Proc\n SIGCOMM ’  Conf\n  ACM  pp\n   –    \n ANDERSON  C\n: The Long Tail: Why the Future of Business is Selling Less of More  rev\n upd\n ed\n  New York: Hyperion  a\n ANDERSON   \n: urity Engineering: A Guide to Building Dependable Distributed Systems  nd ed\n  New York: John Wiley & Sons  b\n ANDERSON   \n: ‘‘Free Speech Online and Offline ’’ IEEE Computer  vol\n pp\n  –   June \n   ALPHABETICAL BIBLIOGRAPHY ANDERSON   \n: ‘‘The Eternity Service ’’ Proc\n Pragocrypt Conf\n  CTU Publishing House  pp\n   –    \n ANDREWS  J\n  GHOSH  A\n  and MUHAMED  R\n: Fundamentals of WiMAX: Understanding Broadband Wireless Networking  Upper Saddle River  NJ: Pearson Education  \n ASTELY  D\n  DAHLMAN  E\n  FURUSKAR  A\n  JADING  Y\n  LINDSTROM  M\n  and PARKVALL  S\n: ‘‘LTE: The Evolution of Mobile Broadband ’’ IEEE Commun\n Magazine  vol\n pp\n  –   Apr BALLARDIE  T\n  FRANCIS  P\n  and CROWCROFT  J\n: ‘‘Core Based Trees (CBT) ’’ Proc\n SIGCOMM ’  Conf\n  ACM  pp\n  –   \n BARAN  P\n: ‘‘On Distributed Communications: I\n Introduction to Distributed Communication Networks ’’ Memorandum RM-  -PR  Rand Corporation  Aug BELLAMY  J\n: Digital Telephony  rd ed\n  New York: John Wiley & Sons  \n BELLMAN   \n: Dynamic Programming  Princeton  NJ: Princeton University Press  \n BELLOVIN  S\n: ‘‘The urity Flag in the IPv  Header ’’ RFC  Apr BELSNES  D\n: ‘‘Flow Control in the Packet Switching Networks ’’ Communications Networks  Uxbridge  England: Online  pp\n   –    \n BENNET   \n  and BRASSARD  G\n: ‘‘Quantum Cryptography: Public Key Distribution and Coin Tossing ’’ Int’l Conf\n on Computer Systems and Signal Processing  pp\n   –    \n BERESFORD  A\n  and STAJANO  F\n: ‘‘Location Privacy in Pervasive Computing ’’ IEEE Pervasive Computing  vol\n   pp\n  –   Jan BERGHEL   \n: ‘‘Cyber Privacy in the New Millennium ’’ IEEE Computer  vol\n pp\n   – Jan BERNERS-LEE  T\n  CAILLIAU  A\n  LOUTONEN  A\n  NIELSEN   \n  and RET  A\n: ‘‘The World Wide Web ’’ Commun\n of the ACM  vol\n pp\n  –   Aug BERTSEKAS  D\n  and GALLAGER  R\n: Data Networks  nd ed\n  Englewood Cliffs  NJ: Prentice Hall  \n BHATTI   \n  and CROWCROFT  J\n: ‘‘QoS Sensitive Flows: Issues in IP Packet Handling ’’ IEEE Internet Computing  vol\n   pp\n  –   July–Aug BIHAM  E\n  and SHAMIR  A\n: ‘‘Differential Fault Analysis of ret Key Cryptosystems ’’ Proc\n  th Ann\n Int’l Cryptology Conf\n  Berlin: Springer-Verlag LNCS  pp\n   –    \n BIRD  R\n  GOPAL  I\n  HERZBERG  A\n  JANSON   \n  KUTTEN  S\n  MOLVA  R\n  and YUNG  M\n: ‘‘Systematic Design of a Family of Attack-Resistant Authentication Protocols ’’ IEEE J\n on Selected Areas in Commun\n  vol\n pp\n   – June \n BIRRELL   \n  and NELSON   \n: ‘‘Implementing Remote Procedure Calls ’’ ACM Trans\n on Computer Systems  vol\n   pp\n  –   Feb READING LIST AND BIBLIOGRAPHY  \n  BIRYUKOV  A\n  SHAMIR  A\n  and WAGNER  D\n: ‘‘Real Time Cryptanalysis of A /  on a PC ’’ Proc\n Seventh Int’l Workshop on Fast Software Encryption  Berlin: Springer- Verlag LNCS  pp\n  –  \n BLAZE  M\n  and BELLOVIN  S\n: ‘‘Tapping on My Network Door ’’ Commun\n of the ACM  vol\n p\n  Oct BOGGS  D\n  MOGUL  J\n  and KENT  C\n: ‘‘Measured Capacity of an Ethernet: Myths and Reality ’’ Proc\n SIGCOMM ’  Conf\n  ACM  pp\n   –    \n BORISOV  N\n  GOLDBERG  I\n  and WAGNER  D\n: ‘‘Intercepting Mobile Communications: The Inurity of   \n  ’’ Seventh Int’l Conf\n on Mobile Computing and Networking  ACM  pp\n   –    \n BRADEN  R\n: ‘‘Requirements for Internet Hosts—Communication Layers ’’ RFC  Oct BRADEN  R\n  BORMAN  D\n  and PARTRIDGE  C\n: ‘‘Computing the Internet Checksum ’’ RFC  Sept BRANDENBURG  K\n: ‘‘MP  and AAC Explained ’’ Proc\n  th Intl\n Conf\n: High-Quality Audio Coding  Audio Engineering Society  pp\n  – Aug BRAY  T\n  PAOLI  J\n  SPERBERG-MCQUEEN  C\n  MALER  E\n  YERGEAU  F\n  and COWAN  J\n: ‘‘Extensible Markup Language (XML)  \n  (ond Edition) ’’ W C Recommendation  Sept BRESLAU  L\n  CAO  P\n  FAN  L\n  PHILLIPS  G\n  and SHENKER  S\n: ‘‘Web Caching and Zipf-like Distributions: Evidence and Implications ’’ Proc\n INFOCOM Conf\n  IEEE  pp\n   –    \n BURLEIGH  S\n  HOOKE  A\n  TORGERSON  L\n  FALL  K\n  CERF  V\n  DURST  B\n  SCOTT  K\n  and WEISS  H\n: ‘‘Delay-Tolerant Networking: An Approach to Interplanetary Internet ’’ IEEE Commun\n Magazine  vol\n pp\n   – June \n BURNETT  S\n  and PAINE  S\n: RSA urity’s Official Guide to Cryptography  Berkeley  CA: Osborne/McGraw-Hill  \n BUSH  V\n: ‘‘As We May Think ’’ Atlantic Monthly  vol\n  pp\n   – July \n CAPETANAKIS   \n: ‘‘Tree Algorithms for Packet Broadcast Channels ’’ IEEE Trans\n on Information Theory  vol\n IT–  pp\n   – Sept CASTAGNOLI  G\n  BRAUER  S\n  and HERRMANN  M\n: ‘‘Optimization of Cyclic Redundancy- Check Codes with   and   Parity Bits ’’ IEEE Trans\n on Commun\n  vol\n pp\n   – June \n CERF  V\n  and KAHN  R\n: ‘‘A Protocol for Packet Network Interconnection ’’ IEEE Trans\n on Commun\n  vol\n COM–  pp\n   – May \n CHANG  F\n  DEAN  J\n  GHEMAWAT  S\n  HSIEH  W\n  WALLACH  D\n  BURROWS  M\n  CHANDRA  T\n  FIKES  A\n  and GRUBER  R\n: ‘‘Bigtable: A Distributed Storage System for Structured Data ’’ Proc\n OSDI  Symp\n  USENIX  pp\n  –   \n CHASE   \n  GALLATIN   \n  and YOCUM   \n: ‘‘End System Optimizations for High- Speed TCP ’’ IEEE Commun\n Magazine  vol\n pp\n  –   Apr   ALPHABETICAL BIBLIOGRAPHY CHEN  S\n  and NAHRSTEDT  K\n: ‘‘An Overview of QoS Routing for Next-Generation Networks ’’ IEEE Network Magazine  vol\n pp\n  –   Nov\n/Dec CHIU  D\n  and JAIN  R\n: ‘‘Analysis of the Increase and Decrease Algorithms for Congestion Avoidance in Computer Networks ’’ Comput\n Netw\n ISDN Syst\n  vol\n pp\n  –  June \n CISCO: ‘‘Cisco Visual Networking Index: Forecast and Methodology  – ’’ Cisco Systems Inc\n  June \n CLARK   \n: ‘‘The Design Philosophy of the DARPA Internet Protocols ’’ Proc\n SIGCOMM ’  Conf\n  ACM  pp\n   –    \n CLARK   \n: ‘‘Window and Acknowledgement Strategy in TCP ’’ RFC  July \n CLARK   \n  JACOBSON  V\n  ROMKEY  J\n  and SALWEN  H\n: ‘‘An Analysis of TCP Processing Overhead ’’ IEEE Commun\n Magazine  vol\n pp\n  –   June \n CLARK   \n  SHENKER  S\n  and ZHANG  L\n: ‘‘Supporting Real-Time Applications in an Integrated Services Packet Network ’’ Proc\n SIGCOMM ’  Conf\n  ACM  pp\n  –   \n CLARKE   \n: ‘‘Extra-Terrestrial Relays ’’ Wireless World  \n CLARKE  I\n  MILLER   \n  HONG   \n  SANDBERG  O\n  and WILEY  B\n: ‘‘Protecting Free Expression Online with Freenet ’’ IEEE Internet Computing  vol\n   pp\n  –   Jan\n–Feb COHEN  B\n: ‘‘Incentives Build Robustness in BitTorrent ’’ Proc\n First Workshop on Economics of Peer-to-Peer Systems  June \n COMER   \n: The Internet Book  th ed\n  Englewood Cliffs  NJ: Prentice Hall  \n COMER   \n: Internetworking with TCP/IP  vol\n th ed\n  Englewood Cliffs  NJ: Prentice Hall  \n CRAVER   \n  WU  M\n  LIU  B\n  STUBBLEFIELD  A\n  SWARTZLANDER  B\n  WALLACH   \n  DEAN  D\n  and FELTEN   \n: ‘‘Reading Between the Lines: Lessons from the SDMI Challenge ’’ Proc\n  th USENIX urity Symp\n  USENIX  \n CROVELLA  M\n  and KRISHNAMURTHY  B\n: Internet Measurement  New York: John Wiley & Sons  \n DAEMEN  J\n  and RIJMEN  V\n: The Design of Rijndael  Berlin: Springer-Verlag  \n DALAL  Y\n  and METCLFE  R\n: ‘‘Reverse Path Forwarding of Broadcast Packets ’’ Commun\n of the ACM  vol\n pp\n –  Dec DAVIE  B\n  and FARREL  A\n: MPLS: Next Steps  San Francisco: Morgan Kaufmann  \n DAVIE  B\n  and REKHTER  Y\n: MPLS Technology and Applications  San Francisco: Morgan Kaufmann  \n DAVIES  J\n: Understanding IPv   nd ed\n  Redmond  WA: Microsoft Press  \n DAY   \n: ‘‘The (Un)Revised OSI Reference Model ’’ Computer Commun\n Rev\n  vol\n pp\n  –   Oct READING LIST AND BIBLIOGRAPHY  \n  DAY   \n  and ZIMMERMANN  H\n: ‘‘The OSI Reference Model ’’ Proc\n of the IEEE  vol\n pp\n –  Dec DECANDIA  G\n  HASTORIN  D\n  JAMPANI  M\n  KAKULAPATI  G\n  LAKSHMAN  A\n  PILCHIN  A\n  SIVASUBRAMANIAN  S\n  VOSSHALL  P\n  and VOGELS  W\n: ‘‘Dynamo: Amazon’s Highly Available Key-value Store ’’ Proc\n  th Symp\n on Operating Systems Prin\n  ACM  pp\n   – Dec DEERING   \n: ‘‘SIP: Simple Internet Protocol ’’ IEEE Network Magazine  vol\n   pp\n  –   May/June \n DEERING  S\n  and CHERITON  D\n: ‘‘Multicast Routing in Datagram Networks and Extended LANs ’’ ACM Trans\n on Computer Systems  vol\n   pp\n  – May \n DEMERS  A\n  KESHAV  S\n  and SHENKER  S\n: ‘‘Analysis and Simulation of a Fair Queueing Algorithm ’’ Internetwork: Research and Experience  vol\n   pp\n  –   Sept DENNING   \n  and SACCO   \n: ‘‘Timestamps in Key Distribution Protocols ’’ Commun\n of the ACM  vol\n pp\n   – Aug DEVARAPALLI  V\n  WAKIKAWA  R\n  PETRESCU  A\n  and THUBERT  P\n: ‘‘Network Mobility (NEMO) Basic Support Protocol ’’ RFC  Jan DIFFIE  W\n  and HELLMAN   \n: ‘‘Exhaustive Cryptanalysis of the NBS Data Encryption Standard ’’ IEEE Computer  vol\n pp\n  –   June \n DIFFIE  W\n  and HELLMAN   \n: ‘‘New Directions in Cryptography ’’ IEEE Trans\n on Information Theory  vol\n IT–  pp\n   – Nov DIJKSTRA   \n: ‘‘A Note on Two Problems in Connexion with Graphs ’’ Numer\n Math\n  vol\n   pp\n   – Oct DILLEY  J\n  MAGGS  B\n  PARIKH  J\n  PROKOP  H\n  SITARAMAN  R\n  and WHEIL  B\n: ‘‘Globally Distributed Content Delivery ’’ IEEE Internet Computing  vol\n   pp\n  –   \n DINGLEDINE  R\n  MATHEWSON  N\n  SYVERSON  P\n: ‘‘Tor: The ond-Generation Onion Router ’’ Proc\n  th USENIX urity Symp\n  USENIX  pp\n   – Aug DONAHOO  M\n  and CALVERT  K\n: TCP/IP Sockets in C  nd ed\n  San Francisco: Morgan Kaufmann  \n DONAHOO  M\n  and CALVERT  K\n: TCP/IP Sockets in Java  nd ed\n  San Francisco: Morgan Kaufmann  \n DONALDSON  G\n  and JONES  D\n: ‘‘Cable Television Broadband Network Architectures ’’ IEEE Commun\n Magazine  vol\n pp\n   – June \n DORFMAN  R\n: ‘‘Detection of Defective Members of a Large Population ’’ Annals Math\n Statistics  vol\n pp\n   –    \n DUTCHER  B\n: The NAT Handbook  New York: John Wiley & Sons  \n DUTTA-ROY  A\n: ‘‘An Overview of Cable Modem Technology and Market Perspectives ’’ IEEE Commun\n Magazine  vol\n pp\n  –   June \n   ALPHABETICAL BIBLIOGRAPHY EDELMAN  B\n  OSTROVSKY  M\n  and SCHWARZ  M\n: ‘‘Internet Advertising and the Generalized ond-Price Auction: Selling Billions of Dollars Worth of Keywords ’’ American Economic Review  vol\n pp\n   – Mar EL GAMAL  T\n: ‘‘A Public-Key Cryptosystem and a Signature Scheme Based on Discrete Logarithms ’’ IEEE Trans\n on Information Theory  vol\n IT–  pp\n   – July \n EPCGLOBAL: EPC Radio-Frequency Identity Protocols Class– Generation– UHF RFID Protocol for Communication at   -MHz to   -MHz Version    Brussels: EPCglobal Inc\n  Oct FALL  K\n: ‘‘A Delay-Tolerant Network Architecture for Challenged Internets ’’ Proc\n SIGCOMM  Conf\n  ACM  pp\n  –   Aug FALOUTSOS  M\n  FALOUTSOS  P\n  and FALOUTSOS  C\n: ‘‘On Power-Law Relationships of the Internet Topology ’’ Proc\n SIGCOMM ’  Conf\n  ACM  pp\n   –    \n FARRELL  S\n  and CAHILL  V\n: Delay- and Disruption-Tolerant Networking  London: Artech House  \n FELLOWS  D\n  and JONES  D\n: ‘‘DOCSIS Cable Modem Technology ’’ IEEE Commun\n Magazine  vol\n pp\n   – Mar FENNER  B\n  HANDLEY  M\n  HOLBROOK  H\n  and KOUVELAS  I\n: ‘‘Protocol Independent Multicast-Sparse Mode (PIM-SM) ’’ RFC  Aug FERGUSON  N\n  SCHNEIER  B\n  and KOHNO  T\n: Cryptography Engineering: Design Principles and Practical Applications  New York: John Wiley & Sons  \n FLANAGAN  D\n: JavaScript: The Definitive Guide  th ed\n  Sebastopol  CA: O’Reilly  \n FLETCHER  J\n: ‘‘An Arithmetic Checksum for Serial Transmissions ’’ IEEE Trans\n on Commun\n  vol\n COM–  pp\n   – Jan FLOYD  S\n  HANDLEY  M\n  PADHYE  J\n  and WIDMER  J\n: ‘‘Equation-Based Congestion Control for Unicast Applications ’’ Proc\n SIGCOMM  Conf\n  ACM  pp\n  –   Aug FLOYD  S\n  and JACOBSON  V\n: ‘‘Random Early Detection for Congestion Avoidance ’’ IEEE/ACM Trans\n on Networking  vol\n   pp\n   – Aug FLUHRER  S\n  MANTIN  I\n  and SHAMIR  A\n: ‘‘Weakness in the Key Scheduling Algorithm of RC  ’’ Proc\n Eighth Ann\n Workshop on Selected Areas in Cryptography  Berlin: Springer-Verlag LNCS  pp\n  –   \n FORD  B\n: ‘‘Structured Streams: A New Transport Abstraction ’’ Proc\n SIGCOMM  Conf\n  ACM  pp\n   –    \n FORD   \n  Jr\n  and FULKERSON   \n: Flows in Networks  Princeton  NJ: Princeton University Press  \n FORD  W\n  and BAUM   \n: ure Electronic Commerce  Upper Saddle River  NJ: Prentice Hall  \n FORNEY   \n: ‘‘The Viterbi Algorithm ’’ Proc\n of the IEEE  vol\n pp\n   – Mar READING LIST AND BIBLIOGRAPHY  \n  FOULI  K\n  and MALER  M\n: ‘‘The Road to Carrier-Grade Ethernet ’’ IEEE Commun\n Magazine  vol\n pp\n S  –S   Mar FOX  A\n  GRIBBLE  S\n  BREWER  E\n  and AMIR  E\n: ‘‘Adapting to Network and Client Variability via On-Demand Dynamic Distillation ’’ SIGOPS Oper\n Syst\n Rev\n  vol\n pp\n   – Dec FRANCIS  P\n: ‘‘A Near-Term Architecture for Deploying Pip ’’ IEEE Network Magazine  vol\n   pp\n  –   May/June \n FRASER   \n: ‘‘Towards a Universal Data Transport System ’’ IEEE J\n on Selected Areas in Commun\n  vol\n   pp\n   – Nov FRIDRICH  J\n: Steganography in Digital Media: Principles  Algorithms  and Applications  Cambridge: Cambridge University Press  \n FULLER  V\n  and LI  T\n: ‘‘Classless Inter-domain Routing (CIDR): The Internet Address Assignment and Aggregation Plan ’’ RFC  Aug GALLAGHER   \n: ‘‘A Minimum Delay Routing Algorithm Using Distributed Computation ’’ IEEE Trans\n on Commun\n  vol\n COM–  pp\n  –   Jan GALLAGHER   \n: ‘‘Low-Density Parity Check Codes ’’ IRE Trans\n on Information Theory  vol\n   pp\n  –   Jan GARFINKEL  S\n  with SPAFFORD  G\n: Web urity  Privacy  and Commerce  Sebastopol  CA: O’Reilly  \n GAST  M\n:   \n  Wireless Networks: The Definitive Guide  nd ed\n  Sebastopol  CA: O’Reilly  \n GERSHENFELD  N\n  and KRIKORIAN  R\n  and COHEN  D\n: ‘‘The Internet of Things ’’ Scientific American  vol\n  pp\n  –   Oct GILDER  G\n: ‘‘Metcalfe’s Law and Legacy ’’ Forbes ASAP  Sepy\n    \n GOODE  B\n: ‘‘Voice over Internet Protocol ’’ Proc\n of the IEEE  vol\n pp\n –  Sept GORALSKI   \n: SONET  nd ed\n  New York: McGraw-Hill  \n GRAYSON  M\n  SHATZKAMER  K\n  and WAINNER  S\n: IP Design for Mobile Networks  Indianapolis  IN: Cisco Press  \n GROBE  K\n  and ELBERS  J\n: ‘‘PON in Adolescence: From TDMA to WDM-PON ’’ IEEE Commun\n Magazine  vol\n pp\n  –   Jan GROSS  G\n  KAYCEE  M\n  LIN  A\n  MALIS  A\n  and STEPHENS  J\n: ‘‘The PPP Over AAL  ’’ RFC  July \n HA  S\n  RHEE  I\n  and LISONG  X\n: ‘‘CUBIC: A New TCP-Friendly High-Speed TCP Variant ’’ SIGOPS Oper\n Syst\n Rev\n  vol\n pp\n  –   June \n HAFNER  K\n  and LYON  M\n: Where Wizards Stay Up Late  New York: Simon & Schuster  \n HALPERIN  D\n  HEYDT-BENJAMIN  T\n  RANSFORD  B\n  CLARK  S\n  DEFEND  B\n  MORGAN  W\n  FU  K\n  KOHNO  T\n  and MAISEL  W\n: ‘‘Pacemakers and Implantable Cardi  ALPHABETICAL BIBLIOGRAPHY ac Defibrillators: Software Radio Attacks and Zero-Power Defenses ’’ IEEE Symp\n on urity and Privacy  pp\n   – May \n HALPERIN  D\n  HU  W\n  SHETH  A\n  and WETHERALL  D\n: ‘‘  \n  with Multiple Antennas for Dummies ’’ Computer Commun\n Rev\n  vol\n pp\n  –   Jan HAMMING   \n: ‘‘Error Detecting and Error Correcting Codes ’’ Bell System Tech\n J\n  vol\n pp\n   – Apr HARTE  L\n  KELLOGG  S\n  DREHER  R\n  and SCHAFFNIT  T\n: The Comprehensive Guide to Wireless Technology  Fuquay-Varina  NC: APDG Publishing  \n HAWLEY   \n: ‘‘Historical Perspectives on the  \n Telephone Loop ’’ IEEE Commun\n Magazine  vol\n pp\n  –   Mar HECHT  J\n: Understanding Fiber Optics  Upper Saddle River  NJ: Prentice Hall  \n HELD  G\n: A Practical Guide to Content Delivery Networks  nd ed\n  Boca Raton  FL: CRC Press  \n HEUSSE  M\n  ROUSSEAU  F\n  BERGER-SABBATEL  G\n  DUDA  A\n: ‘‘Performance Anomaly of   \n  b ’’ Proc\n INFOCOM Conf\n  IEEE  pp\n   –    \n HIERTZ  G\n  DENTENEER  D\n  STIBOR  L\n  ZANG  Y\n  COSTA  X\n  and WALKE  B\n: ‘‘The IEEE   \n  Universe ’’ IEEE Commun\n Magazine  vol\n pp\n  –   Jan HOE  J\n: ‘‘Improving the Start-up Behavior of a Congestion Control Scheme for TCP ’’ Proc\n SIGCOMM ’  Conf\n  ACM  pp\n   –    \n HU  Y\n  and LI   \n:‘‘Satellite-Based Internet: A Tutorial ’’ IEEE Commun\n Magazine  vol\n pp\n   – Mar HUITEMA  C\n: Routing in the Internet  nd ed\n  Englewood Cliffs  NJ: Prentice Hall  \n HULL  B\n  BYCHKOVSKY  V\n  CHEN  K\n  GORACZKO  M\n  MIU  A\n  SHIH  E\n  ZHANG  Y\n  BALAKRISHNAN  H\n  and MADDEN  S\n: ‘‘CarTel: A Distributed Mobile Sensor Computing System ’’ Proc\n Sensys  Conf\n  ACM  pp\n   – Nov HUNTER  D\n  RAFTER  J\n  FAWCETT  J\n  VAN DER LIST  E\n  AYERS  D\n  DUCKETT  J\n  WATT  A\n  and MCKINNON  L\n: Beginning XML  th ed\n  New Jersey: Wrox  \n IRMER  T\n: ‘‘Shaping Future Telecommunications: The Challenge of Global Standardization ’’ IEEE Commun\n Magazine  vol\n pp\n  –   Jan ITU (INTERNATIONAL TELECOMMUNICATION UNION): ITU Internet Reports : The Internet of Things  Geneva: ITU  Nov ITU (INTERNATIONAL TELECOMMUNICATION UNION): Measuring the Information Society: The ICT Development Index  Geneva: ITU  Mar JACOBSON  V\n: ‘‘Compressing TCP/IP Headers for Low-Speed Serial Links ’’ RFC  Feb JACOBSON  V\n: ‘‘Congestion Avoidance and Control ’’ Proc\n SIGCOMM ’  Conf\n  ACM  pp\n   –    \n READING LIST AND BIBLIOGRAPHY  \n  JAIN  R\n  and ROUTHIER  S\n: ‘‘Packet Trains—Measurements and a New Model for Computer Network Traffic ’’ IEEE J\n on Selected Areas in Commun\n  vol\n   pp\n   – Sept JAKOBSSON  M\n  and WETZEL  S\n: ‘‘urity Weaknesses in Bluetooth ’’ Topics in Cryptology: CT-RSA  Berlin: Springer-Verlag LNCS  pp\n   –    \n JOEL  A\n: ‘‘Telecommunications and the IEEE Communications Society ’’ IEEE Commun\n Magazine   th Anniversary Issue  pp\n  –  and   – May \n JOHNSON  D\n  PERKINS  C\n  and ARKKO  J\n: ‘‘Mobility Support in IPv  ’’ RFC  June \n JOHNSON   \n  MALTZ  D\n  and BROCH  J\n: ‘‘DSR: The Dynamic Source Routing Protocol for Multi-Hop Wireless Ad Hoc Networks ’’ Ad Hoc Networking  Boston: Addison-Wesley  pp\n   –    \n JUANG  P\n  OKI  H\n  WANG  Y\n  MARTONOSI  M\n  PEH  L\n  and RUBENSTEIN  D\n: ‘‘Energy- Efficient Computing for Wildlife Tracking: Design Tradeoffs and Early Experiences with ZebraNet ’’ SIGOPS Oper\n Syst\n Rev\n  vol\n pp\n  – Oct KAHN  D\n: The Codebreakers  nd ed\n  New York: Macmillan  \n KAMOUN  F\n  and KLEINROCK  L\n: ‘‘Stochastic Performance Evaluation of Hierarchical Routing for Large Networks ’’ Computer Networks  vol\n   pp\n   – Nov KARN  P\n: ‘‘MACA—A New Channel Access Protocol for Packet Radio ’’ ARRL/CRRL Amateur Radio Ninth Computer Networking Conf\n  pp\n   –    \n KARN  P\n  and PARTRIDGE  C\n: ‘‘Improving Round-Trip Estimates in Reliable Transport Protocols ’’ Proc\n SIGCOMM ’  Conf\n  ACM  pp\n  –  \n KARP  B\n  and KUNG   \n: ‘‘GPSR: Greedy Perimeter Stateless Routing for Wireless Networks ’’ Proc\n MOBICOM  Conf\n  ACM  pp\n   –    \n KASIM  A\n: Delivering Carrier Ethernet  New York: McGraw-Hill  \n KATABI  D\n  HANDLEY  M\n  and ROHRS  C\n: ‘‘Internet Congestion Control for Future High Bandwidth-Delay Product Environments ’’ Proc\n SIGCOMM  Conf\n  ACM  pp\n  –    \n KATZ  D\n  and FORD   \n: ‘‘TUBA: Replacing IP with CLNP ’’ IEEE Network Magazine  vol\n   pp\n  –   May/June \n KAUFMAN  C\n  PERLMAN  R\n  and SPECINER  M\n: Network urity  nd ed\n  Englewood Cliffs  NJ: Prentice Hall  \n KENT  C\n  and MOGUL  J\n: ‘‘Fragmentation Considered Harmful ’’ Proc\n SIGCOMM ’  Conf\n  ACM  pp\n   –    \n KERCKHOFF  A\n: ‘‘La Cryptographie Militaire ’’ J\n des Sciences Militaires  vol\n   pp\n  –   Jan\n  and pp\n   – Feb KHANNA  A\n  and ZINKY  J\n: ‘‘The Revised ARPANET Routing Metric ’’ Proc\n SIGCOMM ’  Conf\n  ACM  pp\n  –   \n KIPNIS  J\n: ‘‘Beating the System: Abuses of the Standards Adoption Process ’’ IEEE Commun\n Magazine  vol\n pp\n   – July \n   ALPHABETICAL BIBLIOGRAPHY KLEINROCK  L\n: ‘‘Power and Other Deterministic Rules of Thumb for Probabilistic Problems in Computer Communications ’’ Proc\n Intl\n Conf\n on Commun\n  pp\n   –     June \n KLEINROCK  L\n  and TOBAGI  F\n: ‘‘Random Access Techniques for Data Transmission over Packet-Switched Radio Channels ’’ Proc\n Nat\n Computer Conf\n  pp\n   –    \n KOHLER  E\n  HANDLEY  H\n  and FLOYD  S\n: ‘‘Designing DCCP: Congestion Control without Reliability ’’ Proc\n SIGCOMM  Conf\n  ACM  pp\n  –   \n KOODLI  R\n  and PERKINS   \n: Mobile Inter-networking with IPv  New York: John Wiley & Sons  \n KOOPMAN  P\n: ‘‘  -Bit Cyclic Redundancy Codes for Internet Applications ’’ Proc\n Intl\n Conf\n on Dependable Systems and Networks\n  IEEE  pp\n   –    \n KRISHNAMURTHY  B\n  and REXFORD  J\n: Web Protocols and Practice  Boston: Addison-Wesley  \n KUMAR  S\n  PAAR  C\n  PELZL  J\n  PFEIFFER  G\n  and SCHIMMLER  M\n: ‘‘Breaking Ciphers with COPACOBANA: A Cost-Optimized Parallel Code Breaker ’’ Proc\n  th Cryptographic Hardware and Embedded Systems Wksp\n  IACR  pp\n   – Oct LABOVITZ  C\n  AHUJA  A\n  BOSE  A\n  and JAHANIAN  F\n: ‘‘Delayed Internet Routing Convergence ’’ IEEE/ACM Trans\n on Networking  vol\n   pp\n   – June \n LAM   \n  and TAN   \n: ‘‘The Internet Is Changing the Music Industry ’’ Commun\n of the ACM  vol\n pp\n  –   Aug LAOUTARIS  N\n  SMARAGDAKIS  G\n  RODRIGUEZ  P\n  and SUNDARAM  R\n: ‘‘Delay Tolerant Bulk Data Transfers on the Internet ’’ Proc\n SIGMETRICS  Conf\n  ACM  pp\n   – June \n LARMO  A\n  LINDSTROM  M\n  MEYER  M\n  PELLETIER  G\n  TORSNER  J\n  and WIEMANN  H\n: ‘‘The LTE Link-Layer Design ’’ IEEE Commun\n Magazine  vol\n pp\n  –   Apr LEE   \n  and MILLER   \n: CDMA Systems Engineering Handbook  London: Artech House  \n LELAND  W\n  TAQQU  M\n  WILLINGER  W\n  and WILSON  D\n: ‘‘On the Self-Similar Nature of Ethernet Traffic ’’ IEEE/ACM Trans\n on Networking  vol\n   pp\n  –   Feb LEMON  J\n: ‘‘Resisting SYN Flood DOS Attacks with a SYN Cache ’’ Proc\n BSDCon Conf\n  USENIX  pp\n  –   \n LEVY  S\n: ‘‘Crypto Rebels ’’ Wired  pp\n  –   May/June \n LEWIS  M\n: Comparing  Designing  and Deploying VPNs  Indianapolis  IN: Cisco Press  \n LI  M\n  AGRAWAL  D\n  GANESAN  D\n  and VENKATARAMANI  A\n: ‘‘Block-Switched Networks: A New Paradigm for Wireless Transport ’’ Proc\n NSDI  Conf\n  USENIX  pp\n   –    \n READING LIST AND BIBLIOGRAPHY  \n  LIN  S\n  and COSTELLO  D\n: Error Control Coding  nd ed\n  Upper Saddle River  NJ: Pearson Education  \n LUBACZ  J\n  MAZURCZYK  W\n  and SZCZYPIORSKI  K\n: ‘‘Vice over IP ’’ IEEE Spectrum  pp\n  –   Feb MACEDONIA   \n: ‘‘Distributed File Sharing ’’ IEEE Computer  vol\n pp\n  –    \n MADHAVAN  J\n  KO  D\n  LOT  L\n  GANGPATHY  V\n  RASMUSSEN  A\n  and HALEVY  A\n: ‘‘Google’s Deep Web Crawl ’’ Proc\n VLDB  Conf\n  VLDB Endowment  pp\n –  \n MAHAJAN  R\n  RODRIG  M\n  WETHERALL  D\n  and ZAHORJAN  J\n: ‘‘Analyzing the MAC-Level Behavior of Wireless Networks in the Wild ’’ Proc\n SIGCOMM  Conf\n  ACM  pp\n  –   \n MALIS  A\n  and SIMPSON  W\n: ‘‘PPP over SONET/SDH ’’ RFC  June \n MASSEY   \n: ‘‘Shift-Register Synthesis and BCH Decoding ’’ IEEE Trans\n on Information Theory  vol\n IT–  pp\n   – Jan MATSUI  M\n: ‘‘Linear Cryptanalysis Method for DES Cipher ’’ Advances in Cryptology— Eurocrypt  Proceedings  Berlin: Springer-Verlag LNCS  pp\n   –    \n MAUFER   \n: IP Fundamentals  Upper Saddle River  NJ: Prentice Hall  \n MAYMOUNKOV  P\n  and MAZIERES  D\n: ‘‘Kademlia: A Peer-to-Peer Information System Based on the XOR Metric ’’ Proc\n First Intl\n Wksp\n on Peer-to-Peer Systems  Berlin: Springer-Verlag LNCS  pp\n  –   \n MAZIERES  D\n  and KAASHOEK   \n: ‘‘The Design  Implementation  and Operation of an Email Pseudonym Server ’’ Proc\n Fifth Conf\n on Computer and Commun\n urity  ACM  pp\n  –   \n MCAFEE LABS: McAfee Threat Reports: First Quarter  McAfee Inc MENEZES   \n  and VANSTONE   \n: ‘‘Elliptic Curve Cryptosystems and Their Implementation ’’ Journal of Cryptology  vol\n   pp\n   –    \n MERKLE   \n  and HELLMAN  M\n: ‘‘Hiding and Signatures in Trapdoor Knapsacks ’’ IEEE Trans\n on Information Theory  vol\n IT–  pp\n   – Sept METCALFE   \n: ‘‘Computer/Network Interface Design: Lessons from Arpanet and Ethernet ’’ IEEE J\n on Selected Areas in Commun\n  vol\n pp\n   – Feb METCALFE   \n  and BOGGS   \n: ‘‘Ethernet: Distributed Packet Switching for Local Computer Networks ’’ Commun\n of the ACM  vol\n pp\n   – July \n METZ  C: ‘‘Interconnecting ISP Networks ’’ IEEE Internet Computing  vol\n   pp\n  –   Mar\n–Apr MISHRA   \n  KANAKIA  H\n  and TRIPATHI  S\n: ‘‘On Hop by Hop Rate-Based Congestion Control ’’ IEEE/ACM Trans\n on Networking  vol\n   pp\n   – Apr MOGUL   \n: ‘‘IP Network Performance ’’ in Internet System Handbook   \n Lynch and  \n Rose (eds\n)  Boston: Addison-Wesley  pp\n   –    \n   ALPHABETICAL BIBLIOGRAPHY MOGUL  J\n  and DEERING  S\n: ‘‘Path MTU Discovery ’’ RFC  Nov MOGUL  J\n  and MINSHALL  G\n: ‘‘Rethinking the Nagle Algorithm ’’ Comput\n Commun\n Rev\n  vol\n pp\n  –   Jan MOY  J\n: ‘‘Multicast Routing Extensions for OSPF ’’ Commun\n of the ACM  vol\n pp\n  –   Aug MULLINS  J\n: ‘‘Making Unbreakable Code ’’ IEEE Spectrum  pp\n  –   May \n NAGLE  J\n: ‘‘On Packet Switches with Infinite Storage ’’ IEEE Trans\n on Commun\n  vol\n COM–  pp\n   – Apr NAGLE  J\n: ‘‘Congestion Control in TCP/IP Internetworks ’’ Computer Commun\n Rev\n  vol\n pp\n  –   Oct NAUGHTON  J\n: A Brief History of the Future  Woodstock  NY: Overlook Press  \n NEEDHAM   \n  and SCHROEDER   \n: ‘‘Using Encryption for Authentication in Large Networks of Computers ’’ Commun\n of the ACM  vol\n pp\n   – Dec NEEDHAM   \n  and SCHROEDER   \n: ‘‘Authentication Revisited ’’ Operating Systems Rev\n  vol\n p\n   Jan NELAKUDITI  S\n  and ZHANG  Z\n-L\n: ‘‘A Localized Adaptive Proportioning Approach to QoS Routing ’’ IEEE Commun\n Magazine vol\n pp\n  –   June \n NEUMAN  C\n  and TS’O  T\n: ‘‘Kerberos: An Authentication Service for Computer Networks ’’ IEEE Commun\n Mag\n  vol\n pp\n  –   Sept NICHOLS   \n  and LEKKAS   \n: Wireless urity  New York: McGraw-Hill  \n NIST: ‘‘ure Hash Algorithm ’’  \n Government Federal Information Processing Standard  \n NONNENMACHER  J\n  BIERSACK  E\n  and TOWSLEY  D\n: ‘‘Parity-Based Loss Recovery for Reliable Multicast Transmission ’’ Proc\n SIGCOMM ’  Conf\n  ACM  pp\n   –    \n NUCCI  A\n  and PAPAGIANNAKI  D\n: Design  Measurement and Management of Large- Scale IP Networks  Cambridge: Cambridge University Press  \n NUGENT  R\n  MUNAKANA  R\n  CHIN  A\n  COELHO  R\n  and PUIG-SUARI  J\n: ‘‘The CubeSat: The PicoSatellite Standard for Research and Education ’’ Proc\n SPACE  Conf\n  AIAA  \n ORAN  D\n: ‘‘OSI IS-IS Intra-domain Routing Protocol ’’ RFC  Feb OTWAY  D\n  and REES  O\n: ‘‘Efficient and Timely Mutual Authentication ’’ Operating Systems Rev\n  pp\n  –   Jan PADHYE  J\n  FIROIU  V\n  TOWSLEY  D\n  and KUROSE  J\n: ‘‘Modeling TCP Throughput: A Simple Model and Its Empirical Validation ’’ Proc\n SIGCOMM ’  Conf\n  ACM  pp\n   –    \n PALAIS   \n: Fiber Optic Commun\n  th ed\n  Englewood Cliffs  NJ: Prentice Hall  \n READING LIST AND BIBLIOGRAPHY  \n  PARAMESWARAN  M\n  SUSARLA  A\n  and WHINSTON   \n: ‘‘P P Networking: An Information-Sharing Alternative ’’ IEEE Computer  vol\n pp\n  –   July \n PAREKH  A\n  and GALLAGHER  R\n: ‘‘A Generalized Processor Sharing Approach to Flow Control in Integrated Services Networks: The Multiple-Node Case ’’ IEEE/ACM Trans\n on Networking  vol\n   pp\n   – Apr PAREKH  A\n  and GALLAGHER  R\n: ‘‘A Generalized Processor Sharing Approach to Flow Control in Integrated Services Networks: The Single-Node Case ’’ IEEE/ACM Trans\n on Networking  vol\n   pp\n   – June \n PARTRIDGE  C\n  HUGHES  J\n  and STONE  J\n: ‘‘Performance of Checksums and CRCs over Real Data ’’ Proc\n SIGCOMM ’  Conf\n  ACM  pp\n  –   \n PARTRIDGE  C\n  MENDEZ  T\n  and MILLIKEN  W\n: ‘‘Host Anycasting Service ’’ RFC  Nov PAXSON  V\n  and FLOYD  S\n: ‘‘Wide-Area Traffic: The Failure of Poisson Modeling ’’ IEEE/ACM Trans\n on Networking  vol\n   pp\n   – June \n PERKINS  C\n: ‘‘IP Mobility Support for IPv  ’’ RFC  Aug PERKINS   \n: RTP: Audio and Video for the Internet  Boston: Addison-Wesley  \n PERKINS   \n (ed\n): Ad Hoc Networking  Boston: Addison-Wesley  \n PERKINS   \n: Mobile IP Design Principles and Practices  Upper Saddle River  NJ: Prentice Hall  \n PERKINS   \n  and ROYER  E\n: ‘‘The Ad Hoc On-Demand Distance-Vector Protocol ’’ in Ad Hoc Networking  edited by C\n Perkins  Boston: Addison-Wesley  \n PERLMAN  R\n: Interconnections  nd ed\n  Boston: Addison-Wesley  \n PERLMAN  R\n: Network Layer Protocols with Byzantine Robustness   \n thesis    PERLMAN  R\n: ‘‘An Algorithm for the Distributed Computation of a Spanning Tree in an Extended LAN ’’ Proc\n SIGCOMM ’  Conf\n  ACM  pp\n  –   \n PERLMAN  R\n  and KAUFMAN  C\n: ‘‘Key Exchange in IP ’’ IEEE Internet Computing  vol\n   pp\n  –   Nov\n–Dec PETERSON   \n  and BROWN   \n: ‘‘Cyclic Codes for Error Detection ’’ Proc\n IRE  vol\n pp\n   – Jan PIATEK  M\n  KOHNO  T\n  and KRISHNAMURTHY  A\n: ‘‘Challenges and Directions for Monitoring P P File Sharing Networks—or Why My Printer Received a DMCA Takedown Notice ’’  rd Workshop on Hot Topics in urity  USENIX  July \n PIATEK  M\n  ISDAL  T\n  ANDERSON  T\n  KRISHNAMURTHY  A\n  and VENKATARAMANI  V\n: ‘‘Do Incentives Build Robustness in BitTorrent? ’’ Proc\n NSDI  Conf\n  USENIX  pp\n  –   \n PISCITELLO   \n  and  IN   \n: Open Systems Networking: TCP/IP and OSI  Boston: Addison-Wesley  \n   ALPHABETICAL BIBLIOGRAPHY PIVA  A\n  BARTOLINI  F\n  and BARNI  M\n: ‘‘Managing Copyrights in Open Networks ’’ IEEE Internet Computing  vol\n   pp\n  –   May– \n POSTEL  J\n: ‘‘Internet Control Message Protocols ’’ RFC  Sept RABIN  J\n  and MCCATHIENEVILE  C\n: ‘‘Mobile Web Best Practices  \n  ’’ W C Recommendation  July \n RAMAKRISHNAM   \n  FLOYD  S\n  and BLACK  D\n: ‘‘The Addition of Explicit Congestion Notification (ECN) to IP ’’ RFC  Sept RAMAKRISHNAN   \n  and JAIN  R\n: ‘‘A Binary Feedback Scheme for Congestion Avoidance in Computer Networks with a Connectionless Network Layer ’’ Proc\n SIGCOMM ’  Conf\n  ACM  pp\n   –    \n RAMASWAMI  R\n  KUMAR  S\n  and SASAKI  G\n: Optical Networks: A Practical Perspective  rd ed\n  San Francisco: Morgan Kaufmann  \n RATNASAMY  S\n  FRANCIS  P\n  HANDLEY  M\n  KARP  R\n  and SHENKER  S\n: ‘‘A Scalable Content-Addressable Network ’’ Proc\n SIGCOMM  Conf\n  ACM  pp\n   –    \n RIEBACK  M\n  CRISPO  B\n  and TANENBAUM  A\n: ‘‘Is Your Cat Infected with a Computer Virus? ’’ Proc\n IEEE Percom  pp\n   – Mar RIVEST   \n: ‘‘The MD  Message-Digest Algorithm ’’ RFC  Apr RIVEST   \n  SHAMIR  A\n  and ADLEMAN  L\n: ‘‘On a Method for Obtaining Digital Signatures and Public Key Cryptosystems ’’ Commun\n of the ACM  vol\n pp\n   – Feb ROBERTS   \n: ‘‘Extensions of Packet Communication Technology to a Hand Held Personal Terminal ’’ Proc\n Spring Joint Computer Conf\n  AFIPS  pp\n   –    \n ROBERTS   \n: ‘‘Multiple Computer Networks and Intercomputer Communication ’’ Proc\n First Symp\n on Operating Systems Prin\n  ACM  pp –  ROSE   \n: The Simple Book  Englewood Cliffs  NJ: Prentice Hall  \n ROSE   \n: The Internet Message  Englewood Cliffs  NJ: Prentice Hall  \n ROWSTRON  A\n  and DRUSCHEL  P\n: ‘‘Pastry: Scalable  Distributed Object Location and Routing for Large-Scale Peer-to-Peer Storage Utility ’’ Proc\n  th Int’l Conf\n on Distributed Systems Platforms  London: Springer-Verlag LNCS  pp\n   –    \n RUIZ-SANCHEZ   \n  BIERSACK   \n  and DABBOUS  W\n: ‘‘Survey and Taxonomy of IP Address Lookup Algorithms ’’ IEEE Network Magazine  vol\n pp\n  –   Mar\n–Apr SALTZER   \n  REED   \n  and CLARK   \n: ‘‘End-to-End Arguments in System Design ’’ ACM Trans\n on Computer Systems  vol\n   pp\n   – Nov SAMPLE  A\n  YEAGER  D\n  POWLEDGE  P\n  MAMISHEV  A\n  and SMITH  J\n: ‘‘Design of an RFID-Based Battery-Free Programmable Sensing Platform ’’ IEEE Trans\n on Instrumentation and Measurement  vol\n pp\n –  Nov SAROIU  S\n  GUMMADI  K\n  and GRIBBLE  S\n: ‘‘Measuring and Analyzing the Characteristics of Napster & Gnutella Hosts ’’ Multim\n Syst\n  vol\n pp\n   – Aug READING LIST AND BIBLIOGRAPHY  \n  SCHALLER  R\n: ‘‘Moore’s Law: Past  Present and Future ’’ IEEE Spectrum  vol\n pp\n  –   June \n SCHNEIER  B\n: rets and Lies  New York: John Wiley & Sons  \n SCHNEIER  B\n: E-Mail urity  New York: John Wiley & Sons  \n SCHNORR   \n: ‘‘Efficient Signature Generation for Smart Cards ’’ Journal of Cryptology  vol\n   pp\n   –    \n SCHOLTZ   \n: ‘‘The Origins of Spread-Spectrum Communications ’’ IEEE Trans\n on Commun\n  vol\n COM–  pp\n   – May \n SCHWARTZ  M\n  and ABRAMSON  N\n: ‘‘The AlohaNet: Surfing for Wireless Data ’’ IEEE Commun\n Magazine  vol\n pp\n  –   Dec SEIFERT  R\n  and EDWARDS  J\n: The All-New Switch Book  NY: John Wiley  \n SENN   \n: ‘‘The Emergence of M-Commerce ’’ IEEE Computer  vol\n pp\n   – Dec SERJANTOV  A\n: ‘‘Anonymizing Censorship Resistant Systems ’’ Proc\n First Int’l Workshop on Peer-to-Peer Systems  London: Springer-Verlag LNCS  pp\n   –    \n SHACHAM  N\n  and MCKENNY  P\n: ‘‘Packet Recovery in High-Speed Networks Using Coding and Buffer Management ’’ Proc\n INFOCOM Conf\n  IEEE  pp\n   – June \n SHAIKH  A\n  REXFORD  J\n  and SHIN  K\n: ‘‘Load-Sensitive Routing of Long-Lived IP Flows ’’ Proc\n SIGCOMM ’  Conf\n  ACM  pp\n   – Sept SHALUNOV  S\n  and CARLSON  R\n: ‘‘Detecting Duplex Mismatch on Ethernet ’’ Passive and Active Network Measurement  Berlin: Springer-Verlag LNCS  pp\n –  \n SHANNON  C\n: ‘‘A Mathematical Theory of Communication ’’ Bell System Tech\n J\n  vol\n pp\n   – July ; and pp\n   – Oct SHEPARD  S\n: SONET/SDH Demystified  New York: McGraw-Hill  \n SHREEDHAR  M\n  and VARGHESE  G\n: ‘‘Efficient Fair Queueing Using Deficit Round Robin ’’ Proc\n SIGCOMM ’  Conf\n  ACM  pp\n   –    \n SIMPSON  W\n: Video Over IP  nd ed\n  Burlington  MA: Focal Press  \n SIMPSON  W\n: ‘‘PPP in HDLC-like Framing ’’ RFC  July b\n SIMPSON  W\n: ‘‘The Point-to-Point Protocol (PPP) ’’ RFC  July a\n SIU  K\n  and JAIN  R\n: ‘‘A Brief Overview of ATM: Protocol Layers  LAN Emulation  and Traffic ’’ ACM Computer Communications Review  vol\n pp\n  –   Apr SKOUDIS  E\n  and LISTON  T\n: Counter Hack Reloaded  nd ed\n  Upper Saddle River  NJ: Prentice Hall  \n SMITH   \n  and ALEXANDER   \n: Fumbling the Future  New York: William Morrow  \n   ALPHABETICAL BIBLIOGRAPHY SNOEREN   \n  and BALAKRISHNAN  H\n: ‘‘An End-to-End Approach to Host Mobility ’’ Int’l Conf\n on Mobile Computing and Networking  ACM  pp\n   –    \n SOBEL   \n: ‘‘Will Carnivore Devour Online Privacy ’’ IEEE Computer  vol\n pp\n  –   May \n SOTIROV  A\n  STEVENS  M\n  APPELBAUM  J\n  LENSTRA  A\n  MOLNAR  D\n  OSVIK  D\n  and DE WEGER  B\n: ‘‘MD  Considered Harmful Today ’’ Proc\n  th Chaos Communication Congress  Verlag Art d’Ameublement  \n SOUTHEY  R\n: The Doctors  London: Longman  Brown  Green and Longmans  \n SPURGEON   \n: Ethernet: The Definitive Guide  Sebastopol  CA: O’Reilly  \n STALLINGS  W\n: Data and Computer Communications  th ed\n  Upper Saddle River  NJ: Pearson Education  \n STARR  T\n  SORBARA  M\n  COIFFI  J\n  and SILVERMAN  P\n: ‘‘DSL Advances ’’ Upper Saddle River  NJ: Prentice Hall  \n STEVENS   \n: TCP/IP Illustrated: The Protocols  Boston: Addison Wesley  \n STINSON   \n: Cryptography Theory and Practice  nd ed\n  Boca Raton  FL: CRC Press  \n STOICA  I\n  MORRIS  R\n  KARGER  D\n  KAASHOEK   \n  and BALAKRISHNAN  H\n: ‘‘Chord: A Scalable Peer-to-Peer Lookup Service for Internet Applications ’’ Proc\n SIGCOMM  Conf\n  ACM  pp\n   –    \n STUBBLEFIELD  A\n  IOANNIDIS  J\n  and RUBIN   \n: ‘‘Using the Fluhrer  Mantin  and Shamir Attack to Break WEP ’’ Proc\n Network and Distributed Systems urity Symp\n  ISOC  pp\n  –   \n STUTTARD  D\n  and PINTO  M\n: The Web Application Hacker’s Handbook  New York: John Wiley & Sons  \n SU  S\n: The UMTS Air Interface in RF Engineering  New York: McGraw-Hill  \n SULLIVAN  G\n  and WIEGAND  T\n: ‘‘Tree Algorithms for Packet Broadcast Channels ’’ Proc\n of the IEEE  vol\n pp\n  –   Jan SUNSHINE   \n  and DALAL   \n: ‘‘Connection Management in Transport Protocols ’’ Computer Networks  vol\n   pp\n   –    \n TAN  K\n  SONG  J\n  ZHANG  Q\n  and SRIDHARN  M\n: ‘‘A Compound TCP Approach for High-Speed and Long Distance Networks ’’ Proc\n INFOCOM Conf\n  IEEE  pp\n  –   \n TANENBAUM   \n: Modern Operating Systems  rd ed\n  Upper Saddle River  NJ: Prentice Hall  \n TANENBAUM   \n  and VAN STEEN  M\n: Distributed Systems: Principles and Paradigms  Upper Saddle River  NJ: Prentice Hall  \n TOMLINSON   \n: ‘‘Selecting Sequence Numbers ’’ Proc\n SIGCOMM/SIGOPS Interprocess Commun\n Workshop  ACM  pp\n  –   \n READING LIST AND BIBLIOGRAPHY  \n  TUCHMAN  W\n: ‘‘Hellman Presents No Shortcut Solutions to DES ’’ IEEE Spectrum  vol\n pp\n  –   July \n TURNER   \n: ‘‘New Directions in Communications (or Which Way to the Information Age) ’’ IEEE Commun\n Magazine  vol\n pp\n  –   Oct UNGERBOECK  G\n: ‘‘Trellis-Coded Modulation with Redundant Signal Sets Part I: Introduction ’’ IEEE Commun\n Magazine  vol\n pp\n  –   Feb VALADE  J\n: PHP & MySQL for Dummies  th ed\n  New York: John Wiley & Sons  \n VARGHESE  G\n: Network Algorithmics  San Francisco: Morgan Kaufmann  \n VARGHESE  G\n  and LAUCK  T\n: ‘‘Hashed and Hierarchical Timing Wheels: Data Structures for the Efficient Implementation of a Timer Facility ’’ Proc\n  th Symp\n on Operating Systems Prin\n  ACM  pp\n  –   \n VERIZON BUSINESS:  Data Breach Investigations Report  Verizon  \n VITERBI  A\n: CDMA: Principles of Spread Spectrum Communication  Englewood Cliffs  NJ: Prentice Hall  \n VON AHN  L\n  BLUM  B\n  and LANGFORD  J\n: ‘‘Telling Humans and Computers Apart Automatically ’’ Commun\n of the ACM  vol\n pp\n  –   Feb WAITZMAN  D\n  PARTRIDGE  C\n  and DEERING  S\n: ‘‘Distance Vector Multicast Routing Protocol ’’ RFC  Nov WALDMAN  M\n  RUBIN   \n  and CRANOR   \n: ‘‘Publius: A Robust  Tamper-Evident  Censorship-Resistant Web Publishing System ’’ Proc\n Ninth USENIX urity Symp\n  USENIX  pp\n  –   \n WANG  Z\n  and CROWCROFT  J\n: ‘‘SEAL Detects Cell Misordering ’’ IEEE Network Magazine  vol\n   pp\n  –  July \n WANT  R\n: RFID Explained  San Rafael  CA: Morgan Claypool  \n WARNEKE  B\n  LAST  M\n  LIEBOWITZ  B\n  and PISTER   \n: ‘‘Smart Dust: Communicating with a Cubic Millimeter Computer ’’ IEEE Computer  vol\n pp\n  –   Jan WAYNER  P\n: Disappearing Cryptography: Information Hiding  Steganography  and Watermarking  rd ed\n  San Francisco: Morgan Kaufmann  \n WEI  D\n  CHENG  J\n  LOW  S\n  and HEGDE  S\n: ‘‘FAST TCP: Motivation  Architecture  Algorithms  Performance ’’ IEEE/ACM Trans\n on Networking  vol\n pp\n –  Dec WEISER  M\n: ‘‘The Computer for the Twenty-First Century ’’ Scientific American  vol\n  pp\n  – Sept WELBOURNE  E\n  BATTLE  L\n  COLE  G\n  GOULD  K\n  RECTOR  K\n  RAYMER  S\n  BALAZINSKA  M\n  and BORRIELLO  G\n: ‘‘Building the Internet of Things Using RFID ’’ IEEE Internet Computing  vol\n pp\n  –   May \n WITTENBURG  N\n: Understanding Voice Over IP Technology  Clifton Park  NY: Delmar Cengage Learning  \n   ALPHABETICAL BIBLIOGRAPHY WOLMAN  A\n  VOELKER  G\n  SHARMA  N\n  CARDWELL  N\n  KARLIN  A\n  and LEVY  H\n: ‘‘On the Scale and Performance of Cooperative Web Proxy Caching ’’ Proc\n  th Symp\n on Operating Systems Prin\n  ACM  pp\n  –   \n WOOD  L\n  IVANCIC  W\n  EDDY  W\n  STEWART  D\n  NORTHAM  J\n  JACKSON  C\n  and DA SILVA CURIEL  A\n: ‘‘Use of the Delay-Tolerant Networking Bundle Protocol from Space ’’ Proc\n  th Int’l Astronautical Congress  Int’l Astronautical Federation  pp\n –  \n WU  T\n: ‘‘Network Neutrality  Broadband Discrimination ’’ Journal on Telecom\n and High-Tech\n Law  vol\n   pp\n   –    \n WYLIE  J\n  BIGRIGG   \n  STRUNK   \n  GANGER   \n  KILICCOTE  H\n  and KHOSLA   \n: ‘‘Survivable Information Storage Systems ’’ IEEE Computer  vol\n pp\n  –   Aug YU  T\n  HARTMAN  S\n  and RAEBURN  K\n: ‘‘The Perils of Unauthenticated Encryption: Kerberos Version  ’’ Proc\n NDSS Symposium  Internet Society  Feb YUVAL  G\n: ‘‘How to Swindle Rabin ’’ Cryptologia  vol\n   pp\n   – July \n ZACKS  M\n: ‘‘Antiterrorist Legislation Expands Electronic Snooping ’’ IEEE Internet Computing  vol\n   pp\n  –  Nov\n–Dec ZHANG  Y\n  BRESLAU  L\n  PAXSON  V\n  and SHENKER  S\n: ‘‘On the Characteristics and Origins of Internet Flow Rates ’’ Proc\n SIGCOMM  Conf\n  ACM  pp\n   –    \n ZHAO  B\n  LING  H\n  STRIBLING  J\n  RHEA  S\n  JOSEPH  A\n  and KUBIATOWICZ  J\n: ‘‘Tapestry: A Resilient Global-Scale Overlay for Service Deployment ’’ IEEE J\n on Selected Areas in Commun\n  vol\n pp\n  –   Jan ZIMMERMANN   \n: The Official PGP User’s Guide  Cambridge  MA:  \n Press  a\n ZIMMERMANN   \n: PGP: Source Code and Internals  Cambridge  MA:  \n Press  b\n ZIPF   \n: Human Behavior and the Principle of Least Effort: An Introduction to Human Ecology  Boston: Addison-Wesley  \n ZIV  J\n  and LEMPEL  Z\n: ‘‘A Universal Algorithm for Sequential Data Compression ’’ IEEE Trans\n on Information Theory  vol\n IT–  pp\n   – May \n This page intentionally left blank INDEX This page intentionally left blank INDEX Numbers  -persistent CSMA  GPP (see Third Generation Partnership Project)  B/ B encoding   B/  B encoding    -Gigabit Ethernet –  B/  B encoding    Base-FX Ethernet    Base-T  Ethernet –  \n  (see IEEE   \n  ) Base-T Ethernet –   A A-law  AAL  (see ATM Adaptation Layer  ) Abstract Syntax Notation   Access point    transport layer  Acknowledged datagram Acknowledgement cumulative  duplicate  selective  Acknowledgement clock  TCP  Acknowledgement frame ACL (see Asynchronous Connectionless link) Active server page  ActiveX –   ActiveX control  Ad hoc network    –   routing –   Ad hoc on-demand distance vector  Adaptation  rate  Adaptive frequency hopping  Bluetooth  Adaptive routing algorithm  Adaptive tree walk protocol –   ADC (see Analog-to-Digital Converter) Additive increase multiplicative decrease law  Address resolution protocol –   gratuitous  Address resolution protocol proxy  Addressing classful IP –   transport layer –   INDEX Adjacent router  Admission control  –   –   ADSL (see Asymmetric Digital Subscriber Line) Advanced audio coding  Advanced Encryption Standard  –   Advanced Mobile Phone System    –   Advanced Research Projects Agency Advanced video coding  AES (see Advanced Encryption Standard) Aggregation  route  AH (see Authentication Header) AIFS (see Arbitration InterFrame Space) AIMD (see Additive Increase Multiplicative Decrease law) Air interface  AJAX (see Asynchronous JavaScript and XML) Akamai –   Algorithm adaptive routing  backward learning  Bellman-Ford  binary exponential backoff –   congestion control –   Dijkstra’s  encoding  forwarding international data encryption  Karn’s  leaky bucket  –   longest matching prefix  lottery  Nagle’s  network layer routing –   nonadaptive –   reverse path forwarding  Rivest Shamir Adleman –   routing    –   token bucket –   Alias   Allocation  channel –   ALOHA pure –   slotted –   Alternate mark inversion  AMI (see Alternate Mark Inversion) Amplitude shift keying  AMPS (see Advanced Mobile Phone System) Analog-to-digital converter  Andreessen  Marc –   Anomaly  rate  Anonymous remailer –   ANSNET Antenna  tored  Antheil  George  Anycast routing –   AODV (see Ad-hoc On-demand Distance Vector routing) AP (see Access Point) Apocalypse of the two elephants   –  Applet  Application business   Web   Application layer   –  content-delivery network –   distributed hash table –   Domain Name System –   email –   multimedia –   world Wide Web –   Application-level gateway  APSD (see Automatic Power Save Delivery) Arbitration interframe space  Architectural overview  Web –   Architecture and services  email –   Area  autonomous system backbone  stub  Area border router  ARP (see Address Resolution Protocol) ARPA (see Advanced Research Projects Agency) ARPANET   –  ARQ (see Automatic Repeat reQuest) AS (see Autonomous System) ASK (see Amplitude Shift Keying) ASN\n  (see Abstract Syntax Notation  ) ASP (see Active Server Pages) Aspect ratio  video  Association  IEEE   \n   Assured forwarding –   Asymmetric digital subscriber line     –   vs\n cable  Asynchronous connectionless link  Asynchronous I/O  Asynchronous Javascript and XML –   Asynchronous transfer mode  AT&T  ATM (see Asynchronous Transfer Mode) ATM adaptation layer   INDEX Attack birthday –   bucket brigade  chosen plaintext  ciphertext-only  denial of service  keystream reuse  known plaintext  man-in-the-middle  reflection  replay  Attenuation  Attribute cryptographic certificate  HTML  Auction  spectrum  Audio digital –   streaming –   Audio compression –   Authentication IEEE   \n   Needham-Schroeder –   using key distribution center –   Authentication header –   Authentication protocol –   Authentication using a shared ret –   Authentication using Kerberos –   Authentication using public keys –   Authenticode  Authoritative record  Autocorrelation  Autonegotiation  Automatic power save delivery  Automatic repeat request  Autonomous system  –    Autoresponder  AVC (see Advanced Video Coding) B B-frame  Backbone  Internet Backbone area  Backbone router  Backpressure  hop-by-hop –   Backscatter  RFID  Backward learning algorithm  Backward learning bridge –   Balanced signal –   Bandwidth Bandwidth allocation –   Bandwidth efficiency –   Bandwidth-delay product   Baran  Paul Barker sequence  Base station    Base station controller  Base-T Ethernet –   Base  encoding  Baseband signal  Baseband transmission –   Basic bit-map method  Baud rate  BB  protocol  Beacon frame  Beauty contest  for allocating spectrum  Bell  Alexander Graham  Bell Operating Company  Bellman-Ford routing algorithm  Bent-pipe transponder  Berkeley socket –   Best-effort service –   BGP (see Border Gateway Protocol) Big-endian computer  Binary countdown protocol –   Binary exponential backoff algorithm –   Binary phase shift keying  Bipolar encoding  Birthday attack –   Bit rate  Bit stuffing  Bit-map protocol –   BitTorrent –   choked peer  chunk  free-rider  leecher  seeder  swarm  tit-for-tat strategy  torrent  tracker  unchoked peer  Blaatand  Harald  Block cipher  Block code  INDEX Bluetooth    –   adaptive frequency hopping  applications –   architecture –   frame structure –   link  link layer –   pairing  piconet  profile  protocol stack –   radio layer  scatternet  ure pairing  urity –   Bluetooth SIG  BOC (see Bell Operating Company) Body  HTML tag  Border gateway protocol  –   Botnet  Boundary router  BPSK (see Binary Phase Shift Keying) Bridge –   backward learning –   compared to other devices –   learning –   spanning tree –   use –   Broadband    –   Broadband wireless –   Broadcast control channel  Broadcast network Broadcast routing –   Broadcast storm  Broadcasting  Browser  extension –   helper application  plug-in –    BSC (see Base Station Controller) Bucket  leaky  Bucket brigade attack  Buffering    Bundle  delay-tolerant network  Bundle protocol –   Bursty traffic  Bush  Vannevar  Business application   Byte stream  reliable  Byte stuffing  C CA (see Certification Authority) Cable headend    Cable Internet –   Cable modem    –   –   Cable modem termination system  Cable television –   Cache ARP   –   DNS –   –   poisoned  Web  –   Caesar cipher  Call management  Capacitive coupling  Capacity  channel CAPTCHA Care-of address  Carnivore Carrier extension  Ethernet  Carrier sense multiple access    – -persistent  collision detection –   nonpersistent  p-persistent  Carrier sensing  Carrier-grade Ethernet  Cascading style sheet –   Category  wiring Category  wiring Category  wiring Category  wiring CCITT (see International Telecommunication Union) CCK (see Complementary Code Keying) CD (see Committee Draft) CDM (see Code Division Multiplexing) CDMA (see Code Division Multiple Access) CDMA  CDN (see Content Delivery Network) Cell  mobile phone  Cell phone  first generation –   ond generation –   third generation   –  –   Cellular base station Cellular network Certificate cryptographic –   X\n   –   INDEX Certificate revocation list  Certification authority  Certification path  CGI (see Common Gateway Interface) Chain of trust  Challenge-response protocol  Channel access grant  broadcast control  common control  dedicated control  erasure  multiaccess  paging  random access  Channel allocation –   dynamic –   Channel capacity Channel-associated signaling  Checksum  CRC  Fletcher’s  Chip sequence  CDMA  Choke packet –   Choked peer  BitTorrent  Chord –   finger table  key  Chosen plaintext attack  Chromatic dispersion  Chrominance  video  Chunk  BitTorrent  CIDR (see Classless InterDomain Routing) Cintent delivery network –   Cipher  AES –   Caesar  monoalphabetic substitution  Rijndael –   substitution –   symmetric-key –   transposition –   Cipher block chaining mode –   Cipher feedback mode –   Cipher modes –   Ciphertext  Ciphertext-only attack  Circuit virtual  Circuit switching –   Clark  David    Class A network  Class B network  Class C network  Class-based routing  Classful addressing  IP –   Classic Ethernet    –   Classless interdomain routing –   Clear to send  Click fraud  Client   Client side on the Web –   Client side dynamic Web page generation –   Client side on the Web –   Client stub  Client-server model   Clipper chip  Clock recovery –   Cloud computing  CMTS (see Cable Modem Termination System) Coaxial cable   –  Code  cryptographic  Code division multiple access   Code division multiplexing –   Code rate  Code signing  Codec  Codeword  Collision  Collision detection  CSMA –   Collision domain  Collision-free protocol –   Combing  visual artifact  Committee draft Common control channel  Common gateway interface  Common-channel signaling  Communication medium   Communication satellite –   Communication urity –   Communication subnet Community antenna television –   Companding  Comparison of the OSI and TCP/IP models   –  Complementary code keying  Compression audio –   header –   video –   INDEX Computer  wearable Computer network (see Network) Conditional GET  HTTP  Confidentiality Congestion  network    –   Congestion avoidance  Congestion collapse  TCP  Congestion control convergence –   network layer –   provisioning  TCP –   Congestion window  TCP  Connection  HTTP –   Connection establishment –   TCP –   Connection management  TCP –   Connection release –   TCP  Connection reuse  HTTP  Connection-oriented service   –  –   implementation –   Connectionless service   –  –   implementation –   Connectivity   Constellation  Constellation diagram  Constraint length  Contact  delay-tolerant network  Content and Internet traffic  Content delivery network –   Content distribution –   Content transformation  Contention system  Continuous media  Control channel  broadcast  Control law  Convergence  congestion control –   Convolutional code  Cookie SYN  Web –   Copyright –   Cordless telephone  Core network Core-based tree  Count-to-infinity problem –   Counter mode –   Crash recovery –   CRC (see Cyclic Redundancy Check) Critique of OSI and TCP/IP   –  CRL (see Certificate Revocation List) Cross-correlation  Cryptanalysis  –   differential –   linear  Cryptographic certificate –   Cryptographic key  Cryptographic principles –   Cryptographic round  Cryptography –   AES  certificate –   ciphertext  DES –   Kerckhoff’s principle  key  one-time pad –   P-box  plaintext  public-key –   quantum –   Rijndael  S-box  urity by obscurity  symmetric-key –   triple DES –   vs\n code  work factor  Cryptology  CSMA (see Carrier Sense Multiple Access) CSMA with collision avoidance  CSMA with collision detection  CSMA/CA (see CSMA with Collision Avoidance) CSMA/CD (see CSMA with Collision Detection) CSNET CSS (see Cascading Style Sheet) CTS (see Clear To Send) CubeSat  Cumulative acknowledgement  TCP  Custody transfer  delay-tolerant network  Cut-through switching  Cybersquatting  Cyclic redundancy check  Cypherpunk remailer  INDEX D D-AMPS (see Digital Advanced Mobile Phone System) DAC (see Digital-to-Analog Converter) Daemen  Joan  Daemon  DAG (see Directed Acyclic Graph) Data center Data delivery service  IEEE   \n   Data encryption standard –   Data frame Data link layer    –   bit stuffing  byte stuffing  design issues –   elementary protocols –   example protocols –   sliding window protocols –   stop-and-wait protocol –   Data link layer switching –   Data link protocol –   ADSL –   elementary –   examples –   packet over SONET –   sliding window –   stop-and-wait –   Data over cable service interface specification  Datagram  Datagram congestion control protocol  Datagram network  Datagram service  comparison with VCs –   Davies  Donald DB (see Decibel) DCCP (see Datagram Congestion Controlled Protocol) DCF (see Distributed Coordination Function) DCF interframe spacing  DCT (see Discrete Cosine Transformation) DDoS attack (see Distributed Denial of Service attack) De facto standard De jure standard Decibel  Decoding  audio  Dedicated control channel  Deep Web  Default gateway  Default-free zone  Deficit round robin  Delay  queueing  Delay-tolerant network –   architecture –   custody transfer  protocol –   Delayed acknowledgement  TCP  Demilitarized zone  Denial of service attack  distributed –   Dense wavelength division multiplexing  DES (see Data Encryption Standard) Design issues data link layer –   fast networks –   network   –  network layer –   transport layer –   Designated router  Desktop sharing   Destination port –   Device driver  DHCP (see Dynamic Host Configuration Protocol) DHT (see Distributed Hash Table) Diagonal basis  in quantum cryptography  Dial-up modem Dialog control Differential cryptanalysis –   Differentiated service –    Diffie-Hellman protocol –   DIFS (see DCF InterFrame Spacing) Digital advanced mobile phone system  Digital audio –   Digital Millennium Copyright Act  Digital modulation  Digital signature –   Digital signature standard  Digital subscriber line    –   Digital subscriber line access multiplexer  Digital video –   Digital-to-analog converter  Digitizing voice signals –   Digram  Dijkstra  Edsger  Dijkstra’s algorithm  Direct acyclic graph  Direct sequence spread spectrum  Directed acyclic graph  Directive  HTML  Directory  PKI  INDEX DIS (see Draft International Standard) Disassociation  IEEE   \n   Discovery  path MTU  Discrete cosine transformation  MPEG  Discrete multitone  Dispersion  chromatic  Disposition  message  Disruption-tolerant network  Distance vector multicast routing protocol  Distance vector routing –   Distortion  Distributed coordination function  Distributed denial of service attack –   Distributed Hash Table –   Distributed system   Distribution service  IEEE   \n   Distribution system  DIX Ethernet standard  DMCA (see Digital Millennium Copyright Act) DMCA takedown notice DMT (see Discrete MultiTone) DMZ (see DeMilitarized Zone) DNS (see Domain Name System) DNS Name Space –   DNS spoofing –   DNS (see Domain Name System urity) DOCSIS (see Data Over Cable Service Interface Specification) Document object model  DOM (see Document Object Model) Domain collision  frequency  Domain Name System    –   authoritative record –   cybersquatting  domain resource record –   name server –   name space  registrar  resource record –   reverse lookup  spoofing  top-level domain  zone –   DoS attack (see Denial of Service attack) Dot com era  Dotted decimal notation  Downstream proxy  Draft International Standard Draft standard DSL (see Digital Subscriber Line) DSLAM (see Digital Subscriber Line Access Multiplexer) DTN (see Delay-Tolerant Network) Duplicate acknowledgement  TCP  DVMRP (see Distance Vector Multicast Routing Protocol) DWDM (see Dense Wavelength Division Multiplexing) Dwell time  Dynamic channel allocation –   Dynamic frequency selection  Dynamic host configuration protocol  Dynamic HTML  Dynamic page  Web  Dynamic routing  Dynamic Web page  –   Dynamic Web page generation client side –   server side –   E E-commerce  E-mail (see Email) E  line  EAP (see Extensible Authentication Protocol) Early exit  ECB (see Electronic Code Book mode) ECMP (see Equal Cost MultiPath) ECN (see Explicit Congestion Notification) EDE (see Encrypt Decrypt Encrypt mode) EDGE (see Enhanced Data rates for GSM Evolution) EEE (see Encrypt Encrypt Encrypt mode) EIFS (see Extended InterFrame Spacing) Eisenhower  Dwight Electromagnetic spectrum –   –   Electronic code book mode –   Electronic commerce   Electronic mail (see Email) Electronic product code  Elephant flow  Email   –   architecture and services –   authoritative record  base  encoding  body  cached record  INDEX Email (continued) envelope  final delivery  IMAP –   mail server  mail submission  mailbox  message format  message transfer  –    MIME  name resolution  open mail relay  POP  quoted-printable encoding  signature block  simple mail transfer protocol  transfer agent –   user agent  vacation agent  Webmail –   X    Email header  Email reader  Email urity –   Emoticon  Encapsulating urity payload  Encapsulation  packet  Encoding  B/ B  audio –   video –   Ethernet  B/ B  Ethernet  B/  B  Ethernet  B/  B  Encrypt decrypt encrypt mode  Encrypt encrypt encrypt mode  Encryption  link  End office  End-to-end argument  Endpoint  multiplexing  Enhanced data rates for GSM evolution  Enterprise network Entity  transport  Envelope  EPC (see Electronic Product Code) EPON (see Ethernet PON) Equal cost multipath  Erasure  Erasure channel  Error control –   transport layer –   Error correction Error detection Error syndrome  Error-correcting code –   Error-detecting code –   ESMTP (see Extended SMTP) ESP (see Encapsulating urity Payload) Eternity service  Ethernet    –  -gigabit –  Base-FX    Base-T  Base-T –   Base-T –   carrier-grade  classic    –   DIX  fast –   gigabit –   MAC sublayer –   promiscuous mode  retrospective –   switched    –   Ethernet carrier extension  Ethernet encoding  B/ B   B/  B  B/  B  Ethernet frame bursting  Ethernet header  Ethernet hub  Ethernet jumbo frame  Ethernet performance –   Ethernet PON –   Ethernet port Ethernet switch  EuroDOCSIS  EWMA (see Exponentially Weighted Moving Average) Expedited forwarding –   Explicit congestion notification  Exponential decay  Exponentially weighted moving average  Exposed terminal problem –   Extended hypertext markup language  Extended interframe spacing  Extended SMTP  Extended superframe  Extensible authentication protocol  INDEX Extensible markup language  Extensible stylesheet language transformation  Extension header  IPv  –   Exterior gateway protocol  F Facebook   Fair queueing  Fair use doctrine  Fast Ethernet –   Fast network  design –   Fast recovery  TCP  Fast retransmission  TCP  Fast segment processing –   FCFS (see First-Come First-Served packet scheduling) FDD (see Frequency Division Duplex) FDDI (see Fiber Distributed Data Interface) FDM (see Frequency Division Multiplexing) FEC (see Forwarding Equivalence Class) FEC (see Forward Error Correction) FEC (see Forwarding Equivalence Class) Fiber distributed data interface  Fiber node  Fiber optics   –   compared to copper wire –   Fiber to the home  Fibre channel  Field  video  FIFO (see First-In First-Out packet scheduling) File transfer protocol  Filtering  ingress  Final delivery  email  Finger table  Chord  Firewall –   stateful  First-come first-served packet scheduling  First-generation mobile phone network –   First-in first-out packet scheduling  Fixed wireless Flag byte  Flash crowd  Fletcher’s checksum  Flooding algorithm –   Flow control    –   transport layer –   Flow specification  Footprint  satellite  Forbidden region –   Foreign agent  Form  Web –   Forward error correction  Forwarding  assured –   expedited –   Forwarding algorithm Forwarding equivalence class  Fourier analysis Fourier series Fourier transform  Fragment frame  packet  Fragmentation  packet –   Frame  acknowledgement beacon  data Frame bursting  Ethernet  Frame fragment  Frame header  Frame structure Bluetooth –   IEEE   \n  –   IEEE   \n  –   Framing –   Free-rider  BitTorrent  Free-space optics  Freedom of speech –   Frequency  electromagnetic spectrum  Frequency division duplex  Frequency division multiplexing –   Frequency hopping  Bluetooth  Frequency hopping spread spectrum  Frequency masking  psychoacoustics  Frequency reuse Frequency selection  dynamic  Frequency shift keying  Freshness of messages  Front end  Web server  FSK (see Frequency Shift Keying) FTP (see File Transfer Program) FttH (see Fiber to the Home) Full-duplex link Future of TCP –   Fuzzball INDEX G G\n   standard        Gatekeeper  multimedia  Gateway application level  default  media multimedia  Gateway GPRS support node Gateway mobile switching center Gen  RFID –   General packet radio service Generator polynomial  GEO (see Geostationary Earth Orbit) Geostationary earth orbit  Geostationary satellite  GGSN (see Gateway GPRS Support Node) Gigabit Ethernet –   Gigabit-capable PON  Global Positioning System  Global system for mobile communication    –   Globalstar  Gmail GMSC (see Gateway Mobile Switching Center) Go-back-n protocol –   Goodput  GPON (see Gigabit-capable PON) GPRS (see General Packet Radio Service) GPS (see Global Positioning System) Gratuitous ARP  Gray  Elisha  Gray code  Group  Group  telephone hierarchy  GSM (see Global System for Mobile communication) Guard band  Guard time  Guided transmission media   –  –   H H\n   standard  H\n   standard  H\n   standard  H\n   compared to SIP –   standard –   Half-duplex link Hamming code –   Hamming distance  Handoff   –   hard  soft  Handover (see Handoff) Hard-decision decoding  Harmonic Hashed message authentication code  HDLC (see High-level Data Link Control) HDTV (see High-Definition TeleVision) Headend  cable  Header  email  Ethernet  IPv  –   IPv  –   IPv  extension –   packet TCP segment –   Header compression –   robust  Header prediction  Helper application  browser  Hertz  Hertz  Heinrich  HF RFID HFC (see Hybrid Fiber Coax) Hidden terminal problem  Hierarchical routing –   High-definition television  High-level data link control  High-water mark  History of the Internet   –  HLR (see Home Location Register) HMAC (see Hashed Message Authentication Code) Home agent  Home location  Home location register  Home network  –  Home subscriber server Hop-by-hop backpressure –   Host mobile  Host design for fast networks –   Hosting    INDEX Hot-potato routing  Hotspot HSS (see Home Subscriber Server) HTML(see HyperText Markup Language) HTTP (see HyperText Transfer Protocol) HTTPS (see ure HyperText Transfer Protocol) Hub –   compared to bridge and switch –   Ethernet  satellite  Hybrid fiber coax  Hyperlink  Hypertext  Hypertext markup language –   attribute  directive  tag –   Hypertext transfer protocol     –   conditional get  connection –   connection reuse  method –   parallel connection  persistent connection  scheme  ure Hz (see Hertz) I IAB (see Internet Activities Board) ICANN (see Internet Corporation for Assigned Names and Number) ICMP (see Internet Control Message Protocol) IDEA (see International Data Encryption Algorithm) IEEE   \n  –   architecture –   association  authentication  comparison with IEEE   \n  –   data delivery service  disassociation  distribution service  frame structure –   integration service  MAC sublayer –   MAC sublayer protocol –   IEEE   \n  (continued) physical layer –   privacy service  procotol stack –   reassociation  urity –   services –   transmit power control  IEEE   \n  a  IEEE   \n  b    –   IEEE   \n  g  IEEE   \n  i  IEEE   \n  n –   IEEE   \n   –   architecture –   comparison with IEEE   \n  –   frame structure –   MAC sublayer protocol –   physical layer –   protocol stack –   ranging  IEEE   \n Q –   IEEE   \n X  IEEE(see Institute of Electrical and Electronics Engineers) IETF (see Internet Engineering Task Force) IGMP (see Internet Group Management Protocol) IKE (see Internet Key Exchange) IMAP (see Internet Message Access Protocol IMP (see Interface Message Processor) Improved mobile telephone system  IMT-    –   IMTS (see Improved Mobile Telephone System) In-band signaling  Industrial  scientific  medical bands  Inetd  Infrared Data Association  Infrared transmission  Ingress filtering  Initial connection protocol  Initialization vector  Input form  Web –   Instant messaging   Institute of Electrical and Electronics Engineers Integrated services –   Integration service  IEEE   \n   Intellectual property  Interdomain protocol  Interdomain routing  Interexchange carrier  INDEX Interface air  Interface message processor   –  Interior gateway protocol  Interlacing  video  Interleaving  Internal router  International data encryption algorithm  International Mobile Telecommunication-    –   International Standard   –  International Standard IS-   International Standards Organization International Telecommunication Union Internet   architecture   –  backbone cable –   control protocols –   daemon  history   –  interplanetary key exchange  message access protocol –   multicasting –   protocol version  –   protocol version  –   radio  TCP/IP layer   –  Internet Activities Board Internet Architecture Board Internet control message protocol Internet Corporation for Assigned Names and Numbers  Internet Engineering Task Force Internet exchange point  Internet group management protocol  Internet over cable –   Internet protocol (IP)    –   CIDR –   classful addressing –   control –   control message control protocols –   dotted decimal notation  group management  IP addresses –   message access –   mobile –   subnet –   Internet protocol (continued) version  –   version   version  –   version  controversies –   version  extension headers –   version  main header –   Internet protocol version  –   Internet protocol version  –   Internet Research Task Force Internet service provider    Internet Society Internet standard Internet telephony  Internetwork   –  –   Internetwork routing –   Internetworking    –   network layer    –   Internetworking network layer –   Interoffice trunk  Interplanetary Internet Intradomain protocol  Intradomain routing  Intranet Intruder  urity  Inverse multiplexing  IP (see Internet protocol) IP address –   CIDR –   classful –   NAT –   prefix –   IP urity –   transport mode  tunnel mode  IP telephony   IP television    IP (see IP urity) IPTV (see IP TeleVision) IPv  (see Internet Protocol  version  ) IPv  (see Internet Protocol  version  ) IPv  (see Internet Protocol  version  ) IrDA (see Infrared Data Association) Iridium  IRTF (see Internet Research Task Force) IS (see International Standard) IS-   IS-IS  ISAKMP (see Internet urity Association and Key Management Protocol) INDEX ISM (see Industrial  Scientific  Medical bands) ISO (see International Standards Organization) ISP (see Internet Service Provider) ISP network Iterative query  ITU (see International Telecommunication Union) IV (see Initialization Vector) IXC (see IntereXchange Carrier) IXP (see Internet eXchange Point) J Java applet urity –   Java virtual machine  Java Virtual Machine  JavaScript  Javaserver page  Jitter  Jitter control –   Joint photographic experts group  JPEG (see Joint Photographic Experts Group) JPEG standard –   JSP (see JavaServer Page) Jumbo frame  Ethernet  Jumbogram  JVM (see Java Virtual Machine) K Karn’s algorithm  KDC (see Key Distribution Center) Keepalive timer  TCP  Kepler’s Law  Kerberos –   realm  Kerckhoff’s principle  Key Chord  cryptographic  Key distribution center  authentication using –   Key escrow  Keystream  Keystream reuse attack  Known plaintext attack  L L CAP (see Logical Link Control Adaptation Protocol) Label edge router  Label switched router  Label switching  –   Lamarr  Hedy –   LAN (see Local Area Network) LAN  virtual LATA (see Local Access and Transport Area) Layer application   –  –   data link –   IEEE   \n  physical –   IEEE   \n  physical –   network    –   physical   –   session   –  transport    –   LCP (see Link Control Protocol) LDPC (see Low-Density Parity Check) Leaky bucket algorithm  –   Learning bridge –   LEC (see Local Exchange Carrier) Leecher  BitTorrent  LEO (see Low-Earth Orbit satellite) LER (see Label Edge Router) Level  network Light transmission –   Limited-contention protocol –   Line code  Linear code  Linear cryptanalysis  Link asynchronous connectionless  Bluetooth  full-duplex half-duplex synchronous connection-oriented  Link control protocol  Link encryption  Link layer Bluetooth –   TCP/IP\n   Link state routing –   Little-endian computer  LLC (see Logical Link Control) Load balancing  Web server  Load shedding  –   INDEX Load-shedding policy milk  wine  Local access and transport area  Local area network virtual –   Local central office Local exchange carrier  Local loop  –   Local number portability  Logical link control  Logical link control adaptation protocol  Long fat network –   Long-term evolution  Longest matching prefix algorithm  Lossless audio compression  Lossy audio compression  Lottery algorithm  Low-density parity check  Low-earth orbit satellite  –   Low-water mark  LSR (see Label Switched Router) LTE (see Long Term Evolution) Luminance  video  M M-commerce MAC (see Medium Access Control) MAC sublayer protocol –   –   IEEE   \n  –   IEEE   \n  –   MACA (see Multiple Access with Collision Avoidance) Macroblock  MPEG  Magnetic media   –  MAHO (see Mobile Assisted HandOff) Mail server  Mail submission   Mailbox  Mailing list  Maintenance  route –   MAN (see Metropolitan Area Network) Man-in-the-middle attack  Manchester encoding  MANET (see Mobile Ad hoc NETwork) Markup language  Marshaling parameters  Max-min fairness –   Maximum segment size  TCP  Maximum transfer unit  Maximum transmission unit path  Maxwell  James Clerk  MCI  MD  –   Measurements of network performance –   Media gateway Medium access control sublayer    –   –   Bluetooth –   broadband wireless –   channel allocation –   Ethernet –   IEEE   \n  –   multiple access protocols –   wireless LANs –   Medium-earth orbit satellite  MEO (see Medium-Earth Orbit Satellite) Merkle  Ralph  Message digest –   Message disposition  Message format  Message header –   Message integrity check  Message switching  Message transfer –    Message transfer agent  Metafile  Metcalfe  Robert   Method  HTTP –   Metric units   –  Metropolitan area network MFJ (see Modified Final Judgment) MGW (see Media GateWay) MIC (see Message Integrity Check) Michelson-Morley experiment  Microcell  Microwave transmission –   Middlebox  Middleware   Milk  load-shedding policy  MIME (see Multipurpose Internet Mail Extension) MIME type –   MIMO (see Multiple Input Multiple Output) Minislot  Mirroring a Web site  Mobile ad hoc network –   Mobile assisted handoff  INDEX Mobile code urity –   Mobile commerce Mobile host  routing –   Mobile Internet protocol –   Mobile IP protocol –   Mobile phone –   Mobile phone system first-generation –   ond-generation –   third-generation   –  –   Mobile switching center  Mobile telephone –   Mobile telephone switching office  Mobile telephone system –   Mobile user   –  Mobile Web –   Mobile wireless Mockapetris  Paul Modem  cable    –   dial-up V\n   V\n   V\n   Modified final judgment  Modulation –   amplitude shift keying –   BPSK  digital  discrete multitone  frequency shift keying –   phase shift keying –   pulse code  quadrature phase shift keying  trellis coded  Monoalphabetic substitution cipher  MOSPF (see Multicast OSPF) Motion picture experts group  Mouse  Mouse flow  MP  MP  MPEG (see Motion Picture Experts Group) MPEG compression –   frame types  MPEG-  MPEG-  MPEG-  MPEG standards –   MPLS (see MultiProtocol Label Switching) MSC (see Mobile Switching Center) MSS (see Maximum Segment Size) MTSO (see Mobile Telephone Switching Office) MTU (see Maximum Transfer Unit) Mu law  Mu-law  Multiaccess channel  Multiaccess network  Multicast OSPF  Multicast routing  –   Multicasting  Internet –   Multidestination routing  Multihoming  Multihop network Multimedia –    Internet telephony –   jitter control –   live streaming –   MP  –   RTSP  streaming audio –   video on demand –   videoconferencing –   voice over IP –   Multimode fiber  Multipath fading  Multiple access protocol –   Multiple access with collision avoidance  Multiple input multiple output  Multiplexing  –   endpoint  inverse  statistical Multiprotocol label switching  –   Multiprotocol router  Multipurpose internet mail extension –   Multithreaded Web server  Multitone  discrete  Mutlimedia  streaming video –   N Nagle’s algorithm  Name resolution  Name server –   Naming (see Addressing) INDEX Naming  ure –   NAP (see Network Access Point) NAT (see Network Address Translation) NAT box  National Institute of Standards and Technology  National urity Agency  NAV (see Network Allocation Vector) NCP (see Network Control Protocol) Near field communication Needham-Schroeder authentication –   Negotiation protocol Network ad hoc    –   ALOHA broadcast cellular delay-tolerant –   enterprise first-generation mobile phone –   home  –  local area metropolitan area multiaccess  multihop passive optical  peer-to-peer   performance –   personal area point-to-point power-line    public switched telephone  scalable ond-generation mobile phone –   sensor   –  social   stub  third-generation mobile phone   –  –   uses  –  virtual circuit  virtual private   wide area Network accelerator  Network access point   –  Network address translation –   Network allocation vector  Network architecture Network control protocol  Network design issues   –  Network hardware   –  Network interface card  Network interface device  Network layer   –  –   congestion control –   design issues –   Internet –   internetworking –   quality of service –   routing algorithms –   Network neutrality Network overlay  Network performance measurement –   Network protocol (see Protocol) Network service access point  Network service provider Network software   –  Network standardization   –  NFC (see Near Field Communication) NIC (see Network Interface Card) NID (see Network Interface Device) NIST (see National Institute of Standards and Technology) Node B Node identifier  Non-return-to-zero inverted encoding  Non-return-to-zero modulation  Nonadaptive algorithm –   Nonce  Nonpersistent CSMA  Nonpersistent Web cookie  Nonrepudiation  Notification  explicit congestion  NRZ (see Non-Return-to-Zero modulation) NRZI (see Non-Return-to-Zero Inverted encoding) NSA (see National urity Agency) NSAP (see Network Service Access Point) NSFNET   –  Nyquist frequency  O OFDM (see Orthogonal Frequency Division Multiplexing) OFDMA (see Orthogonal Frequency Division Multiple Access) One-time pad –   Onion routing  Open mail relay  INDEX Open shortest path first  Open shortest path first routing –   Open Systems Interconnection   –  comparison with TCP/IP   –  Open Systems Interconnection  application layer critique   –  data link layer network layer   –  physical layer presentation layer reference model   –  session layer   –  transport layer Optimality principle –   Organizationally unique identifier  Orthogonal frequency division multiple access  Orthogonal frequency division multiplexing    –    Orthogonal sequence  OSI (see Open Systems Interconnection) OSPF (see Open Shortest Path First routing) OSPF(see Open Shortest Path First routing) OUI (see Organizationally Unique Identifier) Out-of-band signaling  Overlay  network  Overprovisioning  P P-box  cryptographic  P-frame –   P-persistent CSMA  P P (see Peer-to-peer network) Packet    Packet encapsulation  Packet filter  Packet fragmentation –    Packet header Packet over SONET –   Packet scheduling –   Packet switching –   store-and-forward  Packet train  Page  Web  Paging channel  Pairing  Bluetooth  PAN (see Personal Area Network) PAR (see Positive Acknowledgement with Retransmission protocol) Parallel connection  HTTP  Parameters  marshaling  Parity bit  Parity packet  Passband Passband signal  Passband transmission  –   Passive optical network  Passive RFID Passkey  Path  autonomous system  certification  maximum transmission unit  Path diversity Path loss  Path maximum transmission unit discovery  Path MTU discovery  Path vector protocol  PAWS (see Protection Against Wrapped Sequence numbers) PCF (see Point Coordination Function) PCM (see Pulse Code Modulation) PCS (see Personal Communications Service) Peer    Peer-to-peer network    –   BitTorrent –   content distribution –   Peering  Per hop behavior  Perceptual coding  Performance  TCP –   Performance issues in networks –   Performance measurements  network –   Perlman  Radia  Persistence timer  TCP  Persistent and nonpersistent CSMA –   Persistent connection  HTTP  Persistent cookie  Web  Personal area network Personal communications service  PGP (see Pretty Good Privacy) Phase shift keying  Phishing Phone (see Telephone) Photon –    PHP  INDEX Physical layer   –   cable television –   code division multiplexing –   communication satellites –   fiber optics   –   frequency division multiplexing –   IEEE   \n  –   IEEE   \n  –   mobile telephones –   modulation –   Open Systems Interconnection telephone system –   time division multiplexing  twisted pairs   –  wireless transmission –   Physical medium Piconet  Bluetooth  Piggybacking  PIM (see Protocol Independent Multicast) Ping  Pipelining  Pixel  PKI (see Public Key Infrastructure) Plain old telephone service  Plaintext  Playback point  Plug-in  browser  Podcast  Poem  spanning tree  Point coordination function  Point of presence  Point-to-point network Point-to-point protocol  Poisoned cache  Poisson model  Polynomial generator  Polynomial code  PON (see Passive Optical Network) POP (see Point of Presence) POP  (see Post Office Protocol) Port destination –   Ethernet source  TCP  transport layer  UDP  Portmapper  Positive acknowledgement with retransmision protocol  Post  Telegraph & Telephone administration Post office protocol  version   POTS (see Plain Old Telephone Service) Power  Power law  Power-line network   –  Power-save mode  Power-line network    PPP (see Point-to-Point Protocol) PPP over ATM  PPPoA (see PPP over ATM) Preamble  Prediction  header Predictive encoding  Prefix  IP address –   Premaster key  Presentation layer Pretty good privacy –   Primitive  service   –  Principal  urity  Privacy –   Privacy amplification  Privacy service  IEEE   \n   Private key ring  Private network  virtual  Process server  Procotol stack  IEEE   \n  –   Product cipher  Product code  electronic  Profile  Bluetooth  Progressive video  Promiscuous mode Ethernet  Proposed standard Protection against wrapped sequence numbers  Protocol  -bit sliding window –   adaptive tree walk –   address resolution –   address resolution gratuitous  address resolution protocol proxy  authentication protocols –   BB   binary countdown –   bit-map –   Bluetooth –   Bluetooth protocol stack –   border gateway  –   bundle –   carrier sense multiple access –   challenge-response  INDEX Protocol (continued) collision-free –   CSMA –   data link –   datagram congestion control  delay-tolerant network –   Diffie-Hellman –   distance vector multicast routing  dotted decimal notation Internet  DVMR  dynamic host configuration  extensible authentication  exterior gateway  file transfer  go-back-n –   hypertext transfer     –   IEEE   \n  –   IEEE   \n  –   initial connection  interdomain  interior gateway  IP –   intradomain  limited-contention –   link control  logical link control adaptation  long fat network –   MAC –   mobile IP –   multiple access –   multiprotocol label switching  –   multiprotocol router  negotiation network network control  packet over SONET –   path vector  point-to-point  POP  positive acknowledgement with retransmission  real time streaming  real-time  real-time transport –   relation to services request-reply reservation  resource reservation  selective repeat –   session initiation –   Protocol (continued) simple Internet plus  simple mail transfer  –   sliding-window –   –    SLIP  SOAP  stop-and-wait –    stream  stream control transmission  subnet Internet –   TCP (see Transmission Control Protocol) temporary key integrity  TKIP  token passing –   transport –   –   tree walk –   UDP –   utopia –   wireless application  wireless LAN –   Protocol  (utopia) –   Protocol  (stop-and-wait) –   Protocol  (PAR) –   Protocol  (sliding window) –   Protocol  (go-back-n) –   Protocol  (selective repeat) –   Protocol hierarchy   –  Protocol independent multicast  Protocol layering Protocol stack   –  Bluetooth –   H\n   –   IEEE   \n  –   IEEE   \n  –   OSI   –  TCP/IP   –  Proxy ARP  Proxy caching  Web  PSK (see Phase Shift Keying) PSTN (see Public Switched Telephone Network) Psychoacoustic audio encoding –   PTT (see Post  Telegraph & Telephone administration) Public switched telephone network    –    Public-key authentication using –   Public-key cryptography –   other algoirhtms –   RSA –   Public-key infrastructure –   directory  Public-key ring  INDEX Public-key signature –   Pulse code modulation  Pure ALOHA –   Push-to-talk system  Q Q\n   standard  QAM (see Quadrature Amplitude Modulation) QoS (see Quality of Service) QoS traffic scheduling (see Transmit power control) QPSK (see Quadrature Phase Shift Keying) Quadrature amplitude modulation  Quadrature phase shift keying  Quality of service    –   –   admission control –   application requirements –   differentiated services –   integrated services –   network layer –   requirements –   traffic shaping –   Quality of service routing  Quantization  MPEG  Quantization noise  Quantum cryptography –   Qubit  Queueing delay  Queueing theory  Quoted-printable encoding  R RA (see Regional Authority) Radio access network Radio frequency identification    –   active backscatter  generation  –   HF LF passive   UHF   –  Radio network controller Radio transmission –   Random access channel  Random early detection –   Ranging  IEEE   \n   RAS (see Registration/Admission/Status) Rate adaptation  Rate anomaly  Rate regulation  sending –   Real-time audio  Real-time conferencing –   Real-time protocol  Real-time streaming protocol  Real-time transport protocols –   Real-time video  Realm  Kerberos  Reassociation  IEEE   \n   Receiving window  Recovery clock –   crash –   fast  Rectilinear basis  in quantum cryptography  Recursive query  RED (see Random Early Detection) Redundancy  in quantum cryptography –   Reed-Solomon code  Reference model   –   Open Systems Interconnection\n  –  TCP/IP   –  Reflection attack  Region  in a network  Regional Authority  Registrar  Registration/admission/status  Relation of protocols to services Relation of services to protocols Reliable byte stream  Remailer anonymous –   cypherpunk  Remote login    –   Remote procedure call –   marshaling parameters  stubs  Rendezvous point  Repeater  –   Replay attack  Request for comments Request header  Request to send  Request-reply protocol    INDEX Request-reply service Reservation protocol  Resilient packet ring  Resolver  Resource record  Resource record set  Resource reservation protocol  Resource sharing   Response header  Retransmission  fast  Retransmission timeout  TCP  Retransmission timer –   Retrospective on Ethernet –   Reverse lookup  Reverse path forwarding algorithm  Revocation certificate –   RFC (see Request For Comments) RFC  RFC  RFC  RFC      RFC  RFC  RFC  RFC   RFC  RFC  RFC  RFC  RFC  RFC  RFC  RFC  RFC  RFC  RFC  RFC  RFC   RFC  RFC  RFC  RFC   RFC  RFC   RFC  RFC   RFC  RFC  RFC  RFC  RFC  RFC    RFC  RFC  RFC  RFC  RFC  RFC  RFC  RFC  RFC  RFC  RFC  RFC  RFC  RFC  RFC  RFC  RFC  RFC  RFC  RFC  RFC  RFC  RFC  RFC  RFC  RFC  RFC  RFC    RFC      RFC  RFC  RFID (see Radio Frequency IDentification) RFID backscatter RFID network   –  Rijmen  Vincent  Rijndael –   Rijndael cipher  Ring resilient packet  token  Rivest  Ron    Rivest Shamir Adleman algorithm –   RNC (see Radio Network Controller) Robbed-bit signaling  Roberts  Larry Robust header compression  ROHC (see RObust Header Compression) Root name server  INDEX Routing algorithm    –   ad hoc network –   adaptive  anycast –   AODV  Bellman-Ford  broadcast –   class-based  classless interdomain –   distance vector multicast protocol  dynamic  hierarchical –   hot-potato  interdomain  internetwork –   intradomain  link state –   mobile host –   multicast –   multidestination  network layer –   onion  OSPF –   distance vector multicast  quality of service  session  shortest path –   static  traffic-aware –   triangle  wormhole  Routing policy  RPC (see Remote Procedure Call) RPR (see Resilient Packet Ring) RRSet (see Resource Record Set) RSA (see Rivest Shamir Adleman algorithm) RSVP (see Resource reSerVation Protocol) RTCP (see Real-time Transport Control Protocol) RTO (see Retransmission TimeOut  TCP) RTP (see Real-time Transport Protocol) RTS (see Request To Send) RTSP (see Real Time Streaming Protocol) Run-length encoding  S S-box  cryptographic  S/MIME  SA (see urity Association) SACK (see Selective ACKnowledgement) Sandbox  Satellite communication –   geostationary  low-earth orbit –   medium-earth orbit  Satellite footprint  Satellite hub  Sawtooth  TCP  Scalable network Scatternet  Bluetooth  Scheduling  packet –   Scheme  HTTP  SCO (see Synchronous Connection Oriented link) Scrambler  SCTP (see Stream Control Transmission Protocol) SDH (see Synchronous Digital Hierarchy) ond-generation mobile phone network –   tored antenna  ure DNS –   ure HTTP  ure naming –   ure pairing bluetooth  ure simple pairing  Bluetooth  ure sockets layer –   ure/MIME  urity Bluetooth –   communication –   email –   IEEE   \n  –   IP –   Java applet –   mobile code –   social issues –   transport layer  Web –   wireless –   urity association  urity by obscurity  urity principal  urity threats –   Seeder  BitTorrent  Segment  Segment header  TCP –   Selective acknowledgement  TCP  Selective repeat protocol –   Self-similarity  INDEX Sending rate  regulation –   Sending window  Sensor network   –  Serial line Internet protocol  Server   Server farm    –   Server side on the Web –   Server side Web page generation –   Server stub  Service connection-oriented   –  –   connectionless   –  –   Service level agreement  Service primitive   –  Service IEEE   \n  –   integrated –   provided by transport layer –   provided to the transport layer –   relation to protocols Service user  transport  Serving GPRS support node Session Session initiation protocol  –   compared to H\n   –   Session key  Session layer   –  Session routing  Set-top box    SGSN (see Serving GPRS Support Node) SHA (see ure Hash Algorithm) Shannon  Claude   –  Shannon limit   Shared ret  authentication using –   Short interframe spacing  Short message service Shortest path routing –   SIFS (see Short InterFrame Spacing) Signal  balanced –   Signal-to-noise ratio Signaling common-channel  in-band  robbed-bit Signature block  Signatures  digital –   Signing  code  Silly window syndrome  SIM card  Simple Internet protocol  plus  Simple mail transfer protocol  –   Simple object access protocol  Simplex link Single-mode fiber  Sink tree  SIP (see Session Initiation Protocol SIPP (see Simple Internet protocol Plus) Skin  player  SLA (see Service Level Agreement) Sliding window  TCP –   Sliding window protocol  -bit –  –   –    SLIP (see Serial Line Internet protocol) Slot  Slotted ALOHA –    Slow start  TCP  threshold  Smart phone Smiley  SMS (see Short Message Service) SMTP (see Simple Mail Transfer Protocol) Snail mail  SNR (see Signal-to-Noise Ratio) SOAP (see Simple Object Access Protocol) Social issues   –  urity –   Social network   Socket Berkeley –   TCP  Socket programming –   Soft handoff  Soft-decision decoding  Soliton  SONET (see Synchronous Optical NETwork) Source port  Spam  Spanning tree  Spanning tree bridge –   Spanning tree poem  SPE (see Synchronous Payload Envelope) Spectrum allocation –   Spectrum auction  Speed of light  Splitter  Spoofing  DNS –   Spot beam  Spread spectrum  direct sequence  frequency hopping  INDEX Sprint  Spyware  SSL (see ure Sockets Layer) SST (see Structured Stream Transport) Stack  protocol   –  Standard de facto de jure Stateful firewall  Static channel allocation –   Static page  Web  Static routing  Static Web page  –   Station keeping  Statistical multiplexing Statistical time division multiplexing  STDM (see Statistical Time Division Multiplexing) Steganography –   Stop-and-wait protocol –    Store-and-forward packet switching  Stream cipher mode –   Stream control transmission protocol  Streaming audio and video –   Streaming live media –   Streaming media  Streaming stored media –   Strowger gear  Structured P P network  Structured stream transport  STS-  (see Synchronous Transport Signal- ) Stub client  server  Stub area  Stub network  Style sheet –   Sublayer  medium access control –   Subnet    –   Subnet Internet protocol –   Subnet mask  Subnetting  Subscriber identity module  Substitution cipher –   Superframe  extended  Supergroup  Supernet  Swarm  BitTorrent  Switch compared to bridge and hub –   Ethernet  Switched Ethernet    –   Switching –   circuit –   cut-through  data link layer –   label  –   message  packet –   store-and-forward Switching element Symbol  Symbol rate  Symmetric-key cryptography –   AES –   cipher feedback mode –   counter mode –   DES –   electronic code book mode –   Rijndael –   stream cipher mode –   triple DES –   Symmetric-key signature –   SYN cookie  TCP  SYN flood attack  Synchronization Synchronous connection-oriented link  Synchronous digital hierarchy –   Synchronous optical network –   Synchronous payload envelope  Synchronous transport signal-  System  distributed   Systematic code  T T  carrier –   T  line  Tag  HTML –   Tag switching  Tail drop  Talkspurt  Tandem office  TCG (see Trusted Computing Group) TCM (see Trellis Coded Modulation) TCP (see Transmission Control Protocol) TDD (see Time Division Duplex) TDM (see Time Division Multiplexing) Telco    INDEX Telephone cordless  mobile –   smart Telephone system –   end office  guard band  guard time  local loop –   mobile –   modem  modulation –   point of presence  politics –   structure –   switching –   tandem office  toll office  trunk –   Telephone trunk –   Television cable –   community antenna –   Temporal masking  Temporary key integrity protocol  Terminal  VoIP  Text messaging Texting Third Generation Partnership Project Third-generation mobile phone network   –  –   Third-party Web cookie  Threats  urity –   Three bears problem  Three-way handshake  Tier  ISP Tier  network  Time division duplex –   Time division multiplexing  –   Time slot  Timer management  TCP –   Timestamp  TCP  Timing wheel  Tit-for-tat strategy  BitTorrent  TKIP (see Temporary Key Integrity Protocol) TLS (see Transport Layer urity) Token  Token bucket algorithm  –   Token bus  Token management Token passing protocol –   Token ring  Toll connecting trunk  Toll office  Top-level domain  Torrent  BitTorrent  TPDU (see Transport Protocol Data Unit) TPM (see Trusted Platform Module) Traceroute  Tracker  BitTorrent  Traffic analysis  Traffic engineering  Traffic policing  Traffic shaping  –   Traffic throttling –   Traffic-aware routing –   Trailer    Transcoding  Transfer agent –   –   Transit service  Transmission baseband  light   –   passband  wireless –   Transmission control protocol (TCP)    –   acknowledgement clock  application layer   –  comparison with OSI   –  congestion collapse  congestion control –   congestion window  connection establishment –   connection management –   connection release  critique   –  cumulative acknowledgement  delayed acknowledgement  duplicate acknowledgement  fast recovery  fast retransmission  future –   introduction –   Karn’s algorithm  keepalive timer  link layer maximum segment size  maximum transfer unit  Nagle’s algorithm  performance –   INDEX Transmission control protocol (continued) persistence timer  port  reference model   –  retransmission timeout  sawtooth  segment header –   selective acknowledgement  silly window syndrome  sliding window –   slow start  slow start threshold  socket  speeding up –   SYN cookie  SYN flood attack  timer management –   timestamp option  transport layer urgent data  well-known port  window probe  window scale  Transmission line Transmission media  guided   –   Transmission opportunity  Transmit power control  IEEE   \n   Transponder  Transport  structured stream  Transport entity  Transport layer addressing –   congestion control –   delay-tolerant networking –   error control –   flow control –   performance –   port  urity  TCP –   TCP/IP Transport protocols –   transport service –   UDP –   Transport mode  IP urity  Transport protocol –   –   design issues –   Transport protocol data unit  Transport service access point  Transport service primitive –   Transport service provider  Transport service user  Transposition cipher –   Tree walk protocol  adaptive –   Trellis-coded modulation  Triangle routing  Trigram  Triple DES –   Trunk  telephone –   Trust anchor  Trusted computing  Trusted platform module  TSAP (see Transport Service Access Point) Tunnel mode  IP  Tunneling  –   Twisted pair   –  unshielded Twitter   Two-army problem –   TXOP (see Transmission opportunity) U U-NII (see Unlicensed National Information Infrastructure) Ubiquitous computing UDP (see User Datagram Protocol) UHF RFID   –  Ultra-wideband  UMTS (see Universal Mobile Telecommunications System) Unchoked peer  BitTorrent  Unicast  Unicasting  Uniform resource identifier  Uniform resource locator  Uniform resource name  Universal mobile telecommunications system  Universal serial bus  Unlicensed national information infrastructure  Unshielded twisted pair Unstructured P P network  Upstream proxy  Urgent data  URI (see Uniform Resource Identifier) URL (see Scheme) URN (see Uniform Resource Name) USB (see Universal Serial Bus) INDEX User  mobile   –  User agent  User datagram protocol    –    –   port  real-time transmission –   remote procedure call –   RTP –   Utopia protocol –   UTP (see Unshielded Twisted Pair) UWB (see Ultra-WideBand) V V\n  modem  V\n  modem  V\n  modem  V\n  modem  Vacation agent  Vampire tap  Van Allen belt  VC (see Virtual Circuit) Very small aperture terminal  Video interlaced  progressive  streaming –   Video compression  Video field  Video on demand  Video server  Virtual circuit  –   Virtual circuit network  comparison with datagram network –   Virtual LAN    –   Virtual private network    –   Virtual-circuit network  Virus  Visitor location register  VLAN (see Virtual LAN) VLR (see Visitor Location Register) Vocal tract  Vocoder  VOD (see Video on Demand) Voice over IP    –   Voice signals  digitizing –   Voice-grade line VoIP (see Voice over IP) VPN (see Virtual Private Network) VSAT (see Very Small Aperture Terminal) W W C (see World Wide Web Consortium) Walled garden  Walsh code  WAN (see Wide Area Network) WAP (see Wireless Application Protocol) Watermarking  Waveform coding  Wavelength  Wavelength division multiplexing –   WCDMA (see Wideband Code Division Multiple Access) WDM (see Wavelength Division Multiplexing) Wearable computer Web (see World Wide Web) Web application   Web browser  extension –   helper application  plug-in –    proxy –   Webmail  –   Weighted fair queueing  Well-known port  TCP  WEP (see Wired Equivalent Privacy) WFQ (see Weighted Fair Queueing) White space  Whitening  Wide area network   –  Wideband code division multiple access  WiFi (see IEEE   \n  ) WiFi Alliance WiFi protected access  WiFi protected access   Wiki   Wikipedia   WiMAX (see IEEE   \n  ) WiMAX Forum  Window probe  TCP  Window scale  TCP  Wine  load-shedding policy  Wired equivalent privacy  INDEX Wireless broadband –   fixed Wireless application protocol  Wireless issues –   Wireless LAN    –   –   Wireless LAN (see IEEE   \n  ) Wireless LAN protocol –   Wireless LAN protocols –   Wireless router Wireless urity –   Wireless transmission –   Work factor  cryptographic  World Wide Web   –   AJAX –   architectural overview –   caching –   cascading style sheets –   client side –   client-side page generation –   connections –   cookies –   crawling  dynamic pages  forms –   HTML –   HTTP –   message headers –   methods –   MIME types –   mobile web –   page  proxy  –   search –   urity –   tracking  server side –   server-side page generation –   static web pages –   World Wide Web Consortium  Wormhole routing  WPA (see WiFi Protected Access) WPA  (see WiFi Protected Access  ) X X\n   standard  X\n   –   XHTML (see eXtended HyperText Markup Language) XML (see eXtensible Markup Language) XSLT (see eXtensible Stylesheet Language Transformation) Z Zipf’s law  Zone DNS –   multimedia  Also by Andrew S\n Tanenbaum Modern Operating Systems  rd ed\n This worldwide best-seller incorporates the latest developments in operating systems\n The book starts with  ters on the principles  including processes  memory management  file systems  I/O  and so on\n Then it goes into three  ter-long case studies: Linux  Windows  and Symbian\n Tanenbaum’s experience as the designer of three operating systems (Amoeba  Globe  and MINIX) gives him a background few other authors can match  so the final  ter distills his long experience into advice for operating system designers\n Also by Andrew S\n Tanenbaum and Albert S\n Woodhull Operating Systems: Design and Implementation  rd ed\n All other textbooks on operating systems are long on theory and short on practice\n This one is different\n In addition to the usual material on processes  memory management  file systems  I/O  and so on  it contains a CD-ROM with the source code (in C) of a small  but complete  POSIXconformant operating system called MINIX  (see   )\n All the principles are illustrated by showing how they apply to MINIX  \n The reader can also compile  test  and experiment with MINIX   leading to in-depth knowledge of how an operating system really works\n Also by Andrew S\n Tanenbaum Structured Computer Organization  th ed\n A computer can be structured as a hierarchy of levels  from the hardware up through the operating system\n This book treats all of them  starting with how a transistor works and ending with operating system design\n No previous experience with either hardware or software is needed to follow this book  however  as all the topics are self contained and explained in simple terms starting right at the beginning\n The running examples used throughout the book range from the high-end UltraSPARC III  through the ever-popular x  (Pentium) to the tiny Intel  used in small embedded systems\n Also by Andrew S\n Tanenbaum and Maarten van Steen Distributed Systems: Principles and Paradigms  nd ed\n Distributed systems are becoming ever-more important in the world and this book explains their principles and illustrates them with numerous examples\n Among the topics covered are architectures  processes  communication  naming  synchronization  consistency  fault tolerance  and urity\n Examples are taken from distributed object-based  file  Web-based  and coordination-based systems\n ABOUT THE AUTHORS Andrew S\n Tanenbaum has an  \n degree from  \n and a  \n from the University of California at Berkeley\n He is currently a Professor of Computer Science at the Vrije Universiteit where he has taught operating systems  networks  and related topics for over   years\n His current research is on highly reliable operating systems although he has worked on compilers  distributed systems  urity  and other topics over the years\n These research projects have led to over refereed papers in journals and conferences\n Prof\n Tanenbaum has also (co)authored five books which have now appeared in   editions\n The books have been translated into   languages  ranging from Basque to Thai and are used at universities all over the world\n In all  there are versions (language/edition combinations)  which are listed at  \n /~ast/publications\n Prof\n Tanenbaum has also produced a considerable volume of software  including the Amsterdam Compiler Kit (a retargetable portable compiler)  Amoeba (an early distributed system used on LANs)  and Globe (a wide-area distributed system)\n He is also the author of MINIX  a small UNIX clone initially intended for use in student programming labs\n It was the direct inspiration for Linux and the platform on which Linux was initially developed\n The current version of MINIX  called MINIX   is now focused on being an extremely reliable and ure operating system\n Prof\n Tanenbaum will consider his work done when no computer is equipped with a reset button and no living person has ever experienced a system crash\n MINIX  is an on-going open-source project to which you are invited to contribute\n Go to    to download a free copy and find out what is happening\n Tanenbaum is a Fellow of the ACM  a Fellow of the the IEEE  and a member of the Royal Netherlands Academy of Arts and Sciences\n He has also won numerous scientific prizes  including:  TAA McGuffey Award for Computer Science and Engineering books  IEEE James H\n Mulligan  Jr\n Education Medal  TAA Texty Award for Computer Science and Engineering books  ACM/SIGCSE Award for Outstanding Contributions to Computer Science Education  ACM Karl V\n Karlstrom Outstanding Educator Award His home page on the World Wide Web can be found at http:// \n /~ast/\n David J\n Wetherall is an Associate Professor of Computer Science and Engineering at the University of Washington in Seattle  and advisor to Intel Labs in Seattle\n He hails from Australia  where he received his  \n in electrical enginering from the University of Western Australia and his  \n in computer science from  \n Prof\n Wetherall has worked in the area of networking for the past two decades\n His research is focused on network systems  especially wireless networks and mobile computing  the design of Internet protocols  and network measurement\n He received the ACM SIGCOMM Test-of-Time award for research that pioneered active networks  an architecture for rapidly introducing new network services\n He received the IEEE William Bennett Prize for breakthroughs in Internet mapping\n His research was recognized with an NSF CAREER award in  and he became a Sloan Fellow in \n As well as teaching networking  Prof\n Wetherall participates in the networking research community\n He has co-chaired the program committees of SIGCOMM  NSDI and MobiSys  and cofounded the ACM HotNets workshops\n He has served on numerous program committees for networking conferences  and is an editor for ACM Computer Communication Review\n His home page on the World Wide Web can be found at http:// 